import {
  multiaddrToUri,
  webSockets
} from "./chunk-BDXCMAX6.js";
import {
  bootstrap
} from "./chunk-VM2ZXPUC.js";
import {
  AdaptiveTimeout,
  Key,
  MemoryDatastore,
  NotFoundError as NotFoundError2,
  PeerMap,
  PeerQueue,
  PeerRecord,
  PeerSet,
  Queue,
  RateLimiter,
  RecordEnvelope,
  anySignal,
  createLibp2p,
  createMortice,
  createScalableCuckooFilter,
  delay_default,
  dns,
  isPrivate,
  isPrivateIp,
  name,
  pbkdf2,
  pbkdf2Async,
  peerFilter,
  peerSet,
  raceEvent,
  src_default as src_default7,
  src_default2 as src_default8,
  trackedMap,
  trackedPeerMap,
  version
} from "./chunk-S4I5QFW2.js";
import {
  Circuit,
  DNS,
  HTTP,
  HTTPS,
  IP,
  IP_OR_DOMAIN,
  P2P,
  TCP,
  WebRTC,
  WebRTCDirect,
  and,
  fmt,
  literal
} from "./chunk-3F7GITD2.js";
import {
  cidrContains,
  getProtocol,
  multiaddr
} from "./chunk-4JGVO3XG.js";
import {
  noise,
  xor
} from "./chunk-FTB6POQW.js";
import {
  byteStream,
  decode as decode3,
  encode as encode2,
  lpStream
} from "./chunk-JJZSNCOQ.js";
import {
  Integer,
  Null,
  ObjectIdentifier,
  OctetString,
  Sequence,
  fromBER,
  generateKeyPair,
  peerIdFromCID,
  peerIdFromMultihash,
  peerIdFromPublicKey,
  peerIdFromString,
  privateKeyFromProtobuf,
  privateKeyFromRaw,
  privateKeyToProtobuf,
  publicKeyFromMultihash,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  randomBytes,
  sha512,
  webcrypto_default
} from "./chunk-DGMPK36G.js";
import {
  toString
} from "./chunk-MWP5OEUY.js";
import {
  AbstractStream,
  closeSource,
  src_default as src_default2,
  yamux
} from "./chunk-C6MF7QUZ.js";
import {
  raceSignal
} from "./chunk-LOB4GZJB.js";
import {
  ConnectionFailedError,
  DialError,
  InvalidMessageError,
  InvalidMultihashError,
  InvalidParametersError,
  InvalidPublicKeyError,
  KEEP_ALIVE,
  ListenError,
  MuxerClosedError,
  NotFoundError,
  NotStartedError,
  ProtocolError,
  StreamStateError,
  TimeoutError,
  TooManyOutboundProtocolStreamsError,
  TypedEventEmitter,
  UnsupportedKeyTypeError,
  UnsupportedProtocolError,
  contentRoutingSymbol,
  peerDiscoverySymbol,
  peerRoutingSymbol,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop,
  transportSymbol
} from "./chunk-W7L7L57K.js";
import {
  code as code3,
  code2 as code4,
  code3 as code5,
  decode2 as decode4,
  encode2 as encode3,
  src_default as src_default3,
  src_default2 as src_default6,
  src_exports,
  src_exports2,
  src_exports3
} from "./chunk-BMUNWA4X.js";
import {
  PQueue,
  defaultLogger,
  logger,
  merge_options_default,
  pTimeout,
  parallel,
  src_default as src_default4,
  src_default2 as src_default5
} from "./chunk-QWUFDZHL.js";
import {
  CustomProgressEvent
} from "./chunk-2LXZBJZU.js";
import {
  pipe
} from "./chunk-U3CLON27.js";
import {
  src_default
} from "./chunk-TDJ2YZLS.js";
import {
  MaxLengthError,
  decodeMessage,
  encodeMessage,
  enumeration,
  message
} from "./chunk-5HCC54LS.js";
import {
  decode as decode2,
  encode,
  encodingLength
} from "./chunk-QINVXJCG.js";
import {
  fromString
} from "./chunk-AKRWU5PV.js";
import {
  base64,
  bases,
  code,
  code2,
  identity,
  json_exports,
  raw_exports,
  sha256,
  sha512 as sha5122
} from "./chunk-LJV7FKKR.js";
import {
  CID,
  base32,
  base36,
  base58btc,
  create,
  decode,
  digest_exports
} from "./chunk-LLHUIDBD.js";
import {
  Uint8ArrayList,
  isUint8ArrayList,
  pushable
} from "./chunk-L26C3OVL.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  concat,
  equals
} from "./chunk-SVJZTA62.js";
import {
  alloc,
  allocUnsafe
} from "./chunk-UVKKAIIP.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-QY3AG7D4.js";

// node_modules/timestamp-nano/dist/timestamp.min.js
var require_timestamp_min = __commonJS({
  "node_modules/timestamp-nano/dist/timestamp.min.js"(exports, module) {
    var Timestamp = function() {
      "undefined" != typeof module && (module.exports = d);
      var l = 86400, s = 3200, T = 146097 * s / 400, e = l * T, f = 1e3 * e, c = 864e13, g = 4294967296, h = 1e6, u = "000000000", m = Math.trunc || function(n2) {
        var t2 = n2 - n2 % 1;
        return 0 == t2 && (n2 < 0 || 0 === n2 && 1 / n2 != 1 / 0) ? -0 : t2;
      }, n = d.prototype, o = (d.fromDate = function(n2) {
        return new d(+n2);
      }, d.fromInt64BE = r(0, 1, 2, 3, 0, 4), d.fromInt64LE = r(3, 2, 1, 0, 4, 0), d.fromString = function(n2) {
        var e2, r2 = new d(), n2 = (n2 += "").replace(/^\s*[+\-]?\d+/, function(n3) {
          var n3 = +n3, t2 = 1970 + (n3 - 1970) % 400;
          return r2.year = n3 - t2, t2;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(n3, t2, r3) {
          return t2 < 0 && (r3 *= -1), e2 = 6e4 * (60 * +t2 + +r3), "";
        }).replace(/\.\d+$/, function(n3) {
          return r2.nano = +(n3 + u).substr(1, 9), "";
        }).split(/\D+/);
        1 < n2.length ? n2[1]-- : n2[1] = 0;
        if (r2.time = e2 = Date.UTC.apply(Date, n2) - (e2 || 0), isNaN(e2))
          throw new TypeError("Invalid Date");
        return p(r2);
      }, d.fromTimeT = function(n2) {
        return y(n2, 0);
      }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function(n2) {
        return this.nano += +n2 || 0, this;
      }, n.getNano = function() {
        var n2 = p(this);
        return (n2.time % 1e3 * h + +n2.nano + 1e9) % 1e9;
      }, n.getTimeT = function() {
        var n2 = p(this), t2 = Math.floor(n2.time / 1e3), n2 = n2.year;
        n2 && (t2 += n2 * T * l / s);
        return t2;
      }, n.getYear = function() {
        return this.toDate().getUTCFullYear() + this.year;
      }, n.toDate = function() {
        return M(p(this).time);
      }, n.toJSON = function() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }, n.toString = function(n2) {
        var t2 = this, r2 = t2.toDate(), u2 = { H: function() {
          return C(r2.getUTCHours());
        }, L: function() {
          return D(r2.getUTCMilliseconds(), 3);
        }, M: function() {
          return C(r2.getUTCMinutes());
        }, N: function() {
          return D(t2.getNano(), 9);
        }, S: function() {
          return C(r2.getUTCSeconds());
        }, Y: function() {
          var n3 = t2.getYear();
          return 999999 < n3 ? "+" + n3 : 9999 < n3 ? "+" + D(n3, 6) : 0 <= n3 ? D(n3, 4) : -999999 <= n3 ? "-" + D(-n3, 6) : n3;
        }, a: function() {
          return a[r2.getUTCDay()];
        }, b: function() {
          return i[r2.getUTCMonth()];
        }, d: function() {
          return C(r2.getUTCDate());
        }, e: function() {
          return function(n3) {
            return (9 < n3 ? "" : " ") + (0 | n3);
          }(r2.getUTCDate());
        }, m: function() {
          return C(r2.getUTCMonth() + 1);
        } };
        return function e2(n3) {
          return n3.replace(/%./g, function(n4) {
            var t3 = n4[1], r3 = v[t3], t3 = u2[t3];
            return r3 ? e2(r3) : t3 ? t3() : n4;
          });
        }(n2 || o);
      }, n.writeInt64BE = t(0, 1, 2, 3, 0, 4), n.writeInt64LE = t(3, 2, 1, 0, 4, 0), "%Y-%m-%dT%H:%M:%S.%NZ"), i = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], a = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], v = { "%": "%", F: "%Y-%m-%d", n: "\n", R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
      return d;
      function d(n2, t2, r2) {
        var e2 = this;
        if (!(e2 instanceof d))
          return new d(n2, t2, r2);
        e2.time = +n2 || 0, e2.nano = +t2 || 0, e2.year = +r2 || 0, p(e2);
      }
      function p(n2) {
        var t2, r2, e2, u2 = n2.year, o2 = n2.time, i2 = n2.nano, a2 = ((i2 < 0 || h <= i2) && (i2 -= (r2 = Math.floor(i2 / h)) * h, o2 += r2, r2 = 1), u2 % s);
        return (o2 < -c || c < o2 || a2) && ((t2 = m(o2 / f)) && (u2 += t2 * s, o2 -= t2 * f), (e2 = M(o2)).setUTCFullYear(a2 + e2.getUTCFullYear()), e2 = (o2 = +e2) + (t2 = m((u2 -= a2) / s)) * f, t2 && -c <= e2 && e2 <= c && (u2 -= t2 * s, o2 = e2), r2 = 1), r2 && (n2.year = u2, n2.time = o2, n2.nano = i2), n2;
      }
      function M(n2) {
        var t2 = /* @__PURE__ */ new Date(0);
        return t2.setTime(n2), t2;
      }
      function y(n2, t2) {
        n2 = +n2 || 0;
        var r2 = m((t2 = (t2 | 0) * g) / e) + m(n2 / e), t2 = t2 % e + n2 % e, n2 = m(t2 / e);
        return n2 && (r2 += n2, t2 -= n2 * e), new d(1e3 * t2, 0, r2 * s);
      }
      function t(e2, u2, o2, i2, a2, f2) {
        return function(n2, t2) {
          var r2 = p(this);
          n2 = n2 || new Array(8);
          w(n2, t2 |= 0);
          var e3 = Math.floor(r2.time / 1e3), r2 = r2.year * (T * l / s), u3 = m(r2 / g) + m(e3 / g), r2 = r2 % g + e3 % g, e3 = Math.floor(r2 / g);
          e3 && (u3 += e3, r2 -= e3 * g);
          return c2(n2, t2 + a2, u3), c2(n2, t2 + f2, r2), n2;
        };
        function c2(n2, t2, r2) {
          n2[t2 + e2] = r2 >> 24 & 255, n2[t2 + u2] = r2 >> 16 & 255, n2[t2 + o2] = r2 >> 8 & 255, n2[t2 + i2] = 255 & r2;
        }
      }
      function r(r2, e2, u2, o2, i2, a2) {
        return function(n2, t2) {
          w(n2, t2 |= 0);
          var r3 = f2(n2, t2 + i2);
          return y(f2(n2, t2 + a2), r3);
        };
        function f2(n2, t2) {
          return 16777216 * n2[t2 + r2] + (n2[t2 + e2] << 16 | n2[t2 + u2] << 8 | n2[t2 + o2]);
        }
      }
      function w(n2, t2) {
        n2 = n2 && n2.length;
        if (null == n2)
          throw new TypeError("Invalid Buffer");
        if (n2 < t2 + 8)
          throw new RangeError("Out of range");
      }
      function C(n2) {
        return (9 < n2 ? "" : "0") + (0 | n2);
      }
      function D(n2, t2) {
        return (u + (0 | n2)).substr(-t2);
      }
    }();
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports, module) {
    function isElectron2() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module.exports = isElectron2;
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function truncate(getLength, string, byteLength) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string.charCodeAt(i);
        segment = string[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
          i += 1;
          segment += string[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string.slice(0, i - segment.length + 1);
        }
      }
      return string;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function getByteLength(string) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser2 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser();
    module.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module) {
    "use strict";
    var truncate = require_browser2();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module.exports = function(input, options2) {
      var replacement = options2 && options2.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// node_modules/@helia/bitswap/dist/src/constants.js
var BITSWAP_120 = "/ipfs/bitswap/1.2.0";
var DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
var DEFAULT_MAX_INBOUND_STREAMS = 1024;
var DEFAULT_MAX_OUTBOUND_STREAMS = 1024;
var DEFAULT_MESSAGE_RECEIVE_TIMEOUT = 5e3;
var DEFAULT_MESSAGE_SEND_DELAY = 10;
var DEFAULT_MESSAGE_SEND_CONCURRENCY = 50;
var DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS = false;
var DEFAULT_MAX_PROVIDERS_PER_REQUEST = 3;
var DEFAULT_MAX_OUTGOING_MESSAGE_SIZE = 1024 * 1024 * 4;
var DEFAULT_MAX_INCOMING_MESSAGE_SIZE = DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;

// node_modules/@helia/bitswap/dist/src/pb/message.js
var WantType;
(function(WantType2) {
  WantType2["WantBlock"] = "WantBlock";
  WantType2["WantHave"] = "WantHave";
})(WantType || (WantType = {}));
var __WantTypeValues;
(function(__WantTypeValues2) {
  __WantTypeValues2[__WantTypeValues2["WantBlock"] = 0] = "WantBlock";
  __WantTypeValues2[__WantTypeValues2["WantHave"] = 1] = "WantHave";
})(__WantTypeValues || (__WantTypeValues = {}));
(function(WantType2) {
  WantType2.codec = () => {
    return enumeration(__WantTypeValues);
  };
})(WantType || (WantType = {}));
var WantlistEntry;
(function(WantlistEntry2) {
  let _codec;
  WantlistEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.cid);
        }
        if (obj.priority != null && obj.priority !== 0) {
          w.uint32(16);
          w.int32(obj.priority);
        }
        if (obj.cancel != null) {
          w.uint32(24);
          w.bool(obj.cancel);
        }
        if (obj.wantType != null) {
          w.uint32(32);
          WantType.codec().encode(obj.wantType, w);
        }
        if (obj.sendDontHave != null) {
          w.uint32(40);
          w.bool(obj.sendDontHave);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {
          cid: alloc(0),
          priority: 0
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.priority = reader.int32();
              break;
            }
            case 3: {
              obj.cancel = reader.bool();
              break;
            }
            case 4: {
              obj.wantType = WantType.codec().decode(reader);
              break;
            }
            case 5: {
              obj.sendDontHave = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  WantlistEntry2.encode = (obj) => {
    return encodeMessage(obj, WantlistEntry2.codec());
  };
  WantlistEntry2.decode = (buf, opts) => {
    return decodeMessage(buf, WantlistEntry2.codec(), opts);
  };
})(WantlistEntry || (WantlistEntry = {}));
var Wantlist;
(function(Wantlist2) {
  let _codec;
  Wantlist2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.entries != null) {
          for (const value of obj.entries) {
            w.uint32(10);
            WantlistEntry.codec().encode(value, w);
          }
        }
        if (obj.full != null) {
          w.uint32(16);
          w.bool(obj.full);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9;
        const obj = {
          entries: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.entries) != null && obj.entries.length === opts.limits.entries) {
                throw new MaxLengthError('Decode error - map field "entries" had too many elements');
              }
              obj.entries.push(WantlistEntry.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.entries$
              }));
              break;
            }
            case 2: {
              obj.full = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Wantlist2.encode = (obj) => {
    return encodeMessage(obj, Wantlist2.codec());
  };
  Wantlist2.decode = (buf, opts) => {
    return decodeMessage(buf, Wantlist2.codec(), opts);
  };
})(Wantlist || (Wantlist = {}));
var Block;
(function(Block3) {
  let _codec;
  Block3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.prefix != null && obj.prefix.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.prefix);
        }
        if (obj.data != null && obj.data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {
          prefix: alloc(0),
          data: alloc(0)
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.prefix = reader.bytes();
              break;
            }
            case 2: {
              obj.data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Block3.encode = (obj) => {
    return encodeMessage(obj, Block3.codec());
  };
  Block3.decode = (buf, opts) => {
    return decodeMessage(buf, Block3.codec(), opts);
  };
})(Block || (Block = {}));
var BlockPresenceType;
(function(BlockPresenceType2) {
  BlockPresenceType2["HaveBlock"] = "HaveBlock";
  BlockPresenceType2["DontHaveBlock"] = "DontHaveBlock";
})(BlockPresenceType || (BlockPresenceType = {}));
var __BlockPresenceTypeValues;
(function(__BlockPresenceTypeValues2) {
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["HaveBlock"] = 0] = "HaveBlock";
  __BlockPresenceTypeValues2[__BlockPresenceTypeValues2["DontHaveBlock"] = 1] = "DontHaveBlock";
})(__BlockPresenceTypeValues || (__BlockPresenceTypeValues = {}));
(function(BlockPresenceType2) {
  BlockPresenceType2.codec = () => {
    return enumeration(__BlockPresenceTypeValues);
  };
})(BlockPresenceType || (BlockPresenceType = {}));
var BlockPresence;
(function(BlockPresence2) {
  let _codec;
  BlockPresence2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.cid != null && obj.cid.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.cid);
        }
        if (obj.type != null && __BlockPresenceTypeValues[obj.type] !== 0) {
          w.uint32(16);
          BlockPresenceType.codec().encode(obj.type, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {
          cid: alloc(0),
          type: BlockPresenceType.HaveBlock
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.cid = reader.bytes();
              break;
            }
            case 2: {
              obj.type = BlockPresenceType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BlockPresence2.encode = (obj) => {
    return encodeMessage(obj, BlockPresence2.codec());
  };
  BlockPresence2.decode = (buf, opts) => {
    return decodeMessage(buf, BlockPresence2.codec(), opts);
  };
})(BlockPresence || (BlockPresence = {}));
var BitswapMessage;
(function(BitswapMessage2) {
  let _codec;
  BitswapMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.wantlist != null) {
          w.uint32(10);
          Wantlist.codec().encode(obj.wantlist, w);
        }
        if (obj.blocks != null) {
          for (const value of obj.blocks) {
            w.uint32(26);
            Block.codec().encode(value, w);
          }
        }
        if (obj.blockPresences != null) {
          for (const value of obj.blockPresences) {
            w.uint32(34);
            BlockPresence.codec().encode(value, w);
          }
        }
        if (obj.pendingBytes != null && obj.pendingBytes !== 0) {
          w.uint32(40);
          w.int32(obj.pendingBytes);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9, _c5, _d2, _e;
        const obj = {
          blocks: [],
          blockPresences: [],
          pendingBytes: 0
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.wantlist = Wantlist.codec().decode(reader, reader.uint32(), {
                limits: (_a13 = opts.limits) == null ? void 0 : _a13.wantlist
              });
              break;
            }
            case 3: {
              if (((_b9 = opts.limits) == null ? void 0 : _b9.blocks) != null && obj.blocks.length === opts.limits.blocks) {
                throw new MaxLengthError('Decode error - map field "blocks" had too many elements');
              }
              obj.blocks.push(Block.codec().decode(reader, reader.uint32(), {
                limits: (_c5 = opts.limits) == null ? void 0 : _c5.blocks$
              }));
              break;
            }
            case 4: {
              if (((_d2 = opts.limits) == null ? void 0 : _d2.blockPresences) != null && obj.blockPresences.length === opts.limits.blockPresences) {
                throw new MaxLengthError('Decode error - map field "blockPresences" had too many elements');
              }
              obj.blockPresences.push(BlockPresence.codec().decode(reader, reader.uint32(), {
                limits: (_e = opts.limits) == null ? void 0 : _e.blockPresences$
              }));
              break;
            }
            case 5: {
              obj.pendingBytes = reader.int32();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  BitswapMessage2.encode = (obj) => {
    return encodeMessage(obj, BitswapMessage2.codec());
  };
  BitswapMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, BitswapMessage2.codec(), opts);
  };
})(BitswapMessage || (BitswapMessage = {}));

// node_modules/@helia/bitswap/dist/src/utils/merge-messages.js
function mergeMessages(existingMessage, newMessage) {
  for (const [key, entry] of newMessage.wantlist.entries()) {
    const existingEntry = existingMessage.wantlist.get(key);
    if (existingEntry != null) {
      if (existingEntry.priority > entry.priority) {
        entry.priority = existingEntry.priority;
      }
      entry.cancel = entry.cancel ?? existingEntry.cancel;
      entry.wantType = entry.wantType ?? existingEntry.wantType;
      entry.sendDontHave = entry.sendDontHave ?? existingEntry.sendDontHave;
    }
    existingMessage.wantlist.set(key, entry);
  }
  for (const [key, blockPresence] of newMessage.blockPresences.entries()) {
    existingMessage.blockPresences.set(key, blockPresence);
  }
  for (const [key, block] of newMessage.blocks.entries()) {
    existingMessage.blocks.set(key, block);
  }
  if (newMessage.full && !existingMessage.full) {
    existingMessage.full = true;
  }
  return existingMessage;
}

// node_modules/@helia/bitswap/dist/src/errors.js
var BlockTooLargeError = class extends Error {
  constructor(message2 = "Block too large") {
    super(message2);
    this.name = "BlockTooLargeError";
  }
};
__publicField(BlockTooLargeError, "name", "BlockTooLargeError");

// node_modules/@helia/bitswap/dist/src/utils/split-message.js
var MAX_BLOCK_SIZE = 4193648;
var MAX_ENCODED_BLOCK_SIZE = MAX_BLOCK_SIZE + 16;
function* splitMessage(message2, maxSize) {
  const wantListEntries = [...message2.wantlist.values()];
  const blockPresences = [...message2.blockPresences.values()];
  const blocks = [...message2.blocks.values()];
  let wantListIndex = 0;
  let blockPresencesIndex = 0;
  let blocksIndex = 0;
  let doneSending = false;
  while (true) {
    const subMessage = {
      wantlist: {
        full: message2.full ?? false,
        entries: []
      },
      blockPresences: [],
      blocks: [],
      pendingBytes: 0
    };
    let size = BitswapMessage.encode(subMessage).byteLength;
    let { added, hasMore, newSize } = addToMessage(blocks, subMessage.blocks, blocksIndex, maxSize, size, calculateEncodedBlockSize);
    blocksIndex += added;
    size = newSize;
    const haveMoreBlocks = hasMore;
    ({ added, hasMore, newSize } = addToMessage(blockPresences, subMessage.blockPresences, blockPresencesIndex, maxSize, size, calculateEncodedBlockPresenceSize));
    blockPresencesIndex += added;
    size = newSize;
    const haveMorePresences = hasMore;
    ({ added, hasMore, newSize } = addToMessage(wantListEntries, subMessage.wantlist.entries, wantListIndex, maxSize, size, calculateEncodedWantlistEntrySize));
    wantListIndex += added;
    size = newSize;
    const haveMoreWantlistEntries = hasMore;
    doneSending = !haveMoreBlocks && !haveMorePresences && !haveMoreWantlistEntries;
    if (!doneSending) {
      subMessage.wantlist.full = false;
    }
    yield BitswapMessage.encode(subMessage);
    if (doneSending) {
      break;
    }
  }
}
function addToMessage(input, output, start2, maxSize, size, calculateSize) {
  let added = 0;
  let hasMore = false;
  for (let i = start2; i < input.length; i++) {
    const item = input[i];
    const itemSize = calculateSize(item);
    if (itemSize > MAX_ENCODED_BLOCK_SIZE) {
      throw new BlockTooLargeError("Cannot send block as after encoding it is over the max message size");
    }
    const newSize = size + itemSize;
    if (newSize > maxSize) {
      hasMore = true;
      break;
    }
    output.push(item);
    added++;
    size = newSize;
  }
  return { hasMore, added, newSize: size };
}
function calculateEncodedBlockSize(block) {
  return calculateLength(3, Block.encode(block));
}
function calculateEncodedBlockPresenceSize(blockPresence) {
  return calculateLength(4, BlockPresence.encode(blockPresence));
}
function calculateEncodedWantlistEntrySize(entry) {
  return calculateLength(1, WantlistEntry.encode(entry));
}
function calculateLength(fieldNumber, data) {
  const fieldNumberLength = encodingLength(fieldNumber);
  const dataLengthLength = encodingLength(data.byteLength);
  return fieldNumberLength + dataLengthLength + data.byteLength;
}

// node_modules/@helia/bitswap/dist/src/network.js
var Network = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    var _a13, _b9;
    super();
    __publicField(this, "log");
    __publicField(this, "libp2p");
    __publicField(this, "routing");
    __publicField(this, "protocols");
    __publicField(this, "running");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "messageReceiveTimeout");
    __publicField(this, "registrarIds");
    __publicField(this, "metrics");
    __publicField(this, "sendQueue");
    __publicField(this, "runOnLimitedConnections");
    __publicField(this, "maxOutgoingMessageSize");
    __publicField(this, "maxIncomingMessageSize");
    this.log = components.logger.forComponent("helia:bitswap:network");
    this.libp2p = components.libp2p;
    this.routing = components.routing;
    this.protocols = init.protocols ?? [BITSWAP_120];
    this.registrarIds = [];
    this.running = false;
    this._onStream = this._onStream.bind(this);
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
    this.messageReceiveTimeout = init.messageReceiveTimeout ?? DEFAULT_MESSAGE_RECEIVE_TIMEOUT;
    this.runOnLimitedConnections = init.runOnLimitedConnections ?? DEFAULT_RUN_ON_TRANSIENT_CONNECTIONS;
    this.maxIncomingMessageSize = init.maxIncomingMessageSize ?? DEFAULT_MAX_OUTGOING_MESSAGE_SIZE;
    this.maxOutgoingMessageSize = init.maxOutgoingMessageSize ?? init.maxIncomingMessageSize ?? DEFAULT_MAX_INCOMING_MESSAGE_SIZE;
    this.metrics = {
      blocksSent: (_a13 = components.metrics) == null ? void 0 : _a13.registerCounter("helia_bitswap_sent_blocks_total"),
      dataSent: (_b9 = components.metrics) == null ? void 0 : _b9.registerCounter("helia_bitswap_sent_data_bytes_total")
    };
    this.sendQueue = new PeerQueue({
      concurrency: init.messageSendConcurrency ?? DEFAULT_MESSAGE_SEND_CONCURRENCY,
      metrics: components.metrics,
      metricName: "helia_bitswap_message_send_queue"
    });
    this.sendQueue.addEventListener("error", (evt) => {
      this.log.error("error sending wantlist to peer", evt.detail);
    });
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.libp2p.handle(this.protocols, this._onStream, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnections
    });
    const topology = {
      onConnect: (peerId) => {
        this.safeDispatchEvent("peer:connected", {
          detail: peerId
        });
      },
      onDisconnect: (peerId) => {
        this.safeDispatchEvent("peer:disconnected", {
          detail: peerId
        });
      }
    };
    this.registrarIds = [];
    for (const protocol of this.protocols) {
      this.registrarIds.push(await this.libp2p.register(protocol, topology));
    }
    this.libp2p.getConnections().forEach((conn) => {
      this.safeDispatchEvent("peer:connected", {
        detail: conn.remotePeer
      });
    });
  }
  async stop() {
    this.running = false;
    await this.libp2p.unhandle(this.protocols);
    if (this.registrarIds != null) {
      for (const id of this.registrarIds) {
        this.libp2p.unregister(id);
      }
      this.registrarIds = [];
    }
  }
  /**
   * Handles incoming bitswap messages
   */
  _onStream(info) {
    if (!this.running) {
      return;
    }
    const { stream, connection } = info;
    Promise.resolve().then(async () => {
      this.log("incoming new bitswap %s stream from %p", stream.protocol, connection.remotePeer);
      const abortListener = () => {
        if (stream.status === "open") {
          stream.abort(new TimeoutError(`Incoming Bitswap stream timed out after ${this.messageReceiveTimeout}ms`));
        } else {
          this.log("stream aborted with status %s", stream.status);
        }
      };
      let signal = AbortSignal.timeout(this.messageReceiveTimeout);
      setMaxListeners(Infinity, signal);
      signal.addEventListener("abort", abortListener);
      await stream.closeWrite();
      await pipe(stream, (source) => decode3(source, {
        maxDataLength: this.maxIncomingMessageSize
      }), async (source) => {
        for await (const data of source) {
          try {
            const message2 = BitswapMessage.decode(data);
            this.log("incoming new bitswap %s message from %p on stream", stream.protocol, connection.remotePeer, stream.id);
            this.safeDispatchEvent("bitswap:message", {
              detail: {
                peer: connection.remotePeer,
                message: message2
              }
            });
            signal.removeEventListener("abort", abortListener);
            signal = AbortSignal.timeout(this.messageReceiveTimeout);
            setMaxListeners(Infinity, signal);
            signal.addEventListener("abort", abortListener);
          } catch (err) {
            this.log.error("error reading incoming bitswap message from %p on stream", connection.remotePeer, stream.id, err);
            stream.abort(err);
            break;
          }
        }
      });
    }).catch((err) => {
      this.log.error("error handling incoming stream from %p", connection.remotePeer, err);
      stream.abort(err);
    });
  }
  /**
   * Find bitswap providers for a given `cid`.
   */
  async *findProviders(cid, options2) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("bitswap:network:find-providers", cid));
    for await (const provider of this.routing.findProviders(cid, options2)) {
      const dialable = await this.libp2p.isDialable(provider.multiaddrs, {
        runOnLimitedConnection: this.runOnLimitedConnections
      });
      if (!dialable) {
        continue;
      }
      yield provider;
    }
  }
  /**
   * Find the providers of a given `cid` and connect to them.
   */
  async findAndConnect(cid, options2) {
    await src_default7(src_default6(src_default8(this.findProviders(cid, options2), (options2 == null ? void 0 : options2.maxProviders) ?? DEFAULT_MAX_PROVIDERS_PER_REQUEST), async (provider) => this.connectTo(provider.id, options2))).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Connect to the given peer
   * Send the given msg (instance of Message) to the given peer
   */
  async sendMessage(peerId, message2, options2) {
    if (!this.running) {
      throw new Error("network isn't running");
    }
    const existingJob = this.sendQueue.queue.find((job) => {
      return peerId.equals(job.options.peerId) && job.status === "queued";
    });
    if (existingJob != null) {
      existingJob.options.message = mergeMessages(existingJob.options.message, message2);
      await existingJob.join({
        signal: options2 == null ? void 0 : options2.signal
      });
      return;
    }
    await this.sendQueue.add(async (options3) => {
      var _a13, _b9;
      const message3 = options3 == null ? void 0 : options3.message;
      if (message3 == null) {
        throw new InvalidParametersError("No message to send");
      }
      this.log("sendMessage to %p", peerId);
      (_a13 = options3 == null ? void 0 : options3.onProgress) == null ? void 0 : _a13.call(options3, new CustomProgressEvent("bitswap:network:send-wantlist", peerId));
      const stream = await this.libp2p.dialProtocol(peerId, BITSWAP_120, options3);
      await stream.closeRead();
      try {
        await pipe(splitMessage(message3, this.maxOutgoingMessageSize), (source) => encode2(source), stream);
        await stream.close(options3);
      } catch (err) {
        (_b9 = options3 == null ? void 0 : options3.onProgress) == null ? void 0 : _b9.call(options3, new CustomProgressEvent("bitswap:network:send-wantlist:error", { peer: peerId, error: err }));
        this.log.error("error sending message to %p", peerId, err);
        stream.abort(err);
      }
      this._updateSentStats(message3.blocks);
    }, {
      peerId,
      signal: options2 == null ? void 0 : options2.signal,
      message: message2
    });
  }
  /**
   * Connects to another peer
   */
  async connectTo(peer, options2) {
    var _a13;
    if (!this.running) {
      throw new NotStartedError("Network isn't running");
    }
    (_a13 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("bitswap:network:dial", peer));
    const [connection] = await Promise.all([
      this.libp2p.dial(peer, options2),
      raceEvent(this.libp2p, "peer:identify", options2 == null ? void 0 : options2.signal, {
        filter: (evt) => {
          if (!evt.detail.peerId.equals(peer)) {
            return false;
          }
          if (evt.detail.protocols.includes(BITSWAP_120)) {
            return true;
          }
          throw new UnsupportedProtocolError(`${peer} did not support ${BITSWAP_120}`);
        }
      })
    ]);
    return connection;
  }
  _updateSentStats(blocks) {
    var _a13, _b9;
    let bytes = 0;
    for (const block of blocks.values()) {
      bytes += block.data.byteLength;
    }
    (_a13 = this.metrics.dataSent) == null ? void 0 : _a13.increment(bytes);
    (_b9 = this.metrics.blocksSent) == null ? void 0 : _b9.increment(blocks.size);
  }
};

// node_modules/@helia/bitswap/dist/src/utils/bitswap-message.js
var QueuedBitswapMessage = class {
  constructor(full = false, pendingBytes = 0) {
    __publicField(this, "full");
    __publicField(this, "pendingBytes");
    __publicField(this, "wantlist");
    __publicField(this, "blocks");
    __publicField(this, "blockPresences");
    this.full = full;
    this.wantlist = /* @__PURE__ */ new Map();
    this.blocks = /* @__PURE__ */ new Map();
    this.blockPresences = /* @__PURE__ */ new Map();
    this.pendingBytes = 0;
  }
  addWantlistEntry(cid, entry) {
    const key = base64.encode(cid.multihash.bytes);
    this.wantlist.set(key, entry);
  }
  addBlockPresence(cid, blockPresence) {
    const key = base64.encode(cid.multihash.bytes);
    this.blockPresences.set(key, blockPresence);
  }
  addBlock(cid, block) {
    const key = base64.encode(cid.multihash.bytes);
    this.blocks.set(key, block);
  }
};

// node_modules/@helia/bitswap/dist/src/utils/varint-encoder.js
function varintEncoder(buf) {
  let out = new Uint8Array(buf.reduce((acc, curr) => {
    return acc + encodingLength(curr);
  }, 0));
  let offset = 0;
  for (const num of buf) {
    out = encode(num, out, offset);
    offset += encodingLength(num);
  }
  return out;
}
var varint_encoder_default = varintEncoder;

// node_modules/@helia/bitswap/dist/src/utils/cid-prefix.js
function cidToPrefix(cid) {
  return varint_encoder_default([
    cid.version,
    cid.code,
    cid.multihash.code,
    cid.multihash.digest.byteLength
  ]);
}

// node_modules/@helia/bitswap/dist/src/peer-want-lists/ledger.js
var Ledger = class {
  constructor(components, init) {
    __publicField(this, "peerId");
    __publicField(this, "blockstore");
    __publicField(this, "network");
    __publicField(this, "wants");
    __publicField(this, "exchangeCount");
    __publicField(this, "bytesSent");
    __publicField(this, "bytesReceived");
    __publicField(this, "lastExchange");
    __publicField(this, "maxSizeReplaceHasWithBlock");
    __publicField(this, "log");
    this.peerId = components.peerId;
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.wants = /* @__PURE__ */ new Map();
    this.log = components.logger.forComponent(`helia:bitswap:ledger:${components.peerId}`);
    this.exchangeCount = 0;
    this.bytesSent = 0;
    this.bytesReceived = 0;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock ?? DEFAULT_MAX_SIZE_REPLACE_HAS_WITH_BLOCK;
  }
  sentBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesSent += n;
  }
  receivedBytes(n) {
    this.exchangeCount++;
    this.lastExchange = (/* @__PURE__ */ new Date()).getTime();
    this.bytesReceived += n;
  }
  debtRatio() {
    return this.bytesSent / (this.bytesReceived + 1);
  }
  async sendBlocksToPeer(options2) {
    const message2 = new QueuedBitswapMessage();
    const sentBlocks = /* @__PURE__ */ new Set();
    for (const [key, entry] of this.wants.entries()) {
      try {
        const block = await this.blockstore.get(entry.cid, options2);
        if (entry.wantType === WantType.WantHave) {
          if (block.byteLength < this.maxSizeReplaceHasWithBlock) {
            this.log("sending have and block for %c", entry.cid);
            sentBlocks.add(key);
            message2.addBlock(entry.cid, {
              data: block,
              prefix: cidToPrefix(entry.cid)
            });
          } else {
            this.log("sending have for %c", entry.cid);
            message2.addBlockPresence(entry.cid, {
              cid: entry.cid.bytes,
              type: BlockPresenceType.HaveBlock
            });
          }
        } else {
          this.log("sending block for %c", entry.cid);
          sentBlocks.add(key);
          message2.addBlock(entry.cid, {
            data: block,
            prefix: cidToPrefix(entry.cid)
          });
        }
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
        this.log("do not have block for %c", entry.cid);
        if (!entry.sendDontHave) {
          continue;
        }
        if (entry.sentDontHave === true) {
          continue;
        }
        entry.sentDontHave = true;
        message2.addBlockPresence(entry.cid, {
          cid: entry.cid.bytes,
          type: BlockPresenceType.DontHaveBlock
        });
      }
    }
    if (message2.blocks.size > 0 || message2.blockPresences.size > 0) {
      this.log("sending message");
      await this.network.sendMessage(this.peerId, message2, options2);
      this.log("sent message");
      this.sentBytes([...message2.blocks.values()].reduce((acc, curr) => acc + curr.data.byteLength, 0));
      for (const key of sentBlocks) {
        this.wants.delete(key);
      }
    }
  }
};

// node_modules/@helia/bitswap/dist/src/peer-want-lists/index.js
var PeerWantLists = class {
  constructor(components, init = {}) {
    __publicField(this, "blockstore");
    __publicField(this, "network");
    __publicField(this, "ledgerMap");
    __publicField(this, "maxSizeReplaceHasWithBlock");
    __publicField(this, "log");
    __publicField(this, "logger");
    this.blockstore = components.blockstore;
    this.network = components.network;
    this.maxSizeReplaceHasWithBlock = init.maxSizeReplaceHasWithBlock;
    this.log = components.logger.forComponent("helia:bitswap:peer-want-lists");
    this.logger = components.logger;
    this.ledgerMap = trackedPeerMap({
      name: "helia_bitswap_ledger_map",
      metrics: components.metrics
    });
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  ledgerForPeer(peerId) {
    const ledger = this.ledgerMap.get(peerId);
    if (ledger == null) {
      return void 0;
    }
    return {
      peer: ledger.peerId,
      value: ledger.debtRatio(),
      sent: ledger.bytesSent,
      received: ledger.bytesReceived,
      exchanged: ledger.exchangeCount
    };
  }
  wantListForPeer(peerId) {
    const ledger = this.ledgerMap.get(peerId);
    if (ledger == null) {
      return void 0;
    }
    return [...ledger.wants.values()];
  }
  peers() {
    return Array.from(this.ledgerMap.values()).map((l) => l.peerId);
  }
  /**
   * Handle incoming messages
   */
  async receiveMessage(peerId, message2) {
    var _a13;
    let ledger = this.ledgerMap.get(peerId);
    if (ledger == null) {
      ledger = new Ledger({
        peerId,
        blockstore: this.blockstore,
        network: this.network,
        logger: this.logger
      }, {
        maxSizeReplaceHasWithBlock: this.maxSizeReplaceHasWithBlock
      });
      this.ledgerMap.set(peerId, ledger);
    }
    ledger.receivedBytes(((_a13 = message2.blocks) == null ? void 0 : _a13.reduce((acc, curr) => acc + curr.data.byteLength, 0)) ?? 0);
    if (message2.wantlist != null) {
      if (message2.wantlist.full === true) {
        ledger.wants.clear();
      }
      for (const entry of message2.wantlist.entries) {
        const cid = CID.decode(entry.cid);
        const cidStr = toString(cid.multihash.bytes, "base64");
        if (entry.cancel === true) {
          this.log("peer %p cancelled want of block for %c", peerId, cid);
          ledger.wants.delete(cidStr);
        } else {
          if (entry.wantType === WantType.WantHave) {
            this.log("peer %p wanted block presence for %c", peerId, cid);
          } else {
            this.log("peer %p wanted block for %c", peerId, cid);
          }
          ledger.wants.set(cidStr, {
            cid,
            priority: entry.priority,
            wantType: entry.wantType ?? WantType.WantBlock,
            sendDontHave: entry.sendDontHave ?? false
          });
        }
      }
    }
    this.log("send blocks to peer");
    await ledger.sendBlocksToPeer();
  }
  async receivedBlock(cid, options2) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    const ledgers = [];
    for (const ledger of this.ledgerMap.values()) {
      if (ledger.wants.has(cidStr)) {
        ledgers.push(ledger);
      }
    }
    await Promise.all(ledgers.map(async (ledger) => ledger.sendBlocksToPeer(options2)));
  }
  peerDisconnected(peerId) {
    this.ledgerMap.delete(peerId);
  }
};

// node_modules/multiformats/dist/src/block.js
function readonly({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index, element] of value.entries()) {
        const elementPath = [...path, index];
        const cid = CID.asCID(element);
        if (cid != null) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value);
      if (cid != null) {
        yield [path.join("/"), cid];
      } else {
        yield* links(value, path);
      }
    }
  }
}
function* links(source, base) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID.asCID(source);
  if (cid != null) {
    yield [base.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [...base, key];
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index, element] of value.entries()) {
      const elementPath = [...path, index];
      yield elementPath.join("/");
      if (typeof element === "object" && CID.asCID(element) == null) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [...base, key];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && CID.asCID(value) == null) {
      yield* treeWithin(path, value);
    }
  }
}
function get(source, path) {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid != null) {
      return { value: cid, remaining: path.slice(index + 1).join("/") };
    }
  }
  return { value: node };
}
var Block2 = class {
  constructor({ cid, bytes, value }) {
    __publicField(this, "cid");
    __publicField(this, "bytes");
    __publicField(this, "value");
    __publicField(this, "asBlock");
    if (cid == null || bytes == null || typeof value === "undefined") {
      throw new Error("Missing required argument");
    }
    this.cid = cid;
    this.bytes = bytes;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly(),
      bytes: readonly(),
      value: readonly(),
      asBlock: readonly()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
};
function createUnsafe({ bytes, cid, value: maybeValue, codec }) {
  const value = maybeValue !== void 0 ? maybeValue : codec == null ? void 0 : codec.decode(bytes);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block2({
    cid,
    bytes,
    value
  });
}

// node_modules/@helia/utils/dist/src/pins.js
var DATASTORE_PIN_PREFIX = "/pin/";
var DATASTORE_BLOCK_PREFIX = "/pinned-block/";
var DATASTORE_ENCODING = base36;
var DAG_WALK_QUEUE_CONCURRENCY = 1;
function toDSKey(cid) {
  if (cid.version === 0) {
    cid = cid.toV1();
  }
  return new Key(`${DATASTORE_PIN_PREFIX}${cid.toString(DATASTORE_ENCODING)}`);
}
var _walkDag, walkDag_fn, _updatePinnedBlock, updatePinnedBlock_fn;
var PinsImpl = class {
  constructor(datastore, blockstore, getCodec2) {
    /**
     * Walk a DAG in an iterable fashion
     */
    __privateAdd(this, _walkDag);
    /**
     * Update the pin count for the CID
     */
    __privateAdd(this, _updatePinnedBlock);
    __publicField(this, "datastore");
    __publicField(this, "blockstore");
    __publicField(this, "getCodec");
    this.datastore = datastore;
    this.blockstore = blockstore;
    this.getCodec = getCodec2;
  }
  async *add(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    if (await this.datastore.has(pinKey)) {
      throw new Error("Already pinned");
    }
    const depth = Math.round(options2.depth ?? Infinity);
    if (depth < 0) {
      throw new Error("Depth must be greater than or equal to 0");
    }
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of __privateMethod(this, _walkDag, walkDag_fn).call(this, cid, queue, {
      ...options2,
      depth
    })) {
      await __privateMethod(this, _updatePinnedBlock, updatePinnedBlock_fn).call(this, childCid, (pinnedBlock) => {
        if (pinnedBlock.pinnedBy.find((c) => equals(c, cid.bytes)) != null) {
          return false;
        }
        pinnedBlock.pinCount++;
        pinnedBlock.pinnedBy.push(cid.bytes);
        return true;
      }, options2);
      yield childCid;
    }
    const pin = {
      depth,
      metadata: options2.metadata ?? {}
    };
    await this.datastore.put(pinKey, encode3(pin), options2);
  }
  async *rm(cid, options2 = {}) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    const pin = decode4(buf);
    await this.datastore.delete(pinKey, options2);
    const queue = new Queue({
      concurrency: DAG_WALK_QUEUE_CONCURRENCY
    });
    for await (const childCid of __privateMethod(this, _walkDag, walkDag_fn).call(this, cid, queue, {
      ...options2,
      depth: pin.depth
    })) {
      await __privateMethod(this, _updatePinnedBlock, updatePinnedBlock_fn).call(this, childCid, (pinnedBlock) => {
        pinnedBlock.pinCount--;
        pinnedBlock.pinnedBy = pinnedBlock.pinnedBy.filter((c) => equals(c, cid.bytes));
        return true;
      }, {
        ...options2,
        depth: pin.depth
      });
      yield childCid;
    }
  }
  async *ls(options2 = {}) {
    for await (const { key, value } of this.datastore.query({
      prefix: DATASTORE_PIN_PREFIX + (options2.cid != null ? `${options2.cid.toString(base36)}` : "")
    }, options2)) {
      const cid = CID.parse(key.toString().substring(5), base36);
      const pin = decode4(value);
      yield {
        cid,
        ...pin
      };
    }
  }
  async isPinned(cid, options2 = {}) {
    const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
    return this.datastore.has(blockKey, options2);
  }
  async get(cid, options2) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    return decode4(buf);
  }
  async setMetadata(cid, metadata, options2) {
    const pinKey = toDSKey(cid);
    const buf = await this.datastore.get(pinKey, options2);
    const pin = decode4(buf);
    pin.metadata = metadata ?? {};
    await this.datastore.put(pinKey, encode3(pin), options2);
  }
};
_walkDag = new WeakSet();
walkDag_fn = async function* (cid, queue, options2) {
  if (options2.depth === -1) {
    return;
  }
  const codec = await this.getCodec(cid.code);
  const bytes = await this.blockstore.get(cid, options2);
  const block = createUnsafe({ bytes, cid, codec });
  yield cid;
  for await (const [, cid2] of block.links()) {
    yield* await queue.add(async () => {
      return __privateMethod(this, _walkDag, walkDag_fn).call(this, cid2, queue, {
        ...options2,
        depth: options2.depth - 1
      });
    });
  }
};
_updatePinnedBlock = new WeakSet();
updatePinnedBlock_fn = async function(cid, withPinnedBlock, options2) {
  var _a13;
  const blockKey = new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(cid.multihash.bytes)}`);
  let pinnedBlock = {
    pinCount: 0,
    pinnedBy: []
  };
  try {
    pinnedBlock = decode4(await this.datastore.get(blockKey, options2));
  } catch (err) {
    if (err.name !== "NotFoundError") {
      throw err;
    }
  }
  const shouldContinue = withPinnedBlock(pinnedBlock);
  if (!shouldContinue) {
    return;
  }
  if (pinnedBlock.pinCount === 0) {
    if (await this.datastore.has(blockKey)) {
      await this.datastore.delete(blockKey);
      return;
    }
  }
  await this.datastore.put(blockKey, encode3(pinnedBlock), options2);
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("helia:pin:add", cid));
};

// node_modules/@helia/interface/dist/src/blocks.js
var DEFAULT_SESSION_MIN_PROVIDERS = 1;
var DEFAULT_SESSION_MAX_PROVIDERS = 5;

// node_modules/@helia/interface/dist/src/errors.js
var InsufficientProvidersError = class extends Error {
  constructor(message2 = "Insufficient providers found") {
    super(message2);
    this.name = "InsufficientProvidersError";
  }
};
__publicField(InsufficientProvidersError, "name", "InsufficientProvidersError");
var NoRoutersAvailableError = class extends Error {
  constructor(message2 = "No routers available") {
    super(message2);
    this.name = "NoRoutersAvailableError";
  }
};
__publicField(NoRoutersAvailableError, "name", "NoRoutersAvailableError");
var UnknownHashAlgorithmError = class extends Error {
  constructor(message2 = "Unknown hash algorithm") {
    super(message2);
    this.name = "UnknownHashAlgorithmError";
  }
};
__publicField(UnknownHashAlgorithmError, "name", "UnknownHashAlgorithmError");
var UnknownCodecError = class extends Error {
  constructor(message2 = "Unknown codec") {
    super(message2);
    this.name = "UnknownCodecError";
  }
};
__publicField(UnknownCodecError, "name", "UnknownCodecError");

// node_modules/@helia/utils/dist/src/routing.js
var DEFAULT_PROVIDER_LOOKUP_CONCURRENCY = 5;
var Routing = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "routers");
    __publicField(this, "providerLookupConcurrency");
    var _a13, _b9, _c5, _d2, _e, _f, _g;
    this.log = components.logger.forComponent("helia:routing");
    this.routers = init.routers ?? [];
    this.providerLookupConcurrency = init.providerLookupConcurrency ?? DEFAULT_PROVIDER_LOOKUP_CONCURRENCY;
    this.findProviders = ((_a13 = components.metrics) == null ? void 0 : _a13.traceFunction("helia.routing.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1
    })) ?? this.findProviders;
    this.provide = ((_b9 = components.metrics) == null ? void 0 : _b9.traceFunction("helia.routing.provide", this.provide.bind(this), {
      optionsIndex: 1
    })) ?? this.provide;
    this.cancelReprovide = ((_c5 = components.metrics) == null ? void 0 : _c5.traceFunction("helia.routing.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1
    })) ?? this.cancelReprovide;
    this.put = ((_d2 = components.metrics) == null ? void 0 : _d2.traceFunction("helia.routing.put", this.put.bind(this), {
      optionsIndex: 2
    })) ?? this.put;
    this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("helia.routing.get", this.get.bind(this), {
      optionsIndex: 1
    })) ?? this.get;
    this.findPeer = ((_f = components.metrics) == null ? void 0 : _f.traceFunction("helia.routing.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1
    })) ?? this.findPeer;
    this.getClosestPeers = ((_g = components.metrics) == null ? void 0 : _g.traceFunction("helia.routing.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1
    })) ?? this.getClosestPeers;
  }
  async start() {
    await start(...this.routers);
  }
  async stop() {
    await stop(...this.routers);
  }
  /**
   * Iterates over all content routers in parallel to find providers of the
   * given key
   */
  async *findProviders(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No content routers available");
    }
    const queue = new PeerQueue({
      concurrency: this.providerLookupConcurrency
    });
    queue.addEventListener("error", () => {
    });
    for await (const peer of src_default(queue.toGenerator(), ...supports(this.routers, "findProviders").map((router) => router.findProviders(key, options2)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length === 0) {
        if (queue.find(peer.id) != null) {
          continue;
        }
        queue.add(async () => {
          try {
            const provider = await this.findPeer(peer.id, options2);
            if (provider.multiaddrs.length === 0) {
              return null;
            }
            return provider;
          } catch (err) {
            this.log.error("could not load multiaddrs for peer %p", peer.id, err);
            return null;
          }
        }, {
          peerId: peer.id,
          signal: options2.signal
        }).catch((err) => {
          this.log.error("could not load multiaddrs for peer %p", peer.id, err);
        });
      }
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No content routers available");
    }
    await Promise.all(supports(this.routers, "provide").map(async (router) => {
      await router.provide(key, options2);
    }));
  }
  async cancelReprovide(key, options2 = {}) {
    await Promise.all(supports(this.routers, "cancelReprovide").map(async (router) => {
      await router.cancelReprovide(key, options2);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options2) {
    await Promise.all(supports(this.routers, "put").map(async (router) => {
      await router.put(key, value, options2);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options2) {
    return Promise.any(supports(this.routers, "get").map(async (router) => {
      return router.get(key, options2);
    }));
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options2) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No peer routers available");
    }
    const self2 = this;
    const source = src_default(...supports(this.routers, "findPeer").map((router) => async function* () {
      try {
        yield await router.findPeer(id, options2);
      } catch (err) {
        self2.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      return peer;
    }
    throw new NotFoundError("Could not find peer in routing");
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options2 = {}) {
    if (this.routers.length === 0) {
      throw new NoRoutersAvailableError("No peer routers available");
    }
    for await (const peer of src_default(...supports(this.routers, "getClosestPeers").map((router) => router.getClosestPeers(key, options2)))) {
      if (peer == null) {
        continue;
      }
      yield peer;
    }
  }
};
function supports(routers, key) {
  return routers.filter((router) => router[key] != null);
}

// node_modules/@helia/utils/dist/src/storage.js
var BlockStorage = class {
  /**
   * Create a new BlockStorage
   */
  constructor(blockstore, pins, options2 = {}) {
    __publicField(this, "lock");
    __publicField(this, "child");
    __publicField(this, "pins");
    __publicField(this, "started");
    this.child = blockstore;
    this.pins = pins;
    this.lock = createMortice({
      singleProcess: options2.holdGcLock
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child);
    this.started = true;
  }
  async stop() {
    await stop(this.child);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.put(cid, block, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.putMany(blocks, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.get(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getMany(cids, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      if (await this.pins.isPinned(cid)) {
        throw new Error("CID was pinned");
      }
      await this.child.delete(cid, options2);
    } finally {
      releaseLock();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.writeLock();
    try {
      const storage = this;
      yield* this.child.deleteMany(async function* () {
        for await (const cid of cids) {
          if (await storage.pins.isPinned(cid)) {
            throw new Error("CID was pinned");
          }
          yield cid;
        }
      }(), options2);
    } finally {
      releaseLock();
    }
  }
  async has(cid, options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      return await this.child.has(cid, options2);
    } finally {
      releaseLock();
    }
  }
  async *getAll(options2 = {}) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const releaseLock = await this.lock.readLock();
    try {
      yield* this.child.getAll(options2);
    } finally {
      releaseLock();
    }
  }
  createSession(root, options2) {
    var _a13;
    (_a13 = options2 == null ? void 0 : options2.signal) == null ? void 0 : _a13.throwIfAborted();
    return this.child.createSession(root, options2);
  }
};

// node_modules/@helia/utils/dist/src/utils/datastore-version.js
var DS_VERSION_KEY = new Key("/version");
var CURRENT_VERSION = 1;
async function assertDatastoreVersionIsCurrent(datastore) {
  if (!await datastore.has(DS_VERSION_KEY)) {
    await datastore.put(DS_VERSION_KEY, fromString(`${CURRENT_VERSION}`));
    return;
  }
  const buf = await datastore.get(DS_VERSION_KEY);
  const str = toString(buf);
  const version3 = parseInt(str, 10);
  if (version3 !== CURRENT_VERSION) {
    throw new Error("Unknown datastore version, a datastore migration may be required");
  }
}

// node_modules/@helia/utils/dist/src/utils/is-promise.js
function isPromise(p) {
  return (p == null ? void 0 : p.then) != null;
}

// node_modules/@helia/utils/dist/src/utils/get-codec.js
function getCodec(initialCodecs = [], loadCodec) {
  const codecs = {
    [code3]: src_exports,
    [code2]: raw_exports,
    [code4]: src_exports2,
    [code5]: src_exports3,
    [code]: json_exports
  };
  initialCodecs.forEach((codec) => {
    codecs[codec.code] = codec;
  });
  return async (code6) => {
    let codec = codecs[code6];
    if (codec == null && loadCodec != null) {
      const res = loadCodec(code6);
      if (isPromise(res)) {
        codec = await res;
      } else {
        codec = res;
      }
      codecs[codec.code] = codec;
    }
    if (codec != null) {
      return codec;
    }
    throw new UnknownCodecError(`Could not load codec for ${code6}`);
  };
}

// node_modules/@helia/utils/dist/src/utils/get-hasher.js
function getHasher(initialHashers = [], loadHasher) {
  const hashers = {
    [sha256.code]: sha256,
    [sha5122.code]: sha5122,
    [identity.code]: identity
  };
  initialHashers.forEach((hasher) => {
    hashers[hasher.code] = hasher;
  });
  return async (code6) => {
    let hasher = hashers[code6];
    if (hasher == null && loadHasher != null) {
      const res = loadHasher(code6);
      if (isPromise(res)) {
        hasher = await res;
      } else {
        hasher = res;
      }
      hashers[hasher.code] = hasher;
    }
    if (hasher != null) {
      return hasher;
    }
    throw new UnknownHashAlgorithmError(`No hasher configured for multihash code 0x${code6.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
  };
}

// node_modules/blockstore-core/dist/src/base.js
var BaseBlockstore = class {
  has(key, options2) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  put(key, val, options2) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  async *putMany(source, options2) {
    for await (const { cid, block } of source) {
      await this.put(cid, block, options2);
      yield cid;
    }
  }
  get(key, options2) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  async *getMany(source, options2) {
    for await (const key of source) {
      yield {
        cid: key,
        block: await this.get(key, options2)
      };
    }
  }
  delete(key, options2) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *deleteMany(source, options2) {
    for await (const key of source) {
      await this.delete(key, options2);
      yield key;
    }
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  async *getAll(options2) {
    throw new Error(".getAll is not implemented");
  }
};

// node_modules/blockstore-core/dist/src/identity.js
var IDENTITY_CODEC = 0;
var IdentityBlockstore = class extends BaseBlockstore {
  constructor(child) {
    super();
    __publicField(this, "child");
    this.child = child;
  }
  put(key, block) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key;
    }
    if (this.child == null) {
      return key;
    }
    return this.child.put(key, block);
  }
  get(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return key.multihash.digest;
    }
    if (this.child == null) {
      throw new NotFoundError2();
    }
    return this.child.get(key);
  }
  has(key) {
    if (key.multihash.code === IDENTITY_CODEC) {
      return true;
    }
    if (this.child == null) {
      return false;
    }
    return this.child.has(key);
  }
  delete(key) {
    if (key.code === IDENTITY_CODEC) {
      return;
    }
    if (this.child != null) {
      return this.child.delete(key);
    }
  }
  getAll(options2) {
    if (this.child != null) {
      return this.child.getAll(options2);
    }
    return [];
  }
};

// node_modules/@helia/utils/dist/src/utils/networked-storage.js
var Storage = class {
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    __publicField(this, "child");
    __publicField(this, "getHasher");
    __publicField(this, "log");
    __publicField(this, "logger");
    __publicField(this, "components");
    this.log = components.logger.forComponent("helia:networked-storage");
    this.logger = components.logger;
    this.components = components;
    this.child = new IdentityBlockstore(components.blockstore);
    this.getHasher = components.getHasher;
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    var _a13, _b9, _c5;
    if (await this.child.has(cid, options2)) {
      (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:put:duplicate", cid));
      return cid;
    }
    (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("blocks:put:providers:notify", cid));
    await Promise.all(this.components.blockBrokers.map(async (broker) => {
      var _a14;
      return (_a14 = broker.announce) == null ? void 0 : _a14.call(broker, cid, block, options2);
    }));
    (_c5 = options2.onProgress) == null ? void 0 : _c5.call(options2, new CustomProgressEvent("blocks:put:blockstore:put", cid));
    return this.child.put(cid, block, options2);
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    var _a13;
    const missingBlocks = src_default5(blocks, async ({ cid }) => {
      var _a14;
      const has = await this.child.has(cid, options2);
      if (has) {
        (_a14 = options2.onProgress) == null ? void 0 : _a14.call(options2, new CustomProgressEvent("blocks:put-many:duplicate", cid));
      }
      return !has;
    });
    const notifyEach = src_default2(missingBlocks, async ({ cid, block }) => {
      var _a14;
      (_a14 = options2.onProgress) == null ? void 0 : _a14.call(options2, new CustomProgressEvent("blocks:put-many:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => {
        var _a15;
        return (_a15 = broker.announce) == null ? void 0 : _a15.call(broker, cid, block, options2);
      }));
    });
    (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:put-many:blockstore:put-many"));
    yield* this.child.putMany(notifyEach, options2);
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    var _a13, _b9, _c5, _d2;
    if (options2.offline !== true && !await this.child.has(cid, options2)) {
      const hasher = await this.getHasher(cid.multihash.code);
      (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:get:providers:get", cid));
      const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
        ...options2,
        log: this.log
      });
      (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("blocks:get:blockstore:put", cid));
      await this.child.put(cid, block, options2);
      (_c5 = options2.onProgress) == null ? void 0 : _c5.call(options2, new CustomProgressEvent("blocks:get:providers:notify", cid));
      await Promise.all(this.components.blockBrokers.map(async (broker) => {
        var _a14;
        return (_a14 = broker.announce) == null ? void 0 : _a14.call(broker, cid, block, options2);
      }));
      return block;
    }
    (_d2 = options2.onProgress) == null ? void 0 : _d2.call(options2, new CustomProgressEvent("blocks:get:blockstore:get", cid));
    return this.child.get(cid, options2);
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    var _a13;
    (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:get-many:blockstore:get-many"));
    yield* this.child.getMany(src_default2(cids, async (cid) => {
      var _a14, _b9, _c5;
      if (options2.offline !== true && !await this.child.has(cid, options2)) {
        const hasher = await this.getHasher(cid.multihash.code);
        (_a14 = options2.onProgress) == null ? void 0 : _a14.call(options2, new CustomProgressEvent("blocks:get-many:providers:get", cid));
        const block = await raceBlockRetrievers(cid, this.components.blockBrokers, hasher, {
          ...options2,
          log: this.log
        });
        (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("blocks:get-many:blockstore:put", cid));
        await this.child.put(cid, block, options2);
        (_c5 = options2.onProgress) == null ? void 0 : _c5.call(options2, new CustomProgressEvent("blocks:get-many:providers:notify", cid));
        await Promise.all(this.components.blockBrokers.map(async (broker) => {
          var _a15;
          return (_a15 = broker.announce) == null ? void 0 : _a15.call(broker, cid, block, options2);
        }));
      }
    }));
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    var _a13;
    (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:delete:blockstore:delete", cid));
    await this.child.delete(cid, options2);
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    var _a13;
    (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:delete-many:blockstore:delete-many"));
    yield* this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cid;
      }
    }(), options2);
  }
  async has(cid, options2 = {}) {
    return this.child.has(cid, options2);
  }
  async *getAll(options2 = {}) {
    var _a13;
    (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("blocks:get-all:blockstore:get-many"));
    yield* this.child.getAll(options2);
  }
};
var NetworkedStorage = class extends Storage {
  /**
   * Create a new BlockStorage
   */
  constructor(components) {
    super(components);
    __publicField(this, "started");
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await start(this.child, ...this.components.blockBrokers);
    this.started = true;
  }
  async stop() {
    await stop(this.child, ...this.components.blockBrokers);
    this.started = false;
  }
  unwrap() {
    return this.child;
  }
  createSession(root, options2) {
    const blockBrokers = this.components.blockBrokers.map((broker) => {
      if (broker.createSession == null) {
        return broker;
      }
      return broker.createSession(options2);
    });
    return new SessionStorage({
      blockstore: this.child,
      blockBrokers,
      getHasher: this.getHasher,
      logger: this.logger
    }, {
      root
    });
  }
};
var SessionStorage = class extends Storage {
  constructor(components, init) {
    super(components);
    __publicField(this, "closeController");
    this.closeController = new AbortController();
    setMaxListeners(Infinity, this.closeController.signal);
    this.log = components.logger.forComponent(`helia:session-storage:${init.root}`);
  }
  close() {
    this.closeController.abort();
  }
  /**
   * Put a block to the underlying datastore
   */
  async put(cid, block, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.put(cid, block, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Put a multiple blocks to the underlying datastore
   */
  async *putMany(blocks, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.putMany(blocks, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get a block by cid
   */
  async get(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.get(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Get multiple blocks back from an (async) iterable of cids
   */
  async *getMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete a block from the blockstore
   */
  async delete(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      await super.delete(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  /**
   * Delete multiple blocks from the blockstore
   */
  async *deleteMany(cids, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.deleteMany(cids, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async has(cid, options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      return await super.has(cid, {
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
  async *getAll(options2 = {}) {
    const signal = anySignal([this.closeController.signal, options2.signal]);
    setMaxListeners(Infinity, signal);
    try {
      yield* super.getAll({
        ...options2,
        signal
      });
    } finally {
      signal.clear();
    }
  }
};
function isRetrievingBlockBroker(broker) {
  return typeof broker.retrieve === "function";
}
var getCidBlockVerifierFunction = (cid, hasher) => {
  if (hasher == null) {
    throw new InvalidParametersError(`No hasher configured for multihash code 0x${cid.multihash.code.toString(16)}, please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv`);
  }
  return async (block) => {
    let hash;
    const res = hasher.digest(block);
    if (isPromise(res)) {
      hash = await res;
    } else {
      hash = res;
    }
    if (!equals(hash.digest, cid.multihash.digest)) {
      throw new InvalidMultihashError("Hash of downloaded block did not match multihash from passed CID");
    }
  };
};
async function raceBlockRetrievers(cid, blockBrokers, hasher, options2) {
  const validateFn = getCidBlockVerifierFunction(cid, hasher);
  const controller = new AbortController();
  const signal = anySignal([controller.signal, options2.signal]);
  setMaxListeners(Infinity, controller.signal, signal);
  const retrievers = [];
  for (const broker of blockBrokers) {
    if (isRetrievingBlockBroker(broker)) {
      retrievers.push(broker);
    }
  }
  try {
    return await Promise.any(retrievers.map(async (retriever) => {
      try {
        let blocksWereValidated = false;
        const block = await retriever.retrieve(cid, {
          ...options2,
          signal,
          validateFn: async (block2) => {
            await validateFn(block2);
            blocksWereValidated = true;
          }
        });
        if (!blocksWereValidated) {
          await validateFn(block);
        }
        return block;
      } catch (err) {
        options2.log.error("could not retrieve verified block for %c", cid, err);
        throw err;
      }
    }));
  } finally {
    controller.abort();
    signal.clear();
  }
}

// node_modules/@helia/utils/dist/src/abstract-session.js
var AbstractSession = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "intialPeerSearchComplete");
    __publicField(this, "requests");
    __publicField(this, "name");
    __publicField(this, "log");
    __publicField(this, "logger");
    __publicField(this, "minProviders");
    __publicField(this, "maxProviders");
    __publicField(this, "providers");
    __publicField(this, "evictionFilter");
    setMaxListeners(Infinity, this);
    this.name = init.name;
    this.logger = components.logger;
    this.log = components.logger.forComponent(this.name);
    this.requests = /* @__PURE__ */ new Map();
    this.minProviders = init.minProviders ?? DEFAULT_SESSION_MIN_PROVIDERS;
    this.maxProviders = init.maxProviders ?? DEFAULT_SESSION_MAX_PROVIDERS;
    this.providers = [];
    this.evictionFilter = createScalableCuckooFilter(this.maxProviders);
  }
  async retrieve(cid, options2 = {}) {
    const cidStr = base64.encode(cid.multihash.bytes);
    const existingJob = this.requests.get(cidStr);
    if (existingJob != null) {
      this.log("join existing request for %c", cid);
      return existingJob;
    }
    const deferred = pDefer();
    this.requests.set(cidStr, deferred.promise);
    if (this.providers.length === 0) {
      let first = false;
      if (this.intialPeerSearchComplete == null) {
        first = true;
        this.log = this.logger.forComponent(`${this.name}:${cid}`);
        this.intialPeerSearchComplete = this.findProviders(cid, this.minProviders, options2);
      }
      await this.intialPeerSearchComplete;
      if (first) {
        this.log("found initial session peers for %c", cid);
      }
    }
    let foundBlock = false;
    const queue = new Queue({
      concurrency: this.maxProviders
    });
    queue.addEventListener("error", () => {
    });
    queue.addEventListener("failure", (evt) => {
      this.log.error("error querying provider %o, evicting from session", evt.detail.job.options.provider, evt.detail.error);
      this.evict(evt.detail.job.options.provider);
    });
    queue.addEventListener("success", (evt) => {
      foundBlock = true;
      deferred.resolve(evt.detail.result);
    });
    queue.addEventListener("idle", () => {
      var _a13;
      if (foundBlock || ((_a13 = options2.signal) == null ? void 0 : _a13.aborted) === true) {
        return;
      }
      Promise.resolve().then(async () => {
        this.log("no session peers had block for for %c, finding new providers", cid);
        for (let i = 0; i < this.minProviders; i++) {
          if (this.providers.length === 0) {
            break;
          }
          const provider = this.providers[Math.floor(Math.random() * this.providers.length)];
          this.evict(provider);
        }
        await this.findProviders(cid, this.minProviders, options2);
        this.log("found new providers re-retrieving %c", cid);
        this.requests.delete(cidStr);
        deferred.resolve(await this.retrieve(cid, options2));
      }).catch((err) => {
        this.log.error("could not find new providers for %c", cid, err);
        deferred.reject(err);
      });
    });
    const peerAddedToSessionListener = (event) => {
      queue.add(async () => {
        return this.queryProvider(cid, event.detail, options2);
      }, {
        provider: event.detail
      }).catch((err) => {
        var _a13;
        if (((_a13 = options2.signal) == null ? void 0 : _a13.aborted) === true) {
          return;
        }
        this.log.error("error retrieving session block for %c", cid, err);
      });
    };
    this.addEventListener("provider", peerAddedToSessionListener);
    Promise.all([...this.providers].map(async (provider) => {
      return queue.add(async () => {
        return this.queryProvider(cid, provider, options2);
      }, {
        provider
      });
    })).catch((err) => {
      var _a13;
      if (((_a13 = options2.signal) == null ? void 0 : _a13.aborted) === true) {
        return;
      }
      this.log.error("error retrieving session block for %c", cid, err);
    });
    try {
      return await deferred.promise;
    } finally {
      this.removeEventListener("provider", peerAddedToSessionListener);
      queue.clear();
      this.requests.delete(cidStr);
    }
  }
  evict(provider) {
    this.evictionFilter.add(this.toEvictionKey(provider));
    const index = this.providers.findIndex((prov) => this.equals(prov, provider));
    if (index === -1) {
      return;
    }
    this.providers.splice(index, 1);
  }
  isEvicted(provider) {
    return this.evictionFilter.has(this.toEvictionKey(provider));
  }
  hasProvider(provider) {
    if (this.providers.find((prov) => this.equals(prov, provider)) != null) {
      return true;
    }
    if (this.isEvicted(provider)) {
      return true;
    }
    return false;
  }
  async findProviders(cid, count, options2) {
    const deferred = pDefer();
    let found = 0;
    void Promise.resolve().then(async () => {
      var _a13;
      this.log("finding %d-%d new provider(s) for %c", count, this.maxProviders, cid);
      for await (const provider of this.findNewProviders(cid, options2)) {
        if (found === this.maxProviders || ((_a13 = options2.signal) == null ? void 0 : _a13.aborted) === true) {
          break;
        }
        if (this.hasProvider(provider)) {
          continue;
        }
        this.log("found %d/%d new providers", found, this.maxProviders);
        this.providers.push(provider);
        this.safeDispatchEvent("provider", {
          detail: provider
        });
        found++;
        if (found === count) {
          this.log("session is ready");
          deferred.resolve();
        }
        if (this.providers.length === this.maxProviders) {
          this.log("found max session peers", found);
          break;
        }
      }
      this.log("found %d/%d new session peers", found, this.maxProviders);
      if (found < count) {
        throw new InsufficientProvidersError(`Found ${found} of ${count} ${this.name} providers for ${cid}`);
      }
    }).catch((err) => {
      this.log.error("error searching routing for potential session peers for %c", cid, err.errors ?? err);
      deferred.reject(err);
    });
    return deferred.promise;
  }
};

// node_modules/@helia/utils/dist/src/index.js
var Helia = class {
  constructor(init) {
    __publicField(this, "blockstore");
    __publicField(this, "datastore");
    __publicField(this, "pins");
    __publicField(this, "logger");
    __publicField(this, "routing");
    __publicField(this, "getCodec");
    __publicField(this, "getHasher");
    __publicField(this, "dns");
    __publicField(this, "metrics");
    __publicField(this, "log");
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("helia");
    this.getHasher = getHasher(init.hashers, init.loadHasher);
    this.getCodec = getCodec(init.codecs, init.loadCodec);
    this.dns = init.dns ?? dns();
    this.metrics = init.metrics;
    const components = {
      blockstore: init.blockstore,
      datastore: init.datastore,
      logger: this.logger,
      blockBrokers: [],
      getHasher: this.getHasher,
      getCodec: this.getCodec,
      dns: this.dns,
      metrics: this.metrics,
      ...init.components ?? {}
    };
    this.routing = components.routing = new Routing(components, {
      routers: (init.routers ?? []).flatMap((router) => {
        const routers = [
          router
        ];
        if (router[contentRoutingSymbol] != null) {
          routers.push(router[contentRoutingSymbol]);
        }
        if (router[peerRoutingSymbol] != null) {
          routers.push(router[peerRoutingSymbol]);
        }
        return routers;
      }),
      providerLookupConcurrency: init.providerLookupConcurrency
    });
    const networkedStorage = new NetworkedStorage(components);
    this.pins = new PinsImpl(init.datastore, networkedStorage, this.getCodec);
    this.blockstore = new BlockStorage(networkedStorage, this.pins, {
      holdGcLock: init.holdGcLock ?? true
    });
    this.datastore = init.datastore;
    components.blockBrokers = init.blockBrokers.map((fn) => {
      return fn(components);
    });
  }
  async start() {
    await assertDatastoreVersionIsCurrent(this.datastore);
    await start(this.blockstore, this.datastore, this.routing);
  }
  async stop() {
    await stop(this.blockstore, this.datastore, this.routing);
  }
  async gc(options2 = {}) {
    const releaseLock = await this.blockstore.lock.writeLock();
    try {
      const helia = this;
      const blockstore = this.blockstore.unwrap();
      this.log("gc start");
      await src_default7(blockstore.deleteMany(async function* () {
        var _a13, _b9;
        for await (const { cid } of blockstore.getAll()) {
          try {
            if (await helia.pins.isPinned(cid, options2)) {
              continue;
            }
            yield cid;
            (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("helia:gc:deleted", cid));
          } catch (err) {
            helia.log.error("Error during gc", err);
            (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("helia:gc:error", err));
          }
        }
      }()));
    } finally {
      releaseLock();
    }
    this.log("gc finished");
  }
};

// node_modules/@helia/bitswap/dist/src/session.js
var BitswapSession = class extends AbstractSession {
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:bitswap:session"
    });
    __publicField(this, "wantList");
    __publicField(this, "network");
    this.wantList = components.wantList;
    this.network = components.network;
  }
  async queryProvider(cid, provider, options2) {
    this.log("sending WANT-BLOCK for %c to %p", cid, provider);
    const result = await this.wantList.wantSessionBlock(cid, provider, options2);
    this.log("%p %s %c", provider, result.has ? "has" : "does not have", cid);
    if (result.has && result.block != null) {
      return result.block;
    }
    throw new Error("Provider did not have block");
  }
  async *findNewProviders(cid, options2 = {}) {
    for await (const provider of this.network.findProviders(cid, options2)) {
      yield provider.id;
    }
  }
  toEvictionKey(provider) {
    return provider.toMultihash().bytes;
  }
  equals(providerA, providerB) {
    return providerA.equals(providerB);
  }
};
function createBitswapSession(components, init) {
  return new BitswapSession(components, init);
}

// node_modules/@helia/bitswap/dist/src/stats.js
var Stats = class {
  constructor(components) {
    __publicField(this, "blocksReceived");
    __publicField(this, "duplicateBlocksReceived");
    __publicField(this, "dataReceived");
    __publicField(this, "duplicateDataReceived");
    var _a13, _b9, _c5, _d2;
    this.blocksReceived = (_a13 = components.metrics) == null ? void 0 : _a13.registerMetricGroup("helia_bitswap_received_blocks");
    this.duplicateBlocksReceived = (_b9 = components.metrics) == null ? void 0 : _b9.registerMetricGroup("helia_bitswap_duplicate_received_blocks");
    this.dataReceived = (_c5 = components.metrics) == null ? void 0 : _c5.registerMetricGroup("helia_bitswap_data_received_bytes");
    this.duplicateDataReceived = (_d2 = components.metrics) == null ? void 0 : _d2.registerMetricGroup("helia_bitswap_duplicate_data_received_bytes");
  }
  updateBlocksReceived(count = 1, peerId) {
    var _a13;
    const stats = {
      global: count
    };
    if (peerId != null) {
      stats[peerId.toString()] = count;
    }
    (_a13 = this.blocksReceived) == null ? void 0 : _a13.increment(stats);
  }
  updateDuplicateBlocksReceived(count = 1, peerId) {
    var _a13;
    const stats = {
      global: count
    };
    if (peerId != null) {
      stats[peerId.toString()] = count;
    }
    (_a13 = this.duplicateBlocksReceived) == null ? void 0 : _a13.increment(stats);
  }
  updateDataReceived(bytes, peerId) {
    var _a13;
    const stats = {
      global: bytes
    };
    if (peerId != null) {
      stats[peerId.toString()] = bytes;
    }
    (_a13 = this.dataReceived) == null ? void 0 : _a13.increment(stats);
  }
  updateDuplicateDataReceived(bytes, peerId) {
    var _a13;
    const stats = {
      global: bytes
    };
    if (peerId != null) {
      stats[peerId.toString()] = bytes;
    }
    (_a13 = this.duplicateDataReceived) == null ? void 0 : _a13.increment(stats);
  }
};

// node_modules/@helia/bitswap/dist/src/utils/varint-decoder.js
function varintDecoder(buf) {
  if (!(buf instanceof Uint8Array)) {
    throw new Error("arg needs to be a Uint8Array");
  }
  const result = [];
  while (buf.length > 0) {
    const num = decode2(buf);
    result.push(num);
    buf = buf.slice(encodingLength(num));
  }
  return result;
}
var varint_decoder_default = varintDecoder;

// node_modules/@helia/bitswap/dist/src/want-list.js
var WantList = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    /**
     * Tracks what CIDs we've previously sent to which peers
     */
    __publicField(this, "peers");
    __publicField(this, "wants");
    __publicField(this, "network");
    __publicField(this, "log");
    __publicField(this, "sendMessagesDelay");
    __publicField(this, "sendMessagesTimeout");
    __publicField(this, "hashLoader");
    __publicField(this, "sendingMessages");
    setMaxListeners(Infinity, this);
    this.peers = trackedPeerMap({
      name: "helia_bitswap_peers",
      metrics: components.metrics
    });
    this.wants = trackedMap({
      name: "helia_bitswap_wantlist",
      metrics: components.metrics
    });
    this.network = components.network;
    this.sendMessagesDelay = init.sendMessagesDelay ?? DEFAULT_MESSAGE_SEND_DELAY;
    this.log = components.logger.forComponent("helia:bitswap:wantlist");
    this.hashLoader = init.hashLoader;
    this.network.addEventListener("bitswap:message", (evt) => {
      this.receiveMessage(evt.detail.peer, evt.detail.message).catch((err) => {
        this.log.error("error receiving bitswap message from %p", evt.detail.peer, err);
      });
    });
    this.network.addEventListener("peer:connected", (evt) => {
      this.peerConnected(evt.detail).catch((err) => {
        this.log.error("error processing newly connected bitswap peer %p", evt.detail, err);
      });
    });
    this.network.addEventListener("peer:disconnected", (evt) => {
      this.peerDisconnected(evt.detail);
    });
  }
  async addEntry(cid, options2) {
    var _a13;
    const cidStr = toString(cid.multihash.bytes, "base64");
    let entry = this.wants.get(cidStr);
    if (entry == null) {
      entry = {
        cid,
        priority: options2.priority ?? 1,
        wantType: options2.wantType ?? WantType.WantBlock,
        cancel: false,
        sendDontHave: true
      };
      this.wants.set(cidStr, entry);
    }
    if (entry.wantType === WantType.WantHave && options2.wantType === WantType.WantBlock) {
      entry.wantType = WantType.WantBlock;
    }
    await this.sendMessagesDebounced();
    try {
      if (options2.wantType === WantType.WantBlock) {
        const event2 = await raceEvent(this, "block", options2 == null ? void 0 : options2.signal, {
          filter: (event3) => {
            return equals(cid.multihash.digest, event3.detail.cid.multihash.digest);
          },
          errorMessage: "Want was aborted"
        });
        return event2.detail;
      }
      const event = await raceEvent(this, "presence", options2 == null ? void 0 : options2.signal, {
        filter: (event2) => {
          return equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
        },
        errorMessage: "Want was aborted"
      });
      return event.detail;
    } finally {
      if (((_a13 = options2.signal) == null ? void 0 : _a13.aborted) === true) {
        this.log("want for %c was aborted, cancelling want", cid);
        entry.cancel = true;
        await this.sendMessagesDebounced();
      }
    }
  }
  async sendMessagesDebounced() {
    var _a13;
    await ((_a13 = this.sendingMessages) == null ? void 0 : _a13.promise);
    clearTimeout(this.sendMessagesTimeout);
    this.sendMessagesTimeout = setTimeout(() => {
      void this.sendMessages().catch((err) => {
        this.log("error sending messages to peers", err);
      });
    }, this.sendMessagesDelay);
  }
  async sendMessages() {
    this.sendingMessages = pDefer();
    await Promise.all([...this.peers.entries()].map(async ([peerId, sentWants]) => {
      const sent = /* @__PURE__ */ new Set();
      const message2 = new QueuedBitswapMessage();
      for (const [key, entry] of this.wants.entries()) {
        const sentPreviously = sentWants.has(key);
        if (sentPreviously || entry.cancel) {
          continue;
        }
        sent.add(key);
        message2.addWantlistEntry(entry.cid, {
          cid: entry.cid.bytes,
          priority: entry.priority,
          wantType: entry.wantType,
          cancel: entry.cancel,
          sendDontHave: entry.sendDontHave
        });
      }
      if (message2.wantlist.size === 0) {
        return;
      }
      try {
        await this.network.sendMessage(peerId, message2);
        for (const key of sent) {
          sentWants.add(key);
        }
      } catch (err) {
        this.log.error("error sending full wantlist to new peer", err);
      }
    })).catch((err) => {
      this.log.error("error sending messages", err);
    });
    for (const [key, entry] of this.wants) {
      if (entry.cancel) {
        this.wants.delete(key);
        for (const sentWants of this.peers.values()) {
          sentWants.delete(key);
        }
      }
    }
    this.sendingMessages.resolve();
  }
  has(cid) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    return this.wants.has(cidStr);
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionPresence(cid, peerId, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantHave,
      priority: 1
    });
    await this.network.sendMessage(peerId, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId.equals(event2.detail.sender) && equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Add a CID to the wantlist
   */
  async wantBlock(cid, options2 = {}) {
    return this.addEntry(cid, {
      ...options2,
      wantType: WantType.WantBlock
    });
  }
  /**
   * Add a CID to the wantlist
   */
  async wantSessionBlock(cid, peerId, options2 = {}) {
    const message2 = new QueuedBitswapMessage();
    message2.addWantlistEntry(cid, {
      cid: cid.bytes,
      sendDontHave: true,
      wantType: WantType.WantBlock,
      priority: 1
    });
    await this.network.sendMessage(peerId, message2);
    const event = await raceEvent(this, "presence", options2.signal, {
      filter: (event2) => {
        return peerId.equals(event2.detail.sender) && equals(cid.multihash.digest, event2.detail.cid.multihash.digest);
      }
    });
    return event.detail;
  }
  /**
   * Invoked when a block has been received from an external source
   */
  async receivedBlock(cid, options2) {
    const cidStr = toString(cid.multihash.bytes, "base64");
    const entry = this.wants.get(cidStr);
    if (entry == null) {
      return;
    }
    entry.cancel = true;
    await this.sendMessagesDebounced();
  }
  /**
   * Invoked when a message is received from a bitswap peer
   */
  async receiveMessage(sender, message2) {
    var _a13;
    this.log("received message from %p with %d blocks", sender, message2.blocks.length);
    let blocksCancelled = false;
    for (const block of message2.blocks) {
      if (block.prefix == null || block.data == null) {
        continue;
      }
      const values = varint_decoder_default(block.prefix);
      const cidVersion = values[0];
      const multicodec2 = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha256.code ? sha256 : await ((_a13 = this.hashLoader) == null ? void 0 : _a13.getHasher(hashAlg));
      if (hasher == null) {
        this.log.error("unknown hash algorithm", hashAlg);
        continue;
      }
      let hash = hasher.digest(block.data);
      if (hash.then != null) {
        hash = await hash;
      }
      const cid = CID.create(cidVersion === 0 ? 0 : 1, multicodec2, hash);
      this.log("received block from %p for %c", sender, cid);
      this.safeDispatchEvent("block", {
        detail: {
          sender,
          cid,
          block: block.data
        }
      });
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: true,
          block: block.data
        }
      });
      const cidStr = toString(cid.multihash.bytes, "base64");
      const entry = this.wants.get(cidStr);
      if (entry == null) {
        continue;
      }
      entry.cancel = true;
      blocksCancelled = true;
    }
    for (const { cid: cidBytes, type } of message2.blockPresences) {
      const cid = CID.decode(cidBytes);
      this.log("received %s from %p for %c", type, sender, cid);
      this.safeDispatchEvent("presence", {
        detail: {
          sender,
          cid,
          has: type === BlockPresenceType.HaveBlock
        }
      });
    }
    if (blocksCancelled) {
      await this.sendMessagesDebounced();
    }
  }
  /**
   * Invoked when the network topology notices a new peer that supports Bitswap
   */
  async peerConnected(peerId) {
    const sentWants = /* @__PURE__ */ new Set();
    const message2 = new QueuedBitswapMessage(true);
    for (const [key, entry] of this.wants.entries()) {
      if (entry.cancel) {
        continue;
      }
      sentWants.add(key);
      message2.addWantlistEntry(entry.cid, {
        cid: entry.cid.bytes,
        priority: 1,
        wantType: WantType.WantBlock,
        cancel: false,
        sendDontHave: false
      });
    }
    if (message2.wantlist.size === 0) {
      this.peers.set(peerId, sentWants);
      return;
    }
    try {
      await this.network.sendMessage(peerId, message2);
      this.peers.set(peerId, sentWants);
    } catch (err) {
      this.log.error("error sending full wantlist to new peer %p", peerId, err);
    }
  }
  /**
   * Invoked when the network topology notices peer that supports Bitswap has
   * disconnected
   */
  peerDisconnected(peerId) {
    this.peers.delete(peerId);
  }
  start() {
  }
  stop() {
    this.peers.clear();
    clearTimeout(this.sendMessagesTimeout);
  }
};

// node_modules/@helia/bitswap/dist/src/bitswap.js
var Bitswap = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "logger");
    __publicField(this, "stats");
    __publicField(this, "network");
    __publicField(this, "blockstore");
    __publicField(this, "peerWantLists");
    __publicField(this, "wantList");
    this.logger = components.logger;
    this.log = components.logger.forComponent("helia:bitswap");
    this.blockstore = components.blockstore;
    this.stats = new Stats(components);
    this.network = new Network(components, init);
    this.peerWantLists = new PeerWantLists({
      ...components,
      network: this.network
    }, init);
    this.wantList = new WantList({
      ...components,
      network: this.network
    }, init);
  }
  createSession(options2 = {}) {
    return createBitswapSession({
      wantList: this.wantList,
      network: this.network,
      logger: this.logger
    }, options2);
  }
  async want(cid, options2 = {}) {
    const controller = new AbortController();
    const signal = anySignal([controller.signal, options2.signal]);
    setMaxListeners(Infinity, controller.signal, signal);
    this.network.findAndConnect(cid, {
      ...options2,
      signal
    }).catch((err) => {
      if (!controller.signal.aborted) {
        this.log.error("error during finding and connect for cid %c", cid, err);
      }
    });
    try {
      const result = await this.wantList.wantBlock(cid, {
        ...options2,
        signal
      });
      return result.block;
    } finally {
      controller.abort();
      signal.clear();
    }
  }
  /**
   * Sends notifications about the arrival of a block
   */
  async notify(cid, block, options2 = {}) {
    await Promise.all([
      this.peerWantLists.receivedBlock(cid, options2),
      this.wantList.receivedBlock(cid, options2)
    ]);
  }
  getWantlist() {
    return [...this.wantList.wants.values()].filter((entry) => !entry.cancel).map((entry) => ({
      cid: entry.cid,
      priority: entry.priority,
      wantType: entry.wantType
    }));
  }
  getPeerWantlist(peer) {
    return this.peerWantLists.wantListForPeer(peer);
  }
  /**
   * Start the bitswap node
   */
  async start() {
    this.wantList.start();
    await this.network.start();
  }
  /**
   * Stop the bitswap node
   */
  async stop() {
    this.wantList.stop();
    await this.network.stop();
  }
};

// node_modules/@helia/bitswap/dist/src/index.js
var createBitswap = (components, options2 = {}) => {
  return new Bitswap(components, options2);
};

// node_modules/@helia/block-brokers/dist/src/bitswap.js
var BitswapBlockBroker = class {
  constructor(components, init = {}) {
    __publicField(this, "bitswap");
    __publicField(this, "started");
    const { getHasher: getHasher2 } = components;
    this.bitswap = createBitswap(components, {
      hashLoader: {
        getHasher: async (codecOrName) => {
          return getHasher2(codecOrName);
        }
      },
      ...init
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await this.bitswap.start();
    this.started = true;
  }
  async stop() {
    await this.bitswap.stop();
    this.started = false;
  }
  async announce(cid, block, options2) {
    await this.bitswap.notify(cid, block, options2);
  }
  async retrieve(cid, options2 = {}) {
    return this.bitswap.want(cid, options2);
  }
  createSession(options2) {
    const session = this.bitswap.createSession(options2);
    return {
      announce: async (cid, block, options3) => {
        await this.bitswap.notify(cid, block, options3);
      },
      retrieve: async (cid, options3) => {
        return session.retrieve(cid, options3);
      }
    };
  }
};
function bitswap(init = {}) {
  return (components) => new BitswapBlockBroker(components, init);
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/trustless-gateway.js
var _attempts, _errors, _invalidBlocks, _successes, _pendingResponses, _uniqueBlockId, uniqueBlockId_fn;
var TrustlessGateway = class {
  constructor(url, logger2) {
    /**
     * This function returns a unique string for the multihash.bytes of the CID.
     *
     * Some useful resources for why this is needed can be found using the links below:
     *
     * - https://github.com/ipfs/helia/pull/503#discussion_r1572451331
     * - https://github.com/ipfs/kubo/issues/6815
     * - https://www.notion.so/pl-strflt/Handling-ambiguity-around-CIDs-9d5e14f6516f438980b01ef188efe15d#d9d45cd1ed8b4d349b96285de4aed5ab
     */
    __privateAdd(this, _uniqueBlockId);
    __publicField(this, "url");
    /**
     * The number of times this gateway has been attempted to be used to fetch a
     * block. This includes successful, errored, and aborted attempts. By counting
     * even aborted attempts, slow gateways that are out-raced by others will be
     * considered less reliable.
     */
    __privateAdd(this, _attempts, 0);
    /**
     * The number of times this gateway has errored while attempting to fetch a
     * block. This includes `response.ok === false` and any other errors that
     * throw while attempting to fetch a block. This does not include aborted
     * attempts.
     */
    __privateAdd(this, _errors, 0);
    /**
     * The number of times this gateway has returned an invalid block. A gateway
     * that returns the wrong blocks for a CID should be considered for removal
     * from the list of gateways to fetch blocks from.
     */
    __privateAdd(this, _invalidBlocks, 0);
    /**
     * The number of times this gateway has successfully fetched a block.
     */
    __privateAdd(this, _successes, 0);
    /**
     * A map of pending responses for this gateway. This is used to ensure that
     * only one request per CID is made to a given gateway at a time, and that we
     * don't make multiple in-flight requests for the same CID to the same gateway.
     */
    __privateAdd(this, _pendingResponses, /* @__PURE__ */ new Map());
    __publicField(this, "log");
    this.url = url instanceof URL ? url : new URL(url);
    this.log = logger2.forComponent(`helia:trustless-gateway-block-broker:${this.url.hostname}`);
  }
  /**
   * Fetch a raw block from `this.url` following the specification defined at
   * https://specs.ipfs.tech/http-gateways/trustless-gateway/
   */
  async getRawBlock(cid, signal) {
    const gwUrl = new URL(this.url.toString());
    gwUrl.pathname = `/ipfs/${cid.toString()}`;
    gwUrl.search = "?format=raw";
    if ((signal == null ? void 0 : signal.aborted) === true) {
      throw new Error(`Signal to fetch raw block for CID ${cid} from gateway ${this.url} was aborted prior to fetch`);
    }
    const blockId = __privateMethod(this, _uniqueBlockId, uniqueBlockId_fn).call(this, cid);
    const innerController = new AbortController();
    const abortInnerSignal = () => {
      innerController.abort();
    };
    signal == null ? void 0 : signal.addEventListener("abort", abortInnerSignal);
    try {
      let pendingResponse = __privateGet(this, _pendingResponses).get(blockId);
      if (pendingResponse == null) {
        __privateWrapper(this, _attempts)._++;
        pendingResponse = fetch(gwUrl.toString(), {
          signal: innerController.signal,
          headers: {
            Accept: "application/vnd.ipld.raw"
          },
          cache: "force-cache"
        }).then(async (res) => {
          this.log("GET %s %d", gwUrl, res.status);
          if (!res.ok) {
            __privateWrapper(this, _errors)._++;
            throw new Error(`unable to fetch raw block for CID ${cid} from gateway ${this.url}`);
          }
          __privateWrapper(this, _successes)._++;
          return new Uint8Array(await res.arrayBuffer());
        });
        __privateGet(this, _pendingResponses).set(blockId, pendingResponse);
      }
      return await pendingResponse;
    } catch (cause) {
      if ((signal == null ? void 0 : signal.aborted) === true) {
        throw new Error(`fetching raw block for CID ${cid} from gateway ${this.url} was aborted`);
      }
      __privateWrapper(this, _errors)._++;
      throw new Error(`unable to fetch raw block for CID ${cid}`);
    } finally {
      signal == null ? void 0 : signal.removeEventListener("abort", abortInnerSignal);
      __privateGet(this, _pendingResponses).delete(blockId);
    }
  }
  /**
   * Encapsulate the logic for determining whether a gateway is considered
   * reliable, for prioritization. This is based on the number of successful attempts made
   * and the number of errors encountered.
   *
   * Unused gateways have 100% reliability; They will be prioritized over
   * gateways with a 100% success rate to ensure that we attempt all gateways.
   */
  reliability() {
    if (__privateGet(this, _attempts) === 0) {
      return 1;
    }
    if (__privateGet(this, _invalidBlocks) > 0) {
      return -Infinity;
    }
    return __privateGet(this, _successes) / (__privateGet(this, _attempts) + __privateGet(this, _errors) * 3);
  }
  /**
   * Increment the number of invalid blocks returned by this gateway.
   */
  incrementInvalidBlocks() {
    __privateWrapper(this, _invalidBlocks)._++;
  }
  getStats() {
    return {
      attempts: __privateGet(this, _attempts),
      errors: __privateGet(this, _errors),
      invalidBlocks: __privateGet(this, _invalidBlocks),
      successes: __privateGet(this, _successes),
      pendingResponses: __privateGet(this, _pendingResponses).size
    };
  }
};
_attempts = new WeakMap();
_errors = new WeakMap();
_invalidBlocks = new WeakMap();
_successes = new WeakMap();
_pendingResponses = new WeakMap();
_uniqueBlockId = new WeakSet();
uniqueBlockId_fn = function(cid) {
  const multihashBytes = cid.multihash.bytes;
  return base64.encode(multihashBytes);
};

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/utils.js
function filterNonHTTPMultiaddrs(multiaddrs, allowInsecure, allowLocal) {
  return multiaddrs.filter((ma) => {
    if (HTTPS.matches(ma) || allowInsecure && HTTP.matches(ma)) {
      if (allowLocal) {
        return true;
      }
      if (DNS.matches(ma)) {
        return true;
      }
      return isPrivateIp(ma.toOptions().host) === false;
    }
    if (!allowInsecure && allowLocal) {
      const { host } = ma.toOptions();
      if (host === "127.0.0.1" || host === "localhost" || host.endsWith(".localhost")) {
        return true;
      }
    }
    return false;
  });
}
async function* findHttpGatewayProviders(cid, routing, logger2, allowInsecure, allowLocal, options2) {
  for await (const provider of routing.findProviders(cid, options2)) {
    const httpAddresses = filterNonHTTPMultiaddrs(provider.multiaddrs, allowInsecure, allowLocal);
    if (httpAddresses.length === 0) {
      continue;
    }
    const uri = multiaddrToUri(httpAddresses[0]);
    yield new TrustlessGateway(uri, logger2);
  }
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/session.js
var TrustlessGatewaySession = class extends AbstractSession {
  constructor(components, init) {
    super(components, {
      ...init,
      name: "helia:trustless-gateway:session"
    });
    __publicField(this, "routing");
    __publicField(this, "allowInsecure");
    __publicField(this, "allowLocal");
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
  }
  async queryProvider(cid, provider, options2) {
    var _a13;
    this.log("fetching BLOCK for %c from %s", cid, provider.url);
    const block = await provider.getRawBlock(cid, options2.signal);
    this.log.trace("got block for %c from %s", cid, provider.url);
    await ((_a13 = options2.validateFn) == null ? void 0 : _a13.call(options2, block));
    return block;
  }
  async *findNewProviders(cid, options2 = {}) {
    yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, options2);
  }
  toEvictionKey(provider) {
    return provider.url.toString();
  }
  equals(providerA, providerB) {
    return providerA.url.toString() === providerB.url.toString();
  }
};
function createTrustlessGatewaySession(components, init) {
  return new TrustlessGatewaySession(components, init);
}

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/broker.js
var TrustlessGatewayBlockBroker = class {
  constructor(components, init = {}) {
    __publicField(this, "allowInsecure");
    __publicField(this, "allowLocal");
    __publicField(this, "routing");
    __publicField(this, "log");
    __publicField(this, "logger");
    this.log = components.logger.forComponent("helia:trustless-gateway-block-broker");
    this.logger = components.logger;
    this.routing = components.routing;
    this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
    this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
  }
  async retrieve(cid, options2 = {}) {
    var _a13, _b9;
    const aggregateErrors = [];
    for await (const gateway of findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, options2)) {
      this.log("getting block for %c from %s", cid, gateway.url);
      try {
        const block = await gateway.getRawBlock(cid, options2.signal);
        this.log.trace("got block for %c from %s", cid, gateway.url);
        try {
          await ((_a13 = options2.validateFn) == null ? void 0 : _a13.call(options2, block));
        } catch (err) {
          this.log.error("failed to validate block for %c from %s", cid, gateway.url, err);
          continue;
        }
        return block;
      } catch (err) {
        this.log.error("failed to get block for %c from %s", cid, gateway.url, err);
        if (err instanceof Error) {
          aggregateErrors.push(err);
        } else {
          aggregateErrors.push(new Error(`Unable to fetch raw block for CID ${cid} from gateway ${gateway.url}`));
        }
        if (((_b9 = options2.signal) == null ? void 0 : _b9.aborted) === true) {
          this.log.trace("request aborted while fetching raw block for CID %c from gateway %s", cid, gateway.url);
          break;
        }
      }
    }
    if (aggregateErrors.length > 0) {
      throw new AggregateError(aggregateErrors, `Unable to fetch raw block for CID ${cid} from any gateway`);
    } else {
      throw new Error(`Unable to fetch raw block for CID ${cid} from any gateway`);
    }
  }
  createSession(options2 = {}) {
    return createTrustlessGatewaySession({
      logger: this.logger,
      routing: this.routing
    }, {
      ...options2,
      allowLocal: this.allowLocal,
      allowInsecure: this.allowInsecure
    });
  }
};

// node_modules/@helia/block-brokers/dist/src/trustless-gateway/index.js
var DEFAULT_ALLOW_INSECURE = false;
var DEFAULT_ALLOW_LOCAL = false;
function trustlessGateway(init = {}) {
  return (components) => new TrustlessGatewayBlockBroker(components, init);
}

// node_modules/browser-readablestream-to-it/dist/src/index.js
async function* browserReadableStreamToIt(stream, options2 = {}) {
  const reader = stream.getReader();
  try {
    while (true) {
      const result = await reader.read();
      if (result.done) {
        return;
      }
      yield result.value;
    }
  } finally {
    if (options2.preventCancel !== true) {
      await reader.cancel();
    }
    reader.releaseLock();
  }
}

// node_modules/ipns/dist/src/index.js
var import_timestamp_nano = __toESM(require_timestamp_min());

// node_modules/ipns/dist/src/errors.js
var SignatureVerificationError = class extends Error {
  constructor(message2 = "Record signature verification failed") {
    super(message2);
    this.name = "SignatureVerificationError";
  }
};
__publicField(SignatureVerificationError, "name", "SignatureVerificationError");
var RecordExpiredError = class extends Error {
  constructor(message2 = "Record has expired") {
    super(message2);
    this.name = "RecordExpiredError";
  }
};
__publicField(RecordExpiredError, "name", "RecordExpiredError");
var UnsupportedValidityError = class extends Error {
  constructor(message2 = "The validity type is unsupported") {
    super(message2);
    this.name = "UnsupportedValidityError";
  }
};
__publicField(UnsupportedValidityError, "name", "UnsupportedValidityError");
var RecordTooLargeError = class extends Error {
  constructor(message2 = "The record is too large") {
    super(message2);
    this.name = "RecordTooLargeError";
  }
};
__publicField(RecordTooLargeError, "name", "RecordTooLargeError");
var InvalidValueError = class extends Error {
  constructor(message2 = "Value must be a valid content path starting with /") {
    super(message2);
    this.name = "InvalidValueError";
  }
};
__publicField(InvalidValueError, "name", "InvalidValueError");
var InvalidRecordDataError = class extends Error {
  constructor(message2 = "Invalid record data") {
    super(message2);
    this.name = "InvalidRecordDataError";
  }
};
__publicField(InvalidRecordDataError, "name", "InvalidRecordDataError");
var InvalidEmbeddedPublicKeyError = class extends Error {
  constructor(message2 = "Invalid embedded public key") {
    super(message2);
    this.name = "InvalidEmbeddedPublicKeyError";
  }
};
__publicField(InvalidEmbeddedPublicKeyError, "name", "InvalidEmbeddedPublicKeyError");

// node_modules/ipns/dist/src/pb/ipns.js
var IpnsEntry;
(function(IpnsEntry2) {
  let ValidityType;
  (function(ValidityType2) {
    ValidityType2["EOL"] = "EOL";
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let __ValidityTypeValues;
  (function(__ValidityTypeValues2) {
    __ValidityTypeValues2[__ValidityTypeValues2["EOL"] = 0] = "EOL";
  })(__ValidityTypeValues || (__ValidityTypeValues = {}));
  (function(ValidityType2) {
    ValidityType2.codec = () => {
      return enumeration(__ValidityTypeValues);
    };
  })(ValidityType = IpnsEntry2.ValidityType || (IpnsEntry2.ValidityType = {}));
  let _codec;
  IpnsEntry2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null) {
          w.uint32(10);
          w.bytes(obj.value);
        }
        if (obj.signatureV1 != null) {
          w.uint32(18);
          w.bytes(obj.signatureV1);
        }
        if (obj.validityType != null) {
          w.uint32(24);
          IpnsEntry2.ValidityType.codec().encode(obj.validityType, w);
        }
        if (obj.validity != null) {
          w.uint32(34);
          w.bytes(obj.validity);
        }
        if (obj.sequence != null) {
          w.uint32(40);
          w.uint64(obj.sequence);
        }
        if (obj.ttl != null) {
          w.uint32(48);
          w.uint64(obj.ttl);
        }
        if (obj.pubKey != null) {
          w.uint32(58);
          w.bytes(obj.pubKey);
        }
        if (obj.signatureV2 != null) {
          w.uint32(66);
          w.bytes(obj.signatureV2);
        }
        if (obj.data != null) {
          w.uint32(74);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.bytes();
              break;
            }
            case 2: {
              obj.signatureV1 = reader.bytes();
              break;
            }
            case 3: {
              obj.validityType = IpnsEntry2.ValidityType.codec().decode(reader);
              break;
            }
            case 4: {
              obj.validity = reader.bytes();
              break;
            }
            case 5: {
              obj.sequence = reader.uint64();
              break;
            }
            case 6: {
              obj.ttl = reader.uint64();
              break;
            }
            case 7: {
              obj.pubKey = reader.bytes();
              break;
            }
            case 8: {
              obj.signatureV2 = reader.bytes();
              break;
            }
            case 9: {
              obj.data = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  IpnsEntry2.encode = (obj) => {
    return encodeMessage(obj, IpnsEntry2.codec());
  };
  IpnsEntry2.decode = (buf, opts) => {
    return decodeMessage(buf, IpnsEntry2.codec(), opts);
  };
})(IpnsEntry || (IpnsEntry = {}));

// node_modules/ipns/dist/src/utils.js
var log = logger("ipns:utils");
var IPNS_PREFIX = fromString("/ipns/");
var IDENTITY_CODEC2 = 0;
var SHA2_256_CODEC = 18;
function extractPublicKeyFromIPNSRecord(record) {
  let pubKey;
  if (record.pubKey != null) {
    try {
      pubKey = publicKeyFromProtobuf(record.pubKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  if (pubKey != null) {
    return pubKey;
  }
}
function ipnsRecordDataForV2Sig(data) {
  const entryData = fromString("ipns-signature:");
  return concat([entryData, data]);
}
function marshalIPNSRecord(obj) {
  if ("signatureV1" in obj) {
    return IpnsEntry.encode({
      value: fromString(obj.value),
      signatureV1: obj.signatureV1,
      validityType: obj.validityType,
      validity: fromString(obj.validity),
      sequence: obj.sequence,
      ttl: obj.ttl,
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  } else {
    return IpnsEntry.encode({
      pubKey: obj.pubKey,
      signatureV2: obj.signatureV2,
      data: obj.data
    });
  }
}
function unmarshalIPNSRecord(buf) {
  const message2 = IpnsEntry.decode(buf);
  if (message2.sequence != null) {
    message2.sequence = BigInt(message2.sequence);
  }
  if (message2.ttl != null) {
    message2.ttl = BigInt(message2.ttl);
  }
  if (message2.signatureV2 == null || message2.data == null) {
    throw new SignatureVerificationError("Missing data or signatureV2");
  }
  const data = parseCborData(message2.data);
  const value = normalizeByteValue(data.Value);
  const validity = toString(data.Validity);
  if (message2.value != null && message2.signatureV1 != null) {
    validateCborDataMatchesPbData(message2);
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV1: message2.signatureV1,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else if (message2.signatureV2 != null) {
    return {
      value,
      validityType: IpnsEntry.ValidityType.EOL,
      validity,
      sequence: data.Sequence,
      ttl: data.TTL,
      pubKey: message2.pubKey,
      signatureV2: message2.signatureV2,
      data: message2.data
    };
  } else {
    throw new Error("invalid record: does not include signatureV1 or signatureV2");
  }
}
function multihashToIPNSRoutingKey(digest) {
  return concat([
    IPNS_PREFIX,
    digest.bytes
  ]);
}
function multihashFromIPNSRoutingKey(key) {
  const digest = decode(key.slice(IPNS_PREFIX.length));
  if (!isCodec(digest, IDENTITY_CODEC2) && !isCodec(digest, SHA2_256_CODEC)) {
    throw new InvalidMultihashError("Multihash in IPNS key was not identity or sha2-256");
  }
  return digest;
}
function parseCborData(buf) {
  const data = decode4(buf);
  if (data.ValidityType === 0) {
    data.ValidityType = IpnsEntry.ValidityType.EOL;
  } else {
    throw new UnsupportedValidityError("The validity type is unsupported");
  }
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  return data;
}
function normalizeByteValue(value) {
  const string = toString(value).trim();
  if (string.startsWith("/")) {
    return string;
  }
  try {
    return `/ipfs/${CID.decode(value).toV1().toString()}`;
  } catch {
  }
  try {
    return `/ipfs/${CID.parse(string).toV1().toString()}`;
  } catch {
  }
  throw new InvalidValueError("Value must be a valid content path starting with /");
}
function validateCborDataMatchesPbData(entry) {
  if (entry.data == null) {
    throw new InvalidRecordDataError("Record data is missing");
  }
  const data = parseCborData(entry.data);
  if (!equals(data.Value, entry.value ?? new Uint8Array(0))) {
    throw new SignatureVerificationError('Field "value" did not match between protobuf and CBOR');
  }
  if (!equals(data.Validity, entry.validity ?? new Uint8Array(0))) {
    throw new SignatureVerificationError('Field "validity" did not match between protobuf and CBOR');
  }
  if (data.ValidityType !== entry.validityType) {
    throw new SignatureVerificationError('Field "validityType" did not match between protobuf and CBOR');
  }
  if (data.Sequence !== entry.sequence) {
    throw new SignatureVerificationError('Field "sequence" did not match between protobuf and CBOR');
  }
  if (data.TTL !== entry.ttl) {
    throw new SignatureVerificationError('Field "ttl" did not match between protobuf and CBOR');
  }
}
function isCodec(digest, codec) {
  return digest.code === codec;
}

// node_modules/ipns/dist/src/index.js
var log2 = logger("ipns");
var DEFAULT_TTL_NS = 60 * 60 * 1e9;
var namespace = "/ipns/";
var namespaceLength = namespace.length;

// node_modules/ipns/dist/src/validator.js
var import_timestamp_nano2 = __toESM(require_timestamp_min());
var log3 = logger("ipns:validator");
var MAX_RECORD_SIZE = 1024 * 10;
var validate = async (publicKey, buf) => {
  const record = unmarshalIPNSRecord(buf);
  let isValid;
  try {
    const dataForSignature = ipnsRecordDataForV2Sig(record.data);
    isValid = await publicKey.verify(dataForSignature, record.signatureV2);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log3.error("record signature verification failed");
    throw new SignatureVerificationError("Record signature verification failed");
  }
  if (record.validityType === IpnsEntry.ValidityType.EOL) {
    if (import_timestamp_nano2.default.fromString(record.validity).toDate().getTime() < Date.now()) {
      log3.error("record has expired");
      throw new RecordExpiredError("record has expired");
    }
  } else if (record.validityType != null) {
    log3.error("the validity type is unsupported");
    throw new UnsupportedValidityError("The validity type is unsupported");
  }
  log3("ipns record for %s is valid", record.value);
};
async function ipnsValidator(key, marshalledData) {
  if (marshalledData.byteLength > MAX_RECORD_SIZE) {
    throw new RecordTooLargeError("The record is too large");
  }
  const routingMultihash = multihashFromIPNSRoutingKey(key);
  let routingPubKey;
  if (isCodec(routingMultihash, 0)) {
    routingPubKey = publicKeyFromMultihash(routingMultihash);
  }
  const receivedRecord = unmarshalIPNSRecord(marshalledData);
  const recordPubKey = extractPublicKeyFromIPNSRecord(receivedRecord) ?? routingPubKey;
  if (recordPubKey == null) {
    throw new InvalidEmbeddedPublicKeyError("Could not extract public key from IPNS record or routing key");
  }
  const routingKey = multihashToIPNSRoutingKey(recordPubKey.toMultihash());
  if (!equals(key, routingKey)) {
    throw new InvalidEmbeddedPublicKeyError("Embedded public key did not match routing key");
  }
  await validate(recordPubKey, marshalledData);
}

// node_modules/it-ndjson/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MESSAGE_LENGTH");
  }
};

// node_modules/it-ndjson/dist/src/parse.js
async function* parse(source, opts = {}) {
  const matcher = /\r?\n/;
  const decoder = new TextDecoder("utf8");
  let buffer = "";
  for await (let chunk of source) {
    if (typeof chunk === "string") {
      chunk = new TextEncoder().encode(chunk);
    }
    if (isUint8ArrayList(chunk)) {
      chunk = chunk.subarray();
    }
    buffer += decoder.decode(chunk, { stream: true });
    if (buffer.length > ((opts == null ? void 0 : opts.maxMessageLength) ?? buffer.length)) {
      throw new InvalidMessageLengthError("Incoming message too long");
    }
    const parts = buffer.split(matcher);
    buffer = parts.pop() ?? "";
    for (let i = 0; i < parts.length; i++) {
      yield JSON.parse(parts[i]);
    }
  }
  buffer += decoder.decode();
  if (buffer !== "") {
    yield JSON.parse(buffer);
  }
}

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/errors.js
var InvalidRequestError = class extends Error {
  constructor(message2 = "Invalid request") {
    super(message2);
    this.name = "InvalidRequestError";
  }
};
__publicField(InvalidRequestError, "name", "InvalidRequestError");
var BadResponseError = class extends Error {
  constructor(message2 = "Bad response") {
    super(message2);
    this.name = "BadResponseError";
  }
};
__publicField(BadResponseError, "name", "BadResponseError");

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/routings.js
var IPNS_PREFIX2 = fromString("/ipns/");
function isIPNSKey(key) {
  return equals(key.subarray(0, IPNS_PREFIX2.byteLength), IPNS_PREFIX2);
}
var DelegatedRoutingV1HttpApiClientContentRouting = class {
  constructor(client) {
    __publicField(this, "client");
    this.client = client;
  }
  async *findProviders(cid, options2 = {}) {
    yield* src_default6(this.client.getProviders(cid, options2), (record) => {
      return {
        id: record.ID,
        multiaddrs: record.Addrs ?? []
      };
    });
  }
  async provide() {
  }
  async cancelReprovide() {
  }
  async put(key, value, options2) {
    if (!isIPNSKey(key)) {
      return;
    }
    const digest = multihashFromIPNSRoutingKey(key);
    const cid = CID.createV1(114, digest);
    const record = unmarshalIPNSRecord(value);
    await this.client.putIPNS(cid, record, options2);
  }
  async get(key, options2) {
    if (!isIPNSKey(key)) {
      throw new NotFoundError("Not found");
    }
    const digest = multihashFromIPNSRoutingKey(key);
    const cid = CID.createV1(114, digest);
    try {
      const record = await this.client.getIPNS(cid, options2);
      return marshalIPNSRecord(record);
    } catch (err) {
      if (err.name === "BadResponseError") {
        throw new NotFoundError("Not found");
      }
      throw err;
    }
  }
};
var DelegatedRoutingV1HttpApiClientPeerRouting = class {
  constructor(client) {
    __publicField(this, "client");
    this.client = client;
  }
  async findPeer(peerId, options2 = {}) {
    const peer = await src_default3(this.client.getPeers(peerId, options2));
    if (peer != null) {
      return {
        id: peer.ID,
        multiaddrs: peer.Addrs ?? []
      };
    }
    throw new NotFoundError("Not found");
  }
  async *getClosestPeers(key, options2 = {}) {
  }
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/client.js
var log4 = logger("delegated-routing-v1-http-api-client");
var defaultValues = {
  concurrentRequests: 4,
  timeout: 3e4,
  cacheTTL: 5 * 60 * 1e3,
  // 5 minutes default as per https://specs.ipfs.tech/routing/http-routing-v1/#response-headers
  cacheName: "delegated-routing-v1-cache"
};
var _conformToPeerSchema, conformToPeerSchema_fn, _addFilterParams, addFilterParams_fn, _makeRequest, makeRequest_fn;
var DefaultDelegatedRoutingV1HttpApiClient = class {
  /**
   * Create a new DelegatedContentRouting instance
   */
  constructor(url, init = {}) {
    __privateAdd(this, _conformToPeerSchema);
    __privateAdd(this, _addFilterParams);
    /**
     * makeRequest has two features:
     * - Ensures only one concurrent request is made for the same URL
     * - Caches GET requests if the Cache API is available
     */
    __privateAdd(this, _makeRequest);
    __publicField(this, "started");
    __publicField(this, "httpQueue");
    __publicField(this, "shutDownController");
    __publicField(this, "clientUrl");
    __publicField(this, "timeout");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "filterAddrs");
    __publicField(this, "filterProtocols");
    __publicField(this, "inFlightRequests");
    __publicField(this, "cacheName");
    __publicField(this, "cache");
    __publicField(this, "cacheTTL");
    this.started = false;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.httpQueue = new PQueue({
      concurrency: init.concurrentRequests ?? defaultValues.concurrentRequests
    });
    this.inFlightRequests = /* @__PURE__ */ new Map();
    this.clientUrl = url instanceof URL ? url : new URL(url);
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.filterAddrs = init.filterAddrs;
    this.filterProtocols = init.filterProtocols;
    this.contentRouting = new DelegatedRoutingV1HttpApiClientContentRouting(this);
    this.peerRouting = new DelegatedRoutingV1HttpApiClientPeerRouting(this);
    this.cacheName = init.cacheName ?? defaultValues.cacheName;
    this.cacheTTL = init.cacheTTL ?? defaultValues.cacheTTL;
  }
  get [contentRoutingSymbol]() {
    return this.contentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.peerRouting;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    var _a13;
    if (this.started) {
      return;
    }
    this.started = true;
    if (this.cacheTTL > 0) {
      this.cache = await ((_a13 = globalThis.caches) == null ? void 0 : _a13.open(this.cacheName));
      if (this.cache != null) {
        log4("cache enabled with ttl %d", this.cacheTTL);
      }
    }
  }
  async stop() {
    var _a13;
    this.httpQueue.clear();
    this.shutDownController.abort();
    await ((_a13 = globalThis.caches) == null ? void 0 : _a13.delete(this.cacheName));
    this.started = false;
  }
  async *getProviders(cid, options2 = {}) {
    log4("getProviders starts: %c", cid);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const url = new URL(`${this.clientUrl}routing/v1/providers/${cid.toString()}`);
      __privateMethod(this, _addFilterParams, addFilterParams_fn).call(this, url, options2.filterAddrs, options2.filterProtocols);
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await __privateMethod(this, _makeRequest, makeRequest_fn).call(this, url.toString(), getOptions);
      if (res.status === 404) {
        throw new NotFoundError("No matching records found");
      }
      if (res.status === 422) {
        throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
      }
      if (res.body == null) {
        throw new BadResponseError("Routing response had no body");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const provider of body.Providers) {
          const record = __privateMethod(this, _conformToPeerSchema, conformToPeerSchema_fn).call(this, provider);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const provider of parse(browserReadableStreamToIt(res.body))) {
          const record = __privateMethod(this, _conformToPeerSchema, conformToPeerSchema_fn).call(this, provider);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log4.error("getProviders errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getProviders finished: %c", cid);
    }
  }
  async *getPeers(peerId, options2 = {}) {
    log4("getPeers starts: %c", peerId);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    try {
      await onStart.promise;
      const url = new URL(`${this.clientUrl}routing/v1/peers/${peerId.toCID().toString()}`);
      __privateMethod(this, _addFilterParams, addFilterParams_fn).call(this, url, options2.filterAddrs, options2.filterProtocols);
      const getOptions = { headers: { Accept: "application/x-ndjson" }, signal };
      const res = await __privateMethod(this, _makeRequest, makeRequest_fn).call(this, url.toString(), getOptions);
      if (res.status === 404) {
        throw new NotFoundError("No matching records found");
      }
      if (res.status === 422) {
        throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
      }
      if (res.body == null) {
        throw new BadResponseError("Routing response had no body");
      }
      const contentType = res.headers.get("Content-Type");
      if (contentType === "application/json") {
        const body = await res.json();
        for (const peer of body.Peers) {
          const record = __privateMethod(this, _conformToPeerSchema, conformToPeerSchema_fn).call(this, peer);
          if (record != null) {
            yield record;
          }
        }
      } else {
        for await (const peer of parse(browserReadableStreamToIt(res.body))) {
          const record = __privateMethod(this, _conformToPeerSchema, conformToPeerSchema_fn).call(this, peer);
          if (record != null) {
            yield record;
          }
        }
      }
    } catch (err) {
      log4.error("getPeers errored:", err);
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getPeers finished: %c", peerId);
    }
  }
  async getIPNS(libp2pKey, options2 = {}) {
    log4("getIPNS starts: %s", libp2pKey);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
    try {
      await onStart.promise;
      const getOptions = { headers: { Accept: "application/vnd.ipfs.ipns-record" }, signal };
      const res = await __privateMethod(this, _makeRequest, makeRequest_fn).call(this, resource, getOptions);
      log4("getIPNS GET %s %d", resource, res.status);
      if (res.status === 404) {
        throw new NotFoundError("No matching records found");
      }
      if (res.status === 422) {
        throw new InvalidRequestError("Request does not conform to schema or semantic constraints");
      }
      if (res.body == null) {
        throw new BadResponseError("GET ipns response had no body");
      }
      const buf = await res.arrayBuffer();
      const body = new Uint8Array(buf, 0, buf.byteLength);
      if (options2.validate !== false) {
        await ipnsValidator(multihashToIPNSRoutingKey(libp2pKey.multihash), body);
      }
      return unmarshalIPNSRecord(body);
    } catch (err) {
      log4.error("getIPNS GET %s error:", resource, err);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("getIPNS finished: %s", libp2pKey);
    }
  }
  async putIPNS(libp2pKey, record, options2 = {}) {
    log4("putIPNS starts: %c", libp2pKey);
    const timeoutSignal = AbortSignal.timeout(this.timeout);
    const signal = anySignal([this.shutDownController.signal, timeoutSignal, options2.signal]);
    setMaxListeners(Infinity, timeoutSignal, signal);
    const onStart = pDefer();
    const onFinish = pDefer();
    void this.httpQueue.add(async () => {
      onStart.resolve();
      return onFinish.promise;
    });
    const resource = `${this.clientUrl}routing/v1/ipns/${libp2pKey}`;
    try {
      await onStart.promise;
      const body = marshalIPNSRecord(record);
      const getOptions = { method: "PUT", headers: { "Content-Type": "application/vnd.ipfs.ipns-record" }, body, signal };
      const res = await __privateMethod(this, _makeRequest, makeRequest_fn).call(this, resource, getOptions);
      log4("putIPNS PUT %s %d", resource, res.status);
      if (res.status !== 200) {
        throw new BadResponseError("PUT ipns response had status other than 200");
      }
    } catch (err) {
      log4.error("putIPNS PUT %s error:", resource, err.stack);
      throw err;
    } finally {
      signal.clear();
      onFinish.resolve();
      log4("putIPNS finished: %c", libp2pKey);
    }
  }
};
_conformToPeerSchema = new WeakSet();
conformToPeerSchema_fn = function(record) {
  var _a13;
  try {
    const protocols = [];
    const multiaddrs = ((_a13 = record.Addrs) == null ? void 0 : _a13.map(multiaddr)) ?? [];
    if (record.Protocols != null) {
      protocols.push(...record.Protocols);
    }
    if (record.Protocol != null) {
      protocols.push(record.Protocol);
      delete record.Protocol;
    }
    return {
      ...record,
      Schema: "peer",
      ID: peerIdFromString(record.ID),
      Addrs: multiaddrs,
      Protocols: protocols
    };
  } catch (err) {
    log4.error("could not conform record to peer schema", err);
  }
};
_addFilterParams = new WeakSet();
addFilterParams_fn = function(url, filterAddrs, filterProtocols) {
  var _a13, _b9;
  if (filterAddrs != null || this.filterAddrs != null) {
    const adressFilter = (filterAddrs == null ? void 0 : filterAddrs.join(",")) ?? ((_a13 = this.filterAddrs) == null ? void 0 : _a13.join(",")) ?? "";
    if (adressFilter !== "") {
      url.searchParams.set("filter-addrs", adressFilter);
    }
  }
  if (filterProtocols != null || this.filterProtocols != null) {
    const protocolFilter = (filterProtocols == null ? void 0 : filterProtocols.join(",")) ?? ((_b9 = this.filterProtocols) == null ? void 0 : _b9.join(",")) ?? "";
    if (protocolFilter !== "") {
      url.searchParams.set("filter-protocols", protocolFilter);
    }
  }
};
_makeRequest = new WeakSet();
makeRequest_fn = async function(url, options2) {
  var _a13, _b9;
  const requestMethod = options2.method ?? "GET";
  const key = `${requestMethod}-${url}`;
  if (requestMethod === "GET") {
    const cachedResponse = await ((_a13 = this.cache) == null ? void 0 : _a13.match(url));
    if (cachedResponse != null) {
      const expires = parseInt(cachedResponse.headers.get("x-cache-expires") ?? "0", 10);
      if (expires > Date.now()) {
        log4("returning cached response for %s", key);
        return cachedResponse;
      } else {
        await ((_b9 = this.cache) == null ? void 0 : _b9.delete(url));
      }
    }
  }
  const existingRequest = this.inFlightRequests.get(key);
  if (existingRequest != null) {
    const response2 = await existingRequest;
    log4("deduplicating outgoing request for %s", key);
    return response2.clone();
  }
  const requestPromise = fetch(url, options2).then(async (response2) => {
    if (this.cache != null && response2.ok && requestMethod === "GET") {
      const expires = Date.now() + this.cacheTTL;
      const headers = new Headers(response2.headers);
      headers.set("x-cache-expires", expires.toString());
      const cachedResponse = new Response(response2.clone().body, {
        status: response2.status,
        statusText: response2.statusText,
        headers
      });
      await this.cache.put(url, cachedResponse);
    }
    return response2;
  }).finally(() => {
    this.inFlightRequests.delete(key);
  });
  this.inFlightRequests.set(key, requestPromise);
  const response = await requestPromise;
  return response;
};

// node_modules/@helia/delegated-routing-v1-http-api-client/dist/src/index.js
function createDelegatedRoutingV1HttpApiClient(url, init = {}) {
  return new DefaultDelegatedRoutingV1HttpApiClient(new URL(url), init);
}

// node_modules/@helia/routers/dist/src/utils/delegated-http-routing-defaults.browser.js
function delegatedHTTPRoutingDefaults() {
  return {
    filterProtocols: ["unknown", "transport-bitswap", "transport-ipfs-gateway-http"],
    filterAddrs: ["https", "webtransport", "webrtc", "webrtc-direct", "wss", "tls"]
  };
}

// node_modules/@helia/routers/dist/src/delegated-http-routing.js
var IPNS_PREFIX3 = fromString("/ipns/");

// node_modules/ip-regex/index.js
var word = "[a-fA-F\\d:]";
var boundry = (options2) => options2 && options2.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);
var ipRegex = (options2) => options2 && options2.exact ? v46Exact : new RegExp(`(?:${boundry(options2)}${v4}${boundry(options2)})|(?:${boundry(options2)}${v6}${boundry(options2)})`, "g");
ipRegex.v4 = (options2) => options2 && options2.exact ? v4exact : new RegExp(`${boundry(options2)}${v4}${boundry(options2)}`, "g");
ipRegex.v6 = (options2) => options2 && options2.exact ? v6exact : new RegExp(`${boundry(options2)}${v6}${boundry(options2)}`, "g");
var ip_regex_default = ipRegex;

// node_modules/function-timeout/browser.js
function functionTimeout(function_) {
  const wrappedFunction = (...arguments_) => function_(...arguments_);
  Object.defineProperty(wrappedFunction, "name", {
    value: `functionTimeout(${function_.name || "<anonymous>"})`,
    configurable: true
  });
  return wrappedFunction;
}
function isTimeoutError() {
  return false;
}

// node_modules/is-regexp/index.js
var { toString: toString2 } = Object.prototype;
function isRegexp(value) {
  return toString2.call(value) === "[object RegExp]";
}

// node_modules/clone-regexp/index.js
var flagMap = {
  global: "g",
  ignoreCase: "i",
  multiline: "m",
  dotAll: "s",
  sticky: "y",
  unicode: "u"
};
function clonedRegexp(regexp, options2 = {}) {
  if (!isRegexp(regexp)) {
    throw new TypeError("Expected a RegExp instance");
  }
  const flags = Object.keys(flagMap).map((flag) => (typeof options2[flag] === "boolean" ? options2[flag] : regexp[flag]) ? flagMap[flag] : "").join("");
  const clonedRegexp2 = new RegExp(options2.source || regexp.source, flags);
  clonedRegexp2.lastIndex = typeof options2.lastIndex === "number" ? options2.lastIndex : regexp.lastIndex;
  return clonedRegexp2;
}

// node_modules/super-regex/index.js
function isMatch(regex, string, { timeout } = {}) {
  try {
    return functionTimeout(() => clonedRegexp(regex).test(string), { timeout })();
  } catch (error) {
    if (isTimeoutError(error)) {
      return false;
    }
    throw error;
  }
}

// node_modules/is-ip/index.js
var maxIPv4Length = 15;
var maxIPv6Length = 45;
var options = {
  timeout: 400
};
function isIPv6(string) {
  if (string.length > maxIPv6Length) {
    return false;
  }
  return isMatch(ip_regex_default.v6({ exact: true }), string, options);
}
function isIPv4(string) {
  if (string.length > maxIPv4Length) {
    return false;
  }
  return isMatch(ip_regex_default.v4({ exact: true }), string, options);
}

// node_modules/@multiformats/uri-to-multiaddr/dist/src/index.js
var portFor = {
  http: "80",
  https: "443",
  ws: "80",
  wss: "443"
};
var BROWSER_SCHEMES = ["http", "https", "ws", "wss"];
function uriToMultiaddr(uriStr, opts) {
  opts = opts ?? {};
  const defaultDnsType = opts.defaultDnsType ?? "dns4";
  const { scheme, hostname, port } = parseUri(uriStr);
  const parts = [
    tupleForHostname(hostname, defaultDnsType),
    tupleForPort(port, scheme),
    tupleForScheme(scheme)
  ];
  const multiaddrStr = "/" + parts.filter((x) => Boolean(x)).reduce((a, b) => a.concat(b), []).join("/");
  return multiaddr(multiaddrStr);
}
function parseUri(uriStr) {
  const [scheme] = uriStr.split(":");
  if (!BROWSER_SCHEMES.includes(scheme)) {
    uriStr = "http" + uriStr.substring(scheme.length);
  }
  let { protocol, hostname, port } = new URL(uriStr);
  if (port == null || port === "") {
    const protocolPort = portForProtocol(scheme);
    if (protocolPort != null) {
      port = protocolPort;
    }
    if (protocolPort == null && protocol === "http:") {
      port = "80";
    }
  }
  return { scheme, hostname, port };
}
function tupleForHostname(hostname, defaultDnsType) {
  if (hostname == null || hostname === "") {
    return void 0;
  }
  if (isIPv4(hostname)) {
    return ["ip4", hostname];
  }
  if (isIPv6(hostname)) {
    return ["ip6", hostname];
  }
  if (hostname[0] === "[") {
    const trimmed = hostname.substring(1, hostname.length - 1);
    if (isIPv6(trimmed)) {
      return ["ip6", trimmed];
    }
  }
  return [defaultDnsType, hostname];
}
function tupleForPort(port, scheme) {
  if (port == null || port === "") {
    return void 0;
  }
  if (scheme === "udp") {
    return ["udp", port];
  }
  return ["tcp", port];
}
function tupleForScheme(scheme) {
  if (scheme.match(/^tcp$|^udp$/) != null) {
    return void 0;
  }
  return [scheme];
}
function portForProtocol(protocol) {
  if (protocol == null || protocol === "" || portFor[protocol] == null) {
    return void 0;
  }
  return portFor[protocol];
}

// node_modules/@helia/routers/dist/src/http-gateway-routing.js
var DEFAULT_TRUSTLESS_GATEWAYS = [
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://trustless-gateway.link",
  // 2023-10-03: IPNS, Origin, and Block/CAR support from https://ipfs-public-gateway-checker.on.fleek.co/
  "https://4everland.io"
];
var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
function toPeerInfo(url) {
  url = url.toString();
  return {
    id: peerIdFromCID(CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, identity.digest(fromString(url)))),
    multiaddrs: [
      uriToMultiaddr(url)
    ]
  };
}
var HTTPGatewayRouter = class {
  constructor(init = {}) {
    __publicField(this, "gateways");
    this.gateways = (init.gateways ?? DEFAULT_TRUSTLESS_GATEWAYS).map((url) => toPeerInfo(url));
  }
  async *findProviders(cid, options2) {
    yield* this.gateways.toSorted(() => Math.random() > 0.5 ? 1 : -1).map((info) => ({
      ...info,
      protocols: ["transport-ipfs-gateway-http"]
    }));
  }
};
function httpGatewayRouting(init = {}) {
  return new HTTPGatewayRouter(init);
}

// node_modules/@helia/routers/dist/src/libp2p-routing.js
var Libp2pRouter = class {
  constructor(libp2p) {
    __publicField(this, "libp2p");
    this.libp2p = libp2p;
  }
  async provide(cid, options2) {
    await this.libp2p.contentRouting.provide(cid, options2);
  }
  async cancelReprovide(key, options2) {
    await this.libp2p.contentRouting.cancelReprovide(key, options2);
  }
  async *findProviders(cid, options2) {
    yield* this.libp2p.contentRouting.findProviders(cid, options2);
  }
  async put(key, value, options2) {
    await this.libp2p.contentRouting.put(key, value, options2);
  }
  async get(key, options2) {
    return this.libp2p.contentRouting.get(key, options2);
  }
  async findPeer(peerId, options2) {
    return this.libp2p.peerRouting.findPeer(peerId, options2);
  }
  async *getClosestPeers(key, options2) {
    yield* this.libp2p.peerRouting.getClosestPeers(key, options2);
  }
};
function libp2pRouting(libp2p) {
  return new Libp2pRouter(libp2p);
}

// node_modules/blockstore-core/dist/src/memory.js
var MemoryBlockstore = class extends BaseBlockstore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(base32.encode(key.multihash.bytes), val);
    return key;
  }
  get(key) {
    const buf = this.data.get(base32.encode(key.multihash.bytes));
    if (buf == null) {
      throw new NotFoundError2();
    }
    return buf;
  }
  has(key) {
    return this.data.has(base32.encode(key.multihash.bytes));
  }
  async delete(key) {
    this.data.delete(base32.encode(key.multihash.bytes));
  }
  async *getAll() {
    for (const [key, value] of this.data.entries()) {
      yield {
        cid: CID.createV1(code2, decode(base32.decode(key))),
        block: value
      };
    }
  }
};

// node_modules/blockstore-core/dist/src/tiered.js
var log5 = logger("blockstore:core:tiered");

// node_modules/datastore-core/dist/src/shard.js
var SHARDING_FN = "SHARDING";

// node_modules/datastore-core/dist/src/sharding.js
var shardKey = new Key(SHARDING_FN);

// node_modules/datastore-core/dist/src/tiered.js
var log6 = logger("datastore:core:tiered");

// node_modules/helia/dist/src/helia-p2p.js
var HeliaP2P = class extends Helia {
  constructor(init) {
    super({
      ...init,
      components: {
        libp2p: init.libp2p
      }
    });
    __publicField(this, "libp2p");
    this.libp2p = init.libp2p;
  }
  async start() {
    await super.start();
    await this.libp2p.start();
  }
  async stop() {
    await super.stop();
    await this.libp2p.stop();
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
var CODEC_IP6 = 41;
function isGlobalUnicast(ma) {
  try {
    const [[codec, value]] = ma.stringTuples();
    if (value == null) {
      return false;
    }
    if (codec === CODEC_IP6) {
      return cidrContains("2000::/3", value);
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/repeating-task.js
function repeatingTask(fn, interval, options2) {
  let timeout;
  let shutdownController;
  function runTask() {
    const opts = {
      signal: shutdownController.signal
    };
    if ((options2 == null ? void 0 : options2.timeout) != null) {
      const signal = anySignal([shutdownController.signal, AbortSignal.timeout(options2.timeout)]);
      setMaxListeners(Infinity, signal);
      opts.signal = signal;
    }
    Promise.resolve().then(async () => {
      await fn(opts);
    }).catch(() => {
    }).finally(() => {
      if (shutdownController.signal.aborted) {
        return;
      }
      timeout = setTimeout(runTask, interval);
    });
  }
  let started = false;
  return {
    start: () => {
      if (started) {
        return;
      }
      started = true;
      shutdownController = new AbortController();
      setMaxListeners(Infinity, shutdownController.signal);
      if ((options2 == null ? void 0 : options2.runImmediately) === true) {
        queueMicrotask(() => {
          runTask();
        });
      } else {
        timeout = setTimeout(runTask, interval);
      }
    },
    stop: () => {
      clearTimeout(timeout);
      shutdownController == null ? void 0 : shutdownController.abort();
      started = false;
    }
  };
}

// node_modules/it-protobuf-stream/dist/src/index.js
function pbStream(duplex, opts) {
  const lp = lpStream(duplex, opts);
  const W = {
    read: async (proto, options2) => {
      const value = await lp.read(options2);
      return proto.decode(value);
    },
    write: async (message2, proto, options2) => {
      await lp.write(proto.encode(message2), options2);
    },
    writeV: async (messages, proto, options2) => {
      await lp.writeV(messages.map((message2) => proto.encode(message2)), options2);
    },
    pb: (proto) => {
      return {
        read: async (options2) => W.read(proto, options2),
        write: async (d, options2) => W.write(d, proto, options2),
        writeV: async (d, options2) => W.writeV(d, proto, options2),
        unwrap: () => W
      };
    },
    unwrap: () => {
      return lp.unwrap();
    }
  };
  return W;
}

// node_modules/@libp2p/autonat/dist/src/constants.js
var PROTOCOL_PREFIX = "libp2p";
var PROTOCOL_NAME = "autonat";
var PROTOCOL_VERSION = "1.0.0";
var TIMEOUT = 3e4;
var MAX_INBOUND_STREAMS = 2;
var MAX_OUTBOUND_STREAMS = 20;
var DEFAULT_CONNECTION_THRESHOLD = 80;
var MAX_MESSAGE_SIZE = 8192;

// node_modules/@libp2p/autonat/dist/src/pb/index.js
var Message;
(function(Message5) {
  let MessageType2;
  (function(MessageType3) {
    MessageType3["DIAL"] = "DIAL";
    MessageType3["DIAL_RESPONSE"] = "DIAL_RESPONSE";
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let __MessageTypeValues2;
  (function(__MessageTypeValues3) {
    __MessageTypeValues3[__MessageTypeValues3["DIAL"] = 0] = "DIAL";
    __MessageTypeValues3[__MessageTypeValues3["DIAL_RESPONSE"] = 1] = "DIAL_RESPONSE";
  })(__MessageTypeValues2 || (__MessageTypeValues2 = {}));
  (function(MessageType3) {
    MessageType3.codec = () => {
      return enumeration(__MessageTypeValues2);
    };
  })(MessageType2 = Message5.MessageType || (Message5.MessageType = {}));
  let ResponseStatus;
  (function(ResponseStatus2) {
    ResponseStatus2["OK"] = "OK";
    ResponseStatus2["E_DIAL_ERROR"] = "E_DIAL_ERROR";
    ResponseStatus2["E_DIAL_REFUSED"] = "E_DIAL_REFUSED";
    ResponseStatus2["E_BAD_REQUEST"] = "E_BAD_REQUEST";
    ResponseStatus2["E_INTERNAL_ERROR"] = "E_INTERNAL_ERROR";
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let __ResponseStatusValues;
  (function(__ResponseStatusValues2) {
    __ResponseStatusValues2[__ResponseStatusValues2["OK"] = 0] = "OK";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_ERROR"] = 100] = "E_DIAL_ERROR";
    __ResponseStatusValues2[__ResponseStatusValues2["E_DIAL_REFUSED"] = 101] = "E_DIAL_REFUSED";
    __ResponseStatusValues2[__ResponseStatusValues2["E_BAD_REQUEST"] = 200] = "E_BAD_REQUEST";
    __ResponseStatusValues2[__ResponseStatusValues2["E_INTERNAL_ERROR"] = 300] = "E_INTERNAL_ERROR";
  })(__ResponseStatusValues || (__ResponseStatusValues = {}));
  (function(ResponseStatus2) {
    ResponseStatus2.codec = () => {
      return enumeration(__ResponseStatusValues);
    };
  })(ResponseStatus = Message5.ResponseStatus || (Message5.ResponseStatus = {}));
  let PeerInfo2;
  (function(PeerInfo3) {
    let _codec2;
    PeerInfo3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.id != null) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              w.uint32(18);
              w.bytes(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length2, opts = {}) => {
          var _a13;
          const obj = {
            addrs: []
          };
          const end = length2 == null ? reader.len : reader.pos + length2;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.id = reader.bytes();
                break;
              }
              case 2: {
                if (((_a13 = opts.limits) == null ? void 0 : _a13.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                  throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
                }
                obj.addrs.push(reader.bytes());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    PeerInfo3.encode = (obj) => {
      return encodeMessage(obj, PeerInfo3.codec());
    };
    PeerInfo3.decode = (buf, opts) => {
      return decodeMessage(buf, PeerInfo3.codec(), opts);
    };
  })(PeerInfo2 = Message5.PeerInfo || (Message5.PeerInfo = {}));
  let Dial;
  (function(Dial2) {
    let _codec2;
    Dial2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.peer != null) {
            w.uint32(10);
            Message5.PeerInfo.codec().encode(obj.peer, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length2, opts = {}) => {
          var _a13;
          const obj = {};
          const end = length2 == null ? reader.len : reader.pos + length2;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peer = Message5.PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: (_a13 = opts.limits) == null ? void 0 : _a13.peer
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Dial2.encode = (obj) => {
      return encodeMessage(obj, Dial2.codec());
    };
    Dial2.decode = (buf, opts) => {
      return decodeMessage(buf, Dial2.codec(), opts);
    };
  })(Dial = Message5.Dial || (Message5.Dial = {}));
  let DialResponse;
  (function(DialResponse2) {
    let _codec2;
    DialResponse2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.status != null) {
            w.uint32(8);
            Message5.ResponseStatus.codec().encode(obj.status, w);
          }
          if (obj.statusText != null) {
            w.uint32(18);
            w.string(obj.statusText);
          }
          if (obj.addr != null) {
            w.uint32(26);
            w.bytes(obj.addr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length2, opts = {}) => {
          const obj = {};
          const end = length2 == null ? reader.len : reader.pos + length2;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.status = Message5.ResponseStatus.codec().decode(reader);
                break;
              }
              case 2: {
                obj.statusText = reader.string();
                break;
              }
              case 3: {
                obj.addr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    DialResponse2.encode = (obj) => {
      return encodeMessage(obj, DialResponse2.codec());
    };
    DialResponse2.decode = (buf, opts) => {
      return decodeMessage(buf, DialResponse2.codec(), opts);
    };
  })(DialResponse = Message5.DialResponse || (Message5.DialResponse = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message5.MessageType.codec().encode(obj.type, w);
        }
        if (obj.dial != null) {
          w.uint32(18);
          Message5.Dial.codec().encode(obj.dial, w);
        }
        if (obj.dialResponse != null) {
          w.uint32(26);
          Message5.DialResponse.codec().encode(obj.dialResponse, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9;
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message5.MessageType.codec().decode(reader);
              break;
            }
            case 2: {
              obj.dial = Message5.Dial.codec().decode(reader, reader.uint32(), {
                limits: (_a13 = opts.limits) == null ? void 0 : _a13.dial
              });
              break;
            }
            case 3: {
              obj.dialResponse = Message5.DialResponse.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.dialResponse
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message || (Message = {}));

// node_modules/@libp2p/autonat/dist/src/autonat.js
var REQUIRED_SUCCESSFUL_DIALS = 4;
var REQUIRED_FAILED_DIALS = 8;
var _a, _b;
var AutoNATService = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "protocol");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxMessageSize");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "topologyId");
    __publicField(this, "dialResults");
    __publicField(this, "findPeers");
    __publicField(this, "addressFilter");
    __publicField(this, "connectionThreshold");
    __publicField(this, _a, "@libp2p/autonat");
    __publicField(this, _b, [
      "@libp2p/autonat"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:auto-nat");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? TIMEOUT;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS;
    this.connectionThreshold = init.connectionThreshold ?? DEFAULT_CONNECTION_THRESHOLD;
    this.maxMessageSize = init.maxMessageSize ?? MAX_MESSAGE_SIZE;
    this.dialResults = /* @__PURE__ */ new Map();
    this.findPeers = repeatingTask(this.findRandomPeers.bind(this), 6e4);
    this.addressFilter = createScalableCuckooFilter(1024);
  }
  get [(_a = Symbol.toStringTag, _b = serviceCapabilities, serviceDependencies)]() {
    return [
      "@libp2p/identify"
    ];
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleIncomingAutonatStream(data).catch((err) => {
        this.log.error("error handling incoming autonat stream - %e", err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams
    });
    this.topologyId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId, connection) => {
        this.verifyExternalAddresses(connection).catch((err) => {
          this.log.error("could not verify addresses - %e", err);
        });
      }
    });
    this.findPeers.start();
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    if (this.topologyId != null) {
      await this.components.registrar.unhandle(this.topologyId);
    }
    this.dialResults.clear();
    this.findPeers.stop();
    this.started = false;
  }
  allAddressesAreVerified() {
    return this.components.addressManager.getAddressesWithMetadata().every((addr) => {
      if (addr.expires > Date.now()) {
        return true;
      }
      return addr.verified;
    });
  }
  async findRandomPeers(options2) {
    if (this.allAddressesAreVerified()) {
      return;
    }
    const signal = anySignal([
      AbortSignal.timeout(1e4),
      options2 == null ? void 0 : options2.signal
    ]);
    try {
      this.log("starting random walk to find peers to run AutoNAT");
      for await (const peer of this.components.randomWalk.walk({ signal })) {
        if (!await this.components.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable %s", peer.id, peer.multiaddrs.map((ma) => ma.toString()).join(", "));
          continue;
        }
        try {
          this.log.trace("dial random peer %p", peer.id);
          await this.components.connectionManager.openConnection(peer.multiaddrs, {
            signal
          });
        } catch {
        }
        if (this.allAddressesAreVerified()) {
          this.log("stopping random walk, all addresses are verified");
          return;
        }
        if (!this.hasConnectionCapacity()) {
          this.log("stopping random walk, too close to max connections");
          return;
        }
      }
    } catch {
    }
  }
  /**
   * Handle an incoming AutoNAT request
   */
  async handleIncomingAutonatStream(data) {
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    const messages = pbStream(data.stream, {
      maxDataLength: this.maxMessageSize
    }).pb(Message);
    try {
      const request = await messages.read({
        signal
      });
      const response = await this.handleAutonatMessage(request, data.connection, {
        signal
      });
      await messages.write(response, {
        signal
      });
      await messages.unwrap().unwrap().close({
        signal
      });
    } catch (err) {
      this.log.error("error handling incoming autonat stream - %e", err);
      data.stream.abort(err);
    }
  }
  async handleAutonatMessage(message2, connection, options2) {
    const ourHosts = this.components.addressManager.getAddresses().map((ma) => ma.toOptions().host);
    const dialRequest = message2.dial;
    if (dialRequest == null) {
      this.log.error("dial was missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "No Dial message found in message"
        }
      };
    }
    let peerId;
    const peer = dialRequest.peer;
    if ((peer == null ? void 0 : peer.id) == null) {
      this.log.error("PeerId missing from message");
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "missing peer info"
        }
      };
    }
    try {
      const digest = decode(peer.id);
      peerId = peerIdFromMultihash(digest);
    } catch (err) {
      this.log.error("invalid PeerId - %e", err);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "bad peer id"
        }
      };
    }
    this.log("incoming request from %p", peerId);
    if (!connection.remotePeer.equals(peerId)) {
      this.log("target peer %p did not equal sending peer %p", peerId, connection.remotePeer);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_BAD_REQUEST,
          statusText: "peer id mismatch"
        }
      };
    }
    const multiaddrs = peer.addrs.map((buf) => multiaddr(buf)).filter((ma) => {
      const options3 = ma.toOptions();
      if (isPrivate(ma)) {
        return false;
      }
      if (options3.host !== connection.remoteAddr.toOptions().host) {
        this.log.trace("not dialing %a - target host did not match remote host %a", ma, connection.remoteAddr);
        return false;
      }
      if (ourHosts.includes(options3.host)) {
        return false;
      }
      if (this.components.transportManager.dialTransportForMultiaddr(ma) == null) {
        this.log.trace("not dialing %a - transport unsupported", ma);
        return false;
      }
      return true;
    }).map((ma) => {
      if (ma.getPeerId() == null) {
        ma = ma.encapsulate(`/p2p/${peerId.toString()}`);
      }
      return ma;
    });
    if (multiaddrs.length === 0) {
      this.log("refused to dial all multiaddrs for %p from message", peerId);
      return {
        type: Message.MessageType.DIAL_RESPONSE,
        dialResponse: {
          status: Message.ResponseStatus.E_DIAL_REFUSED,
          statusText: "no dialable addresses"
        }
      };
    }
    this.log("dial multiaddrs %s for peer %p", multiaddrs.map((ma) => ma.toString()).join(", "), peerId);
    let errorMessage = "";
    let lastMultiaddr = multiaddrs[0];
    for await (const multiaddr2 of multiaddrs) {
      let connection2;
      lastMultiaddr = multiaddr2;
      try {
        connection2 = await this.components.connectionManager.openConnection(multiaddr2, options2);
        if (!connection2.remoteAddr.equals(multiaddr2)) {
          this.log.error("tried to dial %a but dialed %a", multiaddr2, connection2.remoteAddr);
          throw new Error("Unexpected remote address");
        }
        this.log("successfully dialed %p via %a", peerId, multiaddr2);
        return {
          type: Message.MessageType.DIAL_RESPONSE,
          dialResponse: {
            status: Message.ResponseStatus.OK,
            addr: connection2.remoteAddr.decapsulateCode(getProtocol("p2p").code).bytes
          }
        };
      } catch (err) {
        this.log.error("could not dial %p - %e", peerId, err);
        errorMessage = err.message;
      } finally {
        if (connection2 != null) {
          await connection2.close();
        }
      }
    }
    return {
      type: Message.MessageType.DIAL_RESPONSE,
      dialResponse: {
        status: Message.ResponseStatus.E_DIAL_ERROR,
        statusText: errorMessage,
        addr: lastMultiaddr.bytes
      }
    };
  }
  /**
   * The AutoNAT v1 server is not required to send us the address that it
   * dialed successfully.
   *
   * When addresses fail, it can be because they are NATed, or because the peer
   * did't support the transport, we have no way of knowing, so just send them
   * one address so we can treat the response as:
   *
   * - OK - the dial request worked and the address is not NATed
   * - E_DIAL_ERROR - the dial request failed and the address may be NATed
   * - E_DIAL_REFUSED/E_BAD_REQUEST/E_INTERNAL_ERROR - the remote didn't dial the address
   */
  getFirstUnverifiedMultiaddr(segment, supportsIPv6) {
    var _a13, _b9;
    const addrs = this.components.addressManager.getAddressesWithMetadata().sort((a, b) => {
      if (a.type === "observed" && b.type !== "observed") {
        return 1;
      }
      if (b.type === "observed" && a.type !== "observed") {
        return -1;
      }
      return 0;
    }).filter((addr) => {
      const expired = addr.expires < Date.now();
      if (!expired) {
        return false;
      }
      const options2 = addr.multiaddr.toOptions();
      if (options2.family === 6) {
        if (!supportsIPv6) {
          return false;
        }
        if (!isGlobalUnicast(addr.multiaddr)) {
          return false;
        }
      }
      if (isPrivate(addr.multiaddr)) {
        return false;
      }
      return true;
    });
    for (const addr of addrs) {
      const addrString = addr.multiaddr.toString();
      let results = this.dialResults.get(addrString);
      if (results != null) {
        if (results.networkSegments.includes(segment)) {
          this.log.trace("%a already has a network segment result from %s", results.multiaddr, segment);
          continue;
        }
        if (results.queue.size > 10) {
          this.log.trace("%a already has enough peers queued", results.multiaddr);
          continue;
        }
      }
      if (results == null) {
        const needsRevalidating = addr.expires < Date.now();
        if (needsRevalidating) {
          (_b9 = (_a13 = this.addressFilter).remove) == null ? void 0 : _b9.call(_a13, addrString);
        }
        if (this.addressFilter.has(addrString)) {
          continue;
        }
        this.addressFilter.add(addrString);
        this.log.trace("creating dial result %s %s", needsRevalidating ? "to revalidate" : "for", addrString);
        results = {
          multiaddr: addr.multiaddr,
          success: 0,
          failure: 0,
          networkSegments: [],
          verifyingPeers: peerSet(),
          queue: new PeerQueue({
            concurrency: 3,
            maxSize: 50
          }),
          type: addr.type,
          lastVerified: addr.lastVerified
        };
        this.dialResults.set(addrString, results);
      }
      return results;
    }
  }
  /**
   * Removes any multiaddr result objects created for old multiaddrs that we are
   * no longer waiting on
   */
  removeOutdatedMultiaddrResults() {
    const unverifiedMultiaddrs = new Set(this.components.addressManager.getAddressesWithMetadata().filter(({ expires }) => {
      if (expires < Date.now()) {
        return true;
      }
      return false;
    }).map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    for (const multiaddr2 of this.dialResults.keys()) {
      if (!unverifiedMultiaddrs.has(multiaddr2)) {
        this.log.trace("remove results for %a", multiaddr2);
        this.dialResults.delete(multiaddr2);
      }
    }
  }
  /**
   * Our multicodec topology noticed a new peer that supports autonat
   */
  async verifyExternalAddresses(connection) {
    if (!this.isStarted()) {
      return;
    }
    this.removeOutdatedMultiaddrResults();
    const peer = await this.components.peerStore.get(connection.remotePeer);
    const supportsIPv6 = peer.addresses.some(({ multiaddr: multiaddr2 }) => {
      return multiaddr2.toOptions().family === 6;
    });
    const segment = this.getNetworkSegment(connection.remoteAddr);
    const results = this.getFirstUnverifiedMultiaddr(segment, supportsIPv6);
    if (results == null) {
      this.log.trace("no unverified public addresses found for peer %p to verify, not requesting verification", connection.remotePeer);
      return;
    }
    if (!this.hasConnectionCapacity()) {
      if (results.lastVerified != null) {
        this.log("automatically re-verifying %a because we are too close to the connection limit", results.multiaddr);
        this.confirmAddress(results);
      } else {
        this.log("skipping verifying %a because we are too close to the connection limit", results.multiaddr);
      }
      return;
    }
    results.queue.add(async (options2) => {
      await this.askPeerToVerify(connection, segment, options2);
    }, {
      peerId: connection.remotePeer,
      multiaddr: results.multiaddr
    }).catch((err) => {
      if ((results == null ? void 0 : results.result) == null) {
        this.log.error("error from %p verifying address %a - %e", connection.remotePeer, results == null ? void 0 : results.multiaddr, err);
      }
    });
  }
  async askPeerToVerify(connection, segment, options2) {
    let results = this.dialResults.get(options2.multiaddr.toString());
    if (results == null) {
      this.log("%a was verified while %p was queued", options2.multiaddr, connection.remotePeer);
      return;
    }
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    this.log.trace("asking %p to verify multiaddr %s", connection.remotePeer, options2.multiaddr);
    const stream = await connection.newStream(this.protocol, {
      signal
    });
    try {
      const messages = pbStream(stream).pb(Message);
      const [, response] = await Promise.all([
        messages.write({
          type: Message.MessageType.DIAL,
          dial: {
            peer: {
              id: this.components.peerId.toMultihash().bytes,
              addrs: [options2.multiaddr.bytes]
            }
          }
        }, { signal }),
        messages.read({ signal })
      ]);
      if (response.type !== Message.MessageType.DIAL_RESPONSE || response.dialResponse == null) {
        this.log("invalid autonat response from %p - %j", connection.remotePeer, response);
        return;
      }
      const status = response.dialResponse.status;
      this.log.trace("autonat response from %p for %a is %s", connection.remotePeer, options2.multiaddr, status);
      if (status !== Message.ResponseStatus.OK && status !== Message.ResponseStatus.E_DIAL_ERROR) {
        return;
      }
      results = this.dialResults.get(options2.multiaddr.toString());
      if (results == null) {
        this.log.trace("peer reported %a as %s but there is no result object", options2.multiaddr, response.dialResponse.status);
        return;
      }
      if (results.networkSegments.includes(segment)) {
        this.log.trace("%a results included network segment %s", options2.multiaddr, segment);
        return;
      }
      if (results.result != null) {
        this.log.trace("already resolved result for %a, ignoring response from", options2.multiaddr, connection.remotePeer);
        return;
      }
      if (results.verifyingPeers.has(connection.remotePeer)) {
        this.log.trace("peer %p has already verified %a, ignoring response", connection.remotePeer, options2.multiaddr);
        return;
      }
      results.verifyingPeers.add(connection.remotePeer);
      results.networkSegments.push(segment);
      if (status === Message.ResponseStatus.OK) {
        results.success++;
        if (results.type !== "observed") {
          this.confirmAddress(results);
          return;
        }
      } else if (status === Message.ResponseStatus.E_DIAL_ERROR) {
        results.failure++;
      }
      this.log("%a success %d failure %d", results.multiaddr, results.success, results.failure);
      if (results.success === REQUIRED_SUCCESSFUL_DIALS) {
        this.confirmAddress(results);
      }
      if (results.failure === REQUIRED_FAILED_DIALS) {
        this.unconfirmAddress(results);
      }
    } finally {
      try {
        await stream.close({
          signal
        });
      } catch (err) {
        stream.abort(err);
      }
    }
  }
  hasConnectionCapacity() {
    const connections = this.components.connectionManager.getConnections();
    const currentConnectionCount = connections.length;
    const maxConnections = this.components.connectionManager.getMaxConnections();
    return currentConnectionCount / maxConnections * 100 < this.connectionThreshold;
  }
  confirmAddress(results) {
    this.log("%s address %a is externally dialable", results.type, results.multiaddr);
    this.components.addressManager.confirmObservedAddr(results.multiaddr);
    this.dialResults.delete(results.multiaddr.toString());
    results.result = true;
    results.queue.abort();
  }
  unconfirmAddress(results) {
    this.log("%s address %a is not externally dialable", results.type, results.multiaddr);
    this.components.addressManager.removeObservedAddr(results.multiaddr);
    this.dialResults.delete(results.multiaddr.toString());
    results.result = false;
    results.queue.abort();
  }
  getNetworkSegment(ma) {
    const options2 = ma.toOptions();
    if (options2.family === 4) {
      const octets2 = options2.host.split(".");
      return octets2[0].padStart(3, "0");
    }
    const octets = options2.host.split(":");
    return octets[0].padStart(4, "0");
  }
};

// node_modules/@libp2p/autonat/dist/src/index.js
function autoNAT(init = {}) {
  return (components) => {
    return new AutoNATService(components, init);
  };
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var CIRCUIT_PROTO_CODE = 290;
var DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var DEFAULT_RESERVATION_COMPLETION_TIMEOUT = 2e3;
var DEFAULT_MAX_RESERVATION_QUEUE_LENGTH = 100;
var RELAY_SOURCE_TAG = "circuit-relay-source";
var KEEP_ALIVE_TAG = `${KEEP_ALIVE}-circuit-relay`;
var KEEP_ALIVE_SOURCE_TAG = `${KEEP_ALIVE}-circuit-relay-source`;
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS = 300;
var DEFAULT_DISCOVERY_FILTER_SIZE = 4096;
var DEFAULT_DISCOVERY_FILTER_ERROR_RATE = 1e-3;

// node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type;
  (function(Type2) {
    Type2["RESERVE"] = "RESERVE";
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9, _c5;
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: (_a13 = opts.limits) == null ? void 0 : _a13.peer
              });
              break;
            }
            case 3: {
              obj.reservation = Reservation.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.reservation
              });
              break;
            }
            case 4: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: (_c5 = opts.limits) == null ? void 0 : _c5.limit
              });
              break;
            }
            case 5: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, HopMessage2.codec(), opts);
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type;
  (function(Type2) {
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9;
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.peer = Peer.codec().decode(reader, reader.uint32(), {
                limits: (_a13 = opts.limits) == null ? void 0 : _a13.peer
              });
              break;
            }
            case 3: {
              obj.limit = Limit.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.limit
              });
              break;
            }
            case 4: {
              obj.status = Status.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf, opts) => {
    return decodeMessage(buf, StopMessage2.codec(), opts);
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13;
        const obj = {
          id: alloc(0),
          addrs: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          Envelope.codec().encode(obj.voucher, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9;
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.expire = reader.uint64();
              break;
            }
            case 2: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.addrs) != null && obj.addrs.length === opts.limits.addrs) {
                throw new MaxLengthError('Decode error - map field "addrs" had too many elements');
              }
              obj.addrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.voucher = Envelope.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.voucher
              });
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf, opts) => {
    return decodeMessage(buf, Reservation2.codec(), opts);
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.duration = reader.uint32();
              break;
            }
            case 2: {
              obj.data = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf, opts) => {
    return decodeMessage(buf, Limit2.codec(), opts);
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {
          relay: alloc(0),
          peer: alloc(0),
          expiration: 0n
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.relay = reader.bytes();
              break;
            }
            case 2: {
              obj.peer = reader.bytes();
              break;
            }
            case 3: {
              obj.expiration = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf, opts) => {
    return decodeMessage(buf, ReservationVoucher2.codec(), opts);
  };
})(ReservationVoucher || (ReservationVoucher = {}));
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null) {
          w.uint32(26);
          ReservationVoucher.codec().encode(obj.payload, w);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13;
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          signature: alloc(0)
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = ReservationVoucher.codec().decode(reader, reader.uint32(), {
                limits: (_a13 = opts.limits) == null ? void 0 : _a13.payload
              });
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/circuit-relay-v2/dist/src/errors.js
var TransferLimitError = class extends Error {
  constructor(message2 = "Transfer limit error") {
    super(message2);
    this.name = "TransferLimitError";
  }
};
var DurationLimitError = class extends Error {
  constructor(message2 = "Duration limit error") {
    super(message2);
    this.name = "DurationLimitError";
  }
};
var HadEnoughRelaysError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "HadEnoughRelaysError");
  }
};
__publicField(HadEnoughRelaysError, "name", "HadEnoughRelaysError");
var DoubleRelayError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "DoubleRelayError");
  }
};
__publicField(DoubleRelayError, "name", "DoubleRelayError");
var RelayQueueFullError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "RelayQueueFullError");
  }
};
__publicField(RelayQueueFullError, "name", "RelayQueueFullError");

// node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
async function* countStreamBytes(source, limit, options2) {
  const limitBytes = limit.remaining;
  for await (const buf of source) {
    const len = BigInt(buf.byteLength);
    if (limit.remaining - len < 0) {
      const remaining = Number(limit.remaining);
      limit.remaining = 0n;
      try {
        if (remaining !== 0) {
          yield buf.subarray(0, remaining);
        }
      } catch (err) {
        options2.log.error(err);
      }
      throw new TransferLimitError(`data limit of ${limitBytes} bytes exceeded`);
    }
    limit.remaining -= len;
    yield buf;
  }
}
function createLimitedRelay(src, dst, abortSignal, reservation, options2) {
  var _a13, _b9;
  function abortStreams(err) {
    src.abort(err);
    dst.abort(err);
  }
  const signals = [abortSignal, reservation.signal];
  if (((_a13 = reservation.limit) == null ? void 0 : _a13.duration) != null) {
    options2.log("limiting relayed connection duration to %dms", reservation.limit.duration);
    signals.push(AbortSignal.timeout(reservation.limit.duration));
  }
  const signal = anySignal(signals);
  let srcDstFinished = false;
  let dstSrcFinished = false;
  let dataLimit;
  if (((_b9 = reservation.limit) == null ? void 0 : _b9.data) != null) {
    dataLimit = {
      remaining: reservation.limit.data
    };
  }
  queueMicrotask(() => {
    const onAbort = () => {
      var _a14;
      options2.log("relayed connection reached time limit");
      dst.abort(new DurationLimitError(`duration limit of ${(_a14 = reservation.limit) == null ? void 0 : _a14.duration} ms exceeded`));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options2)).catch((err) => {
      options2.log.error("error while relaying streams src -> dst", err);
      abortStreams(err);
    }).finally(() => {
      srcDstFinished = true;
      if (dstSrcFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
  queueMicrotask(() => {
    const onAbort = () => {
      var _a14;
      options2.log("relayed connection reached time limit");
      src.abort(new DurationLimitError(`duration limit of ${(_a14 = reservation.limit) == null ? void 0 : _a14.duration} ms exceeded`));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options2)).catch((err) => {
      options2.log.error("error while relaying streams dst -> src", err);
      abortStreams(err);
    }).finally(() => {
      dstSrcFinished = true;
      if (srcDstFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}
var LimitTracker = class {
  constructor(limits) {
    __publicField(this, "expires");
    __publicField(this, "bytes");
    if ((limits == null ? void 0 : limits.duration) != null && (limits == null ? void 0 : limits.duration) !== 0) {
      this.expires = Date.now() + limits.duration * 1e3;
    }
    this.bytes = limits == null ? void 0 : limits.data;
    if (this.bytes === 0n) {
      this.bytes = void 0;
    }
    this.onData = this.onData.bind(this);
  }
  onData(buf) {
    if (this.bytes == null) {
      return;
    }
    this.bytes -= BigInt(buf.byteLength);
    if (this.bytes < 0n) {
      this.bytes = 0n;
    }
  }
  getLimits() {
    if (this.expires == null && this.bytes == null) {
      return;
    }
    const output = {};
    if (this.bytes != null) {
      const self2 = this;
      Object.defineProperty(output, "bytes", {
        get() {
          return self2.bytes;
        }
      });
    }
    if (this.expires != null) {
      const self2 = this;
      Object.defineProperty(output, "seconds", {
        get() {
          return Math.round(((self2.expires ?? 0) - Date.now()) / 1e3);
        }
      });
    }
    return output;
  }
};
var CircuitListen = fmt(and(P2P.matchers[0], literal("p2p-circuit")));
var CircuitSearch = fmt(literal("p2p-circuit"));

// node_modules/retimeable-signal/dist/src/index.js
var AbortError = class extends Error {
  constructor(message2, code6, name3) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = name3 ?? "AbortError";
    this.code = code6 ?? "ABORT_ERR";
  }
};
function retimeableSignal(ms, opts) {
  const error = new AbortError(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName);
  const controller = new AbortController();
  const abortHandler = () => {
    controller.abort(error);
  };
  let signal = AbortSignal.timeout(ms);
  signal.addEventListener("abort", abortHandler);
  const retimerSignal = controller.signal;
  retimerSignal.reset = (newMs) => {
    signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
    signal = AbortSignal.timeout(newMs ?? ms);
    signal.addEventListener("abort", () => {
      controller.abort(error);
    });
  };
  retimerSignal.clear = () => {
    signal == null ? void 0 : signal.removeEventListener("abort", abortHandler);
    signal = void 0;
  };
  return retimerSignal;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-store.js
var ReservationStore = class {
  constructor(components, init = {}) {
    __publicField(this, "reservations");
    __publicField(this, "maxReservations");
    __publicField(this, "applyDefaultLimit");
    __publicField(this, "reservationTtl");
    __publicField(this, "defaultDurationLimit");
    __publicField(this, "defaultDataLimit");
    __publicField(this, "log");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server:reservation-store");
    this.maxReservations = init.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
    this.applyDefaultLimit = init.applyDefaultLimit !== false;
    this.reservationTtl = init.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
    this.defaultDurationLimit = init.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
    this.defaultDataLimit = init.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
    this.reservations = trackedPeerMap({
      metrics: components.metrics,
      name: "libp2p_circuit_relay_server_reservations_total"
    });
  }
  reserve(peer, addr, limit) {
    let reservation = this.reservations.get(peer);
    if (this.reservations.size >= this.maxReservations && reservation == null) {
      return { status: Status.RESERVATION_REFUSED };
    }
    const expiry = new Date(Date.now() + this.reservationTtl);
    let checkedLimit;
    if (this.applyDefaultLimit) {
      checkedLimit = limit ?? {
        data: this.defaultDataLimit,
        duration: this.defaultDurationLimit
      };
    }
    if (reservation != null) {
      this.log("refreshing reservation for client %p", peer);
      reservation.signal.reset(this.reservationTtl);
    } else {
      this.log("creating new reservation for client %p", peer);
      reservation = {
        addr,
        expiry,
        limit: checkedLimit,
        signal: retimeableSignal(this.reservationTtl)
      };
    }
    this.reservations.set(peer, reservation);
    reservation.signal.addEventListener("abort", () => {
      this.reservations.delete(peer);
    });
    return { status: Status.OK, expire: Math.round(expiry.getTime() / 1e3) };
  }
  removeReservation(peer) {
    this.reservations.delete(peer);
  }
  get(peer) {
    return this.reservations.get(peer);
  }
  clear() {
    this.reservations.clear();
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-voucher.js
var ReservationVoucherRecord = class _ReservationVoucherRecord {
  constructor({ relay, peer, expiration }) {
    __publicField(this, "domain", "libp2p-relay-rsvp");
    __publicField(this, "codec", new Uint8Array([3, 2]));
    __publicField(this, "relay");
    __publicField(this, "peer");
    __publicField(this, "expiration");
    this.relay = relay;
    this.peer = peer;
    this.expiration = expiration;
  }
  marshal() {
    return ReservationVoucher.encode({
      relay: this.relay.toMultihash().bytes,
      peer: this.peer.toMultihash().bytes,
      expiration: BigInt(this.expiration)
    });
  }
  equals(other) {
    if (!(other instanceof _ReservationVoucherRecord)) {
      return false;
    }
    if (!this.peer.equals(other.peer)) {
      return false;
    }
    if (!this.relay.equals(other.relay)) {
      return false;
    }
    if (this.expiration !== other.expiration) {
      return false;
    }
    return true;
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/index.js
var isRelayAddr = (ma) => ma.protoCodes().includes(CIRCUIT_PROTO_CODE);
var defaults = {
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var _a2;
var CircuitRelayServer = class extends TypedEventEmitter {
  /**
   * Creates an instance of Relay
   */
  constructor(components, init = {}) {
    super();
    __publicField(this, "registrar");
    __publicField(this, "peerStore");
    __publicField(this, "addressManager");
    __publicField(this, "peerId");
    __publicField(this, "privateKey");
    __publicField(this, "connectionManager");
    __publicField(this, "connectionGater");
    __publicField(this, "reservationStore");
    __publicField(this, "started");
    __publicField(this, "hopTimeout");
    __publicField(this, "shutdownController");
    __publicField(this, "maxInboundHopStreams");
    __publicField(this, "maxOutboundHopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "log");
    __publicField(this, _a2, "@libp2p/circuit-relay-v2-server");
    this.log = components.logger.forComponent("libp2p:circuit-relay:server");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.addressManager = components.addressManager;
    this.peerId = components.peerId;
    this.privateKey = components.privateKey;
    this.connectionManager = components.connectionManager;
    this.connectionGater = components.connectionGater;
    this.started = false;
    this.hopTimeout = (init == null ? void 0 : init.hopTimeout) ?? DEFAULT_HOP_TIMEOUT;
    this.maxInboundHopStreams = init.maxInboundHopStreams;
    this.maxOutboundHopStreams = init.maxOutboundHopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    this.reservationStore = new ReservationStore(components, init.reservations);
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.started) {
      return;
    }
    await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {
      void this.onHop(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundHopStreams,
      maxOutboundStreams: this.maxOutboundHopStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    this.reservationStore.clear();
    this.shutdownController.abort();
    await this.registrar.unhandle(RELAY_V2_HOP_CODEC);
    this.started = false;
  }
  async onHop({ connection, stream }) {
    this.log("received circuit v2 hop protocol stream from %p", connection.remotePeer);
    const options2 = {
      signal: AbortSignal.timeout(this.hopTimeout)
    };
    const pbstr = pbStream(stream);
    try {
      const request = await pbstr.pb(HopMessage).read(options2);
      if ((request == null ? void 0 : request.type) == null) {
        throw new Error("request was invalid, could not read from stream");
      }
      this.log("received", request.type);
      await this.handleHopProtocol({
        connection,
        stream: pbstr,
        request
      }, options2);
    } catch (err) {
      this.log.error("error while handling hop", err);
      await pbstr.pb(HopMessage).write({
        type: HopMessage.Type.STATUS,
        status: Status.MALFORMED_MESSAGE
      }, options2);
      stream.abort(err);
    }
  }
  async handleHopProtocol({ stream, request, connection }, options2) {
    this.log("received hop message");
    switch (request.type) {
      case HopMessage.Type.RESERVE:
        await this.handleReserve({ stream, request, connection }, options2);
        break;
      case HopMessage.Type.CONNECT:
        await this.handleConnect({ stream, request, connection }, options2);
        break;
      default: {
        this.log.error("invalid hop request type %s via peer %p", request.type, connection.remotePeer);
        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      }
    }
  }
  async handleReserve({ stream, connection }, options2) {
    var _a13, _b9, _c5;
    const hopstr = stream.pb(HopMessage);
    this.log("hop reserve request from %p", connection.remotePeer);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    if (await ((_b9 = (_a13 = this.connectionGater).denyInboundRelayReservation) == null ? void 0 : _b9.call(_a13, connection.remotePeer)) === true) {
      this.log.error("reservation for %p denied by connection gater", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
    try {
      if (result.status !== Status.OK) {
        await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status }, options2);
        return;
      }
      if (result.expire != null) {
        const ttl = result.expire * 1e3 - Date.now();
        await this.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: { value: 1, ttl },
            [KEEP_ALIVE_SOURCE_TAG]: { value: 1, ttl }
          }
        });
      }
      await hopstr.write({
        type: HopMessage.Type.STATUS,
        status: Status.OK,
        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
        limit: (_c5 = this.reservationStore.get(connection.remotePeer)) == null ? void 0 : _c5.limit
      }, options2);
      this.log("sent confirmation response to %s", connection.remotePeer);
    } catch (err) {
      this.log.error("failed to send confirmation response to %p - %e", connection.remotePeer, err);
      this.reservationStore.removeReservation(connection.remotePeer);
      try {
        await this.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: void 0,
            [KEEP_ALIVE_SOURCE_TAG]: void 0
          }
        });
      } catch (err2) {
        this.log.error("failed to untag relay source peer %p - %e", connection.remotePeer, err2);
      }
    }
  }
  async makeReservation(remotePeer, expire) {
    const addrs = [];
    for (const relayAddr of this.addressManager.getAddresses()) {
      if (relayAddr.toString().includes("/p2p-circuit")) {
        continue;
      }
      addrs.push(relayAddr.bytes);
    }
    const envelope = await RecordEnvelope.seal(new ReservationVoucherRecord({
      peer: remotePeer,
      relay: this.peerId,
      expiration: expire
    }), this.privateKey);
    return {
      addrs,
      expire,
      voucher: {
        publicKey: publicKeyToProtobuf(envelope.publicKey),
        payloadType: envelope.payloadType,
        payload: {
          peer: remotePeer.toMultihash().bytes,
          relay: this.peerId.toMultihash().bytes,
          expiration: expire
        },
        signature: envelope.signature
      }
    };
  }
  async handleConnect({ stream, request, connection }, options2) {
    var _a13, _b9;
    const hopstr = stream.pb(HopMessage);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    this.log("hop connect request from %p", connection.remotePeer);
    let dstPeer;
    try {
      if (request.peer == null) {
        this.log.error("no peer info in hop connect request");
        throw new Error("no peer info in request");
      }
      request.peer.addrs.forEach(multiaddr);
      dstPeer = peerIdFromMultihash(decode(request.peer.id));
    } catch (err) {
      this.log.error("invalid hop connect request via peer %p %s", connection.remotePeer, err);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, options2);
      return;
    }
    const reservation = this.reservationStore.get(dstPeer);
    if (reservation == null) {
      this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s", dstPeer, connection.remotePeer, Status.NO_RESERVATION);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options2);
      return;
    }
    if (await ((_b9 = (_a13 = this.connectionGater).denyOutboundRelayedConnection) == null ? void 0 : _b9.call(_a13, connection.remotePeer, dstPeer)) === true) {
      this.log.error("hop connect for %p to %p denied by connection gater", connection.remotePeer, dstPeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, options2);
      return;
    }
    const connections = this.connectionManager.getConnections(dstPeer);
    if (connections.length === 0) {
      this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection", dstPeer, connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION }, options2);
      return;
    }
    const destinationConnection = connections[0];
    const destinationStream = await this.stopHop({
      connection: destinationConnection,
      request: {
        type: StopMessage.Type.CONNECT,
        peer: {
          id: connection.remotePeer.toMultihash().bytes,
          addrs: []
        },
        limit: reservation == null ? void 0 : reservation.limit
      }
    }, options2);
    if (destinationStream == null) {
      this.log.error("failed to open stream to destination peer %p", destinationConnection == null ? void 0 : destinationConnection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED }, options2);
      return;
    }
    await hopstr.write({
      type: HopMessage.Type.STATUS,
      status: Status.OK,
      limit: reservation == null ? void 0 : reservation.limit
    }, options2);
    const sourceStream = stream.unwrap();
    this.log("connection from %p to %p established - merging streams", connection.remotePeer, dstPeer);
    createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, reservation, {
      log: this.log
    });
  }
  /**
   * Send a STOP request to the target peer that the dialing peer wants to contact
   */
  async stopHop({ connection, request }, options2) {
    this.log("starting circuit relay v2 stop request to %s", connection.remotePeer);
    const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true,
      ...options2
    });
    const pbstr = pbStream(stream);
    const stopstr = pbstr.pb(StopMessage);
    await stopstr.write(request, options2);
    let response;
    try {
      response = await stopstr.read(options2);
    } catch (err) {
      this.log.error("error parsing stop message response from %p", connection.remotePeer);
    }
    if (response == null) {
      this.log.error("could not read response from %p", connection.remotePeer);
      await stream.close(options2);
      return;
    }
    if (response.status === Status.OK) {
      this.log("stop request to %p was successful", connection.remotePeer);
      return pbstr.unwrap();
    }
    this.log("stop request failed with code %d", response.status);
    await stream.close(options2);
  }
  get reservations() {
    return this.reservationStore.reservations;
  }
};
_a2 = Symbol.toStringTag;

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
function streamToMaConnection(props) {
  const { stream, remoteAddr, logger: logger2, onDataRead, onDataWrite } = props;
  const log7 = logger2.forComponent("libp2p:stream:converter");
  let closedRead = false;
  let closedWrite = false;
  const streamClose = stream.close.bind(stream);
  stream.close = async (options2) => {
    await streamClose(options2);
    close(true);
  };
  const streamAbort = stream.abort.bind(stream);
  stream.abort = (err) => {
    streamAbort(err);
    close(true);
  };
  const streamSink = stream.sink.bind(stream);
  stream.sink = async (source) => {
    try {
      await streamSink(pipe(source, (source2) => src_default2(source2, (buf) => onDataWrite == null ? void 0 : onDataWrite(buf))));
    } catch (err) {
      if (err.type !== "aborted") {
        log7.error("%s error in sink", remoteAddr, err);
      }
    } finally {
      closedWrite = true;
      close();
    }
  };
  const maConn = {
    log: log7,
    sink: stream.sink,
    source: async function* () {
      try {
        for await (const buf of stream.source) {
          onDataRead == null ? void 0 : onDataRead(buf);
          yield buf;
        }
      } finally {
        closedRead = true;
        close();
      }
    }(),
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    close: stream.close,
    abort: stream.abort
  };
  function close(force) {
    if (force === true) {
      closedRead = true;
      closedWrite = true;
    }
    if (closedRead && closedWrite && maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }
  return maConn;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "connectionManager");
    __publicField(this, "randomWalk");
    __publicField(this, "started");
    __publicField(this, "running");
    __publicField(this, "topologyId");
    __publicField(this, "log");
    __publicField(this, "discoveryController");
    __publicField(this, "filter");
    __publicField(this, "queue");
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.started = false;
    this.running = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.connectionManager = components.connectionManager;
    this.randomWalk = components.randomWalk;
    this.filter = init.filter;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {
      filter: this.filter,
      onConnect: (peerId) => {
        var _a13, _b9;
        this.log.trace("discovered relay %p queue (length: %d, active %d)", peerId, (_a13 = this.queue) == null ? void 0 : _a13.size, (_b9 = this.queue) == null ? void 0 : _b9.running);
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  stop() {
    var _a13;
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    (_a13 = this.discoveryController) == null ? void 0 : _a13.abort();
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected to
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network
   */
  startDiscovery() {
    if (this.running) {
      return;
    }
    this.log("start discovery");
    this.running = true;
    this.discoveryController = new AbortController();
    setMaxListeners(Infinity, this.discoveryController.signal);
    Promise.resolve().then(async () => {
      var _a13;
      this.log("searching peer store for relays");
      const peers = await this.peerStore.all({
        filters: [
          // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
          (peer) => {
            return peer.protocols.includes(RELAY_V2_HOP_CODEC);
          }
        ],
        orders: [
          // randomise
          () => Math.random() < 0.5 ? 1 : -1,
          // prefer peers we've connected to in the past
          (a, b) => {
            const lastDialA = getLastDial(a);
            const lastDialB = getLastDial(b);
            if (lastDialA > lastDialB) {
              return -1;
            }
            if (lastDialB > lastDialA) {
              return 1;
            }
            return 0;
          }
        ]
      });
      for (const peer of peers) {
        this.log.trace("found relay peer %p in peer store", peer.id);
        this.safeDispatchEvent("relay:discover", { detail: peer.id });
      }
      this.log("found %d relay peers in peer store", peers.length);
      const queue = this.queue = new PeerQueue({
        concurrency: 5
      });
      this.log("start random walk");
      for await (const peer of this.randomWalk.walk({ signal: this.discoveryController.signal })) {
        this.log.trace("found random peer %p", peer.id);
        if (queue.has(peer.id)) {
          this.log.trace("random peer %p was already in queue", peer.id);
          continue;
        }
        if (((_a13 = this.connectionManager.getConnections(peer.id)) == null ? void 0 : _a13.length) > 0) {
          this.log.trace("random peer %p was already connected", peer.id);
          continue;
        }
        if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
          this.log.trace("random peer %p was not dialable", peer.id, peer.multiaddrs.map((ma) => ma.toString()));
          continue;
        }
        if (queue.queued > 10) {
          this.log.trace("wait for space in queue for %p", peer.id);
          await queue.onSizeLessThan(10, {
            signal: this.discoveryController.signal
          });
        }
        this.log("adding random peer %p to dial queue (length: %d, active %d)", peer.id, queue.size, queue.running);
        queue.add(async () => {
          const signal = anySignal([this.discoveryController.signal, AbortSignal.timeout(5e3)]);
          setMaxListeners(Infinity, signal);
          try {
            await this.connectionManager.openConnection(peer.id, { signal });
          } finally {
            signal.clear();
          }
        }, {
          peerId: peer.id,
          signal: this.discoveryController.signal
        }).catch((err) => {
          this.log.error("error opening connection to random peer %p", peer.id, err);
        });
      }
      this.log("stop random walk");
      await queue.onIdle();
    }).catch((err) => {
      if (!this.discoveryController.signal.aborted) {
        this.log.error("failed when finding relays on the network", err);
      }
    });
  }
  stopDiscovery() {
    var _a13;
    this.log("stop discovery");
    this.running = false;
    (_a13 = this.discoveryController) == null ? void 0 : _a13.abort();
  }
};
function getLastDial(peer) {
  const lastDial = peer.metadata.get("last-dial-success");
  if (lastDial == null) {
    return 0;
  }
  return new Date(toString(lastDial)).getTime();
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  constructor(components, init = {}) {
    super();
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "reservationStore");
    __publicField(this, "listeningAddrs");
    __publicField(this, "log");
    __publicField(this, "listenTimeout");
    __publicField(this, "reservationId");
    __publicField(this, "relay");
    __publicField(this, "_onRemoveRelayPeer", (evt) => {
      var _a13, _b9;
      this.log("relay removed %p our relay %p", evt.detail.relay, this.relay, (_a13 = this.relay) == null ? void 0 : _a13.equals(evt.detail.relay));
      if (((_b9 = this.relay) == null ? void 0 : _b9.equals(evt.detail.relay)) !== true) {
        return;
      }
      this.log("relay peer removed %p", evt.detail.relay);
      this.listeningAddrs.forEach((ma) => {
        this.addressManager.removeObservedAddr(ma);
      });
      this.listeningAddrs = [];
      this.safeDispatchEvent("listening");
    });
    __publicField(this, "_onAddRelayPeer", (evt) => {
      const { details } = evt.detail;
      if (details.type === "configured") {
        return;
      }
      if (details.id !== this.reservationId) {
        return;
      }
      this.addedRelay(evt.detail);
    });
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.addressManager = components.addressManager;
    this.reservationStore = components.reservationStore;
    this.listeningAddrs = [];
    this.listenTimeout = init.listenTimeout ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.reservationStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
    this.reservationStore.addEventListener("relay:created-reservation", this._onAddRelayPeer);
  }
  async listen(addr) {
    this.log("listen on %a", addr);
    if (CircuitSearch.exactMatch(addr)) {
      this.reservationId = this.reservationStore.reserveRelay();
    } else if (CircuitListen.exactMatch(addr)) {
      const signal = AbortSignal.timeout(this.listenTimeout);
      setMaxListeners(Infinity, signal);
      const relayAddr = addr.decapsulate("/p2p-circuit");
      const relayConn = await this.connectionManager.openConnection(relayAddr, {
        signal
      });
      if (!this.reservationStore.hasReservation(relayConn.remotePeer)) {
        this.log("making reservation on peer %p", relayConn.remotePeer);
        const reservation = await this.reservationStore.addRelay(relayConn.remotePeer, "configured");
        this.addedRelay(reservation);
      }
    } else {
      throw new ListenError(`Could not listen on p2p-circuit address "${addr}"`);
    }
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  async close() {
    this.reservationStore.cancelReservations();
    this.listeningAddrs = [];
    this.reservationStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
  addedRelay(reservation) {
    this.log("relay peer added %p", reservation.relay);
    this.relay = reservation.relay;
    this.listeningAddrs = reservation.details.reservation.addrs.map((buf) => multiaddr(buf).encapsulate("/p2p-circuit"));
    this.listeningAddrs.forEach((ma) => {
      this.addressManager.confirmObservedAddr(ma, {
        type: "transport"
      });
    });
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
};
function createListener(options2) {
  return new CircuitRelayTransportListener(options2);
}

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size |= 0));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var _createReservation, createReservation_fn, _removeReservation, removeReservation_fn, _checkReservationCount, checkReservationCount_fn;
var ReservationStore2 = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __privateAdd(this, _createReservation);
    /**
     * Remove listen relay
     */
    __privateAdd(this, _removeReservation);
    __privateAdd(this, _checkReservationCount);
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "events");
    __publicField(this, "reserveQueue");
    __publicField(this, "reservations");
    __publicField(this, "pendingReservations");
    __publicField(this, "maxReservationQueueLength");
    __publicField(this, "reservationCompletionTimeout");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, "relayFilter");
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.pendingReservations = [];
    this.maxReservationQueueLength = (init == null ? void 0 : init.maxReservationQueueLength) ?? DEFAULT_MAX_RESERVATION_QUEUE_LENGTH;
    this.reservationCompletionTimeout = (init == null ? void 0 : init.reservationCompletionTimeout) ?? DEFAULT_RESERVATION_COMPLETION_TIMEOUT;
    this.started = false;
    this.relayFilter = createScalableCuckooFilter(100);
    this.reserveQueue = new PeerQueue({
      concurrency: (init == null ? void 0 : init.reservationConcurrency) ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("connection:close", (evt) => {
      const reservation = [...this.reservations.values()].find((reservation2) => reservation2.connection === evt.detail.id);
      if (reservation == null) {
        return;
      }
      __privateMethod(this, _removeReservation, removeReservation_fn).call(this, evt.detail.remotePeer).catch((err) => {
        this.log("could not remove relay %p - %e", evt.detail, err);
      });
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  afterStart() {
    void Promise.resolve().then(async () => {
      const relayPeers = await this.peerStore.all({
        filters: [(peer) => {
          return peer.tags.has(KEEP_ALIVE_TAG);
        }]
      });
      this.log("removing tag from %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => {
        await this.peerStore.merge(peer.id, {
          tags: {
            [KEEP_ALIVE_TAG]: void 0
          }
        });
      }));
      this.log("redialing %d old relays", relayPeers.length);
      await Promise.all(relayPeers.map(async (peer) => this.addRelay(peer.id, "discovered")));
      __privateMethod(this, _checkReservationCount, checkReservationCount_fn).call(this);
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  reserveRelay() {
    const id = nanoid();
    this.pendingReservations.push(id);
    __privateMethod(this, _checkReservationCount, checkReservationCount_fn).call(this);
    return id;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed
   * connection to the remote, and the remote peer speaks the hop protocol, try
   * to reserve a slot on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log.trace("not trying to use self as relay");
      throw new ListenError("Cannot use self as relay");
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      throw new RelayQueueFullError("The reservation queue is full");
    }
    const existingJob = this.reserveQueue.find(peerId);
    if (existingJob != null) {
      this.log.trace("potential relay peer %p is already in the reservation queue", peerId);
      return existingJob.join();
    }
    if (this.relayFilter.has(peerId.toMultihash().bytes)) {
      throw new ListenError("The relay was previously invalid");
    }
    this.log.trace("try to reserve relay slot with %p", peerId);
    return this.reserveQueue.add(async () => {
      const start2 = Date.now();
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          const connections = this.connectionManager.getConnections(peerId);
          let connected = false;
          if (connections.length === 0) {
            this.log("already have relay reservation with %p but we are no longer connected", peerId);
          }
          if (connections.map((conn) => conn.id).includes(existingReservation.connection)) {
            this.log("already have relay reservation with %p and the original connection is still open", peerId);
            connected = true;
          }
          if (connected && getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have relay reservation with %p but we are still connected and it does not expire soon", peerId);
            return {
              relay: peerId,
              details: existingReservation
            };
          }
          await __privateMethod(this, _removeReservation, removeReservation_fn).call(this, peerId);
        }
        if (type === "discovered" && this.pendingReservations.length === 0) {
          throw new HadEnoughRelaysError("Not making reservation on discovered relay because we do not need any more relays");
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        setMaxListeners(Infinity, signal);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (Circuit.matches(connection.remoteAddr)) {
          throw new DoubleRelayError("not creating reservation over relayed connection");
        }
        const reservation = await __privateMethod(this, _createReservation, createReservation_fn).call(this, connection, {
          signal
        });
        const expiration = getExpirationMilliseconds(reservation.expire);
        this.log("created reservation on relay peer %p, expiry date is %s", peerId, new Date(Date.now() + expiration).toString());
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.log("refresh reservation to relay %p", peerId);
          this.addRelay(peerId, type).catch(async (err) => {
            this.log.error("could not refresh reservation to relay %p - %e", peerId, err);
            await __privateMethod(this, _removeReservation, removeReservation_fn).call(this, peerId);
          }).catch((err) => {
            this.log.error("could not remove expired reservation to relay %p - %e", peerId, err);
          });
        }, timeoutDuration);
        let res;
        if (type === "discovered") {
          const id = this.pendingReservations.pop();
          if (id == null) {
            throw new HadEnoughRelaysError("Made reservation on relay but did not need any more discovered relays");
          }
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id,
            id
          };
        } else {
          res = {
            timeout,
            reservation,
            type,
            connection: connection.id
          };
        }
        this.reservations.set(peerId, res);
        await this.peerStore.merge(peerId, {
          tags: {
            [KEEP_ALIVE_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        __privateMethod(this, _checkReservationCount, checkReservationCount_fn).call(this);
        const result = {
          relay: peerId,
          details: res
        };
        this.safeDispatchEvent("relay:created-reservation", {
          detail: result
        });
        return result;
      } catch (err) {
        if (!(type === "discovered" && err.name === "HadEnoughRelaysError")) {
          this.log.error("could not reserve slot on %p after %dms - %e", peerId, Date.now() - start2, err);
        }
        if (err.name === "DialError" || err.name === "UnsupportedProtocolError") {
          this.relayFilter.add(peerId.toMultihash().bytes);
        }
        __privateMethod(this, _removeReservation, removeReservation_fn).call(this, peerId).catch((err2) => {
          this.log.error("could not remove reservation on %p after reserving slot failed - %e", peerId, err2);
        });
        throw err;
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    var _a13;
    return (_a13 = this.reservations.get(peerId)) == null ? void 0 : _a13.reservation;
  }
  reservationCount(type) {
    if (type == null) {
      return this.reservations.size;
    }
    return [...this.reservations.values()].reduce((acc, curr) => {
      if (curr.type === type) {
        acc++;
      }
      return acc;
    }, 0);
  }
  cancelReservations() {
    [...this.reservations.values()].forEach((reservation) => {
      clearTimeout(reservation.timeout);
    });
    this.reservations.clear();
  }
};
_createReservation = new WeakSet();
createReservation_fn = async function(connection, options2) {
  var _a13;
  (_a13 = options2.signal) == null ? void 0 : _a13.throwIfAborted();
  this.log("requesting reservation from %p", connection.remotePeer);
  const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options2);
  const pbstr = pbStream(stream);
  const hopstr = pbstr.pb(HopMessage);
  this.log.trace("send RESERVE to %p", connection.remotePeer);
  await hopstr.write({ type: HopMessage.Type.RESERVE }, options2);
  let response;
  try {
    this.log.trace("reading response from %p", connection.remotePeer);
    response = await hopstr.read(options2);
  } catch (err) {
    stream.abort(err);
    throw err;
  } finally {
    if (stream.status !== "closed") {
      await stream.close(options2);
    }
  }
  this.log.trace("read response %o", response);
  if (response.status === Status.OK && response.reservation != null) {
    const addresses = /* @__PURE__ */ new Set();
    addresses.add(connection.remoteAddr.toString());
    for (const buf of response.reservation.addrs) {
      let ma = multiaddr(buf);
      if (ma.getPeerId() == null) {
        ma = ma.encapsulate(`/p2p/${connection.remotePeer}`);
      }
      ma = multiaddr(ma.toString().replace(`/p2p/${connection.remotePeer}/p2p/${connection.remotePeer}`, `/p2p/${connection.remotePeer}`));
      addresses.add(ma.toString());
    }
    response.reservation.addrs = [...addresses].map((str) => multiaddr(str).bytes);
    return response.reservation;
  }
  const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
  this.log.error(errMsg);
  throw new Error(errMsg);
};
_removeReservation = new WeakSet();
removeReservation_fn = async function(peerId) {
  const reservation = this.reservations.get(peerId);
  if (reservation == null) {
    return;
  }
  this.log("removing relay reservation with %p from local store", peerId);
  clearTimeout(reservation.timeout);
  this.reservations.delete(peerId);
  if (reservation.type === "discovered") {
    this.pendingReservations.push(reservation.id);
  }
  await this.peerStore.merge(peerId, {
    tags: {
      [KEEP_ALIVE_TAG]: void 0
    }
  });
  this.safeDispatchEvent("relay:removed", {
    detail: {
      relay: peerId,
      details: reservation
    }
  });
  __privateMethod(this, _checkReservationCount, checkReservationCount_fn).call(this);
};
_checkReservationCount = new WeakSet();
checkReservationCount_fn = function() {
  if (this.pendingReservations.length === 0) {
    this.log.trace("have discovered enough relays");
    this.reserveQueue.clear();
    this.safeDispatchEvent("relay:found-enough-relays");
    return;
  }
  this.relayFilter = createScalableCuckooFilter(100);
  this.log("not discovered enough relays %d/%d", this.reservations.size, this.pendingReservations.length);
  this.safeDispatchEvent("relay:not-enough-relays");
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/transport.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults2 = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var _a3, _b2, _c;
var CircuitRelayTransport = class {
  constructor(components, init) {
    __publicField(this, "discovery");
    __publicField(this, "registrar");
    __publicField(this, "peerStore");
    __publicField(this, "connectionManager");
    __publicField(this, "transportManager");
    __publicField(this, "peerId");
    __publicField(this, "upgrader");
    __publicField(this, "addressManager");
    __publicField(this, "connectionGater");
    __publicField(this, "reservationStore");
    __publicField(this, "logger");
    __publicField(this, "maxInboundStopStreams");
    __publicField(this, "maxOutboundStopStreams");
    __publicField(this, "stopTimeout");
    __publicField(this, "started");
    __publicField(this, "log");
    __publicField(this, _a3, "@libp2p/circuit-relay-v2-transport");
    __publicField(this, _b2, [
      "@libp2p/transport",
      "@libp2p/circuit-relay-v2-transport"
    ]);
    __publicField(this, _c, true);
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults2.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults2.maxOutboundStopStreams;
    this.stopTimeout = init.stopTimeout ?? defaults2.stopTimeout;
    this.discovery = new RelayDiscovery(components, {
      filter: init.discoveryFilter ?? peerFilter(DEFAULT_DISCOVERY_FILTER_SIZE, DEFAULT_DISCOVERY_FILTER_ERROR_RATE)
    });
    this.discovery.addEventListener("relay:discover", (evt) => {
      this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
        if (err.name !== "HadEnoughRelaysError" && err.name !== "RelayQueueFullError") {
          this.log.error("could not add discovered relay %p", evt.detail, err);
        }
      });
    });
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      var _a13;
      (_a13 = this.discovery) == null ? void 0 : _a13.startDiscovery();
    });
    this.reservationStore.addEventListener("relay:found-enough-relays", () => {
      var _a13;
      (_a13 = this.discovery) == null ? void 0 : _a13.stopDiscovery();
    });
    this.started = false;
  }
  get [(_a3 = Symbol.toStringTag, _b2 = serviceCapabilities, serviceDependencies)]() {
    if (this.discovery != null) {
      return [
        "@libp2p/identify"
      ];
    }
    return [];
  }
  isStarted() {
    return this.started;
  }
  async start() {
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      void this.onStop(data).catch((err) => {
        this.log.error("error while handling STOP protocol", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnLimitedConnection: true
    });
    await start(this.discovery, this.reservationStore);
    this.started = true;
  }
  async stop() {
    await stop(this.discovery, this.reservationStore);
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options2) {
    var _a13, _b9, _c5, _d2, _e, _f;
    if (ma.protoCodes().filter((code6) => code6 === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      this.log.error(errMsg, ma);
      throw new DialError(errMsg);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `ircuit relay dial to ${ma.toString()} failed as address did not have both relay and destination PeerIDs`;
      this.log.error(`c${errMsg}`);
      throw new DialError(`C${errMsg}`);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("circuit-relay:open-connection"));
      relayConnection = await this.connectionManager.openConnection(relayPeer, options2);
    } else {
      (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("circuit-relay:reuse-connection"));
    }
    let stream;
    try {
      (_c5 = options2.onProgress) == null ? void 0 : _c5.call(options2, new CustomProgressEvent("circuit-relay:open-hop-stream"));
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC, options2);
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      (_d2 = options2.onProgress) == null ? void 0 : _d2.call(options2, new CustomProgressEvent("circuit-relay:write-connect-message"));
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toMultihash().bytes,
          addrs: [multiaddr(destinationAddr).bytes]
        }
      }, options2);
      (_e = options2.onProgress) == null ? void 0 : _e.call(options2, new CustomProgressEvent("circuit-relay:read-connect-response"));
      const status = await hopstr.read(options2);
      if (status.status !== Status.OK) {
        throw new InvalidMessageError(`failed to connect via relay with status ${((_f = status == null ? void 0 : status.status) == null ? void 0 : _f.toString()) ?? "undefined"}`);
      }
      const limits = new LimitTracker(status.limit);
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
        logger: this.logger,
        onDataRead: limits.onData,
        onDataWrite: limits.onData
      });
      this.log("new outbound relayed connection %a", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn, {
        ...options2,
        limits: limits.getLimits()
      });
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options2) {
    return createListener({
      peerId: this.peerId,
      connectionManager: this.connectionManager,
      addressManager: this.addressManager,
      reservationStore: this.reservationStore,
      logger: this.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return CircuitListen.exactMatch(ma) || CircuitSearch.exactMatch(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.exactMatch(ma);
    });
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }) {
    var _a13, _b9;
    if (!this.reservationStore.hasReservation(connection.remotePeer)) {
      try {
        this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
        await this.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
      } catch (err) {
        this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
      }
    }
    const signal = AbortSignal.timeout(this.stopTimeout);
    const pbstr = pbStream(stream).pb(StopMessage);
    const request = await pbstr.read({
      signal
    });
    this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
    if ((request == null ? void 0 : request.type) === void 0) {
      this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (request.type !== StopMessage.Type.CONNECT) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (!isValidStop(request)) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    const remotePeerId = peerIdFromMultihash(decode(request.peer.id));
    if (await ((_b9 = (_a13 = this.connectionGater).denyInboundRelayedConnection) == null ? void 0 : _b9.call(_a13, connection.remotePeer, remotePeerId)) === true) {
      this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
        signal
      });
      await stream.close();
      return;
    }
    this.log.trace("sending success response to %p", connection.remotePeer);
    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
      signal
    });
    const limits = new LimitTracker(request.limit);
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap().unwrap(),
      remoteAddr,
      localAddr,
      logger: this.logger,
      onDataRead: limits.onData,
      onDataWrite: limits.onData
    });
    this.log("new inbound relayed connection %a", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn, {
      limits: limits.getLimits()
    });
    this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
  }
};
_c = transportSymbol;

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}

// node_modules/@libp2p/dcutr/dist/src/pb/message.js
var HolePunch;
(function(HolePunch2) {
  let Type;
  (function(Type2) {
    Type2["UNUSED"] = "UNUSED";
    Type2["CONNECT"] = "CONNECT";
    Type2["SYNC"] = "SYNC";
  })(Type = HolePunch2.Type || (HolePunch2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["UNUSED"] = 0] = "UNUSED";
    __TypeValues2[__TypeValues2["CONNECT"] = 100] = "CONNECT";
    __TypeValues2[__TypeValues2["SYNC"] = 300] = "SYNC";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HolePunch2.Type || (HolePunch2.Type = {}));
  let _codec;
  HolePunch2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HolePunch2.Type.codec().encode(obj.type, w);
        }
        if (obj.observedAddresses != null) {
          for (const value of obj.observedAddresses) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13;
        const obj = {
          observedAddresses: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = HolePunch2.Type.codec().decode(reader);
              break;
            }
            case 2: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.observedAddresses) != null && obj.observedAddresses.length === opts.limits.observedAddresses) {
                throw new MaxLengthError('Decode error - map field "observedAddresses" had too many elements');
              }
              obj.observedAddresses.push(reader.bytes());
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HolePunch2.encode = (obj) => {
    return encodeMessage(obj, HolePunch2.codec());
  };
  HolePunch2.decode = (buf, opts) => {
    return decodeMessage(buf, HolePunch2.codec(), opts);
  };
})(HolePunch || (HolePunch = {}));

// node_modules/@libp2p/dcutr/dist/src/utils.js
function isPublicAndDialable(ma, transportManager) {
  if (Circuit.matches(ma)) {
    return false;
  }
  const transport = transportManager.dialTransportForMultiaddr(ma);
  if (transport == null) {
    return false;
  }
  if (DNS.matches(ma)) {
    return true;
  }
  if (!IP.matches(ma)) {
    return false;
  }
  return isPrivateIp(ma.toOptions().host) === false;
}

// node_modules/@libp2p/dcutr/dist/src/dcutr.js
var MAX_DCUTR_MESSAGE_SIZE = 1024 * 4;
var DCUTR_DIAL_PRIORITY = 100;
var defaultValues2 = {
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27
  timeout: 5e3,
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28
  retries: 3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1
};
var _a4, _b3;
var DefaultDCUtRService = class {
  constructor(components, init) {
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "retries");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "connectionManager");
    __publicField(this, "addressManager");
    __publicField(this, "transportManager");
    __publicField(this, "topologyId");
    __publicField(this, "log");
    __publicField(this, _a4, "@libp2p/dcutr");
    __publicField(this, _b3, [
      "@libp2p/identify"
    ]);
    this.log = components.logger.forComponent("libp2p:dcutr");
    this.started = false;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.timeout = init.timeout ?? defaultValues2.timeout;
    this.retries = init.retries ?? defaultValues2.retries;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues2.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues2.maxOutboundStreams;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.topologyId = await this.registrar.register(multicodec, {
      notifyOnLimitedConnection: true,
      onConnect: (peerId, connection) => {
        if (!Circuit.exactMatch(connection.remoteAddr)) {
          return;
        }
        if (connection.direction !== "inbound") {
          return;
        }
        this.upgradeInbound(connection).catch((err) => {
          this.log.error("error during outgoing DCUtR attempt", err);
        });
      }
    });
    await this.registrar.handle(multicodec, (data) => {
      void this.handleIncomingUpgrade(data.stream, data.connection).catch((err) => {
        this.log.error("error during incoming DCUtR attempt", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: true
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(multicodec);
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Perform the inbound connection upgrade as B
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async upgradeInbound(relayedConnection) {
    if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {
      return;
    }
    let stream;
    for (let i = 0; i < this.retries; i++) {
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      try {
        stream = await relayedConnection.newStream([multicodec], {
          signal: options2.signal,
          runOnLimitedConnection: true
        });
        const pb = pbStream(stream, {
          maxDataLength: MAX_DCUTR_MESSAGE_SIZE
        }).pb(HolePunch);
        this.log("B sending connect to %p", relayedConnection.remotePeer);
        const connectTimer = Date.now();
        await pb.write({
          type: HolePunch.Type.CONNECT,
          observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
        }, options2);
        this.log("B receiving connect from %p", relayedConnection.remotePeer);
        const connect = await pb.read(options2);
        if (connect.type !== HolePunch.Type.CONNECT) {
          this.log("A sent wrong message type");
          throw new InvalidMessageError("DCUtR message type was incorrect");
        }
        const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses);
        if (multiaddrs.length === 0) {
          this.log("A did not have any dialable multiaddrs");
          throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
        }
        const rtt = Date.now() - connectTimer;
        this.log("A sending sync, rtt %dms", rtt);
        await pb.write({
          type: HolePunch.Type.SYNC,
          observedAddresses: []
        }, options2);
        this.log("A waiting for half RTT");
        await delay_default(rtt / 2);
        this.log("B dialing", multiaddrs);
        const conn = await this.connectionManager.openConnection(multiaddrs, {
          signal: options2.signal,
          priority: DCUTR_DIAL_PRIORITY
        });
        this.log("DCUtR to %p succeeded to address %a, closing relayed connection", relayedConnection.remotePeer, conn.remoteAddr);
        await relayedConnection.close(options2);
        break;
      } catch (err) {
        this.log.error("error while attempting DCUtR on attempt %d of %d", i + 1, this.retries, err);
        stream == null ? void 0 : stream.abort(err);
        if (i === this.retries) {
          throw err;
        }
      } finally {
        if (stream != null) {
          await stream.close(options2);
        }
      }
    }
  }
  /**
   * This is performed when A has dialed B via a relay but A also has a public
   * address that B can dial directly
   */
  async attemptUnilateralConnectionUpgrade(relayedConnection) {
    const peerInfo = await this.peerStore.get(relayedConnection.remotePeer);
    const publicAddresses = peerInfo.addresses.map((address) => {
      const ma = address.multiaddr;
      if (ma.getPeerId() == null) {
        return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`);
      }
      return ma;
    }).filter((ma) => {
      return isPublicAndDialable(ma, this.transportManager);
    });
    if (publicAddresses.length > 0) {
      const signal = AbortSignal.timeout(this.timeout);
      try {
        this.log("attempting unilateral connection upgrade to %a", publicAddresses);
        const connection = await this.connectionManager.openConnection(publicAddresses, {
          signal,
          force: true
        });
        if (Circuit.exactMatch(connection.remoteAddr)) {
          throw new Error("Could not open a new, non-limited, connection");
        }
        this.log("unilateral connection upgrade to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
        await relayedConnection.close({
          signal
        });
        return true;
      } catch (err) {
        this.log.error("unilateral connection upgrade to %p on addresses %a failed", relayedConnection.remotePeer, publicAddresses, err);
      }
    } else {
      this.log("peer %p has no public addresses, not attempting unilateral connection upgrade", relayedConnection.remotePeer);
    }
    return false;
  }
  /**
   * Perform the connection upgrade as A
   *
   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol
   */
  async handleIncomingUpgrade(stream, relayedConnection) {
    const options2 = {
      signal: AbortSignal.timeout(this.timeout)
    };
    try {
      const pb = pbStream(stream, {
        maxDataLength: MAX_DCUTR_MESSAGE_SIZE
      }).pb(HolePunch);
      this.log("A receiving connect");
      const connect = await pb.read(options2);
      if (connect.type !== HolePunch.Type.CONNECT) {
        this.log("B sent wrong message type");
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      if (connect.observedAddresses.length === 0) {
        this.log("B sent no multiaddrs");
        throw new InvalidMessageError("DCUtR connect message had no multiaddrs");
      }
      const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses);
      if (multiaddrs.length === 0) {
        this.log("B had no dialable multiaddrs");
        throw new InvalidMessageError("DCUtR connect message had no dialable multiaddrs");
      }
      this.log("A sending connect");
      await pb.write({
        type: HolePunch.Type.CONNECT,
        observedAddresses: this.addressManager.getAddresses().map((ma) => ma.bytes)
      });
      this.log("A receiving sync");
      const sync = await pb.read(options2);
      if (sync.type !== HolePunch.Type.SYNC) {
        throw new InvalidMessageError("DCUtR message type was incorrect");
      }
      this.log("A dialing", multiaddrs);
      const connection = await this.connectionManager.openConnection(multiaddrs, {
        signal: options2.signal,
        priority: DCUTR_DIAL_PRIORITY,
        force: true
      });
      this.log("DCUtR to %p succeeded via %a, closing relayed connection", relayedConnection.remotePeer, connection.remoteAddr);
      await relayedConnection.close(options2);
    } catch (err) {
      this.log.error("incoming DCUtR from %p failed", relayedConnection.remotePeer, err);
      stream.abort(err);
    } finally {
      await stream.close(options2);
    }
  }
  /**
   * Takes the `addr` and converts it to a Multiaddr if possible
   */
  getDialableMultiaddrs(addrs) {
    const output = [];
    for (const addr of addrs) {
      if (addr == null || addr.length === 0) {
        continue;
      }
      try {
        const ma = multiaddr(addr);
        if (!isPublicAndDialable(ma, this.transportManager)) {
          continue;
        }
        output.push(ma);
      } catch {
      }
    }
    return output;
  }
};
_a4 = Symbol.toStringTag, _b3 = serviceDependencies;

// node_modules/@libp2p/dcutr/dist/src/index.js
var multicodec = "/libp2p/dcutr";
function dcutr(init = {}) {
  return (components) => new DefaultDCUtRService(components, init);
}

// node_modules/@libp2p/identify/dist/src/consts.js
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var MAX_PUSH_CONCURRENCY = 32;

// node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9;
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              obj.protocolVersion = reader.string();
              break;
            }
            case 6: {
              obj.agentVersion = reader.string();
              break;
            }
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.listenAddrs) != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
              }
              obj.listenAddrs.push(reader.bytes());
              break;
            }
            case 4: {
              obj.observedAddr = reader.bytes();
              break;
            }
            case 3: {
              if (((_b9 = opts.limits) == null ? void 0 : _b9.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 8: {
              obj.signedPeerRecord = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf, opts) => {
    return decodeMessage(buf, Identify3.codec(), opts);
  };
})(Identify || (Identify = {}));

// node_modules/wherearewe/src/index.js
var import_is_electron = __toESM(require_is_electron());
var isEnvWithDom = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
var isElectron = (0, import_is_electron.default)();
var isBrowser = isEnvWithDom && !isElectron;
var isElectronMain = isElectron && !isEnvWithDom;
var isElectronRenderer = isElectron && isEnvWithDom;
var isNode = typeof globalThis.process !== "undefined" && typeof globalThis.process.release !== "undefined" && globalThis.process.release.name === "node" && !isElectron;
var isWebWorker = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
var isTest = typeof globalThis.process !== "undefined" && typeof globalThis.process.env !== "undefined" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test";
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/@libp2p/identify/dist/src/utils.js
var defaultValues3 = {
  protocolPrefix: "ipfs",
  timeout: 5e3,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxObservedAddresses: 10,
  maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
  runOnConnectionOpen: true,
  runOnSelfUpdate: true,
  runOnLimitedConnection: true,
  concurrency: MAX_PUSH_CONCURRENCY
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}
function getAgentVersion(nodeInfo, agentVersion) {
  if (agentVersion != null) {
    return agentVersion;
  }
  agentVersion = `${nodeInfo.name}/${nodeInfo.version}`;
  if (isNode || isElectronMain) {
    agentVersion += ` UserAgent=${globalThis.process.version}`;
  } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
    agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
  }
  return agentVersion;
}
async function consumeIdentifyMessage(peerStore, events, log7, connection, message2) {
  log7("received identify from %p", connection.remotePeer);
  if (message2 == null) {
    throw new InvalidMessageError("message was null or undefined");
  }
  const peer = {};
  if (message2.listenAddrs.length > 0) {
    peer.addresses = message2.listenAddrs.map((buf) => ({
      isCertified: false,
      multiaddr: multiaddr(buf)
    }));
  }
  if (message2.protocols.length > 0) {
    peer.protocols = message2.protocols;
  }
  if (message2.publicKey != null) {
    const publicKey = publicKeyFromProtobuf(message2.publicKey);
    const peerId = peerIdFromPublicKey(publicKey);
    if (!peerId.equals(connection.remotePeer)) {
      throw new InvalidMessageError("public key did not match remote PeerId");
    }
    peer.publicKey = publicKey;
  }
  let output;
  if (message2.signedPeerRecord != null) {
    log7.trace("received signedPeerRecord from %p", connection.remotePeer);
    let peerRecordEnvelope = message2.signedPeerRecord;
    const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);
    let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
    const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
    if (!peerRecord.peerId.equals(envelopePeer)) {
      throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
    }
    if (!connection.remotePeer.equals(peerRecord.peerId)) {
      throw new InvalidMessageError("signing key does not match remote PeerId");
    }
    let existingPeer;
    try {
      existingPeer = await peerStore.get(peerRecord.peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if (existingPeer != null) {
      peer.metadata = existingPeer.metadata;
      if (existingPeer.peerRecordEnvelope != null) {
        const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
        const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          log7("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          peerRecord = storedRecord;
          peerRecordEnvelope = existingPeer.peerRecordEnvelope;
        }
      }
    }
    peer.peerRecordEnvelope = peerRecordEnvelope;
    peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
      isCertified: true,
      multiaddr: multiaddr2
    }));
    output = {
      seq: peerRecord.seqNumber,
      addresses: peerRecord.multiaddrs
    };
  } else {
    log7("%p did not send a signed peer record", connection.remotePeer);
  }
  log7.trace("patching %p with", connection.remotePeer, peer);
  await peerStore.patch(connection.remotePeer, peer);
  if (message2.agentVersion != null || message2.protocolVersion != null) {
    const metadata = {};
    if (message2.agentVersion != null) {
      metadata.AgentVersion = fromString(message2.agentVersion);
    }
    if (message2.protocolVersion != null) {
      metadata.ProtocolVersion = fromString(message2.protocolVersion);
    }
    log7.trace("merging %p metadata", connection.remotePeer, metadata);
    await peerStore.merge(connection.remotePeer, {
      metadata
    });
  }
  const result = {
    peerId: connection.remotePeer,
    protocolVersion: message2.protocolVersion,
    agentVersion: message2.agentVersion,
    publicKey: message2.publicKey,
    listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
    observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
    protocols: message2.protocols,
    signedPeerRecord: output,
    connection
  };
  events.safeDispatchEvent("peer:identify", { detail: result });
  return result;
}
var AbstractIdentify = class {
  constructor(components, init) {
    __publicField(this, "host");
    __publicField(this, "protocol");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "peerId");
    __publicField(this, "privateKey");
    __publicField(this, "peerStore");
    __publicField(this, "registrar");
    __publicField(this, "addressManager");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "maxMessageSize");
    __publicField(this, "maxObservedAddresses");
    __publicField(this, "events");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    this.protocol = init.protocol;
    this.started = false;
    this.peerId = components.peerId;
    this.privateKey = components.privateKey;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.events = components.events;
    this.log = init.log;
    this.timeout = init.timeout ?? defaultValues3.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues3.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues3.maxOutboundStreams;
    this.maxMessageSize = init.maxMessageSize ?? defaultValues3.maxMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues3.maxObservedAddresses;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues3.runOnLimitedConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
    };
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.protocol, (data) => {
      void this.handleProtocol(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.protocol);
    this.started = false;
  }
};

// node_modules/@libp2p/identify/dist/src/identify-push.js
var _a5;
var IdentifyPush = class extends AbstractIdentify {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify-push")
    });
    __publicField(this, "connectionManager");
    __publicField(this, "concurrency");
    __publicField(this, _a5, [
      "@libp2p/identify-push"
    ]);
    this.connectionManager = components.connectionManager;
    this.concurrency = init.concurrency ?? defaultValues3.concurrency;
    if (init.runOnSelfUpdate ?? defaultValues3.runOnSelfUpdate) {
      components.events.addEventListener("self:peer:update", (evt) => {
        void this.push().catch((err) => {
          this.log.error(err);
        });
      });
    }
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.privateKey);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
    const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
    const self2 = this;
    async function* pushToConnections() {
      for (const connection of self2.connectionManager.getConnections()) {
        const peer2 = await self2.peerStore.get(connection.remotePeer);
        if (!peer2.protocols.includes(self2.protocol)) {
          continue;
        }
        yield async () => {
          let stream;
          const signal = AbortSignal.timeout(self2.timeout);
          setMaxListeners(Infinity, signal);
          try {
            stream = await connection.newStream(self2.protocol, {
              signal,
              runOnLimitedConnection: self2.runOnLimitedConnection
            });
            const pb = pbStream(stream, {
              maxDataLength: self2.maxMessageSize
            }).pb(Identify);
            await pb.write({
              listenAddrs: listenAddresses.map((ma) => ma.bytes),
              signedPeerRecord: signedPeerRecord.marshal(),
              protocols: supportedProtocols,
              agentVersion,
              protocolVersion
            }, {
              signal
            });
            await stream.close({
              signal
            });
          } catch (err) {
            self2.log.error("could not push identify update to peer", err);
            stream == null ? void 0 : stream.abort(err);
          }
        };
      }
    }
    await src_default7(parallel(pushToConnections(), {
      concurrency: this.concurrency
    }));
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options2 = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      await consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log.trace("handled push from %p", connection.remotePeer);
  }
};
_a5 = serviceCapabilities;

// node_modules/@libp2p/identify/dist/src/identify.js
var CODEC_IP62 = 41;
var _a6;
var Identify2 = class extends AbstractIdentify {
  constructor(components, init = {}) {
    super(components, {
      ...init,
      protocol: `/${init.protocolPrefix ?? defaultValues3.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
      log: components.logger.forComponent("libp2p:identify")
    });
    __publicField(this, _a6, [
      "@libp2p/identify"
    ]);
    if (init.runOnConnectionOpen ?? defaultValues3.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          if (err.name === UnsupportedProtocolError.name) {
            return;
          }
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
  }
  async _identify(connection, options2 = {}) {
    let stream;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxMessageSize
      }).pb(Identify);
      const message2 = await pb.read(options2);
      await stream.close(options2);
      return message2;
    } catch (err) {
      stream == null ? void 0 : stream.abort(err);
      throw err;
    }
  }
  async identify(connection, options2 = {}) {
    const message2 = await this._identify(connection, options2);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new InvalidMessageError("public key was missing from identify message");
    }
    const key = publicKeyFromProtobuf(publicKey);
    const id = peerIdFromCID(key.toCID());
    if (!connection.remotePeer.equals(id)) {
      throw new InvalidMessageError("identified peer does not match the expected peer");
    }
    if (this.peerId.equals(id)) {
      throw new InvalidMessageError("identified peer is our own peer id?");
    }
    this.maybeAddObservedAddress(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols);
    return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
  }
  maybeAddObservedAddress(observedAddr) {
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    if (cleanObservedAddr == null) {
      return;
    }
    this.log.trace("our observed address was %a", cleanObservedAddr);
    if (isPrivate(cleanObservedAddr)) {
      this.log.trace("our observed address was private");
      return;
    }
    const tuples = cleanObservedAddr.stringTuples();
    if (tuples[0][0] === CODEC_IP62 && !isGlobalUnicast(cleanObservedAddr)) {
      this.log.trace("our observed address was IPv6 but not a global unicast address");
      return;
    }
    if (TCP.exactMatch(cleanObservedAddr)) {
      return;
    }
    this.log.trace("storing the observed address");
    this.addressManager.addObservedAddr(cleanObservedAddr);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async handleProtocol(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey: publicKeyToProtobuf(this.privateKey.publicKey),
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
};
_a6 = serviceCapabilities;

// node_modules/@libp2p/identify/dist/src/index.js
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
function identifyPush(init = {}) {
  return (components) => new IdentifyPush(components, init);
}

// node_modules/@libp2p/kad-dht/dist/src/constants.js
var second2 = 1e3;
var minute2 = 60 * second2;
var hour = 60 * minute2;
var MAX_RECORD_AGE = 36 * hour;
var PROTOCOL = "/ipfs/kad/1.0.0";
var PROVIDERS_VALIDITY = 48 * hour;
var REPROVIDE_THRESHOLD = 24 * hour;
var REPROVIDE_CONCURRENCY = 10;
var REPROVIDE_MAX_QUEUE_SIZE = 16384;
var REPROVIDE_INTERVAL = hour;
var READ_MESSAGE_TIMEOUT = 10 * second2;
var K = 20;
var ALPHA = 3;
var QUERY_SELF_INTERVAL = 5 * minute2;
var QUERY_SELF_INITIAL_INTERVAL = second2;
var QUERY_SELF_TIMEOUT = 5 * second2;
var TABLE_REFRESH_INTERVAL = 5 * minute2;
var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second2;
var DEFAULT_QUERY_TIMEOUT = 180 * second2;
var KEEP_ALIVE_TAG2 = `${KEEP_ALIVE}-kad-dht`;

// node_modules/@libp2p/record/dist/src/record.js
var Record;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null && obj.key.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.timeReceived != null && obj.timeReceived !== "") {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {
          key: alloc(0),
          value: alloc(0),
          timeReceived: ""
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf, opts) => {
    return decodeMessage(buf, Record3.codec(), opts);
  };
})(Record || (Record = {}));

// node_modules/@libp2p/record/dist/src/utils.js
function toRFC3339(time) {
  const year = time.getUTCFullYear();
  const month = String(time.getUTCMonth() + 1).padStart(2, "0");
  const day = String(time.getUTCDate()).padStart(2, "0");
  const hour2 = String(time.getUTCHours()).padStart(2, "0");
  const minute3 = String(time.getUTCMinutes()).padStart(2, "0");
  const seconds = String(time.getUTCSeconds()).padStart(2, "0");
  const milliseconds = time.getUTCMilliseconds();
  const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
  return `${year}-${month}-${day}T${hour2}:${minute3}:${seconds}.${nanoseconds}Z`;
}
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp(
    // 2006-01-02T
    "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
  );
  const m = String(time).trim().match(rfc3339Matcher);
  if (m == null) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour2 = parseInt(m[4], 10);
  const minute3 = parseInt(m[5], 10);
  const second3 = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour2, minute3, second3, millisecond));
}

// node_modules/@libp2p/record/dist/src/index.js
var Libp2pRecord = class _Libp2pRecord {
  constructor(key, value, timeReceived) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "timeReceived");
    if (!(key instanceof Uint8Array)) {
      throw new Error("key must be a Uint8Array");
    }
    if (!(value instanceof Uint8Array)) {
      throw new Error("value must be a Uint8Array");
    }
    this.key = key;
    this.value = value;
    this.timeReceived = timeReceived;
  }
  serialize() {
    return Record.encode(this.prepareSerialize());
  }
  /**
   * Return the object format ready to be given to the protobuf library.
   */
  prepareSerialize() {
    return {
      key: this.key,
      value: this.value,
      timeReceived: toRFC3339(this.timeReceived)
    };
  }
  /**
   * Decode a protobuf encoded record
   */
  static deserialize(raw) {
    const rec = Record.decode(raw);
    return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
  }
  /**
   * Create a record from the raw object returned from the protobuf library
   */
  static fromDeserialized(obj) {
    const recvtime = parseRFC3339(obj.timeReceived);
    if (obj.key == null) {
      throw new Error("key missing from deserialized object");
    }
    if (obj.value == null) {
      throw new Error("value missing from deserialized object");
    }
    const rec = new _Libp2pRecord(obj.key, obj.value, recvtime);
    return rec;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/errors.js
var QueryError = class extends Error {
  constructor(message2 = "Query error") {
    super(message2);
    this.name = "QueryError";
  }
};
var QueryAbortedError = class extends Error {
  constructor(message2 = "Query aborted") {
    super(message2);
    this.name = "QueryAbortedError";
  }
};
var InvalidRecordError = class extends Error {
  constructor(message2 = "Invalid record") {
    super(message2);
    this.name = "InvalidRecordError";
  }
};
var MissingSelectorError = class extends Error {
  constructor(message2 = "No selector function configured for prefix") {
    super(message2);
    this.name = "MissingSelectorError";
  }
};

// node_modules/@libp2p/kad-dht/dist/src/message/dht.js
var Record2;
(function(Record3) {
  let _codec;
  Record3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.key != null) {
          w.uint32(10);
          w.bytes(obj.key);
        }
        if (obj.value != null) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (obj.author != null) {
          w.uint32(26);
          w.bytes(obj.author);
        }
        if (obj.signature != null) {
          w.uint32(34);
          w.bytes(obj.signature);
        }
        if (obj.timeReceived != null) {
          w.uint32(42);
          w.string(obj.timeReceived);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.key = reader.bytes();
              break;
            }
            case 2: {
              obj.value = reader.bytes();
              break;
            }
            case 3: {
              obj.author = reader.bytes();
              break;
            }
            case 4: {
              obj.signature = reader.bytes();
              break;
            }
            case 5: {
              obj.timeReceived = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Record3.encode = (obj) => {
    return encodeMessage(obj, Record3.codec());
  };
  Record3.decode = (buf, opts) => {
    return decodeMessage(buf, Record3.codec(), opts);
  };
})(Record2 || (Record2 = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["PUT_VALUE"] = "PUT_VALUE";
  MessageType2["GET_VALUE"] = "GET_VALUE";
  MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
  MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
  MessageType2["FIND_NODE"] = "FIND_NODE";
  MessageType2["PING"] = "PING";
})(MessageType || (MessageType = {}));
var __MessageTypeValues;
(function(__MessageTypeValues2) {
  __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
  __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
  __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
  __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
  __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
})(__MessageTypeValues || (__MessageTypeValues = {}));
(function(MessageType2) {
  MessageType2.codec = () => {
    return enumeration(__MessageTypeValues);
  };
})(MessageType || (MessageType = {}));
var ConnectionType;
(function(ConnectionType2) {
  ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
  ConnectionType2["CONNECTED"] = "CONNECTED";
  ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
  ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
})(ConnectionType || (ConnectionType = {}));
var __ConnectionTypeValues;
(function(__ConnectionTypeValues2) {
  __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
  __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
})(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
(function(ConnectionType2) {
  ConnectionType2.codec = () => {
    return enumeration(__ConnectionTypeValues);
  };
})(ConnectionType || (ConnectionType = {}));
var PeerInfo;
(function(PeerInfo2) {
  let _codec;
  PeerInfo2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.multiaddrs != null) {
          for (const value of obj.multiaddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.connection != null) {
          w.uint32(24);
          ConnectionType.codec().encode(obj.connection, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13;
        const obj = {
          id: alloc(0),
          multiaddrs: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.id = reader.bytes();
              break;
            }
            case 2: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.multiaddrs) != null && obj.multiaddrs.length === opts.limits.multiaddrs) {
                throw new MaxLengthError('Decode error - map field "multiaddrs" had too many elements');
              }
              obj.multiaddrs.push(reader.bytes());
              break;
            }
            case 3: {
              obj.connection = ConnectionType.codec().decode(reader);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerInfo2.encode = (obj) => {
    return encodeMessage(obj, PeerInfo2.codec());
  };
  PeerInfo2.decode = (buf, opts) => {
    return decodeMessage(buf, PeerInfo2.codec(), opts);
  };
})(PeerInfo || (PeerInfo = {}));
var Message2;
(function(Message5) {
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
          w.uint32(8);
          MessageType.codec().encode(obj.type, w);
        }
        if (obj.clusterLevel != null) {
          w.uint32(80);
          w.int32(obj.clusterLevel);
        }
        if (obj.key != null) {
          w.uint32(18);
          w.bytes(obj.key);
        }
        if (obj.record != null) {
          w.uint32(26);
          w.bytes(obj.record);
        }
        if (obj.closer != null) {
          for (const value of obj.closer) {
            w.uint32(66);
            PeerInfo.codec().encode(value, w);
          }
        }
        if (obj.providers != null) {
          for (const value of obj.providers) {
            w.uint32(74);
            PeerInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        var _a13, _b9, _c5, _d2;
        const obj = {
          type: MessageType.PUT_VALUE,
          closer: [],
          providers: []
        };
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = MessageType.codec().decode(reader);
              break;
            }
            case 10: {
              obj.clusterLevel = reader.int32();
              break;
            }
            case 2: {
              obj.key = reader.bytes();
              break;
            }
            case 3: {
              obj.record = reader.bytes();
              break;
            }
            case 8: {
              if (((_a13 = opts.limits) == null ? void 0 : _a13.closer) != null && obj.closer.length === opts.limits.closer) {
                throw new MaxLengthError('Decode error - map field "closer" had too many elements');
              }
              obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b9 = opts.limits) == null ? void 0 : _b9.closer$
              }));
              break;
            }
            case 9: {
              if (((_c5 = opts.limits) == null ? void 0 : _c5.providers) != null && obj.providers.length === opts.limits.providers) {
                throw new MaxLengthError('Decode error - map field "providers" had too many elements');
              }
              obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                limits: (_d2 = opts.limits) == null ? void 0 : _d2.providers$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message2 || (Message2 = {}));

// node_modules/@libp2p/kad-dht/dist/src/query/events.js
function sendQueryEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "SEND_QUERY",
    type: 0,
    messageName: fields.type,
    messageType: fields.type
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:send-query", { detail: event }));
  return event;
}
function peerResponseEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "PEER_RESPONSE",
    type: 1,
    messageName: fields.messageType,
    closer: fields.closer ?? [],
    providers: fields.providers ?? []
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:peer-response", { detail: event }));
  return event;
}
function finalPeerEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "FINAL_PEER",
    type: 2
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:final-peer", { detail: event }));
  return event;
}
function queryErrorEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "QUERY_ERROR",
    type: 3
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:query-error", { detail: event }));
  return event;
}
function providerEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "PROVIDER",
    type: 4
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:provider", { detail: event }));
  return event;
}
function valueEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "VALUE",
    type: 5
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:value", { detail: event }));
  return event;
}
function dialPeerEvent(fields, options2 = {}) {
  var _a13;
  const event = {
    ...fields,
    name: "DIAL_PEER",
    type: 7
  };
  (_a13 = options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
  return event;
}

// node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
function bestRecord(selectors2, k, records) {
  if (records.length === 0) {
    throw new InvalidParametersError("No records given");
  }
  const kStr = toString(k);
  const parts = kStr.split("/");
  if (parts.length < 3) {
    throw new InvalidParametersError("Record key does not have a selector function");
  }
  const selector = selectors2[parts[1].toString()];
  if (selector == null) {
    throw new MissingSelectorError(`No selector function configured for key type "${parts[1]}"`);
  }
  if (records.length === 1) {
    return 0;
  }
  return selector(k, records);
}
function publickKey(k, records) {
  return 0;
}
var selectors = {
  pk: publickKey
};

// node_modules/@libp2p/kad-dht/dist/src/record/validators.js
async function verifyRecord(validators2, record) {
  const key = record.key;
  const keyString = toString(key);
  const parts = keyString.split("/");
  if (parts.length < 3) {
    return;
  }
  const validator = validators2[parts[1].toString()];
  if (validator == null) {
    throw new InvalidParametersError(`No validator available for key type "${parts[1]}"`);
  }
  await validator(key, record.value);
}
var validatePublicKeyRecord = async (key, publicKey) => {
  if (!(key instanceof Uint8Array)) {
    throw new InvalidParametersError('"key" must be a Uint8Array');
  }
  if (key.byteLength < 5) {
    throw new InvalidParametersError("Invalid public key record");
  }
  const prefix = toString(key.subarray(0, 4));
  if (prefix !== "/pk/") {
    throw new InvalidParametersError("key was not prefixed with /pk/");
  }
  const pubKey = publicKeyFromProtobuf(publicKey);
  const keyhash = key.slice(4);
  if (!equals(keyhash, pubKey.toMultihash().bytes)) {
    throw new InvalidParametersError("public key does not match passed in key");
  }
};
var validators = {
  pk: validatePublicKeyRecord
};

// node_modules/@libp2p/kad-dht/dist/src/utils.js
var PK_PREFIX = fromString("/pk/");
function removePrivateAddressesMapper(peer) {
  return {
    ...peer,
    multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
      const [[type, addr]] = multiaddr2.stringTuples();
      if (type === 53 || type === 54 || type === 55) {
        if (addr === "localhost") {
          return false;
        }
        return true;
      }
      if (type !== 4 && type !== 6) {
        return false;
      }
      if (addr == null) {
        return false;
      }
      const isPrivate2 = isPrivateIp(addr);
      if (isPrivate2 == null) {
        return true;
      }
      return !isPrivate2;
    })
  };
}
async function convertBuffer(buf) {
  const multihash = await sha256.digest(buf);
  return multihash.digest;
}
async function convertPeerId(peerId) {
  return convertBuffer(peerId.toMultihash().bytes);
}
function bufferToRecordKey(prefix, buf) {
  return new Key(`${prefix}/${toString(buf, "base32")}`, false);
}
function keyForPublicKey(peerId) {
  return concat([
    PK_PREFIX,
    peerId.toMultihash().bytes
  ]);
}
function isPublicKeyKey(key) {
  return toString(key.subarray(0, 4)) === "/pk/";
}
function fromPublicKeyKey(key) {
  const multihash = decode(key.subarray(4));
  return peerIdFromMultihash(multihash);
}
function createPutRecord(key, value) {
  const timeReceived = /* @__PURE__ */ new Date();
  const rec = new Libp2pRecord(key, value, timeReceived);
  return rec.serialize();
}
var P2P_CIRCUIT_CODE = 290;
var DNS4_CODE = 54;
var DNS6_CODE = 55;
var DNSADDR_CODE = 56;
var IP4_CODE = 4;
var IP6_CODE = 41;
function multiaddrIsPublic(multiaddr2) {
  const tuples = multiaddr2.stringTuples();
  for (const tuple of tuples) {
    if (tuple[0] === P2P_CIRCUIT_CODE) {
      return false;
    }
  }
  if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {
    return true;
  }
  if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {
    const result = isPrivateIp(`${tuples[0][1]}`);
    const isPublic = result == null || !result;
    return isPublic;
  }
  return false;
}
function parseProviderKey(key) {
  const parts = key.toString().split("/");
  const peerIdStr = parts.pop();
  const cidStr = parts.pop();
  if (peerIdStr == null || cidStr == null) {
    throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
  }
  return {
    cid: CID.createV1(code2, decode(fromString(cidStr, "base32"))),
    peerId: peerIdFromString(peerIdStr)
  };
}
function toProviderKey(prefix, cid, peerId) {
  const cidStr = typeof cid === "string" ? cid : toString(cid.multihash.bytes, "base32");
  const parts = [
    prefix,
    cidStr
  ];
  if (peerId != null) {
    parts.push(peerId.toString());
  }
  return new Key(parts.join("/"));
}
function readProviderTime(buf) {
  return new Date(decode2(buf));
}
function timeOperationGenerator(fn, operationMetrics, type) {
  return async function* (...args) {
    var _a13, _b9, _c5, _d2, _e;
    const stopSuccessTimer = (_a13 = operationMetrics.queryTime) == null ? void 0 : _a13.timer(type);
    const stopErrorTimer = (_b9 = operationMetrics.errorTime) == null ? void 0 : _b9.timer(type);
    let errored = false;
    try {
      (_c5 = operationMetrics.queries) == null ? void 0 : _c5.increment({ [type]: true });
      yield* fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer == null ? void 0 : stopErrorTimer();
      (_d2 = operationMetrics.errors) == null ? void 0 : _d2.increment({ [type]: true });
      throw err;
    } finally {
      (_e = operationMetrics.queries) == null ? void 0 : _e.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer == null ? void 0 : stopSuccessTimer();
      }
    }
  };
}
function timeOperationMethod(fn, operationMetrics, type) {
  return async function(...args) {
    var _a13, _b9, _c5, _d2, _e;
    const stopSuccessTimer = (_a13 = operationMetrics == null ? void 0 : operationMetrics.queryTime) == null ? void 0 : _a13.timer(type);
    const stopErrorTimer = (_b9 = operationMetrics == null ? void 0 : operationMetrics.errorTime) == null ? void 0 : _b9.timer(type);
    let errored = false;
    try {
      (_c5 = operationMetrics.queries) == null ? void 0 : _c5.increment({ [type]: true });
      return await fn(...args);
    } catch (err) {
      errored = true;
      stopErrorTimer == null ? void 0 : stopErrorTimer();
      (_d2 = operationMetrics.errors) == null ? void 0 : _d2.increment({ [type]: true });
      throw err;
    } finally {
      (_e = operationMetrics.queries) == null ? void 0 : _e.decrement({ [type]: true });
      if (!errored) {
        stopSuccessTimer == null ? void 0 : stopSuccessTimer();
      }
    }
  };
}

// node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
var ContentFetching = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "validators");
    __publicField(this, "selectors");
    __publicField(this, "peerRouting");
    __publicField(this, "queryManager");
    __publicField(this, "network");
    __publicField(this, "datastorePrefix");
    var _a13, _b9;
    const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
    this.selectors = selectors2;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.network = network;
    this.get = ((_a13 = components.metrics) == null ? void 0 : _a13.traceFunction("libp2p.kadDHT.get", this.get.bind(this), {
      optionsIndex: 1
    })) ?? this.get;
    this.put = ((_b9 = components.metrics) == null ? void 0 : _b9.traceFunction("libp2p.kadDHT.put", this.put.bind(this), {
      optionsIndex: 2
    })) ?? this.put;
  }
  /**
   * Attempt to retrieve the value for the given key from
   * the local datastore
   */
  async getLocal(key) {
    this.log("getLocal %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log("fetching record for key %k", dsKey);
    const raw = await this.components.datastore.get(dsKey);
    this.log("found %k in local datastore", dsKey);
    const rec = Libp2pRecord.deserialize(raw);
    await verifyRecord(this.validators, rec);
    return rec;
  }
  /**
   * Send the best record found to any peers that have an out of date record
   */
  async *sendCorrectionRecord(key, vals, best, options2 = {}) {
    this.log("sendCorrection for %b", key);
    const fixupRec = createPutRecord(key, best);
    for (const { value, from } of vals) {
      if (equals(value, best)) {
        this.log("record was ok");
        continue;
      }
      if (this.components.peerId.equals(from)) {
        try {
          const dsKey = bufferToRecordKey(this.datastorePrefix, key);
          this.log(`Storing corrected record for key ${dsKey.toString()}`);
          await this.components.datastore.put(dsKey, fixupRec.subarray());
        } catch (err) {
          this.log.error("Failed error correcting self", err);
        }
        continue;
      }
      let sentCorrection = false;
      const request = {
        type: MessageType.PUT_VALUE,
        key,
        record: fixupRec
      };
      for await (const event of this.network.sendRequest(from, request, options2)) {
        if (event.name === "PEER_RESPONSE" && event.record != null && equals(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
          sentCorrection = true;
        }
        yield event;
      }
      if (!sentCorrection) {
        yield queryErrorEvent({ from, error: new QueryError("Value not put correctly") }, options2);
      }
      this.log.error("Failed error correcting entry");
    }
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options2 = {}) {
    this.log("put key %b value %b", key, value);
    const record = createPutRecord(key, value);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    this.log(`storing record for key ${dsKey.toString()}`);
    await this.components.datastore.put(dsKey, record.subarray());
    yield* pipe(this.peerRouting.getClosestPeers(key, {
      ...options2,
      signal: options2.signal
    }), (source) => src_default6(source, (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events = [];
        const msg = {
          type: MessageType.PUT_VALUE,
          key,
          record
        };
        this.log("send put to %p", event.peer.id);
        for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options2)) {
          events.push(putEvent);
          if (putEvent.name !== "PEER_RESPONSE") {
            continue;
          }
          if (!(putEvent.record != null && equals(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
            events.push(queryErrorEvent({ from: event.peer.id, error: new QueryError("Value not put correctly") }, options2));
          }
        }
        return events;
      };
    }), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events of source) {
        yield* events;
      }
    });
  }
  /**
   * Get the value to the given key
   */
  async *get(key, options2 = {}) {
    this.log("get %b", key);
    const vals = [];
    for await (const event of this.getMany(key, options2)) {
      if (event.name === "VALUE") {
        vals.push(event);
      }
      yield event;
    }
    if (vals.length === 0) {
      return;
    }
    const records = vals.map((v) => v.value);
    let i = 0;
    try {
      i = bestRecord(this.selectors, key, records);
    } catch (err) {
      if (err.name !== "InvalidParametersError") {
        throw err;
      }
    }
    const best = records[i];
    this.log("GetValue %b %b", key, best);
    if (best == null) {
      throw new NotFoundError("Best value was not found");
    }
    yield* this.sendCorrectionRecord(key, vals, best, options2);
    yield vals[i];
  }
  /**
   * Get the `n` values to the given key without sorting
   */
  async *getMany(key, options2 = {}) {
    this.log("getMany values for %b", key);
    try {
      const localRec = await this.getLocal(key);
      yield valueEvent({
        value: localRec.value,
        from: this.components.peerId
      }, options2);
    } catch (err) {
      this.log("error getting local value for %b", key, err);
    }
    const self2 = this;
    const getValueQuery = async function* ({ peer, signal }) {
      for await (const event of self2.peerRouting.getValueOrPeers(peer, key, {
        ...options2,
        signal
      })) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          yield valueEvent({ from: peer, value: event.record.value }, options2);
        }
      }
    };
    yield* this.queryManager.run(key, getValueQuery, options2);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/message/utils.js
function toPbPeerInfo(peer, connection) {
  const output = {
    id: peer.id.toMultihash().bytes,
    multiaddrs: (peer.multiaddrs ?? []).map((m) => m.bytes),
    connection
  };
  return output;
}
function fromPbPeerInfo(peer) {
  if (peer.id == null) {
    throw new Error("Invalid peer in message");
  }
  const multihash = decode(peer.id);
  return {
    id: peerIdFromMultihash(multihash),
    multiaddrs: (peer.multiaddrs ?? []).map((a) => multiaddr(a))
  };
}

// node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
var ContentRouting = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "network");
    __publicField(this, "peerRouting");
    __publicField(this, "queryManager");
    __publicField(this, "routingTable");
    __publicField(this, "providers");
    var _a13, _b9;
    const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
    this.network = network;
    this.peerRouting = peerRouting;
    this.queryManager = queryManager;
    this.routingTable = routingTable;
    this.providers = providers;
    this.findProviders = ((_a13 = components.metrics) == null ? void 0 : _a13.traceFunction("libp2p.kadDHT.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PROVIDER") {
          attrs.providers ?? (attrs.providers = []);
          attrs.providers.push(...event.providers.map((info) => info.id.toString()));
        }
        return attrs;
      }
    })) ?? this.findProviders;
    this.provide = ((_b9 = components.metrics) == null ? void 0 : _b9.traceFunction("libp2p.kadDHT.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE" && event.messageName === "ADD_PROVIDER") {
          attrs.providers ?? (attrs.providers = []);
          attrs.providers.push(event.from.toString());
        }
        return attrs;
      }
    })) ?? this.provide;
  }
  /**
   * Announce to the network that we can provide the value for a given key and
   * are contactable on the given multiaddrs
   */
  async *provide(key, multiaddrs, options2 = {}) {
    this.log("provide %s", key);
    const target = key.multihash.bytes;
    await this.providers.addProvider(key, this.components.peerId);
    const msg = {
      type: MessageType.ADD_PROVIDER,
      key: target,
      providers: [
        toPbPeerInfo({
          id: this.components.peerId,
          multiaddrs
        })
      ]
    };
    let sent = 0;
    const maybeNotifyPeer = (event) => {
      return async () => {
        if (event.name !== "FINAL_PEER") {
          return [event];
        }
        const events = [];
        this.log("putProvider %s to %p", key, event.peer.id);
        try {
          this.log("sending provider record for %s to %p", key, event.peer.id);
          for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options2)) {
            if (sendEvent.name === "PEER_RESPONSE") {
              this.log("sent provider record for %s to %p", key, event.peer.id);
              sent++;
            }
            events.push(sendEvent);
          }
        } catch (err) {
          this.log.error("error sending provide record to peer %p", event.peer.id, err);
          events.push(queryErrorEvent({ from: event.peer.id, error: err }, options2));
        }
        return events;
      };
    };
    yield* pipe(this.peerRouting.getClosestPeers(target, options2), (source) => src_default6(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {
      ordered: false,
      concurrency: ALPHA
    }), async function* (source) {
      for await (const events of source) {
        yield* events;
      }
    });
    this.log("sent provider records to %d peers", sent);
  }
  /**
   * Search the dht for up to `K` providers of the given CID.
   */
  async *findProviders(key, options2) {
    const toFind = this.routingTable.kBucketSize;
    let found = 0;
    const target = key.multihash.bytes;
    const self2 = this;
    this.log("findProviders %c", key);
    const provs = await this.providers.getProviders(key);
    if (provs.length > 0) {
      const providers2 = [];
      for (const peerId of provs.slice(0, toFind)) {
        try {
          const peer = await this.components.peerStore.get(peerId);
          providers2.push({
            id: peerId,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
          this.log("no peer store entry for %p", peerId);
        }
      }
      yield peerResponseEvent({ from: this.components.peerId, messageType: MessageType.GET_PROVIDERS, providers: providers2 }, options2);
      yield providerEvent({ from: this.components.peerId, providers: providers2 }, options2);
      found += providers2.length;
      if (found >= toFind) {
        return;
      }
    }
    const findProvidersQuery = async function* ({ peer, signal }) {
      const request = {
        type: MessageType.GET_PROVIDERS,
        key: target
      };
      yield* self2.network.sendRequest(peer, request, {
        ...options2,
        signal
      });
    };
    const providers = new PeerSet(provs);
    for await (const event of this.queryManager.run(target, findProvidersQuery, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE") {
        this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
        const newProviders = [];
        for (const peer of event.providers) {
          if (providers.has(peer.id)) {
            continue;
          }
          providers.add(peer.id);
          newProviders.push(peer);
        }
        if (newProviders.length > 0) {
          yield providerEvent({ from: event.from, providers: newProviders }, options2);
          found += newProviders.length;
          if (found >= toFind) {
            return;
          }
        }
      }
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/network.js
var Network2 = class extends TypedEventEmitter {
  /**
   * Create a new network
   */
  constructor(components, init) {
    var _a13, _b9, _c5, _d2;
    super();
    __publicField(this, "log");
    __publicField(this, "protocol");
    __publicField(this, "running");
    __publicField(this, "components");
    __publicField(this, "timeout");
    __publicField(this, "metrics");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:network`);
    this.running = false;
    this.protocol = init.protocol;
    this.timeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_network_message_send_times_milliseconds`
    });
    this.metrics = {
      operations: (_a13 = components.metrics) == null ? void 0 : _a13.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_requests_total`),
      errors: (_b9 = components.metrics) == null ? void 0 : _b9.registerCounterGroup(`${init.metricsPrefix}_outbound_rpc_errors_total`)
    };
    this.sendRequest = ((_c5 = components.metrics) == null ? void 0 : _c5.traceFunction("libp2p.kadDHT.sendRequest", this.sendRequest.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value, index) => {
              attrs[`providers-${index}`] = value.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value, index) => {
              attrs[`closer-${index}`] = value.id.toString();
            });
          }
        }
        return attrs;
      }
    })) ?? this.sendRequest;
    this.sendMessage = ((_d2 = components.metrics) == null ? void 0 : _d2.traceFunction("libp2p.kadDHT.sendMessage", this.sendMessage.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs([to, message2], attrs) {
        return {
          ...attrs,
          to: to.toString(),
          "message type": `${message2.type}`
        };
      },
      getAttributesFromYieldedValue: (event, attrs) => {
        if (event.name === "PEER_RESPONSE") {
          if (event.providers.length > 0) {
            event.providers.forEach((value, index) => {
              attrs[`providers-${index}`] = value.id.toString();
            });
          }
          if (event.closer.length > 0) {
            event.closer.forEach((value, index) => {
              attrs[`closer-${index}`] = value.id.toString();
            });
          }
        }
        return attrs;
      }
    })) ?? this.sendMessage;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
  }
  /**
   * Is the network online?
   */
  isStarted() {
    return this.running;
  }
  /**
   * Send a request and read a response
   */
  async *sendRequest(to, msg, options2 = {}) {
    var _a13, _b9, _c5;
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError("Message type was missing");
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options2);
    yield sendQueryEvent({ to, type }, options2);
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      (_a13 = this.metrics.operations) == null ? void 0 : _a13.increment({ [type]: true });
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      const response = await this._writeReadMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream == null ? void 0 : stream.abort(err);
      });
      yield peerResponseEvent({
        from: to,
        messageType: response.type,
        closer: response.closer.map(fromPbPeerInfo),
        providers: response.providers.map(fromPbPeerInfo),
        record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record)
      }, options2);
    } catch (err) {
      (_b9 = this.metrics.errors) == null ? void 0 : _b9.increment({ [type]: true });
      stream == null ? void 0 : stream.abort(err);
      if (((_c5 = options2.signal) == null ? void 0 : _c5.aborted) !== true) {
        this.log.error("could not send %s to %p - %e", msg.type, to, err);
      }
      yield queryErrorEvent({ from: to, error: err }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Sends a message without expecting an answer
   */
  async *sendMessage(to, msg, options2 = {}) {
    var _a13, _b9;
    if (!this.running) {
      return;
    }
    const type = msg.type;
    if (type == null) {
      throw new InvalidParametersError("Message type was missing");
    }
    this.log("sending %s to %p", msg.type, to);
    yield dialPeerEvent({ peer: to }, options2);
    yield sendQueryEvent({ to, type }, options2);
    let stream;
    const signal = this.timeout.getTimeoutSignal(options2);
    options2 = {
      ...options2,
      signal
    };
    try {
      (_a13 = this.metrics.operations) == null ? void 0 : _a13.increment({ [type]: true });
      const connection = await this.components.connectionManager.openConnection(to, options2);
      stream = await connection.newStream(this.protocol, options2);
      await this._writeMessage(stream, msg, options2);
      stream.close(options2).catch((err) => {
        this.log.error("error closing stream to %p", to, err);
        stream == null ? void 0 : stream.abort(err);
      });
      yield peerResponseEvent({ from: to, messageType: type }, options2);
    } catch (err) {
      (_b9 = this.metrics.errors) == null ? void 0 : _b9.increment({ [type]: true });
      stream == null ? void 0 : stream.abort(err);
      yield queryErrorEvent({ from: to, error: err }, options2);
    } finally {
      this.timeout.cleanUp(signal);
    }
  }
  /**
   * Write a message to the given stream
   */
  async _writeMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
  }
  /**
   * Write a message and read its response.
   * If no response is received after the specified timeout
   * this will error out.
   */
  async _writeReadMessage(stream, msg, options2) {
    const pb = pbStream(stream);
    await pb.write(msg, Message2, options2);
    const message2 = await pb.read(Message2, options2);
    message2.closer.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    message2.providers.forEach((peerData) => {
      this.safeDispatchEvent("peer", {
        detail: fromPbPeerInfo(peerData)
      });
    });
    return message2;
  }
};

// node_modules/uint8arrays/dist/src/xor-compare.js
function xorCompare(a, b) {
  if (a.byteLength !== b.byteLength) {
    throw new Error("Inputs should have the same length");
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] === b[i]) {
      continue;
    }
    return a[i] < b[i] ? -1 : 1;
  }
  return 0;
}

// node_modules/@libp2p/kad-dht/dist/src/peer-distance-list.js
var PeerDistanceList = class {
  constructor(originDhtKey, capacity) {
    /**
     * The DHT key from which distance is calculated
     */
    __publicField(this, "originDhtKey");
    /**
     * The maximum size of the list
     */
    __publicField(this, "capacity");
    __publicField(this, "peerDistances");
    this.originDhtKey = originDhtKey;
    this.capacity = capacity;
    this.peerDistances = [];
  }
  /**
   * The length of the list
   */
  get length() {
    return this.peerDistances.length;
  }
  /**
   * The peers in the list, in order of distance from the origin key
   */
  get peers() {
    return this.peerDistances.map((pd) => pd.peer);
  }
  /**
   * Add a peerId to the list.
   */
  async add(peer) {
    const dhtKey = await convertPeerId(peer.id);
    this.addWitKadId(peer, dhtKey);
  }
  /**
   * Add a peerId to the list.
   */
  addWitKadId(peer, kadId) {
    if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
      return;
    }
    const el = {
      peer,
      distance: xor(this.originDhtKey, kadId)
    };
    this.peerDistances.push(el);
    this.peerDistances.sort((a, b) => xorCompare(a.distance, b.distance));
    this.peerDistances = this.peerDistances.slice(0, this.capacity);
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async isCloser(peerId) {
    if (this.length === 0) {
      return true;
    }
    const dhtKey = await convertPeerId(peerId);
    const dhtKeyXor = xor(dhtKey, this.originDhtKey);
    const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
    return xorCompare(dhtKeyXor, furthestDistance) === -1;
  }
  /**
   * Indicates whether any of the peerIds passed as a parameter are closer
   * to the origin key than the furthest peerId in the PeerDistanceList.
   */
  async anyCloser(peerIds) {
    if (peerIds.length === 0) {
      return false;
    }
    return Promise.any(peerIds.map(async (peerId) => this.isCloser(peerId)));
  }
};

// node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
var PeerRouting = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "routingTable");
    __publicField(this, "network");
    __publicField(this, "validators");
    __publicField(this, "queryManager");
    __publicField(this, "peerStore");
    __publicField(this, "peerId");
    var _a13, _b9;
    this.routingTable = init.routingTable;
    this.network = init.network;
    this.validators = init.validators;
    this.queryManager = init.queryManager;
    this.peerStore = components.peerStore;
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${init.logPrefix}:peer-routing`);
    this.findPeer = ((_a13 = components.metrics) == null ? void 0 : _a13.traceFunction("libp2p.kadDHT.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1
    })) ?? this.findPeer;
    this.getClosestPeers = ((_b9 = components.metrics) == null ? void 0 : _b9.traceFunction("libp2p.kadDHT.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1
    })) ?? this.getClosestPeers;
  }
  /**
   * Look if we are connected to a peer with the given id.
   * Returns its id and addresses, if found, otherwise `undefined`.
   */
  async findPeerLocal(peer) {
    let peerData;
    const p = await this.routingTable.find(peer);
    if (p != null) {
      this.log("findPeerLocal found %p in routing table", peer);
      try {
        peerData = await this.peerStore.get(p);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData == null) {
      try {
        peerData = await this.peerStore.get(peer);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (peerData != null) {
      this.log("findPeerLocal found %p in peer store", peer);
      return {
        id: peerData.id,
        multiaddrs: peerData.addresses.map((address) => address.multiaddr)
      };
    }
    return void 0;
  }
  /**
   * Get a value via rpc call for the given parameters
   */
  async *_getValueSingle(peer, key, options2 = {}) {
    const msg = {
      type: MessageType.GET_VALUE,
      key
    };
    yield* this.network.sendRequest(peer, msg, options2);
  }
  /**
   * Get the public key directly from a node
   */
  async *getPublicKeyFromNode(peer, options2 = {}) {
    const pkKey = keyForPublicKey(peer);
    for await (const event of this._getValueSingle(peer, pkKey, options2)) {
      yield event;
      if (event.name === "PEER_RESPONSE" && event.record != null) {
        const publicKey = publicKeyFromProtobuf(event.record.value);
        const recPeer = peerIdFromPublicKey(publicKey);
        if (!recPeer.equals(peer)) {
          throw new InvalidPublicKeyError("public key does not match id");
        }
        if (recPeer.publicKey == null) {
          throw new InvalidPublicKeyError("public key missing");
        }
        yield valueEvent({
          from: peer,
          value: event.record.value
        }, options2);
      }
    }
    throw new QueryError(`Node not responding with its public key: ${peer.toString()}`);
  }
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    this.log("findPeer %p", id);
    if (options2.useCache !== false) {
      const pi = await this.findPeerLocal(id);
      if (pi != null) {
        this.log("found local");
        yield finalPeerEvent({
          from: this.peerId,
          peer: pi
        }, options2);
        return;
      }
    }
    let foundPeer = false;
    if (options2.useNetwork !== false) {
      const self2 = this;
      const findPeerQuery = async function* ({ peer, signal }) {
        const request = {
          type: MessageType.FIND_NODE,
          key: id.toMultihash().bytes
        };
        for await (const event of self2.network.sendRequest(peer, request, {
          ...options2,
          signal
        })) {
          yield event;
          if (event.name === "PEER_RESPONSE") {
            const match = event.closer.find((p) => p.id.equals(id));
            if (match != null) {
              yield finalPeerEvent({ from: event.from, peer: match }, options2);
            }
          }
        }
      };
      for await (const event of this.queryManager.run(id.toMultihash().bytes, findPeerQuery, options2)) {
        if (event.name === "FINAL_PEER") {
          foundPeer = true;
        }
        yield event;
      }
    }
    if (!foundPeer) {
      yield queryErrorEvent({ from: this.peerId, error: new NotFoundError("Not found") }, options2);
    }
  }
  /**
   * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from
   * a multihash or a peer ID
   */
  async *getClosestPeers(key, options2 = {}) {
    this.log("getClosestPeers to %b", key);
    const kadId = await convertBuffer(key);
    const tablePeers = this.routingTable.closestPeers(kadId);
    const self2 = this;
    const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
    await Promise.all(tablePeers.map(async (peer) => {
      await peers.add({ id: peer, multiaddrs: [] });
    }));
    const getCloserPeersQuery = async function* ({ peer, signal }) {
      self2.log("closerPeersSingle %s from %p", toString(key, "base32"), peer);
      const request = {
        type: MessageType.FIND_NODE,
        key
      };
      yield* self2.network.sendRequest(peer, request, {
        ...options2,
        signal
      });
    };
    for await (const event of this.queryManager.run(key, getCloserPeersQuery, options2)) {
      if (event.name === "PEER_RESPONSE") {
        await Promise.all(event.closer.map(async (peerData) => {
          await peers.add(peerData);
        }));
      }
      yield event;
    }
    this.log("found %d peers close to %b", peers.length, key);
    for (const peer of peers.peers) {
      yield finalPeerEvent({
        from: this.peerId,
        peer
      }, options2);
    }
  }
  /**
   * Query a particular peer for the value for the given key.
   * It will either return the value or a list of closer peers.
   *
   * Note: The peerStore is updated with new addresses found for the given peer.
   */
  async *getValueOrPeers(peer, key, options2 = {}) {
    for await (const event of this._getValueSingle(peer, key, options2)) {
      if (event.name === "PEER_RESPONSE") {
        if (event.record != null) {
          try {
            await this._verifyRecordOnline(event.record);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this.log(errMsg);
            yield queryErrorEvent({ from: event.from, error: new QueryError(errMsg) }, options2);
            continue;
          }
        }
      }
      yield event;
    }
  }
  /**
   * Verify a record, fetching missing public keys from the network.
   * Throws an error if the record is invalid.
   */
  async _verifyRecordOnline(record) {
    if (record.timeReceived == null) {
      throw new InvalidRecordError("invalid record received");
    }
    await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
  }
  /**
   * Get the nearest peers to the given query, but if closer than self
   */
  async getCloserPeersOffline(key, closerThan) {
    const output = [];
    try {
      const multihash = decode(key);
      const targetPeerId = peerIdFromMultihash(multihash);
      const peer = await this.peerStore.get(targetPeerId);
      output.push({
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      });
    } catch {
    }
    const keyKadId = await convertBuffer(key);
    const ids = this.routingTable.closestPeers(keyKadId);
    const closerThanKadId = await convertPeerId(closerThan);
    const requesterXor = xor(closerThanKadId, keyKadId);
    for (const peerId of ids) {
      const peerKadId = await convertPeerId(peerId);
      const peerXor = xor(peerKadId, keyKadId);
      if (xorCompare(peerXor, requesterXor) !== -1) {
        continue;
      }
      try {
        const peer = await this.peerStore.get(peerId);
        output.push({
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        });
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
    }
    if (output.length > 0) {
      this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
    } else {
      this.log("getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table", key, closerThan, this.routingTable.size);
    }
    return output;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/providers.js
var Providers = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "datastore");
    __publicField(this, "datastorePrefix");
    __publicField(this, "lock");
    this.log = components.logger.forComponent(`${init.logPrefix}:providers`);
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.datastore = components.datastore;
    this.lock = init.lock;
  }
  /**
   * Add a new provider for the given CID
   */
  async addProvider(cid, provider) {
    const release = await this.lock.readLock();
    try {
      this.log("%p provides %s", provider, cid);
      await this.writeProviderEntry(cid, provider);
    } finally {
      release();
    }
  }
  /**
   * Remove a provider for the given CID
   */
  async removeProvider(cid, provider) {
    const release = await this.lock.writeLock();
    try {
      const key = toProviderKey(this.datastorePrefix, cid, provider);
      this.log("%p no longer provides %s", provider, cid);
      await this.datastore.delete(key);
    } finally {
      release();
    }
  }
  /**
   * Get a list of providers for the given CID
   */
  async getProviders(cid) {
    const release = await this.lock.readLock();
    try {
      this.log("get providers for %c", cid);
      const provs = await this.loadProviders(cid);
      this.log("got %d providers for %c", provs.size, cid);
      return [...provs.keys()];
    } finally {
      release();
    }
  }
  /**
   * Write a provider into the given store
   */
  async writeProviderEntry(cid, peerId, time = /* @__PURE__ */ new Date()) {
    const key = toProviderKey(this.datastorePrefix, cid, peerId);
    const buffer = encode(time.getTime());
    await this.datastore.put(key, buffer);
  }
  /**
   * Load providers for the given CID from the store
   */
  async loadProviders(cid) {
    const providers = new PeerMap();
    const key = toProviderKey(this.datastorePrefix, cid);
    for await (const entry of this.datastore.query({ prefix: key.toString() })) {
      const { peerId } = parseProviderKey(entry.key);
      providers.set(peerId, readProviderTime(entry.value));
    }
    return providers;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
async function* queryPath(options2) {
  const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, queryFuncTimeout, log: log7, peersSeen, connectionManager } = options2;
  const queue = new Queue({
    concurrency: alpha,
    sort: (a, b) => xorCompare(a.options.distance, b.options.distance)
  });
  const kadId = await convertBuffer(key);
  function queryPeer(peer, peerKadId) {
    if (peer == null) {
      return;
    }
    peersSeen.add(peer);
    const peerXor = xor(peerKadId, kadId);
    queue.add(async () => {
      const signals = [signal];
      if (queryFuncTimeout != null) {
        signals.push(AbortSignal.timeout(queryFuncTimeout));
      }
      const compoundSignal = anySignal(signals);
      setMaxListeners(Infinity, compoundSignal);
      try {
        for await (const event of query({
          ...options2,
          key,
          peer,
          signal: compoundSignal,
          pathIndex,
          numPaths
        })) {
          if (compoundSignal.aborted) {
            return;
          }
          if (event.name === "PEER_RESPONSE") {
            for (const closerPeer of event.closer) {
              if (peersSeen.has(closerPeer.id)) {
                log7.trace("already seen %p in query", closerPeer.id);
                continue;
              }
              if (ourPeerId.equals(closerPeer.id)) {
                log7("not querying ourselves");
                continue;
              }
              if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                log7("not querying undialable peer");
                continue;
              }
              const closerPeerKadId = await convertPeerId(closerPeer.id);
              const closerPeerXor = xor(closerPeerKadId, kadId);
              if (xorCompare(closerPeerXor, peerXor) !== -1) {
                log7.trace("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                continue;
              }
              log7.trace("querying closer peer %p", closerPeer.id);
              queryPeer(closerPeer.id, closerPeerKadId);
            }
          }
          queue.safeDispatchEvent("completed", {
            detail: event
          });
        }
      } catch (err) {
        if (!signal.aborted) {
          return queryErrorEvent({
            from: peer,
            error: err
          }, options2);
        }
      } finally {
        compoundSignal.clear();
      }
    }, {
      distance: peerXor
    }).catch((err) => {
      log7.error(err);
    });
  }
  queryPeer(startingPeer, await convertPeerId(startingPeer));
  try {
    for await (const event of queue.toGenerator({ signal })) {
      if (event != null) {
        yield event;
      }
    }
  } catch (err) {
    if (signal.aborted) {
      throw new QueryAbortedError("Query aborted");
    }
    throw err;
  }
}

// node_modules/@libp2p/kad-dht/dist/src/query/manager.js
var QueryManager = class {
  constructor(components, init) {
    __publicField(this, "disjointPaths");
    __publicField(this, "alpha");
    __publicField(this, "shutDownController");
    __publicField(this, "running");
    __publicField(this, "logger");
    __publicField(this, "peerId");
    __publicField(this, "connectionManager");
    __publicField(this, "routingTable");
    __publicField(this, "initialQuerySelfHasRun");
    __publicField(this, "logPrefix");
    this.logPrefix = init.logPrefix;
    this.disjointPaths = init.disjointPaths ?? K;
    this.alpha = init.alpha ?? ALPHA;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.routingTable = init.routingTable;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    this.running = false;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Starts the query manager
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Stops all queries
   */
  async stop() {
    this.running = false;
    this.shutDownController.abort();
  }
  async *run(key, queryFunc, options2 = {}) {
    if (!this.running) {
      throw new Error("QueryManager not started");
    }
    if (options2.signal == null) {
      const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
      setMaxListeners(Infinity, signal2);
      options2 = {
        ...options2,
        signal: signal2
      };
    }
    const queryEarlyExitController = new AbortController();
    const signal = anySignal([
      this.shutDownController.signal,
      queryEarlyExitController.signal,
      options2.signal
    ]);
    setMaxListeners(Infinity, signal, queryEarlyExitController.signal);
    const log7 = this.logger.forComponent(`${this.logPrefix}:query:` + toString(key, "base58btc"));
    let queryFinished = false;
    try {
      if (options2.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
        log7("waiting for initial query-self query before continuing");
        await raceSignal(this.initialQuerySelfHasRun.promise, signal);
        this.initialQuerySelfHasRun = void 0;
      }
      log7("query:start");
      const id = await convertBuffer(key);
      const peers = this.routingTable.closestPeers(id);
      const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
      if (peers.length === 0) {
        log7.error("Running query with no peers");
        return;
      }
      const peersSeen = new PeerSet();
      const paths = peersToQuery.map((peer, index) => {
        return queryPath({
          ...options2,
          key,
          startingPeer: peer,
          ourPeerId: this.peerId,
          signal,
          query: queryFunc,
          pathIndex: index,
          numPaths: peersToQuery.length,
          alpha: this.alpha,
          queryFuncTimeout: options2.queryFuncTimeout,
          log: log7,
          peersSeen,
          onProgress: options2.onProgress,
          connectionManager: this.connectionManager
        });
      });
      for await (const event of src_default(...paths)) {
        if (event.name === "QUERY_ERROR") {
          log7.error("query error", event.error);
        }
        if (event.name === "PEER_RESPONSE") {
          for (const peer of [...event.closer, ...event.providers]) {
            if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
              continue;
            }
            await this.routingTable.add(peer.id);
          }
        }
        yield event;
      }
      queryFinished = true;
    } catch (err) {
      if (!this.running && err.name === "QueryAbortedError") {
      } else {
        throw err;
      }
    } finally {
      if (!queryFinished) {
        log7("query exited early");
        queryEarlyExitController.abort();
      }
      signal.clear();
      log7("query:done");
    }
  }
};

// node_modules/it-length/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function length(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      let count = 0;
      for await (const _ of source) {
        count++;
      }
      return count;
    })();
  } else {
    let count = 0;
    for (const _ of source) {
      count++;
    }
    return count;
  }
}
var src_default10 = length;

// node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.addEventListener || emitter.on || emitter.addListener;
  const removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options2) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    var _a13;
    options2 = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options2
    };
    if (!(options2.count >= 0 && (options2.count === Number.POSITIVE_INFINITY || Number.isInteger(options2.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    (_a13 = options2.signal) == null ? void 0 : _a13.throwIfAborted();
    const events = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value = options2.multiArgs ? arguments_ : arguments_[0];
      if (options2.filter && !options2.filter(value)) {
        return;
      }
      items.push(value);
      if (options2.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options2.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options2.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options2.signal) {
      options2.signal.addEventListener("abort", () => {
        rejectHandler(options2.signal.reason);
      }, { once: true });
    }
    if (options2.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options2.timeout === "number") {
    const timeout = pTimeout(returnValue, { milliseconds: options2.timeout });
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options2) {
  if (typeof options2 === "function") {
    options2 = { filter: options2 };
  }
  options2 = {
    ...options2,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options2);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// node_modules/@libp2p/kad-dht/dist/src/query-self.js
var QuerySelf = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerRouting");
    __publicField(this, "routingTable");
    __publicField(this, "count");
    __publicField(this, "interval");
    __publicField(this, "initialInterval");
    __publicField(this, "queryTimeout");
    __publicField(this, "running");
    __publicField(this, "timeoutId");
    __publicField(this, "controller");
    __publicField(this, "initialQuerySelfHasRun");
    __publicField(this, "querySelfPromise");
    this.peerId = components.peerId;
    this.log = components.logger.forComponent(`${init.logPrefix}:query-self`);
    this.running = false;
    this.peerRouting = init.peerRouting;
    this.routingTable = init.routingTable;
    this.count = init.count ?? K;
    this.interval = init.interval ?? QUERY_SELF_INTERVAL;
    this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
    this.queryTimeout = init.queryTimeout ?? QUERY_SELF_TIMEOUT;
    this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    this.querySelf = timeOperationMethod(this.querySelf.bind(this), init.operationMetrics, "SELF_QUERY");
  }
  isStarted() {
    return this.running;
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    clearTimeout(this.timeoutId);
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.initialInterval);
  }
  stop() {
    this.running = false;
    if (this.timeoutId != null) {
      clearTimeout(this.timeoutId);
    }
    if (this.controller != null) {
      this.controller.abort();
    }
  }
  async querySelf() {
    if (!this.running) {
      this.log("skip self-query because we are not started");
      return;
    }
    if (this.querySelfPromise != null) {
      this.log("joining existing self query");
      return this.querySelfPromise.promise;
    }
    this.querySelfPromise = pDefer();
    if (this.running) {
      this.controller = new AbortController();
      const signals = [this.controller.signal];
      if (this.initialQuerySelfHasRun == null) {
        const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
        setMaxListeners(Infinity, timeoutSignal);
        signals.push(timeoutSignal);
      }
      const signal = anySignal(signals);
      setMaxListeners(Infinity, signal, this.controller.signal);
      try {
        if (this.routingTable.size === 0) {
          this.log("routing table was empty, waiting for some peers before running query");
          await pEvent(this.routingTable, "peer:add", {
            signal,
            filter: (event) => !this.peerId.equals(event.detail)
          });
          this.log("routing table has peers, continuing with query");
        }
        this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
        const start2 = Date.now();
        const found = await pipe(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
          signal,
          isSelfQuery: true
        }), (source) => src_default8(source, this.count), async (source) => src_default10(source));
        this.log("self-query found %d peers in %dms", found, Date.now() - start2);
      } catch (err) {
        this.log.error("self-query error", err);
      } finally {
        signal.clear();
        if (this.initialQuerySelfHasRun != null) {
          this.initialQuerySelfHasRun.resolve();
          this.initialQuerySelfHasRun = void 0;
        }
      }
    }
    this.querySelfPromise.resolve();
    this.querySelfPromise = void 0;
    if (!this.running) {
      return;
    }
    this.timeoutId = setTimeout(() => {
      this.querySelf().catch((err) => {
        this.log.error("error running self-query", err);
      });
    }, this.interval);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/reprovider.js
var Reprovider = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "reprovideQueue");
    __publicField(this, "maxQueueSize");
    __publicField(this, "datastore");
    __publicField(this, "timeout");
    __publicField(this, "reprovideTimeout");
    __publicField(this, "running");
    __publicField(this, "shutdownController");
    __publicField(this, "reprovideThreshold");
    __publicField(this, "contentRouting");
    __publicField(this, "datastorePrefix");
    __publicField(this, "addressManager");
    __publicField(this, "validity");
    __publicField(this, "interval");
    __publicField(this, "lock");
    __publicField(this, "peerId");
    this.log = components.logger.forComponent(`${init.logPrefix}:reprovider`);
    this.peerId = components.peerId;
    this.reprovideQueue = new Queue({
      concurrency: init.concurrency ?? REPROVIDE_CONCURRENCY,
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_queue`
    });
    this.reprovideTimeout = new AdaptiveTimeout({
      ...init.timeout ?? {},
      metrics: components.metrics,
      metricName: `${init.metricsPrefix}_reprovide_timeout_milliseconds`
    });
    this.datastore = components.datastore;
    this.addressManager = components.addressManager;
    this.datastorePrefix = `${init.datastorePrefix}/provider`;
    this.reprovideThreshold = init.threshold ?? REPROVIDE_THRESHOLD;
    this.maxQueueSize = init.maxQueueSize ?? REPROVIDE_MAX_QUEUE_SIZE;
    this.validity = init.validity ?? PROVIDERS_VALIDITY;
    this.interval = init.interval ?? REPROVIDE_INTERVAL;
    this.contentRouting = init.contentRouting;
    this.lock = init.lock;
    this.running = false;
    this.reprovide = timeOperationMethod(this.reprovide.bind(this), init.operationMetrics, "PROVIDE");
  }
  start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    this.timeout = setTimeout(() => {
      this.cleanUp().catch((err) => {
        this.log.error("error running reprovide/cleanup - %e", err);
      });
    }, this.interval);
  }
  stop() {
    var _a13;
    this.running = false;
    this.reprovideQueue.clear();
    clearTimeout(this.timeout);
    (_a13 = this.shutdownController) == null ? void 0 : _a13.abort();
  }
  /**
   * Check all provider records. Delete them if they have expired, reprovide
   * them if the provider is us and the expiry is within the reprovide window.
   */
  async cleanUp() {
    const release = await this.lock.writeLock();
    try {
      this.safeDispatchEvent("reprovide:start");
      for await (const entry of this.datastore.query({
        prefix: this.datastorePrefix
      })) {
        try {
          const { cid, peerId } = parseProviderKey(entry.key);
          const created = readProviderTime(entry.value).getTime();
          const expires = created + this.validity;
          const now = Date.now();
          const expired = now > expires;
          this.log.trace("comparing: %d < %d = %s %s", created, now - this.validity, expired, expired ? "(expired)" : "");
          if (expired) {
            await this.datastore.delete(entry.key);
          }
          if (this.peerId.equals(peerId) && now - expires < this.reprovideThreshold) {
            this.queueReprovide(cid).catch((err) => {
              this.log.error("could not reprovide %c - %e", cid, err);
            });
          }
        } catch (err) {
          this.log.error("error processing datastore key %s - %e", entry.key, err.message);
        }
      }
      this.log("reprovide/cleanup successful");
    } finally {
      release();
      this.safeDispatchEvent("reprovide:end");
      if (this.running) {
        this.timeout = setTimeout(() => {
          this.cleanUp().catch((err) => {
            this.log.error("error running re-provide - %e", err);
          });
        }, this.interval);
      }
    }
  }
  async queueReprovide(cid) {
    var _a13;
    if (!this.running) {
      return;
    }
    this.log.trace("waiting for queue capacity before adding %c to re-provide queue", cid);
    await this.reprovideQueue.onSizeLessThan(this.maxQueueSize);
    const existingJob = this.reprovideQueue.queue.find((job) => job.options.cid.equals(cid));
    if (existingJob != null) {
      this.log.trace("not adding %c to re-provide queue - already in queue", cid);
      return existingJob.join();
    }
    this.log.trace("adding %c to re-provide queue", cid);
    this.reprovideQueue.add(async (options2) => {
      var _a14;
      (_a14 = options2.signal) == null ? void 0 : _a14.throwIfAborted();
      if (!this.running) {
        return;
      }
      this.log.trace("re-providing %c", cid);
      const signal = this.reprovideTimeout.getTimeoutSignal(options2);
      try {
        await this.reprovide(options2.cid, options2);
      } finally {
        this.reprovideTimeout.cleanUp(signal);
      }
      this.log.trace("re-provided %c", cid);
    }, {
      signal: (_a13 = this.shutdownController) == null ? void 0 : _a13.signal,
      cid
    }).catch((err) => {
      this.log.error("could not re-provide key %c - %e", cid, err);
    });
  }
  async reprovide(cid, options2) {
    await src_default7(this.contentRouting.provide(cid, this.addressManager.getAddresses(), options2));
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/closest-peers.js
var PEER_SET_SIZE = 20;
var REFRESH_INTERVAL = 5e3;
var KAD_CLOSE_TAG_NAME = "kad-close";
var KAD_CLOSE_TAG_VALUE = 50;
var ClosestPeers = class {
  constructor(components, init) {
    __publicField(this, "routingTable");
    __publicField(this, "components");
    __publicField(this, "closestPeers");
    __publicField(this, "newPeers");
    __publicField(this, "refreshInterval");
    __publicField(this, "peerSetSize");
    __publicField(this, "timeout");
    __publicField(this, "closeTagName");
    __publicField(this, "closeTagValue");
    __publicField(this, "log");
    __publicField(this, "running");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.routingTable = init.routingTable;
    this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
    this.peerSetSize = init.peerSetSize ?? PEER_SET_SIZE;
    this.closeTagName = init.closeTagName ?? KAD_CLOSE_TAG_NAME;
    this.closeTagValue = init.closeTagValue ?? KAD_CLOSE_TAG_VALUE;
    this.closestPeers = new PeerSet();
    this.onPeerPing = this.onPeerPing.bind(this);
    this.running = false;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    const targetKadId = await convertPeerId(this.components.peerId);
    this.newPeers = new PeerDistanceList(targetKadId, this.peerSetSize);
    this.routingTable.addEventListener("peer:ping", this.onPeerPing);
    this.timeout = setInterval(() => {
      this.updatePeerTags().catch((err) => {
        this.log.error("error updating peer tags - %e", err);
      });
    }, this.refreshInterval);
  }
  stop() {
    this.running = false;
    this.routingTable.removeEventListener("peer:ping", this.onPeerPing);
    clearTimeout(this.timeout);
  }
  onPeerPing(event) {
    var _a13;
    (_a13 = this.newPeers) == null ? void 0 : _a13.add({ id: event.detail, multiaddrs: [] }).catch((err) => {
      this.log.error("error adding peer to distance list - %e", err);
    });
  }
  async updatePeerTags() {
    var _a13;
    const newClosest = new PeerSet((_a13 = this.newPeers) == null ? void 0 : _a13.peers.map((peer) => peer.id));
    const added = newClosest.difference(this.closestPeers);
    const removed = this.closestPeers.difference(newClosest);
    this.closestPeers = newClosest;
    await Promise.all([
      ...[...added].map(async (peerId) => {
        await this.components.peerStore.merge(peerId, {
          tags: {
            [this.closeTagName]: {
              value: this.closeTagValue
            },
            [KEEP_ALIVE_TAG2]: {
              value: 1
            }
          }
        });
      }),
      ...[...removed].map(async (peerId) => {
        await this.components.peerStore.merge(peerId, {
          tags: {
            [this.closeTagName]: void 0,
            [KEEP_ALIVE_TAG2]: void 0
          }
        });
      })
    ]);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
function isLeafBucket(obj) {
  return Array.isArray(obj == null ? void 0 : obj.peers);
}
var KBucket = class {
  constructor(options2) {
    __publicField(this, "root");
    __publicField(this, "localPeer");
    __publicField(this, "prefixLength");
    __publicField(this, "splitThreshold");
    __publicField(this, "kBucketSize");
    __publicField(this, "numberOfNodesToPing");
    __publicField(this, "lastPingThreshold");
    __publicField(this, "ping");
    __publicField(this, "verify");
    __publicField(this, "onAdd");
    __publicField(this, "onRemove");
    __publicField(this, "onMove");
    __publicField(this, "addingPeerMap");
    this.prefixLength = options2.prefixLength ?? PREFIX_LENGTH;
    this.kBucketSize = options2.kBucketSize ?? KBUCKET_SIZE;
    this.splitThreshold = options2.splitThreshold ?? this.kBucketSize;
    this.numberOfNodesToPing = options2.numberOfOldContactsToPing ?? PING_OLD_CONTACT_COUNT;
    this.lastPingThreshold = options2.lastPingThreshold ?? LAST_PING_THRESHOLD;
    this.ping = options2.ping;
    this.verify = options2.verify;
    this.onAdd = options2.onAdd;
    this.onRemove = options2.onRemove;
    this.addingPeerMap = new PeerMap();
    this.root = {
      prefix: "",
      depth: 0,
      peers: []
    };
  }
  async addSelfPeer(peerId) {
    this.localPeer = {
      peerId,
      kadId: await convertPeerId(peerId),
      lastPing: Date.now()
    };
  }
  /**
   * Adds a contact to the trie
   */
  async add(peerId, options2) {
    const peer = {
      peerId,
      kadId: await convertPeerId(peerId),
      lastPing: 0
    };
    const existingPromise = this.addingPeerMap.get(peerId);
    if (existingPromise != null) {
      return existingPromise;
    }
    try {
      const p = this._add(peer, options2);
      this.addingPeerMap.set(peerId, p);
      await p;
    } finally {
      this.addingPeerMap.delete(peerId);
    }
  }
  async _add(peer, options2) {
    var _a13;
    const bucket = this._determineBucket(peer.kadId);
    if (this._indexOf(bucket, peer.kadId) > -1) {
      return;
    }
    if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
      await this._split(bucket);
      await this._add(peer, options2);
      return;
    }
    if (bucket.peers.length < this.kBucketSize) {
      if (!needsPing(peer, this.lastPingThreshold)) {
        bucket.peers.push(peer);
        await ((_a13 = this.onAdd) == null ? void 0 : _a13.call(this, peer, bucket));
        return;
      }
      const result = await this.verify(peer, options2);
      if (result) {
        peer.lastPing = Date.now();
        await this._add(peer, options2);
      }
      return;
    }
    const toPing = bucket.peers.filter((peer2) => {
      var _a14;
      if (peer2.peerId.equals((_a14 = this.localPeer) == null ? void 0 : _a14.peerId)) {
        return false;
      }
      if (peer2.lastPing > Date.now() - this.lastPingThreshold) {
        return false;
      }
      return true;
    }).sort((a, b) => {
      if (a.lastPing < b.lastPing) {
        return -1;
      }
      if (a.lastPing > b.lastPing) {
        return 1;
      }
      return 0;
    }).slice(0, this.numberOfNodesToPing);
    let evicted = false;
    for await (const toEvict of this.ping(toPing, options2)) {
      evicted = true;
      await this.remove(toEvict.kadId);
    }
    if (!evicted) {
      return;
    }
    await this._add(peer, options2);
  }
  /**
   * Get 0-n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param {Uint8Array} id - Contact node id
   * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
   */
  *closest(id, n = this.kBucketSize) {
    const list = new PeerDistanceList(id, n);
    for (const peer of this.toIterable()) {
      list.addWitKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
    }
    yield* src_default6(list.peers, (info) => info.id);
  }
  /**
   * Counts the total number of contacts in the tree.
   *
   * @returns {number} The number of contacts held in the tree
   */
  count() {
    function countBucket(bucket) {
      if (isLeafBucket(bucket)) {
        return bucket.peers.length;
      }
      let count = 0;
      if (bucket.left != null) {
        count += countBucket(bucket.left);
      }
      if (bucket.right != null) {
        count += countBucket(bucket.right);
      }
      return count;
    }
    return countBucket(this.root);
  }
  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param {Uint8Array} kadId - The ID of the contact to fetch.
   * @returns {Peer | undefined} The contact if available, otherwise null
   */
  get(kadId) {
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    return bucket.peers[index];
  }
  /**
   * Removes contact with the provided id.
   *
   * @param {Uint8Array} kadId - The ID of the contact to remove
   */
  async remove(kadId) {
    var _a13;
    const bucket = this._determineBucket(kadId);
    const index = this._indexOf(bucket, kadId);
    if (index > -1) {
      const peer = bucket.peers.splice(index, 1)[0];
      await ((_a13 = this.onRemove) == null ? void 0 : _a13.call(this, peer, bucket));
    }
  }
  /**
   * Similar to `toArray()` but instead of buffering everything up into an
   * array before returning it, yields contacts as they are encountered while
   * walking the tree.
   *
   * @returns {Iterable} All of the contacts in the tree, as an iterable
   */
  *toIterable() {
    function* iterate(bucket) {
      if (isLeafBucket(bucket)) {
        yield* bucket.peers;
        return;
      }
      yield* iterate(bucket.left);
      yield* iterate(bucket.right);
    }
    yield* iterate(this.root);
  }
  /**
   * Default distance function. Finds the XOR distance between firstId and
   * secondId.
   *
   * @param  {Uint8Array} firstId - Uint8Array containing first id.
   * @param  {Uint8Array} secondId - Uint8Array containing second id.
   * @returns {number} Integer The XOR distance between firstId and secondId.
   */
  distance(firstId, secondId) {
    return BigInt("0x" + toString(xor(firstId, secondId), "base16"));
  }
  /**
   * Determines whether the id at the bitIndex is 0 or 1
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param {Uint8Array} kadId - Id to compare localNodeId with
   * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  _determineBucket(kadId) {
    const bitString = toString(kadId, "base2");
    function findBucket(bucket, bitIndex = 0) {
      if (isLeafBucket(bucket)) {
        return bucket;
      }
      const bit = bitString[bitIndex];
      if (bit === "0") {
        return findBucket(bucket.left, bitIndex + 1);
      }
      return findBucket(bucket.right, bitIndex + 1);
    }
    return findBucket(this.root);
  }
  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param {object} bucket - internal object that has 2 leafs: left and right
   * @param {Uint8Array} kadId - KadId of peer
   * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
   */
  _indexOf(bucket, kadId) {
    return bucket.peers.findIndex((peer) => equals(peer.kadId, kadId));
  }
  /**
   * Modify the bucket, turn it from a leaf bucket to an internal bucket
   *
   * @param {any} bucket - bucket for splitting
   */
  async _split(bucket) {
    var _a13, _b9;
    const left = {
      prefix: "0",
      depth: bucket.depth + 1,
      peers: []
    };
    const right = {
      prefix: "1",
      depth: bucket.depth + 1,
      peers: []
    };
    for (const peer of bucket.peers) {
      const bitString = toString(peer.kadId, "base2");
      if (bitString[bucket.depth] === "0") {
        left.peers.push(peer);
        await ((_a13 = this.onMove) == null ? void 0 : _a13.call(this, peer, bucket, left));
      } else {
        right.peers.push(peer);
        await ((_b9 = this.onMove) == null ? void 0 : _b9.call(this, peer, bucket, right));
      }
    }
    convertToInternalBucket(bucket, left, right);
  }
};
function convertToInternalBucket(bucket, left, right) {
  delete bucket.peers;
  bucket.left = left;
  bucket.right = right;
  if (bucket.prefix === "") {
    delete bucket.depth;
    delete bucket.prefix;
  }
  return true;
}
function needsPing(peer, threshold) {
  return peer.lastPing < Date.now() - threshold;
}

// node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
var KBUCKET_SIZE = 20;
var PREFIX_LENGTH = 8;
var PING_NEW_CONTACT_CONCURRENCY = 20;
var PING_NEW_CONTACT_MAX_QUEUE_SIZE = 100;
var PING_OLD_CONTACT_COUNT = 3;
var PING_OLD_CONTACT_CONCURRENCY = 20;
var PING_OLD_CONTACT_MAX_QUEUE_SIZE = 100;
var KAD_PEER_TAG_NAME = "kad-peer";
var KAD_PEER_TAG_VALUE = 1;
var LAST_PING_THRESHOLD = 6e5;
var POPULATE_FROM_DATASTORE_ON_START = true;
var POPULATE_FROM_DATASTORE_LIMIT = 1e3;
var RoutingTable = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "kBucketSize");
    __publicField(this, "kb");
    __publicField(this, "network");
    __publicField(this, "closestPeerTagger");
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "running");
    __publicField(this, "pingNewContactTimeout");
    __publicField(this, "pingNewContactQueue");
    __publicField(this, "pingOldContactTimeout");
    __publicField(this, "pingOldContactQueue");
    __publicField(this, "populateFromDatastoreOnStart");
    __publicField(this, "populateFromDatastoreLimit");
    __publicField(this, "protocol");
    __publicField(this, "peerTagName");
    __publicField(this, "peerTagValue");
    __publicField(this, "metrics");
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
    this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
    this.running = false;
    this.protocol = init.protocol;
    this.network = init.network;
    this.peerTagName = init.peerTagName ?? KAD_PEER_TAG_NAME;
    this.peerTagValue = init.peerTagValue ?? KAD_PEER_TAG_VALUE;
    this.pingOldContacts = this.pingOldContacts.bind(this);
    this.verifyNewContact = this.verifyNewContact.bind(this);
    this.peerAdded = this.peerAdded.bind(this);
    this.peerRemoved = this.peerRemoved.bind(this);
    this.populateFromDatastoreOnStart = init.populateFromDatastoreOnStart ?? POPULATE_FROM_DATASTORE_ON_START;
    this.populateFromDatastoreLimit = init.populateFromDatastoreLimit ?? POPULATE_FROM_DATASTORE_LIMIT;
    this.pingOldContactQueue = new PeerQueue({
      concurrency: init.pingOldContactConcurrency ?? PING_OLD_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_old_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingOldContactMaxQueueSize ?? PING_OLD_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingOldContactTimeout = new AdaptiveTimeout({
      ...init.pingOldContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_old_contact_time_milliseconds`
    });
    this.pingNewContactQueue = new PeerQueue({
      concurrency: init.pingNewContactConcurrency ?? PING_NEW_CONTACT_CONCURRENCY,
      metricName: `${init.metricsPrefix}_ping_new_contact_queue`,
      metrics: this.components.metrics,
      maxSize: init.pingNewContactMaxQueueSize ?? PING_NEW_CONTACT_MAX_QUEUE_SIZE
    });
    this.pingNewContactTimeout = new AdaptiveTimeout({
      ...init.pingNewContactTimeout ?? {},
      metrics: this.components.metrics,
      metricName: `${init.metricsPrefix}_routing_table_ping_new_contact_time_milliseconds`
    });
    this.kb = new KBucket({
      kBucketSize: init.kBucketSize,
      prefixLength: init.prefixLength,
      splitThreshold: init.splitThreshold,
      numberOfOldContactsToPing: init.numberOfOldContactsToPing,
      lastPingThreshold: init.lastPingThreshold,
      ping: this.pingOldContacts,
      verify: this.verifyNewContact,
      onAdd: this.peerAdded,
      onRemove: this.peerRemoved
    });
    this.closestPeerTagger = new ClosestPeers(this.components, {
      logPrefix: init.logPrefix,
      routingTable: this,
      peerSetSize: init.closestPeerSetSize,
      refreshInterval: init.closestPeerSetRefreshInterval,
      closeTagName: init.closeTagName,
      closeTagValue: init.closeTagValue
    });
    if (this.components.metrics != null) {
      this.metrics = {
        routingTableSize: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_size`),
        routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_total`),
        routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_average_occupancy`),
        routingTableKadBucketMinOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_min_occupancy`),
        routingTableKadBucketMaxOccupancy: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_occupancy`),
        routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.metricsPrefix}_routing_table_kad_bucket_max_depth`),
        kadBucketEvents: this.components.metrics.registerCounterGroup(`${init.metricsPrefix}_kad_bucket_events_total`)
      };
    }
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await start(this.closestPeerTagger);
    await this.kb.addSelfPeer(this.components.peerId);
  }
  async afterStart() {
    Promise.resolve().then(async () => {
      if (!this.populateFromDatastoreOnStart) {
        return;
      }
      let peerStorePeers = 0;
      for (const peer of await this.components.peerStore.all({
        filters: [(peer2) => {
          return peer2.protocols.includes(this.protocol) && peer2.tags.has(KAD_PEER_TAG_NAME);
        }],
        limit: this.populateFromDatastoreLimit
      })) {
        if (!this.running) {
          return;
        }
        try {
          await this.add(peer.id);
          peerStorePeers++;
        } catch (err) {
          this.log("failed to add peer %p to routing table, removing kad-dht peer tags - %e");
          await this.components.peerStore.merge(peer.id, {
            tags: {
              [this.peerTagName]: void 0
            }
          });
        }
      }
      this.log("added %d peer store peers to the routing table", peerStorePeers);
    }).catch((err) => {
      this.log.error("error adding peer store peers to the routing table %e", err);
    });
  }
  async stop() {
    this.running = false;
    await stop(this.closestPeerTagger);
    this.pingOldContactQueue.abort();
    this.pingNewContactQueue.abort();
  }
  async peerAdded(peer, bucket) {
    var _a13;
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: {
            value: this.peerTagValue
          }
        }
      });
    }
    this.updateMetrics();
    (_a13 = this.metrics) == null ? void 0 : _a13.kadBucketEvents.increment({ peer_added: true });
    this.safeDispatchEvent("peer:add", { detail: peer.peerId });
  }
  async peerRemoved(peer, bucket) {
    var _a13;
    if (!this.components.peerId.equals(peer.peerId)) {
      await this.components.peerStore.merge(peer.peerId, {
        tags: {
          [this.peerTagName]: void 0
        }
      });
    }
    this.updateMetrics();
    (_a13 = this.metrics) == null ? void 0 : _a13.kadBucketEvents.increment({ peer_removed: true });
    this.safeDispatchEvent("peer:remove", { detail: peer.peerId });
  }
  /**
   * Called on the `ping` event from `k-bucket` when a bucket is full
   * and cannot split.
   *
   * `oldContacts.length` is defined by the `numberOfNodesToPing` param
   * passed to the `k-bucket` constructor.
   *
   * `oldContacts` will not be empty and is the list of contacts that
   * have not been contacted for the longest.
   */
  async *pingOldContacts(oldContacts, options2) {
    var _a13;
    if (!this.running) {
      return;
    }
    const jobs = [];
    for (const oldContact of oldContacts) {
      if (this.kb.get(oldContact.kadId) == null) {
        this.log("asked to ping contact %p that was not in routing table", oldContact.peerId);
        continue;
      }
      (_a13 = this.metrics) == null ? void 0 : _a13.kadBucketEvents.increment({ ping_old_contact: true });
      jobs.push(async () => {
        const existingJob = this.pingOldContactQueue.find(oldContact.peerId);
        if (existingJob != null) {
          this.log("asked to ping contact %p was already being pinged", oldContact.peerId);
          const result2 = await existingJob.join(options2);
          if (!result2) {
            return oldContact;
          }
          return;
        }
        const result = await this.pingOldContactQueue.add(async (options3) => {
          var _a14;
          const signal = this.pingOldContactTimeout.getTimeoutSignal();
          const signals = anySignal([signal, options3 == null ? void 0 : options3.signal]);
          setMaxListeners(Infinity, signal, signals);
          try {
            return await this.pingContact(oldContact, options3);
          } catch {
            (_a14 = this.metrics) == null ? void 0 : _a14.kadBucketEvents.increment({ ping_old_contact_error: true });
            return true;
          } finally {
            this.pingOldContactTimeout.cleanUp(signal);
            signals.clear();
          }
        }, {
          peerId: oldContact.peerId,
          signal: options2 == null ? void 0 : options2.signal
        });
        if (!result) {
          return oldContact;
        }
      });
    }
    for await (const peer of parallel(jobs)) {
      if (peer != null) {
        yield peer;
      }
    }
  }
  async verifyNewContact(contact, options2) {
    var _a13;
    const signal = this.pingNewContactTimeout.getTimeoutSignal();
    const signals = anySignal([signal, options2 == null ? void 0 : options2.signal]);
    setMaxListeners(Infinity, signal, signals);
    try {
      const job = this.pingNewContactQueue.find(contact.peerId);
      if (job != null) {
        this.log("joining existing ping to add new peer %p to routing table", contact.peerId);
        return await job.join({
          signal: signals
        });
      } else {
        return await this.pingNewContactQueue.add(async (options3) => {
          var _a14;
          (_a14 = this.metrics) == null ? void 0 : _a14.kadBucketEvents.increment({ ping_new_contact: true });
          this.log("pinging new peer %p before adding to routing table", contact.peerId);
          return this.pingContact(contact, options3);
        }, {
          peerId: contact.peerId,
          signal: signals
        });
      }
    } catch (err) {
      this.log.trace("tried to add peer %p but they were not online", contact.peerId);
      (_a13 = this.metrics) == null ? void 0 : _a13.kadBucketEvents.increment({ ping_new_contact_error: true });
      return false;
    } finally {
      this.pingNewContactTimeout.cleanUp(signal);
      signals.clear();
    }
  }
  async pingContact(contact, options2) {
    let stream;
    try {
      this.log("pinging contact %p", contact.peerId);
      for await (const event of this.network.sendRequest(contact.peerId, { type: MessageType.PING }, options2)) {
        if (event.type === EventTypes.PEER_RESPONSE) {
          if (event.messageType === MessageType.PING) {
            this.log("contact %p ping ok", contact.peerId);
            this.safeDispatchEvent("peer:ping", {
              detail: contact.peerId
            });
            return true;
          }
          return false;
        }
      }
      return false;
    } catch (err) {
      this.log("error pinging old contact %p - %e", contact.peerId, err);
      stream == null ? void 0 : stream.abort(err);
      return false;
    }
  }
  /**
   * Amount of currently stored peers
   */
  get size() {
    if (this.kb == null) {
      return 0;
    }
    return this.kb.count();
  }
  /**
   * Find a specific peer by id
   */
  async find(peer) {
    var _a13;
    const kadId = await convertPeerId(peer);
    return (_a13 = this.kb.get(kadId)) == null ? void 0 : _a13.peerId;
  }
  /**
   * Retrieve the closest peers to the given kadId
   */
  closestPeer(kadId) {
    const res = this.closestPeers(kadId, 1);
    if (res.length > 0) {
      return res[0];
    }
    return void 0;
  }
  /**
   * Retrieve the `count`-closest peers to the given kadId
   */
  closestPeers(kadId, count = this.kBucketSize) {
    if (this.kb == null) {
      return [];
    }
    return [...this.kb.closest(kadId, count)];
  }
  /**
   * Add or update the routing table with the given peer
   */
  async add(peerId, options2) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    await this.kb.add(peerId, options2);
  }
  /**
   * Remove a given peer from the table
   */
  async remove(peer) {
    if (this.kb == null) {
      throw new Error("RoutingTable is not started");
    }
    const kadId = await convertPeerId(peer);
    await this.kb.remove(kadId);
  }
  updateMetrics() {
    if (this.metrics == null || this.kb == null) {
      return;
    }
    let size = 0;
    let buckets = 0;
    let maxDepth = 0;
    let minOccupancy = 20;
    let maxOccupancy = 0;
    function count(bucket) {
      if (isLeafBucket(bucket)) {
        if (bucket.depth > maxDepth) {
          maxDepth = bucket.depth;
        }
        buckets++;
        size += bucket.peers.length;
        if (bucket.peers.length < minOccupancy) {
          minOccupancy = bucket.peers.length;
        }
        if (bucket.peers.length > maxOccupancy) {
          maxOccupancy = bucket.peers.length;
        }
        return;
      }
      count(bucket.left);
      count(bucket.right);
    }
    count(this.kb.root);
    this.metrics.routingTableSize.update(size);
    this.metrics.routingTableKadBucketTotal.update(buckets);
    this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
    this.metrics.routingTableKadBucketMinOccupancy.update(minOccupancy);
    this.metrics.routingTableKadBucketMaxOccupancy.update(maxOccupancy);
    this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
var generated_prefix_list_browser_default = [
  77591,
  22417,
  43971,
  28421,
  740,
  29829,
  71467,
  228973,
  196661,
  78537,
  27689,
  36431,
  44415,
  14362,
  19456,
  106025,
  96308,
  2882,
  49509,
  21149,
  87173,
  131409,
  75844,
  23676,
  121838,
  30291,
  17492,
  2953,
  7564,
  110620,
  129477,
  127283,
  53113,
  72417,
  165166,
  109690,
  21200,
  102125,
  24049,
  71504,
  90342,
  25307,
  72039,
  26812,
  26715,
  32264,
  133800,
  71161,
  88956,
  171987,
  51779,
  24425,
  16671,
  30251,
  186294,
  247761,
  14202,
  2121,
  8465,
  35024,
  4876,
  85917,
  169730,
  3638,
  256836,
  96184,
  943,
  18678,
  6583,
  52907,
  35807,
  112254,
  214097,
  18796,
  11595,
  9243,
  23554,
  887,
  268203,
  382004,
  24590,
  111335,
  11625,
  16619,
  29039,
  102425,
  69006,
  97976,
  92362,
  32552,
  63717,
  41433,
  128974,
  137630,
  59943,
  10019,
  13986,
  35430,
  33665,
  108037,
  43799,
  43280,
  38195,
  29078,
  58629,
  18265,
  14425,
  46832,
  235538,
  40830,
  77881,
  110717,
  58937,
  3463,
  325358,
  51300,
  47623,
  117252,
  19007,
  10170,
  20540,
  91237,
  294813,
  4951,
  79841,
  56232,
  36270,
  128547,
  69209,
  66275,
  100156,
  32063,
  73531,
  34439,
  80937,
  28892,
  44466,
  88595,
  216307,
  32583,
  49620,
  16605,
  82127,
  45807,
  21630,
  78726,
  20235,
  40163,
  111007,
  96926,
  5567,
  72083,
  21665,
  58844,
  39419,
  179767,
  48328,
  42662,
  51550,
  5251,
  37811,
  49608,
  81056,
  50854,
  55513,
  20922,
  18891,
  197409,
  164656,
  32593,
  71449,
  220474,
  58919,
  85682,
  67854,
  13758,
  35066,
  3565,
  61905,
  214793,
  119572,
  141419,
  21504,
  10302,
  27354,
  67003,
  46131,
  32668,
  15165,
  64871,
  34450,
  17821,
  2757,
  11452,
  34189,
  5160,
  12257,
  85523,
  560,
  53385,
  65887,
  119549,
  135620,
  312353,
  115979,
  122356,
  10867,
  193231,
  124537,
  54783,
  90675,
  120791,
  4715,
  142253,
  50943,
  17271,
  43358,
  25331,
  4917,
  120566,
  34580,
  12878,
  33786,
  160528,
  32523,
  4869,
  301307,
  104817,
  81491,
  23276,
  8832,
  97911,
  31265,
  52065,
  7998,
  49622,
  9715,
  43998,
  34091,
  84587,
  20664,
  69041,
  29419,
  53205,
  10838,
  58288,
  116145,
  6185,
  5154,
  141795,
  35924,
  21307,
  144738,
  43730,
  12085,
  8279,
  10002,
  119,
  133779,
  199668,
  72938,
  31768,
  39176,
  67875,
  38453,
  9700,
  44144,
  4121,
  116048,
  41733,
  12868,
  82669,
  92308,
  128,
  34262,
  11332,
  7712,
  90764,
  36141,
  13553,
  71312,
  77470,
  117314,
  96549,
  49135,
  23602,
  54468,
  28605,
  6327,
  62308,
  17171,
  67531,
  21319,
  14105,
  894,
  107722,
  46157,
  8503,
  51069,
  100472,
  45138,
  15246,
  14577,
  35609,
  191464,
  1757,
  13364,
  161349,
  32067,
  91705,
  81144,
  52339,
  5408,
  91066,
  21983,
  14157,
  100545,
  4372,
  26630,
  129112,
  1423,
  29676,
  213626,
  4397,
  88436,
  99190,
  6877,
  49958,
  26122,
  114348,
  60661,
  29818,
  293118,
  50042,
  179738,
  16400,
  163423,
  89627,
  31040,
  43973,
  36638,
  45952,
  5153,
  1894,
  109322,
  1898,
  134021,
  12402,
  112077,
  68309,
  190269,
  69866,
  31938,
  107383,
  11522,
  105232,
  11248,
  14868,
  39852,
  71707,
  186525,
  16530,
  38162,
  106212,
  11700,
  5130,
  16608,
  26998,
  59586,
  108399,
  230033,
  43683,
  48135,
  82179,
  2073,
  5015,
  196684,
  189293,
  16378,
  23452,
  8301,
  35640,
  11632,
  214551,
  29240,
  57644,
  33137,
  91949,
  55157,
  52384,
  117313,
  5090,
  17717,
  89668,
  49363,
  82238,
  241035,
  66216,
  29066,
  184088,
  97206,
  62820,
  26595,
  4241,
  135635,
  173672,
  8202,
  459,
  71355,
  146294,
  29587,
  3008,
  135385,
  141203,
  14803,
  6634,
  45094,
  69362,
  50925,
  546,
  51884,
  62011,
  83296,
  234584,
  44515,
  56050,
  89476,
  87751,
  19373,
  12691,
  149923,
  19794,
  13833,
  35846,
  87557,
  58339,
  2884,
  19145,
  25647,
  12224,
  11024,
  77338,
  64608,
  122297,
  53025,
  7205,
  36189,
  36294,
  170779,
  21750,
  7739,
  173883,
  75192,
  35664,
  224240,
  113121,
  30181,
  26267,
  27036,
  117827,
  92015,
  106516,
  55628,
  203549,
  67949,
  60462,
  60844,
  35911,
  20457,
  1820,
  920,
  19773,
  8738,
  73173,
  181993,
  38521,
  98254,
  76257,
  46008,
  92796,
  5384,
  26868,
  151566,
  22124,
  2411,
  15919,
  186872,
  180021,
  28099,
  152961,
  78811,
  80237,
  62352,
  102653,
  74259,
  184890,
  16792,
  123702,
  224945,
  29940,
  19512,
  75283,
  14059,
  112691,
  92811,
  233329,
  20411,
  138569,
  53341,
  109802,
  50600,
  134528,
  66747,
  5529,
  166531,
  31578,
  64732,
  67189,
  1596,
  126357,
  967,
  167999,
  206598,
  109752,
  119431,
  207825,
  78791,
  91938,
  10301,
  27311,
  24233,
  252343,
  28831,
  32812,
  66002,
  112267,
  90895,
  8786,
  8095,
  16824,
  22866,
  21813,
  60507,
  174833,
  19549,
  130985,
  117051,
  52110,
  6938,
  81923,
  123864,
  38061,
  919,
  18680,
  53534,
  46739,
  112893,
  161529,
  85429,
  26761,
  11900,
  81121,
  91968,
  15390,
  217947,
  56524,
  1713,
  6654,
  37089,
  85630,
  138866,
  61850,
  16491,
  75577,
  16884,
  98296,
  73523,
  6140,
  44645,
  6062,
  36366,
  29844,
  57946,
  37932,
  42472,
  5266,
  20834,
  19309,
  33753,
  127182,
  134259,
  35810,
  41805,
  45878,
  312001,
  14881,
  47757,
  49251,
  120050,
  44252,
  3708,
  25856,
  107864,
  120347,
  1228,
  36550,
  41682,
  34496,
  47025,
  8393,
  173365,
  246526,
  12894,
  161607,
  35670,
  90785,
  126572,
  2095,
  124731,
  157033,
  58694,
  554,
  12786,
  9642,
  4817,
  16136,
  47864,
  174698,
  66992,
  4639,
  69284,
  10625,
  40710,
  27763,
  51738,
  30404,
  264105,
  137904,
  109882,
  52487,
  42824,
  57514,
  2740,
  10479,
  146799,
  107390,
  16586,
  88038,
  174951,
  9410,
  16185,
  44158,
  5568,
  40658,
  46108,
  12763,
  97385,
  26175,
  108859,
  664,
  230732,
  67470,
  46663,
  14395,
  50750,
  141320,
  93140,
  15361,
  47997,
  55784,
  6791,
  307840,
  118569,
  107326,
  18056,
  58281,
  260415,
  54691,
  8790,
  73332,
  45633,
  7511,
  45674,
  143373,
  14031,
  11799,
  94491,
  35646,
  96544,
  14560,
  26049,
  32983,
  25791,
  83814,
  42094,
  231370,
  63955,
  139212,
  2359,
  169908,
  3108,
  183486,
  105867,
  28197,
  32941,
  124968,
  26402,
  88267,
  149768,
  23053,
  3078,
  19091,
  52924,
  25383,
  19209,
  111548,
  97361,
  3959,
  24880,
  235061,
  9099,
  24921,
  161254,
  151405,
  20508,
  7159,
  34381,
  20133,
  11434,
  74036,
  19974,
  34769,
  36585,
  1076,
  22454,
  17354,
  38727,
  235160,
  111547,
  96454,
  117448,
  156940,
  91330,
  37299,
  7310,
  26915,
  117060,
  51369,
  22620,
  61861,
  322264,
  106850,
  111694,
  15091,
  2624,
  40345,
  300446,
  177064,
  1707,
  27389,
  54792,
  327783,
  132669,
  183543,
  59003,
  17744,
  20603,
  151134,
  106923,
  53084,
  71803,
  279424,
  319816,
  11579,
  21946,
  16728,
  38274,
  72711,
  5085,
  83391,
  88646,
  40159,
  25027,
  34680,
  10752,
  12988,
  54126,
  30365,
  18338,
  100445,
  230674,
  44874,
  84974,
  143877,
  123253,
  139372,
  28082,
  91477,
  144002,
  13096,
  219729,
  46016,
  50029,
  42377,
  14601,
  6660,
  58244,
  58978,
  23918,
  88206,
  113611,
  64452,
  17541,
  41032,
  10942,
  12021,
  49189,
  10978,
  40175,
  37156,
  10947,
  71709,
  106894,
  112538,
  57007,
  137486,
  150608,
  152719,
  40615,
  7746,
  279716,
  13101,
  19524,
  28708,
  40578,
  72320,
  1096,
  182051,
  94527,
  51275,
  22833,
  45164,
  81917,
  77519,
  48508,
  5421,
  140302,
  37845,
  149830,
  5587,
  27579,
  5357,
  428725,
  248187,
  6326,
  206760,
  39814,
  32585,
  89923,
  44341,
  288753,
  284443,
  96368,
  31201,
  94189,
  119504,
  20359,
  52073,
  103216,
  179,
  27934,
  32801,
  96035,
  34111,
  34309,
  101326,
  18198,
  20704,
  210266,
  37643,
  27880,
  141873,
  106e3,
  19414,
  56614,
  167714,
  66483,
  107885,
  86602,
  4379,
  20796,
  75467,
  4987,
  5017,
  118857,
  26003,
  34308,
  114428,
  29198,
  6686,
  29697,
  73632,
  3739,
  69795,
  16798,
  41504,
  7207,
  30722,
  21436,
  36735,
  28067,
  28545,
  3239,
  11221,
  36031,
  41889,
  100010,
  19247,
  317673,
  29495,
  174554,
  6424,
  129725,
  53845,
  94986,
  7955,
  59676,
  2604,
  191497,
  19735,
  102214,
  62954,
  23844,
  11872,
  179525,
  261436,
  34492,
  428,
  78404,
  142035,
  16747,
  17246,
  27578,
  37021,
  33672,
  57944,
  26056,
  135760,
  2369,
  61674,
  122066,
  31327,
  19374,
  157065,
  40553,
  130982,
  69619,
  71290,
  38855,
  72100,
  92903,
  95940,
  51422,
  165999,
  65713,
  57873,
  50726,
  7288,
  20272,
  2081,
  42326,
  22624,
  81120,
  57914,
  79352,
  19447,
  1684,
  72302,
  11774,
  302559,
  161481,
  96396,
  13692,
  414988,
  3721,
  79066,
  56627,
  46883,
  21150,
  11747,
  12184,
  5856,
  113458,
  176117,
  84416,
  52079,
  27933,
  3354,
  59765,
  141359,
  2212,
  216309,
  2555,
  23458,
  196722,
  142463,
  45701,
  44548,
  28798,
  19418,
  215,
  29916,
  9396,
  10574,
  114226,
  84475,
  13520,
  18694,
  34056,
  4524,
  90302,
  62930,
  13539,
  19407,
  77209,
  7728,
  38088,
  9535,
  2263,
  23875,
  183945,
  17750,
  26274,
  67172,
  10585,
  28042,
  22199,
  7478,
  51331,
  66030,
  26774,
  192929,
  31434,
  25850,
  50197,
  52926,
  178158,
  4679,
  181256,
  70184,
  229600,
  9959,
  105594,
  72158,
  73974,
  2726,
  35085,
  78087,
  23284,
  35568,
  51713,
  155676,
  5401,
  27254,
  11966,
  17569,
  223253,
  71993,
  103357,
  111477,
  55722,
  30504,
  26034,
  46774,
  35392,
  36285,
  214814,
  41143,
  163465,
  1051,
  16094,
  81044,
  6636,
  76489,
  179102,
  20712,
  39178,
  35683,
  125177,
  54219,
  30617,
  52994,
  25324,
  50123,
  2543,
  87529,
  58995,
  10688,
  125199,
  12388,
  60158,
  125481,
  131646,
  7642,
  133350,
  65874,
  3438,
  97277,
  101450,
  10075,
  56344,
  116821,
  50778,
  60547,
  98016,
  106135,
  13859,
  14255,
  16300,
  77373,
  173521,
  8285,
  45932,
  37426,
  4054,
  114295,
  55947,
  7703,
  39114,
  52,
  51119,
  128135,
  19714,
  60715,
  9554,
  50492,
  88180,
  2823,
  118271,
  52993,
  122625,
  97919,
  23859,
  37895,
  25040,
  33614,
  32102,
  20431,
  3577,
  9275,
  15686,
  43031,
  157741,
  110358,
  1884,
  40291,
  125391,
  13736,
  5008,
  64881,
  87336,
  77381,
  70711,
  43032,
  49155,
  118587,
  70494,
  4318,
  10168,
  30126,
  12580,
  10524,
  280104,
  104001,
  145413,
  2862,
  84140,
  6603,
  106005,
  13566,
  12780,
  11251,
  42830,
  571,
  179910,
  82443,
  13146,
  469,
  42714,
  32591,
  265217,
  424024,
  92553,
  54721,
  134100,
  6007,
  15242,
  114681,
  59030,
  16718,
  85465,
  200214,
  85982,
  55174,
  165013,
  23493,
  56964,
  82529,
  109150,
  32706,
  27568,
  82442,
  5350,
  14976,
  13165,
  44890,
  60021,
  21343,
  33978,
  17264,
  4655,
  22328,
  27819,
  75730,
  16567,
  55483,
  14510,
  17926,
  45827,
  150609,
  3704,
  7385,
  272531,
  161543,
  76904,
  122163,
  52405,
  2039,
  19165,
  41623,
  14423,
  228354,
  3369,
  176360,
  85491,
  7122,
  35789,
  303724,
  4465,
  13628,
  2233,
  55311,
  118771,
  20713,
  10006,
  221519,
  45115,
  71021,
  35650,
  29775,
  7337,
  10864,
  20665,
  21142,
  1746,
  15080,
  1624,
  32449,
  10905,
  105743,
  229797,
  7701,
  3940,
  22997,
  178467,
  57208,
  389057,
  39683,
  59403,
  63344,
  63125,
  54847,
  69691,
  18336,
  56448,
  3362,
  37202,
  18282,
  29648,
  138224,
  35867,
  10495,
  5911,
  28814,
  26653,
  31514,
  176702,
  26550,
  45621,
  11734,
  4525,
  40543,
  73944,
  121080,
  27858,
  155561,
  14887,
  44670,
  30742,
  8796,
  107455,
  113472,
  56369,
  75581,
  183777,
  240095,
  133699,
  153299,
  8768,
  160464,
  26058,
  49078,
  103971,
  21875,
  71486,
  44888,
  17156,
  9678,
  89541,
  123019,
  102337,
  3972,
  83930,
  21245,
  87852,
  109660,
  287918,
  183019,
  686,
  10100,
  39177,
  283941,
  11274,
  24736,
  26793,
  26214,
  25995,
  77011,
  141580,
  4070,
  23742,
  46285,
  46632,
  30700,
  26669,
  19056,
  35951,
  115575,
  174034,
  56097,
  35463,
  87425,
  24575,
  44245,
  38701,
  82317,
  85922,
  281616,
  100333,
  147697,
  61503,
  7730,
  84330,
  8530,
  59917,
  61597,
  17173,
  9092,
  32658,
  90288,
  193136,
  39023,
  20381,
  56654,
  31132,
  7779,
  1919,
  1375,
  117128,
  30819,
  11169,
  40938,
  23935,
  115201,
  101155,
  151034,
  4835,
  11231,
  74550,
  89388,
  59951,
  91704,
  107312,
  167882,
  115062,
  12732,
  72738,
  88703,
  464019,
  158267,
  57995,
  60496,
  737,
  14371,
  123867,
  4174,
  243339,
  159946,
  7568,
  16025,
  134556,
  110916,
  38103,
  191,
  80226,
  88794,
  29688,
  27230,
  10454,
  76308,
  57647,
  77409,
  113483,
  66864,
  14745,
  19808,
  12023,
  46583,
  84805,
  16015,
  17102,
  2231,
  20611,
  3547,
  95740,
  250131,
  34559,
  108894,
  8498,
  15853,
  159169,
  148920,
  20942,
  2813,
  93160,
  45188,
  210613,
  45531,
  52587,
  149062,
  39782,
  28194,
  57849,
  60965,
  84954,
  89766,
  84453,
  100927,
  16501,
  27658,
  165311,
  103841,
  54192,
  207341,
  19558,
  20084,
  319622,
  5672,
  205467,
  98462,
  61849,
  36279,
  13609,
  147177,
  24726,
  165015,
  209489,
  59591,
  31157,
  6551,
  117580,
  75060,
  141146,
  277310,
  21072,
  22023,
  106474,
  63041,
  137443,
  122965,
  68371,
  5383,
  42146,
  98961,
  113467,
  30863,
  23794,
  4843,
  99630,
  30392,
  82679,
  13699,
  241612,
  33601,
  93146,
  24319,
  18643,
  32155,
  95669,
  40440,
  15333,
  34089,
  67799,
  142144,
  58245,
  38633,
  114531,
  117400,
  77861,
  188726,
  5507,
  2568,
  8853,
  10987,
  107222,
  2663,
  2421,
  11530,
  13345,
  30075,
  41785,
  118661,
  104786,
  17459,
  12490,
  16281,
  71936,
  193555,
  17431,
  5944,
  71758,
  26485,
  77317,
  20803,
  367167,
  158,
  7362,
  93430,
  11735,
  172445,
  46002,
  11532,
  54482,
  930,
  62911,
  2235,
  23004,
  179236,
  4764,
  101859,
  208113,
  22477,
  55163,
  95579,
  14098,
  67320,
  162556,
  90709,
  156949,
  3826,
  57492,
  4025,
  34092,
  87442,
  104565,
  6718,
  186015,
  28214,
  14209,
  10039,
  107186,
  233912,
  58877,
  81637,
  55265,
  39828,
  6194,
  145813,
  50831,
  105849,
  4974,
  88319,
  122296,
  10272,
  197216,
  95714,
  51540,
  72418,
  23324,
  91555,
  8743,
  140452,
  250249,
  51666,
  34124,
  7229,
  38592,
  129641,
  78169,
  174242,
  22464,
  149964,
  51450,
  14034,
  10026,
  95376,
  26190,
  120062,
  14401,
  8700,
  265,
  31386,
  143573,
  7203,
  229889,
  61567,
  4227,
  140981,
  2466,
  72052,
  10787,
  10062,
  30958,
  6099,
  38471,
  30103,
  23202,
  208101,
  70847,
  467,
  58934,
  32271,
  32984,
  36637,
  24107,
  30771,
  17109,
  73353,
  13650,
  2098,
  157040,
  67366,
  66904,
  106018,
  265380,
  107238,
  18535,
  44025,
  32681,
  144983,
  62505,
  91295,
  56120,
  3082,
  77508,
  10322,
  63023,
  36700,
  81885,
  224127,
  16721,
  45023,
  239261,
  111272,
  13852,
  7866,
  149243,
  204199,
  32309,
  22084,
  42029,
  38316,
  126644,
  104973,
  14406,
  43454,
  67322,
  61310,
  15789,
  40285,
  24026,
  181047,
  6301,
  70927,
  23319,
  115823,
  27248,
  66693,
  115875,
  278566,
  63007,
  146844,
  56841,
  59007,
  87368,
  180001,
  22370,
  42114,
  80605,
  12022,
  10374,
  308,
  25079,
  14689,
  12618,
  63368,
  7936,
  264973,
  212291,
  136713,
  95999,
  105801,
  18965,
  32075,
  48700,
  52230,
  35119,
  96912,
  32992,
  8586,
  16606,
  101333,
  101812,
  14969,
  39930,
  759,
  193090,
  27387,
  42914,
  12937,
  5058,
  62646,
  64528,
  38624,
  25743,
  37502,
  3716,
  4435,
  30352,
  178687,
  26461,
  132611,
  42002,
  138442,
  35833,
  59582,
  16345,
  8048,
  60319,
  49349,
  309,
  47800,
  49739,
  90482,
  26405,
  34470,
  63786,
  32479,
  85028,
  39866,
  47846,
  11649,
  23934,
  29466,
  2816,
  42864,
  31828,
  7410,
  74885,
  49632,
  47629,
  111801,
  90749,
  19536,
  18767,
  105764,
  59606,
  21223,
  10746,
  76298,
  22220,
  39408,
  7190,
  79654,
  64856,
  11602,
  82156,
  272765,
  17079,
  70089,
  245473,
  51813,
  184407,
  384678,
  1576,
  122249,
  5064,
  27481,
  6188,
  25790,
  74361,
  27541,
  318284,
  45430,
  31488,
  620,
  93579,
  45723,
  192118,
  22670,
  51913,
  4162,
  70244,
  35966,
  26397,
  16199,
  50899,
  209613,
  121702,
  287507,
  2993,
  36101,
  132229,
  67345,
  33062,
  76295,
  118628,
  78705,
  52316,
  34375,
  107083,
  107454,
  44863,
  127561,
  33964,
  3073,
  154010,
  190914,
  55967,
  39074,
  6272,
  31047,
  5550,
  41123,
  26154,
  98638,
  47110,
  19998,
  148091,
  50229,
  31329,
  59900,
  195442,
  19106,
  61347,
  73497,
  70015,
  682,
  45850,
  25776,
  38022,
  148951,
  6288,
  37411,
  232526,
  109277,
  27286,
  32342,
  9262,
  5220,
  16651,
  23175,
  46740,
  129438,
  78614,
  121925,
  66914,
  88710,
  127952,
  5563,
  21500,
  34521,
  10739,
  14863,
  191006,
  62956,
  17359,
  16749,
  67027,
  56284,
  69134,
  43301,
  35039,
  58883,
  54466,
  60823,
  404451,
  75743,
  59856,
  86979,
  7923,
  34273,
  83785,
  32142,
  7693,
  268986,
  197428,
  282681,
  17049,
  22346,
  22990,
  92245,
  107180,
  3357,
  37104,
  96724,
  49153,
  7683,
  31197,
  43267,
  82231,
  164276,
  23696,
  20848,
  188364,
  22309,
  24821,
  158707,
  1018,
  22514,
  70922,
  27792,
  45589,
  59709,
  10765,
  736,
  35218,
  63479,
  51987,
  24275,
  63588,
  55361,
  92929,
  81964,
  4658,
  20122,
  12330,
  44058,
  13065,
  311456,
  72224,
  8337,
  211229,
  38979,
  22590,
  138478,
  52757,
  32595,
  133600,
  8838,
  31549,
  94412,
  43391,
  90056,
  1585,
  94802,
  127271,
  6223,
  31889,
  137038,
  132910,
  2165,
  57616,
  230152,
  6080,
  10748,
  36737,
  74579,
  134062,
  50525,
  180532,
  119270,
  34556,
  76155,
  82394,
  52595,
  29258,
  31435,
  87820,
  67996,
  26943,
  183878,
  38007,
  2410,
  13526,
  180297,
  69856,
  3503,
  187396,
  167700,
  7838,
  16701,
  9199,
  56267,
  3661,
  37407,
  65994,
  23767,
  5708,
  62508,
  221700,
  67088,
  86978,
  46776,
  84434,
  32088,
  5612,
  9149,
  88244,
  21685,
  95151,
  46750,
  189612,
  2979,
  506311,
  2594,
  3628,
  40074,
  105039,
  78243,
  28523,
  6651,
  38058,
  71999,
  30992,
  12764,
  68261,
  108991,
  6165,
  26450,
  61961,
  13400,
  22426,
  7490,
  60890,
  109623,
  2070,
  12958,
  50355,
  67979,
  257096,
  7213,
  42578,
  52121,
  35716,
  65461,
  7516,
  124758,
  39268,
  302,
  64712,
  14977,
  1467,
  219452,
  2840,
  34229,
  11121,
  21602,
  19270,
  63574,
  8024,
  1532,
  17331,
  79839,
  78885,
  52029,
  180767,
  57957,
  6069,
  91265,
  61380,
  55767,
  8927,
  32881,
  287603,
  22149,
  35029,
  68876,
  6428,
  199567,
  46926,
  13412,
  104132,
  21434,
  366616,
  45060,
  110046,
  81924,
  128910,
  45886,
  52821,
  130416,
  29416,
  77342,
  21762,
  67329,
  121432,
  79924,
  11724,
  38625,
  81006,
  102033,
  28338,
  13326,
  3250,
  82056,
  82526,
  38212,
  21112,
  12382,
  111495,
  3263,
  7414,
  86274,
  93490,
  40844,
  30224,
  45212,
  24019,
  48411,
  71367,
  24941,
  76729,
  57776,
  3769,
  38114,
  202019,
  197745,
  31953,
  237533,
  33270,
  201580,
  255648,
  100798,
  44741,
  32241,
  98468,
  106931,
  10085,
  15090,
  170358,
  33154,
  66787,
  18819,
  69760,
  25061,
  234005,
  82660,
  6295,
  131975,
  16874,
  9076,
  4094,
  25005,
  17740,
  40908,
  19533,
  220019,
  44330,
  99792,
  50040,
  19619,
  13950,
  55228,
  24423,
  31253,
  95308,
  103177,
  184795,
  28590,
  82285,
  5059,
  3210,
  75525,
  49894,
  70007,
  56178,
  10580,
  36051,
  139681,
  21617,
  98736,
  3555,
  106306,
  164189,
  37352,
  63915,
  47824,
  24883,
  145530,
  61904,
  28444,
  11483,
  19837,
  145446,
  30420,
  112972,
  85939,
  11835,
  191233,
  2262,
  20705,
  58630,
  1753,
  148334,
  1197,
  144714,
  6887,
  11223,
  107667,
  60879,
  77914,
  4151,
  57417,
  81594,
  96681,
  169430,
  1784,
  20444,
  95138,
  254041,
  27038,
  596,
  7117,
  72808,
  13759,
  3353,
  126776,
  21074,
  55322,
  27081,
  36942,
  39547,
  139830,
  179275,
  4453,
  713,
  8722,
  71399,
  19204,
  25785,
  22794,
  23923,
  104114,
  11291,
  25458,
  102309,
  88396,
  75288,
  230440,
  206396,
  104551,
  58447,
  130857,
  37247,
  94734,
  31548,
  176529,
  226077,
  65159,
  20104,
  10096,
  66881,
  94191,
  237909,
  27109,
  37404,
  1520,
  27421,
  25220,
  113003,
  23423,
  24884,
  50585,
  6286,
  231877,
  150800,
  11789,
  3226,
  90004,
  60642,
  5053,
  202400,
  61442,
  132531,
  175329,
  57138,
  30116,
  103847,
  9973,
  75367,
  16452,
  32360,
  59119,
  21246,
  10191,
  164804,
  23305,
  61051,
  37348,
  154530,
  13214,
  5468,
  50403,
  66754,
  130976,
  50559,
  80515,
  14436,
  155492,
  84017,
  5472,
  43107,
  41240,
  2890,
  90431,
  70188,
  382,
  76234,
  48040,
  50211,
  281038,
  237007,
  32115,
  142178,
  1536,
  22761,
  96429,
  1811,
  31243,
  1679,
  49143,
  55209,
  17402,
  235054,
  61494,
  7462,
  77030,
  34925,
  87609,
  78002,
  9499,
  9027,
  73289,
  201078,
  101379,
  63544,
  27666,
  5469,
  10642,
  30029,
  49816,
  132979,
  95620,
  58086,
  351930,
  116300,
  2110,
  2043,
  30845,
  6154,
  11279,
  16727,
  4122,
  2277,
  27281,
  4971,
  3650,
  39060,
  61970,
  65951,
  39674,
  75686,
  38151,
  11370,
  130809,
  177895,
  32665,
  63725,
  122267,
  7857,
  39618,
  118483,
  44792,
  157755,
  178624,
  136994,
  24260,
  41308,
  22471,
  12404,
  21707,
  12486,
  30473,
  52781,
  50246,
  20247,
  39065,
  909,
  56825,
  103158,
  128603,
  31542,
  1089,
  41935,
  32744,
  12428,
  37963,
  84420,
  33134,
  72921,
  208449,
  42622,
  168151,
  127335,
  147107,
  46699,
  38216,
  12591,
  94342,
  85814,
  31423,
  24944,
  2605,
  87542,
  67473,
  192551,
  4496,
  56321,
  91819,
  17630,
  6300,
  256183,
  114569,
  202090,
  33209,
  35289,
  34897,
  24967,
  40520,
  43470,
  5344,
  10199,
  34810,
  14283,
  10381,
  10017,
  62923,
  49924,
  23233,
  64539,
  13051,
  35686,
  19698,
  11570,
  135555,
  120868,
  44924,
  87065,
  52318,
  52335,
  47586,
  140906,
  245885,
  109834,
  78668,
  9065,
  46990,
  25258,
  72022,
  61243,
  40838,
  4545,
  146387,
  10537,
  11557,
  17470,
  36930,
  68104,
  46711,
  24264,
  79401,
  81043,
  18225,
  120488,
  24746,
  84338,
  81652,
  28266,
  13776,
  21878,
  46973,
  1047,
  230465,
  73357,
  95777,
  24973,
  210160,
  62210,
  58404,
  110633,
  169651,
  6937,
  41870,
  9909,
  26822,
  191062,
  76553,
  27519,
  96256,
  239070,
  2478,
  205678,
  67955,
  58532,
  20601,
  50120,
  19148,
  78501,
  195724,
  110740,
  8249,
  109665,
  27446,
  30568,
  57631,
  31425,
  49752,
  32820,
  65504,
  50079,
  3663,
  102256,
  219898,
  23849,
  211315,
  14645,
  4359,
  91767,
  9528,
  12449,
  49366,
  7941,
  49763,
  107848,
  8930,
  27086,
  50686,
  9744,
  10447,
  81935,
  39513,
  46514,
  1670,
  29229,
  6172,
  22312,
  137280,
  97759,
  9806,
  14445,
  22976,
  56458,
  73391,
  34983,
  93760,
  174219,
  52573,
  33149,
  59747,
  2429,
  136277,
  75123,
  165263,
  91040,
  7446,
  57632,
  48633,
  97140,
  246081,
  84766,
  151684,
  79918,
  93268,
  120346,
  54059,
  54875,
  77858,
  32996,
  103590,
  45276,
  11968,
  19600,
  25849,
  17159,
  132907,
  42828,
  16817,
  4913,
  99462,
  103303,
  27395,
  5737,
  74184,
  20749,
  21160,
  14377,
  77062,
  131403,
  158735,
  10999,
  27799,
  77785,
  9320,
  34366,
  51593,
  61070,
  33746,
  47048,
  29268,
  36675,
  30262,
  53297,
  9832,
  82e3,
  20188,
  122292,
  39917,
  7331,
  18160,
  68301,
  185935,
  134830,
  15031,
  4935,
  10004,
  165845,
  185534,
  46923,
  30109,
  44134,
  122631,
  18874,
  22903,
  112790,
  26561,
  18549,
  348902,
  82871,
  140345,
  255565,
  135390,
  63556,
  103747,
  145055,
  179600,
  145662,
  296111,
  61661,
  211987,
  23952,
  52342,
  126343,
  48450,
  32919,
  44277,
  82185,
  9591,
  62139,
  205363,
  376969,
  394874,
  108461,
  18040,
  120885,
  14798,
  39863,
  16571,
  16794,
  58271,
  81025,
  55206,
  14640,
  118656,
  6361,
  44092,
  85970,
  6262,
  153863,
  108244,
  180200,
  72264,
  79947,
  38044,
  10050,
  5735,
  61221,
  80712,
  5471,
  115689,
  11391,
  11661,
  184257,
  20010,
  60116,
  30320,
  19327,
  134598,
  45455,
  27542,
  18004,
  125092,
  452272,
  1549,
  91523,
  46567,
  180063,
  156026,
  2608,
  11174,
  58848,
  37788,
  65907,
  80194,
  30490,
  5786,
  40775,
  119519,
  106241,
  11323,
  156297,
  8425,
  61495,
  2617,
  29675,
  2425,
  59886,
  112582,
  49142,
  59618,
  4863,
  50597,
  86710,
  50650,
  168632,
  27693,
  85641,
  83643,
  18993,
  25768,
  84284,
  28090,
  93592,
  36627,
  312804,
  43381,
  9887,
  9402,
  100931,
  97165,
  3311,
  173330,
  66805,
  28935,
  4963,
  184460,
  3201,
  78102,
  19126,
  21607,
  37496,
  24938,
  22615,
  16153,
  32862,
  134792,
  153318,
  61120,
  6067,
  2812,
  12826,
  12792,
  23825,
  37559,
  64662,
  202250,
  102694,
  155488,
  85881,
  149193,
  46233,
  65383,
  15521,
  106982,
  11358,
  176786,
  25752,
  39717,
  34208,
  24510,
  32464,
  77742,
  39371,
  72028,
  138229,
  60688,
  71386,
  102834,
  132477,
  2208,
  11548,
  63670,
  271279,
  28351,
  30338,
  38620,
  32491,
  99845,
  143885,
  152266,
  13252,
  2825,
  178663,
  108097,
  1775,
  78201,
  14897,
  113573,
  163346,
  62292,
  171129,
  22183,
  96598,
  38733,
  64971,
  166776,
  117445,
  9968,
  146393,
  44677,
  74867,
  20908,
  97328,
  12761,
  25656,
  26785,
  9148,
  112344,
  26115,
  99176,
  110121,
  22437,
  49547,
  6180,
  79320,
  5835,
  31392,
  43328,
  33377,
  75870,
  119860,
  69497,
  80273,
  7325,
  155219,
  43167,
  111173,
  28347,
  20222,
  3763,
  71752,
  55041,
  47252,
  14618,
  28088,
  15012,
  97805,
  194698,
  54636,
  2036,
  41349,
  6173,
  96604,
  61530,
  51859,
  43782,
  13361,
  24334,
  22668,
  24792,
  7070,
  23441,
  16789,
  3209,
  36211,
  208475,
  26242,
  32880,
  122181,
  182407,
  21444,
  31060,
  88459,
  29929,
  77907,
  12716,
  10934,
  97005,
  20599,
  31690,
  8403,
  58445,
  30303,
  22700,
  10336,
  86731,
  103115,
  337709,
  72556,
  46788,
  112566,
  47684,
  67089,
  53548,
  36874,
  56487,
  41387,
  125985,
  26893,
  40071,
  106683,
  73712,
  18787,
  40105,
  72992,
  67246,
  137276,
  50802,
  36790,
  70328,
  138827,
  22466,
  39263,
  183295,
  29858,
  50975,
  9322,
  57397,
  10654,
  24364,
  30383,
  55799,
  41600,
  23584,
  127295,
  296610,
  129078,
  143558,
  244131,
  86397,
  36049,
  1085,
  80677,
  3820,
  108139,
  5476,
  34767,
  24683,
  7758,
  13060,
  7239,
  131671,
  250593,
  59556,
  103392,
  29810,
  4188,
  252323,
  39404,
  116877,
  7651,
  43600,
  40338,
  13554,
  157253,
  39196,
  25978,
  144387,
  61211,
  234,
  50104,
  6129,
  10449,
  93777,
  9240,
  356378,
  274148,
  4439,
  72970,
  3724,
  147770,
  78680,
  62570,
  115877,
  40027,
  40547,
  36817,
  224392,
  64609,
  34795,
  165027,
  67440,
  2477,
  37206,
  23431,
  50754,
  164797,
  46018,
  94995,
  170982,
  27051,
  7957,
  22767,
  3674,
  27900,
  56419,
  18930,
  60701,
  41302,
  2692,
  84749,
  339721,
  61996,
  111094,
  80221,
  50129,
  1045,
  8153,
  62945,
  19202,
  8250,
  37208,
  37418,
  32560,
  79477,
  41106,
  88569,
  33963,
  36693,
  5892,
  30570,
  1581,
  66471,
  49647,
  11922,
  160717,
  29442,
  5643,
  114865,
  82962,
  95982,
  132098,
  22633,
  22838,
  94726,
  54556,
  28566,
  205039,
  162340,
  33216,
  16849,
  35847,
  221339,
  94851,
  26533,
  71469,
  1805,
  3804,
  12935,
  45483,
  71020,
  36310,
  65381,
  192960,
  34240,
  35165,
  59773,
  1248,
  46954,
  155332,
  96864,
  4246,
  388800,
  16129,
  57133,
  74592,
  44807,
  442014,
  38203,
  42574,
  80818,
  91592,
  26377,
  36424,
  65760,
  977,
  77387,
  22628,
  147610,
  28018,
  30561,
  98454,
  6969,
  119628,
  63648,
  18170,
  36854,
  26601,
  64018,
  22027,
  37279,
  51395,
  152934,
  21153,
  9430,
  58760,
  194742,
  5330,
  55115,
  34158,
  28917,
  174111,
  13171,
  122326,
  1526,
  43896,
  66094,
  25325,
  4234,
  148354,
  11450,
  275,
  18999,
  112191,
  44365,
  22723,
  68409,
  8733,
  57746,
  96565,
  75007,
  14196,
  108844,
  29475,
  88599,
  177563,
  100792,
  106156,
  86323,
  93726,
  14248,
  135341,
  194131,
  40126,
  47099,
  14779,
  8272,
  39597,
  95983,
  171398,
  65882,
  28052,
  10393,
  47213,
  40689,
  22120,
  72212,
  106829,
  34964,
  109146,
  753,
  648,
  21660,
  30047,
  17527,
  181025,
  5619,
  145357,
  4085,
  216883,
  9359,
  186951,
  24779,
  53931,
  24545,
  36197,
  223296,
  62628,
  168101,
  4243,
  107313,
  30321,
  26642,
  13049,
  51059,
  31027,
  107912,
  807,
  73550,
  26551,
  84369,
  122422,
  165872,
  49754,
  74213,
  234264,
  33151,
  52014,
  33100,
  87183,
  22365,
  52500,
  40013,
  23302,
  5652,
  72723,
  21404,
  26107,
  48434,
  587,
  94049,
  168493,
  96418,
  32871,
  70860,
  31709,
  25128,
  443,
  71597,
  166253,
  15670,
  70994,
  26341,
  133675,
  28280,
  75491,
  54756,
  47955,
  56028,
  26182,
  11952,
  113272,
  472197,
  64640,
  110753,
  17919,
  337,
  50642,
  22576,
  142,
  87371,
  53391,
  93210,
  126694,
  15285,
  19642,
  85667,
  14148,
  1506,
  42092,
  52962,
  33243,
  11970,
  20734,
  135843,
  57044,
  58880,
  13002,
  219134,
  22876,
  64754,
  232519,
  4257,
  43120,
  321573,
  24799,
  64526,
  124728,
  52579,
  81472,
  70831,
  276848,
  17403,
  74359,
  23021,
  182101,
  74597,
  23744,
  148267,
  12055,
  7976,
  5349,
  11772,
  67540,
  167347,
  65318,
  18720,
  127832,
  108238,
  22828,
  90233,
  9987,
  259080,
  118185,
  73209,
  79270,
  13775,
  90100,
  137742,
  90799,
  70569,
  15699,
  19961,
  9087,
  67475,
  57872,
  39731,
  8810,
  134897,
  131868,
  146849,
  19898,
  3334,
  2281,
  167061,
  91073,
  60356,
  467742,
  74712,
  188,
  53179,
  137679,
  92769,
  29241,
  9537,
  132595,
  80119,
  1041,
  88962,
  5976,
  40171,
  44911,
  102859,
  139059,
  104558,
  98987,
  47761,
  19272,
  71472,
  113864,
  175377,
  73338,
  10857,
  23402,
  23758,
  1591,
  139864,
  5644,
  4076,
  118760,
  16427,
  134198,
  18853,
  20291,
  100849,
  37423,
  22038,
  36677,
  19071,
  195521,
  57445,
  11069,
  31869,
  55718,
  66882,
  148490,
  44,
  41296,
  75242,
  49704,
  166810,
  9906,
  20943,
  122258,
  49112,
  105667,
  15969,
  10344,
  6408,
  187694,
  21399,
  72742,
  58970,
  14867,
  14376,
  81889,
  41856,
  23225,
  15042,
  56993,
  16074,
  131389,
  74276,
  72407,
  53875,
  383108,
  53597,
  37363,
  68993,
  44854,
  122548,
  430927,
  198279,
  38430,
  80409,
  12245,
  2981,
  628,
  2818,
  17760,
  37437,
  238229,
  7968,
  46892,
  2200,
  3730,
  34190,
  65983,
  37959,
  112291,
  87850,
  70827,
  6522,
  20750,
  73913,
  111621,
  41652,
  19587,
  2780,
  58668,
  25916,
  85259,
  18200,
  168962,
  95781,
  42445,
  102050,
  7776,
  57662,
  103313,
  47742,
  96358,
  41964,
  66174,
  100396,
  29069,
  204735,
  19679,
  27978,
  7479,
  40264,
  22534,
  61183,
  36081,
  107436,
  58223,
  14680,
  23002,
  101311,
  24716,
  124108,
  12908,
  5646,
  31750,
  40380,
  14215,
  232799,
  102772,
  14122,
  96775,
  61398,
  50917,
  12096,
  149880,
  67833,
  598749,
  124194,
  155871,
  49216,
  790,
  14677,
  65319,
  56917,
  7440,
  145744,
  95701,
  12206,
  49405,
  129269,
  76199,
  45732,
  9767,
  11058,
  9047,
  210885,
  11051,
  7392,
  26307,
  2130,
  8132,
  147526,
  20802,
  232698,
  115660,
  50060,
  59789,
  57344,
  107623,
  80343,
  112676,
  23291,
  9866,
  160971,
  34032,
  118291,
  15719,
  59730,
  164911,
  28975,
  2659,
  58046,
  78480,
  21854,
  66209,
  53863,
  109085,
  116045,
  29021,
  46481,
  107552,
  22130,
  18764,
  70254,
  31272,
  11300,
  52460,
  43933,
  84738,
  20721,
  53869,
  190840,
  79673,
  105300,
  7561,
  321817,
  66924,
  13940,
  33281,
  101046,
  183181,
  32176,
  71878,
  5678,
  62924,
  79535,
  56646,
  40303,
  19559,
  27703,
  93042,
  73368,
  42187,
  3670,
  37376,
  46440,
  7023,
  36816,
  109628,
  20680,
  5940,
  276440,
  275233,
  170848,
  112093,
  136996,
  14984,
  20226,
  111441,
  77693,
  112960,
  48577,
  39370,
  55707,
  50314,
  123404,
  26570,
  54281,
  61372,
  123391,
  4857,
  35928,
  246740,
  132507,
  106646,
  44241,
  7196,
  92258,
  9825,
  37688,
  51197,
  303141,
  5590,
  15476,
  132986,
  10955,
  85782,
  34486,
  26696,
  7991,
  28813,
  18858,
  39546,
  11703,
  11365,
  38185,
  5716,
  93555,
  11925,
  40121,
  60002,
  6985,
  10976,
  171384,
  3887,
  43394,
  13337,
  56346,
  6381,
  252336,
  39573,
  75042,
  53711,
  1028,
  31781,
  44295,
  95925,
  131713,
  7214,
  68125,
  43571,
  70954,
  213234,
  1628,
  8760,
  13391,
  65485,
  17320,
  56038,
  1710,
  25248,
  60803,
  57399,
  19839,
  3870,
  326,
  281556,
  50945,
  72400,
  21460,
  316244,
  75619,
  56246,
  98775,
  481,
  13513,
  55765,
  50427,
  7388,
  123519,
  32929,
  57908,
  27124,
  61316,
  101097,
  57467,
  30228,
  48792,
  10788,
  20402,
  37318,
  50526,
  155730,
  34456,
  158065,
  145305,
  17832,
  43733,
  64052,
  4506,
  35072,
  205355,
  177028,
  184004,
  187081,
  68616,
  35938,
  83703,
  10367,
  36892,
  93186,
  260137,
  51934,
  89970,
  4985,
  23445,
  26755,
  21558,
  7948,
  78741,
  23376,
  124405,
  85594,
  68596,
  57536,
  49351,
  12619,
  56593,
  132668,
  99924,
  109728,
  71844,
  71935,
  196018,
  65464,
  17617,
  14987,
  89701,
  143773,
  33997,
  8687,
  22701,
  33258,
  2914,
  4436,
  72108,
  85610,
  9671,
  49067,
  2327,
  82988,
  1361,
  1672,
  44033,
  35777,
  30269,
  24057,
  10605,
  82236,
  616,
  15793,
  13919,
  47249,
  112086,
  116698,
  9484,
  80207,
  90574,
  33304,
  68624,
  93127,
  56101,
  42210,
  160929,
  4827,
  38995,
  38095,
  4701,
  125119,
  5027,
  33680,
  9236,
  231236,
  14135,
  87837,
  23318,
  70261,
  78893,
  30151,
  81482,
  14332,
  1084,
  74256,
  27532,
  46644,
  79185,
  3148,
  62615,
  6981,
  55672,
  31668,
  36825,
  1849,
  14536,
  37446,
  14738,
  23779,
  43058,
  162749,
  72199,
  1168,
  21346,
  5592,
  85932,
  85302,
  9668,
  18351,
  57135,
  150360,
  2080,
  228015,
  77953,
  34670,
  119302,
  151751,
  31009,
  106725,
  84265,
  45214,
  59289,
  74178,
  113071,
  263206,
  111009,
  4021,
  44449,
  188119,
  192629,
  123592,
  392506,
  292847,
  114487,
  12831,
  205858,
  9852,
  20780,
  79648,
  75767,
  357014,
  97721,
  18166,
  21005,
  67950,
  33226,
  204009,
  16536,
  2987,
  11335,
  66717,
  144910,
  47950,
  17262,
  55060,
  15063,
  2934,
  51038,
  26775,
  178497,
  66008,
  3427,
  49433,
  128592,
  20036,
  157553,
  63861,
  3089,
  23015,
  51210,
  28696,
  35933,
  49942,
  71135,
  231518,
  99620,
  17248,
  21835,
  176536,
  20676,
  16944,
  38700,
  165831,
  233253,
  295625,
  36723,
  13023,
  52745,
  10907,
  19423,
  67972,
  125868,
  95473,
  82875,
  1183,
  108455,
  52685,
  33417,
  64095,
  21433,
  52438,
  33191,
  127809,
  44505,
  211823,
  7810,
  2752,
  95548,
  162031,
  7185,
  91196,
  47563,
  61721,
  33359,
  17897,
  23682,
  42806,
  178101,
  22874,
  49707,
  199897,
  75419,
  82456,
  8618,
  11171,
  79712,
  116847,
  18783,
  44190,
  46564,
  5346,
  59046,
  95032,
  7893,
  14916,
  3214,
  26800,
  24172,
  121453,
  34362,
  10250,
  17408,
  18888,
  4840,
  68696,
  22831,
  13162,
  36005,
  32512,
  14800,
  62357,
  41723,
  45046,
  27247,
  37486,
  5372,
  2564,
  34261,
  298500,
  66509,
  133920,
  89138,
  31305,
  117697,
  19097,
  108304,
  81386,
  84106,
  23802,
  46411,
  63304,
  946,
  51417,
  41777,
  41041,
  19501,
  115864,
  60743,
  294354,
  37955,
  94165,
  18116,
  1156,
  17937,
  20645,
  57114,
  90804,
  58042,
  48643,
  92288,
  9861,
  2557,
  88546,
  61333,
  101008,
  12853,
  5148,
  87856,
  4152,
  144503,
  73841,
  18718,
  9789,
  147565,
  10846,
  42085,
  12789,
  30223,
  8993,
  56352,
  67203,
  2448,
  28215,
  6052,
  23540,
  126319,
  75933,
  36689,
  80235,
  23231,
  23561,
  21383,
  38800,
  77548,
  102798,
  21234,
  31468,
  158608,
  46188,
  63960,
  191679,
  8051,
  67014,
  11185,
  170078,
  42186,
  28827,
  34777,
  41930,
  212079,
  12421,
  34750,
  24111,
  110344,
  73918,
  45171,
  70826,
  141949,
  40063,
  23979,
  24254,
  37309,
  26724,
  27179,
  24718,
  83648,
  54938,
  14591,
  17425,
  29525,
  102675,
  48975,
  48654,
  12316,
  8929,
  60640,
  41709,
  50168,
  63264,
  89812,
  50716,
  48632,
  38755,
  138583,
  160123,
  55579,
  71829,
  24230,
  233277,
  46322,
  39650,
  166388,
  34718,
  24108,
  98252,
  7031,
  106695,
  62498,
  18258,
  35062,
  217827,
  78731,
  34824,
  33354,
  19520,
  60852,
  2432,
  60224,
  8587,
  2836,
  62955,
  702,
  20227,
  42285,
  40560,
  95592,
  62486,
  11094,
  53035,
  143291,
  18842,
  46177,
  77994,
  1770,
  9657,
  107422,
  172915,
  32655,
  128716,
  25886,
  25164,
  156740,
  119928,
  165875,
  85817,
  11007,
  89110,
  33956,
  12652,
  65156,
  180266,
  8494,
  36889,
  19958,
  20955,
  96,
  1264,
  118288,
  135769,
  44754,
  86671,
  5632,
  19026,
  168220,
  289120,
  33569,
  93821,
  66144,
  70635,
  7687,
  5642,
  2714,
  55445,
  56636,
  71545,
  184182,
  93133,
  7332,
  37389,
  12643,
  52315,
  22729,
  11014,
  158742,
  17050,
  152889,
  50178,
  34601,
  41945,
  52136,
  9948,
  26914,
  63548,
  95721,
  115951,
  40759,
  8960,
  158258,
  38938,
  49232,
  48325,
  42234,
  81523,
  253019,
  66128,
  40978,
  20048,
  238048,
  38760,
  62928,
  122560,
  118532,
  43687,
  137472,
  163689,
  26680,
  9878,
  17448,
  51035,
  16211,
  60834,
  36749,
  29178,
  14241,
  59868,
  150086,
  2305,
  26477,
  42422,
  34342,
  165341,
  83279,
  33894,
  14257,
  29928,
  12743,
  13957,
  125571,
  89134,
  66712,
  10952,
  16507,
  147839,
  30146,
  7249,
  16565,
  45399,
  39874,
  114565,
  215780,
  31990,
  230881,
  171477,
  102,
  196546,
  44538,
  10880,
  84948,
  281705,
  86651,
  10617,
  31395,
  2342,
  453658,
  43569,
  60561,
  132901,
  21845,
  17727,
  58556,
  258242,
  22262,
  58728,
  4008,
  77997,
  11806,
  37431,
  30599,
  81375,
  109137,
  185787,
  114085,
  217292,
  97453,
  169085,
  30593,
  60212,
  11544,
  102056,
  65580,
  2384,
  91655,
  4855,
  95725,
  7295,
  157994,
  16228,
  20669,
  53276,
  141590,
  105246,
  17334,
  25440,
  76067,
  17967,
  39321,
  38911,
  11362,
  28559,
  63807,
  21627,
  26468,
  85816,
  40120,
  1025,
  15234,
  58319,
  69516,
  66512,
  124548,
  75845,
  78873,
  22137,
  46681,
  51242,
  85683,
  32909,
  76747,
  35555,
  43396,
  101465,
  1765,
  73094,
  1077,
  2962,
  39028,
  66777,
  57831,
  42048,
  15828,
  13962,
  36041,
  63657,
  52412,
  5242,
  58846,
  2141,
  5506,
  219012,
  134451,
  3936,
  182230,
  17558,
  17153,
  152237,
  22621,
  49377,
  170216,
  35257,
  68233,
  65374,
  6510,
  11126,
  212151,
  7184,
  2480,
  22517,
  3437,
  33073,
  30156,
  16557,
  3768,
  55067,
  86829,
  91e3,
  12350,
  148650,
  66017,
  79424,
  70885,
  49066,
  28250,
  21369,
  51213,
  34533,
  11510,
  3258,
  18176,
  18465,
  84413,
  6315,
  36411,
  163765,
  4346,
  356,
  107618,
  598,
  13727,
  285026,
  162695,
  8749,
  14583,
  7132,
  63521,
  184253,
  32378,
  25991,
  5604,
  30961,
  53675,
  4874,
  84693,
  5086,
  34811,
  26978,
  56564,
  7904,
  33519,
  51221,
  113942,
  69253,
  6664,
  125563,
  22055,
  220680,
  102008,
  742,
  51930,
  19494,
  176108,
  44424,
  35123,
  13025,
  75685,
  11759,
  74335,
  22250,
  181453,
  131147,
  16984,
  132115,
  154311,
  11991,
  76452,
  52609,
  85351,
  196,
  30969,
  9198,
  74919,
  2529,
  56838,
  71779,
  29187,
  116304,
  3504,
  62330,
  41190,
  86153,
  28393,
  254926,
  104228,
  105189,
  13264,
  84359,
  3574,
  12415,
  8534,
  57147,
  10175,
  188174,
  59504,
  60932,
  66318,
  16407,
  107921,
  17638,
  99103,
  49278,
  28403,
  39786,
  145865,
  8462,
  3558,
  43406,
  142271,
  29139,
  21989,
  36552,
  93955,
  72365,
  7176,
  13556,
  106185,
  37957,
  321774,
  17782,
  129017,
  51154,
  27938,
  24952,
  1935,
  39366,
  2791,
  33489,
  41582,
  56078,
  24558,
  9311,
  5449,
  218786,
  27808,
  190429,
  68013,
  36020,
  86003,
  29735,
  3404,
  87348,
  119357,
  115714,
  2324,
  86796,
  81973,
  40992,
  43376,
  93621,
  28784,
  16808,
  36367,
  2517,
  2909,
  191926,
  24978,
  55303,
  53308,
  205724,
  60068,
  3098,
  21375,
  64784,
  23949,
  26579,
  63121,
  12319,
  80145,
  39967,
  97861,
  6757,
  70143,
  67642,
  37082,
  34698,
  69140,
  122883,
  46151,
  62187,
  80934,
  429,
  19437,
  135071,
  137885,
  222647,
  13331,
  154065,
  327,
  61778,
  74257,
  40116,
  37493,
  14855,
  85079,
  237641,
  42342,
  102164,
  199965,
  71204,
  4662,
  29368,
  5042,
  113914,
  122214,
  8955,
  13149,
  102503,
  43173,
  5659,
  163787,
  69003,
  307084,
  63392,
  171080,
  21390,
  81918,
  86666,
  36622,
  24126,
  28887,
  5736,
  28054,
  207170,
  163428,
  79891,
  346467,
  95363,
  38980,
  111806,
  80828,
  9200,
  19288,
  294896,
  114468,
  87405,
  111715,
  141705,
  7015,
  72754,
  68463,
  48738,
  243147,
  33397,
  101210,
  37051,
  98801,
  82847,
  20397,
  4940,
  185559,
  18716,
  54718,
  83491,
  11725,
  40803,
  1128,
  12128,
  23060,
  5174,
  7745,
  67007,
  46701,
  1571,
  27807,
  180186,
  256996,
  18975,
  16837,
  7877,
  212758,
  250379,
  15440,
  87954,
  57755,
  24719,
  124057,
  83461,
  258,
  50864,
  8874,
  29038,
  71289,
  31627,
  15429,
  9005,
  4061,
  113851,
  107716,
  82819,
  13651,
  79656,
  117851,
  17539,
  111446,
  12938,
  39724,
  190787,
  4352,
  15402,
  21070,
  62708,
  8539,
  23777,
  73853,
  13552,
  38810,
  86117,
  16285,
  56400,
  1718,
  75342,
  142863,
  29033,
  378,
  110113,
  180321,
  32586,
  23606,
  26393,
  160984,
  207987,
  23783,
  8406,
  16904,
  24596,
  47274,
  11693,
  46539,
  60524,
  78595,
  48423,
  31718,
  20170,
  9009,
  146268,
  15183,
  191060,
  172765,
  1349,
  138436,
  37365,
  10970,
  40509,
  225817,
  20021,
  70394,
  152138,
  21541,
  66559,
  66544,
  89352,
  2725,
  17258,
  91345,
  7313,
  3815,
  115868,
  8660,
  40362,
  4071,
  103524,
  39388,
  118275,
  21950,
  6549,
  38226,
  32754,
  209574,
  29201,
  43495,
  18028,
  20296,
  40597,
  18370,
  47520,
  202450,
  24134,
  2219,
  8195,
  69545,
  38041,
  136934,
  46374,
  19041,
  159811,
  84865,
  58620,
  846,
  98749,
  13569,
  30714,
  97246,
  32186,
  4479,
  27355,
  92973,
  35214,
  151491,
  75963,
  37631,
  1561,
  27200,
  238083,
  23182,
  60756,
  12291,
  25766,
  39355,
  102333,
  87362,
  65741,
  59906,
  19538,
  201575,
  48772,
  102938,
  24438,
  292580,
  39964,
  66366,
  9004,
  61379,
  50548,
  37622,
  38732,
  28379,
  68180,
  76622,
  17488,
  69849,
  5963,
  7219,
  48143,
  43413,
  55358,
  540,
  58691,
  29506,
  19245,
  52193,
  48621,
  5518,
  13048,
  118625,
  44755,
  191081,
  42061,
  89197,
  2259,
  60665,
  66994,
  71210,
  51232,
  3585,
  142096,
  55024,
  7892,
  8345,
  58653,
  463307,
  65658,
  64319,
  137941,
  136323,
  53499,
  12746,
  43492,
  6978,
  95163,
  29925,
  60175,
  5128,
  7352,
  41463,
  184756,
  121146,
  20473,
  18426,
  4598,
  5309,
  54580,
  14277,
  121151,
  10691,
  56711,
  43880,
  63409,
  76682,
  11830,
  172218,
  264898,
  32632,
  66536,
  81062,
  31649,
  25788,
  92774,
  60222,
  11100,
  63159,
  9432,
  224657,
  25240,
  53613,
  152,
  138620,
  163829,
  2397,
  85345,
  12501,
  37507,
  64932,
  38575,
  43522,
  65789,
  80198,
  78796,
  35226,
  3851,
  108891,
  73311,
  3060,
  28391,
  93671,
  39663,
  46142,
  30982,
  66041,
  37281,
  68157,
  26553,
  71872,
  81142,
  211527,
  39747,
  118119,
  22695,
  2859,
  11066,
  20232,
  168911,
  7933,
  197005,
  17066,
  111071,
  44434,
  133994,
  120798,
  12766,
  227798,
  45756,
  132852,
  29917,
  36076,
  55352,
  65281,
  129800,
  41958,
  18944,
  84678,
  18580,
  168093,
  132621,
  39997,
  54092,
  27740,
  32354,
  3770,
  114118,
  103242,
  43918,
  15899,
  18574,
  145944,
  3190,
  123469,
  219903,
  24169,
  100571,
  62403,
  16776,
  92779,
  14535,
  17168,
  16475,
  14304,
  37231,
  1712,
  28218,
  242754,
  61688,
  28980,
  1318,
  51359,
  222657,
  99200,
  67989,
  31772,
  23932,
  35351,
  201251,
  49041,
  27306,
  19128,
  40135,
  3986,
  77333,
  19649,
  120683,
  151927,
  21081,
  7076,
  78375,
  77501,
  101599,
  8011,
  89585,
  96715,
  58179,
  5378,
  102138,
  106793,
  26051,
  217276,
  4197,
  16297,
  27014,
  46721,
  13322,
  22806,
  5278,
  29629,
  70632,
  9647,
  71519,
  58818,
  40603,
  128530,
  8903,
  36770,
  56900,
  31483,
  26935,
  43845,
  34265,
  34920,
  87658,
  6114,
  84767,
  64250,
  47318,
  50720,
  19264,
  162514,
  33357,
  13117,
  6705,
  46696,
  75032,
  71054,
  87004,
  42035,
  69138,
  11903,
  99854,
  102328,
  19611,
  34525,
  69312,
  6431,
  49842,
  101600,
  133178,
  108751,
  41829,
  89939,
  225664,
  48916,
  99556,
  9195,
  130387,
  5960,
  36857,
  116724,
  53518,
  94002,
  39077,
  53996,
  6945,
  22261,
  64291,
  8314,
  152785,
  57588,
  16522,
  9091,
  5048,
  87671,
  35441,
  39509,
  1945,
  12423,
  158923,
  178413,
  37549,
  14095,
  1475,
  73188,
  62878,
  4819,
  24012,
  68534,
  42606,
  4010,
  120809,
  57497,
  59564,
  101758,
  103718,
  32701,
  80116,
  12345,
  95834,
  46918,
  21468,
  53213,
  15665,
  31200,
  3867,
  5140,
  96013,
  250744,
  21016,
  10069,
  13968,
  35449,
  180829,
  27683,
  39704,
  59956,
  22893,
  3115,
  26293,
  32785,
  75934,
  62445,
  141162,
  62720,
  2018,
  83638,
  19949,
  114012,
  95006,
  3330,
  99829,
  130935,
  309272,
  9565,
  55874,
  121727,
  37017,
  23586,
  319858,
  40970,
  27602,
  8625,
  112329,
  61060,
  100088,
  118525,
  25922,
  16232,
  1907,
  60671,
  51583,
  44553,
  80993,
  5262,
  94679,
  8676,
  940,
  20736,
  11823,
  3020,
  16476,
  12340,
  152600,
  97416,
  3703,
  25744,
  66826,
  16245,
  16876,
  46446,
  84798,
  74227,
  176020,
  45192,
  61955,
  75496,
  23946,
  23626,
  40372,
  26036,
  6149,
  11822,
  30582,
  16541,
  41914,
  82385,
  232823,
  40921,
  80773,
  14930,
  3631,
  7517,
  39619,
  4348,
  36180,
  126106,
  138939,
  62611,
  1477,
  113512,
  47321,
  25052,
  14546,
  118881,
  29060,
  23589,
  128322,
  36795,
  18401,
  137921,
  104699,
  267929,
  36194,
  172791,
  18113,
  4766,
  188215,
  30083,
  332586,
  94089,
  5805,
  77909,
  22194,
  68234,
  154976,
  43220,
  40660,
  70001,
  184893,
  138095,
  11128,
  103010,
  22663,
  5108,
  212615,
  8485,
  5565,
  49222,
  54614,
  26530,
  42639,
  16319,
  55062,
  152662,
  105595,
  21114,
  22216,
  10294,
  68158,
  10436,
  86950,
  7206,
  62115,
  3977,
  3657,
  59874,
  456,
  118617,
  18156,
  106663,
  112229,
  80992,
  17442,
  8217,
  55551,
  5133,
  34344,
  251927,
  51153,
  39364,
  201321,
  7816,
  66803,
  23057,
  156724,
  145664,
  14276,
  95705,
  979,
  2796,
  6875,
  13429,
  212525,
  50602,
  26276,
  28284,
  3424,
  19465,
  52397,
  46963,
  31420,
  51399,
  206476,
  92317,
  48851,
  637,
  100820,
  83349,
  10317,
  60227,
  21972,
  6908,
  282439,
  32857,
  224767,
  95629,
  83882,
  42106,
  87338,
  69757,
  29840,
  68709,
  37665,
  45244,
  114577,
  49188,
  175943,
  54009,
  186746,
  106158,
  70168,
  3358,
  234002,
  50555,
  9221,
  129338,
  9562,
  20118,
  32923,
  78479,
  118280,
  65752,
  4977,
  10474,
  102174,
  60947,
  129006,
  10570,
  83451,
  8598,
  8078,
  159367,
  123785,
  80438,
  16742,
  5905,
  5281,
  181513,
  42402,
  6977,
  163136,
  93179,
  42191,
  14968,
  50421,
  112401,
  105440,
  33456,
  57347,
  121611,
  4221,
  94954,
  36517,
  24046,
  27796,
  6255,
  33394,
  72990,
  135408,
  116627,
  1233,
  57874,
  25654,
  95419,
  68156,
  401399,
  313338,
  55208,
  45573,
  93124,
  119251,
  47200,
  38196,
  11909,
  130667,
  45391,
  73904,
  64964,
  167846,
  4137,
  115606,
  52036,
  62214,
  7969,
  160925,
  7187,
  1132,
  134835,
  40309,
  73195,
  64494,
  80472,
  444841,
  61111,
  26500,
  45323,
  40743,
  53625,
  52797,
  22659,
  15631,
  29739,
  36706,
  28841,
  39147,
  102836,
  26794,
  10536,
  14845,
  87305,
  45874,
  12241,
  127587,
  83833,
  57183,
  79722,
  30844,
  41304,
  84655,
  20825,
  92500,
  3722,
  25655,
  27811,
  10157,
  81634,
  31362,
  34088,
  92487,
  70123,
  22190,
  185100,
  72658,
  139035,
  192523,
  88241,
  2078,
  230490,
  44528,
  85638,
  100198,
  22088,
  29982,
  291233,
  241062,
  13865,
  4445,
  137791,
  37835,
  107218,
  31726,
  19718,
  38234,
  72528,
  23046,
  19177,
  66695,
  5109,
  17251,
  28077,
  5617,
  21554,
  47839,
  72425,
  133825,
  1486,
  73065,
  181275,
  141508,
  21768,
  62971,
  63082,
  2512,
  34200,
  9904,
  120309,
  6392,
  91243,
  68416,
  268253,
  41199,
  116757,
  138551,
  185526,
  41246,
  28986,
  4093,
  19057,
  17295,
  4148,
  245766,
  122360,
  35356,
  112075,
  20301,
  75441,
  10998,
  7977,
  19769,
  62922,
  937,
  63547,
  100196,
  26427,
  157820,
  20983,
  236696,
  22935,
  8140,
  90315,
  156004,
  47204,
  140973,
  7726,
  45097,
  52725,
  22636,
  23436,
  257282,
  105247,
  522,
  88389,
  216031,
  202204,
  46812,
  211666,
  19693,
  68828,
  81691,
  45925,
  11256,
  30292,
  372,
  5236,
  167826,
  88328,
  232776,
  151611,
  5360,
  82104,
  18841,
  80393,
  25465,
  18285,
  20320,
  72377,
  31730,
  33160,
  45803,
  38715,
  27705,
  37379,
  24163,
  18360,
  103586,
  4015,
  32305,
  269494,
  91252,
  20080,
  36567,
  54650,
  7797,
  57073,
  12650,
  31164,
  42209,
  6375,
  261663,
  105528,
  81661,
  106002,
  2800,
  5375,
  17247,
  43151,
  4442,
  15727,
  194619,
  100855,
  144898,
  62320,
  78465,
  39929,
  16454,
  1967,
  28311,
  61363,
  17219,
  9395,
  8745,
  121445,
  76939,
  80385,
  162380,
  22009,
  54191,
  44248,
  16299,
  122830,
  48151,
  74429,
  78291,
  64755,
  14238,
  44966,
  2511,
  17712,
  67954,
  93583,
  829,
  105899,
  49935,
  84750,
  11591,
  33185,
  85447,
  42717,
  27409,
  208542,
  28965,
  62052,
  52525,
  5597,
  25694,
  65594,
  16343,
  63224,
  276188,
  12475,
  9331,
  127507,
  38522,
  57287,
  24128,
  133161,
  79723,
  105548,
  133695,
  48917,
  27558,
  43278,
  46520,
  13778,
  141954,
  110785,
  83366,
  17715,
  46317,
  105763,
  66298,
  147013,
  41086,
  94180,
  16478,
  220447,
  44611,
  730,
  19722,
  78975,
  117889,
  125643,
  26254,
  16574,
  18480,
  65006,
  15806,
  38549,
  246418,
  46052,
  36056,
  8440,
  34984,
  30170,
  3163,
  59800,
  4458,
  115442,
  4283,
  41970,
  33507,
  104078,
  1653,
  22,
  121158,
  276486,
  3655,
  6338,
  24048,
  133421,
  23641,
  2161,
  24422,
  36006,
  8086,
  10675,
  181474,
  12307,
  29514,
  59143,
  14729,
  52509,
  87128,
  122470,
  19446,
  80852,
  33314,
  24573,
  119864,
  14237,
  9652,
  57779,
  6612,
  51851,
  15284,
  98871,
  90581,
  124466,
  156831,
  21190,
  22015,
  71380,
  161906,
  87247,
  69201,
  18392,
  17908,
  108470,
  72962,
  40719,
  14338,
  17911,
  95260,
  43339,
  20610,
  78916,
  20710,
  72451,
  11315,
  31448,
  17263,
  58853,
  178878,
  48111,
  116002,
  45497,
  80506,
  82605,
  85880,
  36300,
  121755,
  25215,
  36118,
  301929,
  88728,
  405223,
  276136,
  553,
  34704,
  212438,
  49970,
  78329,
  922,
  20711,
  25036,
  257130,
  38295,
  145369,
  18128,
  15385,
  30829,
  55656,
  48345,
  8012,
  3561,
  28004,
  122041,
  192900,
  58338,
  112508,
  41085,
  29976,
  87040,
  47117,
  23905,
  4336,
  92061,
  138880,
  97407,
  42083,
  172121,
  6256,
  25192,
  172671,
  5,
  93568,
  1420,
  12677,
  31605,
  56743,
  40620,
  6015,
  78415,
  231077,
  31298,
  80026,
  13902,
  19048,
  24924,
  170586,
  32955,
  176119,
  87859,
  36731,
  6773,
  27711,
  24658,
  26475,
  115216,
  133207,
  93250,
  95820,
  88522,
  8317,
  5714,
  124047,
  55219,
  86860,
  19677,
  23961,
  22928,
  162209,
  8904,
  225992,
  359835,
  56084,
  96201,
  29392,
  96558,
  86071,
  93643,
  55114,
  13347,
  8183,
  95129,
  82012,
  2017,
  123336,
  34219,
  115554,
  157159,
  47747,
  101684,
  41008,
  18735,
  193781,
  104151,
  226906,
  7552,
  179874,
  124113,
  31159,
  21162,
  44010,
  14771,
  51268,
  166128,
  31382,
  73124,
  77438,
  92830,
  205709,
  12113,
  1292,
  38937,
  13114,
  1334,
  2118,
  15597,
  69581,
  14449,
  21934,
  76618,
  48728,
  67038,
  14967,
  51495,
  24243,
  87736,
  147249,
  26720,
  11119,
  46063,
  43749,
  5843,
  44147,
  152629,
  133428,
  65703,
  14269,
  45604,
  57982,
  28672,
  55616,
  45957,
  8438,
  95433,
  37698,
  220862,
  132034,
  39456,
  61870,
  4161,
  26501,
  73560,
  56418,
  9845,
  4654,
  20916,
  10456,
  88920,
  119358,
  9015,
  65931,
  96507,
  48029,
  38534,
  21676,
  109081,
  43078,
  34943,
  25089,
  6131,
  28766,
  23665,
  5477,
  10255,
  16695,
  67,
  45778,
  42443,
  42770,
  29534,
  23733,
  100513,
  62617,
  42630,
  48746,
  14191,
  43753,
  50295,
  26007,
  8792,
  57243,
  43119,
  54725,
  164253,
  58250,
  112304,
  131796,
  25165,
  4651,
  3188,
  24831,
  47748,
  3705,
  19540,
  13211,
  102095,
  5593,
  18699,
  23666,
  32005,
  117571,
  33541,
  60584,
  74573,
  86311,
  99443,
  25172,
  27222,
  168938,
  7143,
  11853,
  53560,
  18834,
  19960,
  86522,
  28217,
  53266,
  117700,
  72989,
  34323,
  18721,
  66450,
  34346,
  74056,
  47217,
  202002,
  46269,
  9429,
  68582,
  75458,
  37823,
  82843,
  96652,
  32549,
  145144,
  27958,
  19820,
  158086,
  31955,
  201406,
  135379,
  31207,
  192545,
  12950,
  51704,
  9094,
  248263,
  76147,
  64028,
  110009,
  79407,
  89345,
  99284,
  223492,
  47966,
  26848,
  15359,
  201137,
  2861,
  110507,
  71231,
  72297,
  31851,
  118777,
  71039,
  151051,
  240855,
  16333,
  50766,
  14727,
  7939,
  4149,
  80908,
  418780,
  88378,
  59276,
  1327,
  7284,
  38576,
  79814,
  65820,
  42199,
  84860,
  49574,
  62596,
  12396,
  70598,
  40117,
  8648,
  7994,
  16836,
  7630,
  14047,
  359699,
  106878,
  525,
  29037,
  28064,
  13380,
  11675,
  50669,
  74216,
  103539,
  180314,
  27449,
  56299,
  172344,
  19274,
  7301,
  246099,
  32043,
  19422,
  36506,
  129317,
  6806,
  30140,
  4614,
  46639,
  66926,
  932,
  86600,
  6322,
  27847,
  233103,
  10541,
  39025,
  34887,
  3517,
  12972,
  26220,
  2031,
  66561,
  115015,
  48658,
  47596,
  12714,
  33845,
  3893,
  16165,
  35237,
  89983,
  14769,
  11962,
  147224,
  47018,
  29977,
  27979,
  5552,
  82338,
  86023,
  131368,
  1218,
  24853,
  237840,
  132193,
  15455,
  40873,
  3668,
  65351,
  53388,
  15229,
  59889,
  272245,
  47934,
  11858,
  34347,
  18038,
  90853,
  86981,
  300602,
  19343,
  114181,
  29362,
  84921,
  6095,
  106059,
  79472,
  38015,
  1206,
  48741,
  6208,
  8e4,
  21916,
  17423,
  6002,
  108083,
  24479,
  34931,
  56661,
  9511,
  26995,
  100694,
  163853,
  35997,
  81254,
  58321,
  18919,
  171890,
  86877,
  91341,
  74503,
  70477,
  53412,
  7027,
  59281,
  39892,
  131302,
  5864,
  15947,
  61301,
  67466,
  162369,
  47956,
  27874,
  35624,
  282324,
  21270,
  111847,
  102548,
  41482,
  30955,
  116737,
  28264,
  8592,
  55458,
  22301,
  75090,
  29821,
  30697,
  51709,
  3041,
  19208,
  8038,
  24634,
  30467,
  87509,
  126428,
  19389,
  18814,
  152686,
  20701,
  83474,
  45832,
  80891,
  105808,
  11378,
  153223,
  120770,
  98186,
  150633,
  49838,
  9141,
  12755,
  30962,
  5260,
  74490,
  21256,
  31678,
  65062,
  33326,
  289838,
  187831,
  20595,
  89768,
  2805,
  58535,
  10844,
  70085,
  12090,
  2451,
  138068,
  98544,
  24461,
  4511,
  6754,
  41684,
  28203,
  3383,
  65355,
  82833,
  30161,
  83924,
  234361,
  128424,
  28921,
  222594,
  33975,
  125491,
  34069,
  11508,
  67464,
  144226,
  41850,
  98703,
  34371,
  7901,
  21254,
  38398,
  65651,
  23549,
  53883,
  213340,
  123269,
  12028,
  71764,
  177701,
  28758,
  2623,
  68395,
  11549,
  15232,
  68603,
  9660,
  63116,
  36079,
  57093,
  31198,
  20475,
  48467,
  89984,
  35619,
  186847,
  107469,
  31389,
  43631,
  73867,
  41949,
  68841,
  114250,
  1605,
  30564,
  63403,
  17588,
  27680,
  99533,
  12641,
  70325,
  50428,
  73426,
  78379,
  11855,
  91651,
  72081,
  91720,
  60198,
  15743,
  12065,
  83398,
  140046,
  6761,
  46598,
  45900,
  5068,
  886,
  62448,
  148968,
  37347,
  19405,
  9680,
  15819,
  43496,
  63370,
  75667,
  163700,
  37639,
  3633,
  22774,
  34341,
  183131,
  134335,
  37200,
  23915,
  7054,
  14194,
  12970,
  26438,
  13350,
  285521,
  25594,
  8219,
  104410,
  91039,
  168804,
  138480,
  149734,
  15907,
  33818,
  61132,
  60082,
  4622,
  110187,
  56736,
  13551,
  73571,
  3945,
  73463,
  65498,
  17758,
  263266,
  17593,
  2710,
  27585,
  54469,
  38200,
  45367,
  63754,
  28881,
  3473,
  12791,
  98287,
  31895,
  65787,
  4463,
  94536,
  24951,
  36332,
  59901,
  28803,
  52130,
  86403,
  7668,
  181822,
  74831,
  18977,
  9850,
  177206,
  145485,
  109798,
  7292,
  31421,
  26280,
  77211,
  58511,
  12507,
  127004,
  11113,
  147,
  8729,
  56208,
  43066,
  79926,
  129937,
  31345,
  83947,
  39915,
  46146,
  98763,
  42566,
  1337,
  13192,
  18323,
  105163,
  80570,
  117753,
  16555,
  72883,
  11077,
  159438,
  40764,
  70933,
  83329,
  26066,
  12276,
  72059,
  21655,
  173836,
  126713,
  69454,
  153482,
  91585,
  70644,
  102558,
  110483,
  6764,
  127864,
  190133,
  3961,
  101798,
  20945,
  71138,
  82402,
  90884,
  69669,
  44753,
  923,
  16939,
  59700,
  164258,
  25969,
  27082,
  31399,
  43846,
  6306,
  246093,
  51342,
  6153,
  151581,
  202801,
  182731,
  56475,
  162188,
  89426,
  141356,
  14355,
  121815,
  27536,
  28023,
  65257,
  77523,
  106668,
  127314,
  24947,
  12790,
  38796,
  169698,
  23555,
  10725,
  44573,
  183083,
  42088,
  62716,
  43265,
  105958,
  32050,
  44067,
  50118,
  1668,
  3874,
  6243,
  318411,
  16599,
  1691,
  94999,
  52378,
  28671,
  216728,
  123258,
  2059,
  34969,
  69225,
  5913,
  136280,
  171443,
  141515,
  91662,
  22175,
  135282,
  80020,
  92270,
  1663,
  4808,
  4482,
  3495,
  34691,
  5226,
  109830,
  108512,
  17342,
  107488,
  11606,
  123190,
  100247,
  29666,
  146527,
  113014,
  15794,
  30894,
  13224,
  39585,
  243192,
  22351,
  9903,
  7836,
  47699,
  11078,
  25468,
  122291,
  48821,
  26780,
  122679,
  75521,
  81450,
  630,
  4895,
  92900,
  55074,
  74293,
  17441,
  3563,
  111657,
  103102,
  51613,
  12318,
  52370,
  36191,
  68245,
  34269,
  40445,
  41354,
  122901,
  168604,
  182500,
  62012,
  42557,
  11259,
  24428,
  115113,
  86345,
  12362,
  3909,
  78430,
  86852,
  134602,
  20459,
  47853,
  93879,
  22577,
  7659,
  3688,
  38555,
  13349,
  17381,
  56715,
  91639,
  12493,
  10895,
  92438,
  3142,
  37057,
  28928,
  2004,
  36427,
  32268,
  34222,
  209974,
  10432,
  67436,
  41989,
  173518,
  107930,
  27079,
  62729,
  30908,
  55558,
  5828,
  45031,
  14902,
  53546,
  8204,
  144263,
  60255,
  14520,
  88212,
  86582,
  109589,
  69356,
  8064,
  47449,
  8505,
  66558,
  16886,
  4844,
  52817,
  111260,
  215129,
  12941,
  91118,
  650,
  20770,
  6273,
  73089,
  40618,
  62790,
  2873,
  35002,
  14023,
  97208,
  19386,
  102646,
  36993,
  143736,
  135457,
  35385,
  113601,
  17893,
  32627,
  84439,
  100619,
  56016,
  6581,
  57264,
  172160,
  45452,
  111710,
  203627,
  70131,
  24100,
  322787,
  1996,
  35665,
  70078,
  22358,
  90922,
  83658,
  4097,
  63200,
  58499,
  14542,
  99153,
  52159,
  6615,
  12414,
  63415,
  31986,
  16823,
  1579,
  65405,
  137809,
  8841,
  16898,
  48082,
  259,
  33014,
  42375,
  12260,
  179850,
  73667,
  91389,
  98882,
  29532,
  17311,
  326251,
  41092,
  5928,
  20742,
  44964,
  48019,
  43505,
  9317,
  49265,
  6643,
  192712,
  48424,
  163487,
  19861,
  20113,
  70848,
  31928,
  105333,
  23685,
  78563,
  14638,
  54755,
  7158,
  24142,
  44018,
  20774,
  125255,
  20331,
  24280,
  10163,
  1285,
  2336,
  39851,
  4299,
  117269,
  46714,
  63816,
  87779,
  159624,
  11731,
  9971,
  990,
  137317,
  108831,
  50994,
  74554,
  162680,
  23640,
  131597,
  146962,
  170620,
  34829,
  91205,
  21184,
  1913,
  63616,
  18427,
  93136,
  156592,
  17519,
  67565,
  115882,
  138220,
  78622,
  88535,
  18115,
  2711,
  33554,
  109492,
  54298,
  971,
  24914,
  25863,
  36363,
  45715,
  27099,
  194995,
  14299,
  178181,
  111488,
  72395,
  322385,
  157719,
  130787,
  11897,
  81843,
  83999,
  11369,
  49280,
  118604,
  40922,
  61332,
  110343,
  53407,
  75639,
  40582,
  300440,
  54722,
  25637,
  13694,
  48248,
  48278,
  194521,
  56203,
  52779,
  48783,
  72627,
  10953,
  376,
  16733,
  280238,
  26351,
  230789,
  15132,
  25168,
  137270,
  3588,
  63704,
  73376,
  94031,
  74284,
  19443,
  159557,
  9697,
  39901,
  13351,
  119050,
  15406,
  146455,
  3460,
  29556,
  75195,
  37673,
  102524,
  92329,
  47289,
  98413,
  15311,
  100684,
  56345,
  7116,
  95480,
  11590,
  7200,
  167,
  23610,
  58426,
  17730,
  136656,
  27944,
  53151,
  2701,
  8824,
  103124,
  3017,
  90744,
  113588,
  53216,
  79736,
  65940,
  26931,
  498,
  29568,
  80540,
  143543,
  21292,
  1740,
  59268,
  16561,
  180816,
  42323,
  50174,
  40890,
  52866,
  10703,
  57169,
  4700,
  17191,
  4424,
  93511,
  49698,
  166650,
  26972,
  48631,
  165169,
  82879,
  69326,
  202970,
  4007,
  2376,
  231325,
  139592,
  22119,
  62851,
  37504,
  68816,
  58345,
  67398,
  186643,
  43331,
  277416,
  53749,
  15746,
  23102,
  17432,
  4793,
  151138,
  48822,
  54265,
  48203,
  198688,
  14305,
  54287,
  2291,
  18018,
  113378,
  123260,
  7180,
  97549,
  87027,
  120085,
  2920,
  76080,
  8190,
  102005,
  5641,
  64580,
  14955,
  59802,
  54028,
  58884,
  19367,
  81779,
  412567,
  85957,
  97053,
  103637,
  78871,
  29364,
  27637,
  141728,
  4767,
  30686,
  112738,
  130146,
  42745,
  12730,
  105040,
  14844,
  232,
  210944,
  36581,
  152317,
  135543,
  29744,
  3129,
  55647,
  58149,
  46319,
  27265,
  17499,
  28005,
  59948,
  7170,
  34138,
  5702,
  293047,
  110892,
  408,
  91760,
  218674,
  18469,
  46095,
  81403,
  14389,
  4610,
  35672,
  73060,
  11006,
  74848,
  104820,
  118143,
  190357,
  20043,
  105358,
  141735,
  5115,
  27093,
  45924,
  123073,
  52599,
  29433,
  9616,
  238350,
  78610,
  24851,
  58858,
  26769,
  31969,
  24613,
  18294,
  4982,
  32735,
  39639,
  143563,
  112073,
  202205,
  12567,
  4873,
  88601,
  44897,
  81503,
  101648,
  81362,
  34662,
  85277,
  17574,
  48173,
  21435,
  221188,
  40215,
  39576,
  80786,
  26544,
  64668,
  81841,
  10731,
  37733,
  247986,
  149188,
  127703,
  495,
  18382,
  54388,
  72446,
  43071,
  30974,
  198723,
  89608,
  41360,
  190,
  33045,
  8386,
  31658,
  19992,
  237838,
  119015,
  137622,
  50890,
  100913,
  6460,
  116233,
  267230,
  26621,
  104129,
  65114,
  14190,
  41542,
  14888,
  85962,
  23342,
  23041,
  26453,
  43725,
  71809,
  45186,
  4770,
  46452,
  53894,
  56616,
  221286,
  18973,
  9038,
  109299,
  55365,
  19366,
  26863,
  18808,
  60909,
  69353,
  41738,
  83463,
  12100,
  68561,
  72860,
  3980,
  13796,
  49340,
  12332,
  31311,
  27418,
  4255,
  53430,
  18976,
  45523,
  510,
  14224,
  30477,
  26581,
  4530,
  3651,
  101663,
  139840,
  22709,
  150861,
  31996,
  63923,
  120623,
  262522,
  3076,
  10528,
  2929,
  14672,
  130238,
  18087,
  9816,
  121894,
  100308,
  25085,
  55111,
  14565,
  18952,
  53293,
  2042,
  369988,
  23674,
  61789,
  133529,
  28783,
  108293,
  35477,
  47119,
  36448,
  71049,
  40015,
  33055,
  78598,
  198442,
  1833,
  159937,
  40654,
  77444,
  189245,
  113153,
  8621,
  18599,
  38553,
  35223,
  166072,
  2375,
  11659,
  21786,
  89523,
  6032,
  12116,
  63046,
  159398,
  18454,
  3678,
  32521,
  47626,
  11411,
  103527,
  38896,
  42946,
  15696,
  26370,
  10185,
  8413,
  37080,
  165583,
  4331,
  63555,
  14907,
  72220,
  50056,
  6623,
  62236,
  36565,
  49783,
  10049,
  17503,
  100581,
  55951,
  146244,
  24724,
  9626,
  17969,
  25524,
  109300,
  173965,
  99994,
  101056,
  46459,
  43647,
  53737,
  277968,
  8347,
  123521,
  74858,
  33829,
  44762,
  77574,
  877,
  81377,
  222525,
  123532,
  30602,
  43881,
  53145,
  2973,
  16284,
  81940,
  61281,
  127044,
  63620,
  9875,
  14756,
  114829,
  19032,
  9202,
  52759,
  119141,
  23928,
  120551,
  19607,
  3599,
  33401,
  76821,
  73233,
  117430,
  39968,
  36539,
  7071,
  5446,
  121735,
  194059,
  15206,
  45283,
  6706,
  15603,
  65615,
  1207,
  165723,
  92275,
  34773,
  104447,
  8396,
  32353,
  205240,
  164323,
  13600,
  60555,
  79205,
  25532,
  22907,
  33410,
  57480,
  107111,
  69630,
  32137,
  47832,
  70913,
  33161,
  20321,
  2371,
  117348,
  10714,
  86246,
  1625,
  11763,
  17900,
  268,
  78457,
  99175,
  97940,
  101092,
  86660,
  32221,
  14041,
  128504,
  125080,
  53744,
  124263,
  31017,
  13897,
  403,
  31859,
  21964,
  5633,
  111630,
  5547,
  77329,
  17961,
  18241,
  84995,
  25984,
  12983,
  67491,
  62168,
  47262,
  5241,
  297,
  51191,
  7351,
  8967,
  147212,
  82060,
  16821,
  782,
  11033,
  82431,
  62957,
  5026,
  43459,
  77963,
  203477,
  53528,
  6247,
  191852,
  87774,
  74164,
  215654,
  13467,
  1522,
  219964,
  28589,
  244104,
  16242,
  117821,
  67725,
  72570,
  156792,
  17186,
  15979,
  26990,
  44128,
  193014,
  35276,
  57125,
  16212,
  166451,
  68017,
  6905,
  77608,
  16364,
  53777,
  75921,
  76426,
  37975,
  26203,
  269296,
  64099,
  84122,
  12077,
  38533,
  830,
  4407,
  20139,
  963,
  43028,
  38902,
  42911,
  37503,
  83343,
  85045,
  16979,
  1165,
  60835,
  137387,
  58380,
  86990,
  110066,
  134540,
  56331,
  193845,
  81238,
  17922,
  163093,
  38744,
  110641,
  12502,
  56404,
  34862,
  26865,
  125964,
  12965,
  111648,
  25547,
  7771,
  27196,
  136980,
  9555,
  29551,
  107158,
  57885,
  18831,
  37705,
  35505,
  101742,
  13970,
  102109,
  62548,
  124657,
  23328,
  11124,
  89592,
  146376,
  248050,
  6241,
  22033,
  18337,
  80685,
  29898,
  11908,
  216623,
  67721,
  106162,
  146610,
  21377,
  15085,
  91552,
  42041,
  62560,
  122532,
  125336,
  102365,
  121537,
  142559,
  29693,
  223919,
  11515,
  110495,
  18776,
  22494,
  5895,
  185059,
  103592,
  229351,
  51220,
  100102,
  37027,
  257855,
  29359,
  54123,
  36066,
  106493,
  12244,
  79258,
  32002,
  432,
  56205,
  94836,
  90182,
  6726,
  14762,
  29391,
  48938,
  26864,
  38083,
  60364,
  3310,
  60192,
  14766,
  205567,
  57504,
  110760,
  22649,
  24666,
  46333,
  21517,
  3430,
  13135,
  28873,
  27052,
  158809,
  11597,
  20529,
  6695,
  23138,
  22960,
  37137,
  45574,
  6545,
  305877,
  43423,
  26153,
  24769,
  59844,
  14501,
  10430,
  134352,
  56169,
  13213,
  103432,
  49523,
  35181,
  13435,
  12408,
  129475,
  64620,
  230854,
  77390,
  51990,
  15653,
  83248,
  33466,
  44571,
  117828,
  51481,
  2187,
  10559,
  68019,
  18021,
  54895,
  48247,
  18354,
  33737,
  4554,
  108595,
  37288,
  39767,
  116707,
  9175,
  3726,
  108877,
  21616,
  83684,
  49862,
  1938,
  8543,
  276466,
  20134,
  108498,
  48770,
  102254,
  31914,
  131520,
  185291,
  100559,
  51890,
  209,
  19526,
  76471,
  50544,
  71814,
  99351,
  8172,
  198526,
  28816,
  20419,
  9109,
  98389,
  136777,
  76479,
  75596,
  30635,
  165417,
  48216,
  120220,
  25955,
  211071,
  39314,
  24308,
  32164,
  2559,
  146280,
  43403,
  9233,
  17947,
  90585,
  1786,
  86920,
  125662,
  2457,
  64741,
  32152,
  32918,
  122882,
  78538,
  44001,
  31723,
  56426,
  23375,
  103172,
  88177,
  145697,
  52506,
  49319,
  68016,
  31664,
  41488,
  18486,
  110400,
  7030,
  28241,
  986,
  109199,
  19900,
  42147,
  56864,
  65287,
  49183,
  7858,
  24e3,
  30453,
  840,
  16673,
  25907,
  68916,
  89927,
  6309,
  158335,
  36407,
  199737,
  130464,
  13137,
  59603,
  201778,
  195292,
  21015,
  42466,
  179062,
  172561,
  89492,
  11075,
  180407,
  31868,
  72493,
  20998,
  60217,
  9865,
  19530,
  39274,
  130266,
  54539,
  21623,
  12535,
  13505,
  40641,
  73375,
  4087,
  85633,
  2153,
  3117,
  70680,
  55788,
  92096,
  47509,
  98493,
  37490,
  271936,
  151475,
  3032,
  16171,
  96642,
  34106,
  78425,
  125761,
  19591,
  3366,
  19316,
  54508,
  24183,
  50786,
  194248,
  91528,
  33253,
  34622,
  108355,
  41741,
  705,
  3814,
  3883,
  108929,
  13203,
  67831,
  10142,
  59754,
  68208,
  29128,
  84820,
  56880,
  38794,
  24972,
  48571,
  40821,
  40476,
  18137,
  164254,
  24064,
  236309,
  79181,
  11282,
  395,
  39169,
  2013,
  51587,
  28551,
  9645,
  701,
  109513,
  115899,
  113566,
  12762,
  62045,
  58322,
  103726,
  41343,
  40866,
  244102,
  143816,
  2490,
  70346,
  40973,
  52618,
  15412,
  30720,
  104315,
  38917,
  42027,
  93676,
  17513,
  107418,
  20706,
  123890,
  13399,
  97727,
  24044,
  87962,
  65606,
  44250,
  98044,
  65276,
  74790,
  101473,
  19350,
  91570,
  1326,
  87790,
  172042,
  7577,
  100813,
  86896,
  85891,
  41512,
  108130,
  27794,
  14875,
  71431,
  12835,
  156250,
  58135,
  3759,
  22476,
  42176,
  115873,
  34686,
  56523,
  73643,
  108505,
  51491,
  20838,
  12721,
  32863,
  45700,
  29496,
  13700,
  34294,
  55360,
  29206,
  155942,
  123812,
  7706,
  163234,
  203,
  132720,
  49358,
  144431,
  8130,
  175788,
  35818,
  3270,
  76832,
  25710,
  54095,
  97274,
  28779,
  94621,
  74396,
  19092,
  128242,
  58067,
  20885,
  14670,
  93255,
  15107,
  63291,
  23654,
  126900,
  129421,
  59294,
  262659,
  9798,
  3251,
  67344,
  28600,
  44629,
  50672,
  29072,
  26999,
  31526,
  23183,
  49175,
  165843,
  175455,
  17282,
  175411,
  32022,
  45989,
  30298,
  90690,
  78118,
  83156,
  23749,
  35636,
  31317,
  7069,
  80381,
  94561,
  133756,
  14960,
  97404,
  6138,
  41065,
  78041,
  32843,
  16601,
  34123,
  9559,
  146529,
  123377,
  96395,
  54441,
  42012,
  84257,
  123541,
  10745,
  22139,
  106459,
  11720,
  150883,
  172651,
  154996,
  110538,
  4728,
  53447,
  25704,
  2009,
  71152,
  119354,
  21166,
  66604,
  1429,
  216162,
  8637,
  122250,
  63520,
  27180,
  29172,
  36124,
  276428,
  107787,
  77184,
  4680,
  14952,
  104903,
  24418,
  14793,
  51561,
  52931,
  8371,
  26342,
  48526,
  7118,
  92066,
  67280,
  40653,
  8847,
  34597,
  105438,
  14198,
  50163,
  61188,
  146286,
  50315,
  41205,
  170829,
  161496,
  585,
  197359,
  95056,
  1687,
  365794,
  91349,
  48507,
  5804,
  49263,
  5146,
  104902,
  96365,
  117343,
  132222,
  46084,
  96919,
  16875,
  8073,
  262381,
  79982,
  52663,
  13928,
  16056,
  153908,
  15145,
  109256,
  132308,
  18763,
  24904,
  167644,
  13618,
  40750,
  18686,
  147124,
  114709,
  150038,
  52849,
  2938,
  12568,
  48617,
  8778,
  5459,
  44202,
  44591,
  74914,
  17183,
  248689,
  13878,
  7822,
  80060,
  23116,
  194037,
  18487,
  2067,
  7798,
  43077,
  33678,
  244028,
  31320,
  74273,
  2794,
  19466,
  8218,
  36280,
  183997,
  48124,
  19416,
  29656,
  19280,
  98734,
  7715,
  18311,
  30701,
  133602,
  150307,
  126956,
  7378,
  2933,
  79903,
  13178,
  12593,
  86571,
  26604,
  92446,
  13574,
  44205,
  65699,
  427599,
  21118,
  8245,
  14407,
  27877,
  47936,
  33542,
  7916,
  26460,
  117762,
  21596,
  37818,
  2249,
  127359,
  209394,
  60044,
  47677,
  308089,
  36791,
  154971,
  31417,
  6998,
  150042,
  174360,
  12255,
  43009,
  29335,
  48739,
  3912,
  101398,
  53340,
  2580,
  146939,
  151295,
  45360,
  125275,
  15273,
  45383,
  27456,
  48761,
  23314,
  8750,
  60801,
  85823,
  104759,
  27894,
  123685,
  66968,
  39480,
  26917,
  55290,
  83305,
  2696,
  98390,
  57569,
  145853,
  340733,
  4919,
  20024,
  52268,
  30884,
  7413,
  203685,
  70989,
  112855,
  4129,
  50536,
  349518,
  68205,
  332641,
  159581,
  135361,
  236026,
  37563,
  176404,
  64899,
  6578,
  122033,
  63871,
  1850,
  85234,
  82089,
  66124,
  74145,
  121098,
  107351,
  12687,
  36881,
  117334,
  13136,
  14698,
  85933,
  93866,
  18047,
  32620,
  310,
  15094,
  46e3,
  88451,
  23632,
  36645,
  27940,
  87618,
  80520,
  58892,
  20976,
  27702,
  140090,
  96075,
  67841,
  103292,
  238964,
  87778,
  107338,
  17019,
  83427,
  67522,
  7302,
  8261,
  47570,
  116787,
  8730,
  80484,
  61772,
  174422,
  56005,
  131193,
  52875,
  14588,
  28471,
  59817,
  9586,
  15720,
  158155,
  51307,
  109734,
  15196,
  11025,
  59331,
  3884,
  52626,
  102602,
  84797,
  25158,
  27314,
  4437,
  20488,
  76214,
  189248,
  35023,
  114952,
  157376,
  2827,
  62439,
  102878,
  129749,
  36405,
  10329,
  109339,
  108633,
  36662,
  1254,
  13267,
  5470,
  87105,
  58004,
  15397,
  10434,
  159667,
  21864,
  52022,
  179464,
  3013,
  32147,
  31496,
  116832,
  18494,
  105502,
  129227,
  107267,
  50033,
  13481,
  9954,
  24267,
  22141,
  16257,
  116154,
  36185,
  950,
  115685,
  11305,
  176708,
  2048,
  178671,
  112573,
  287867,
  162328,
  497663,
  95170,
  50979,
  193861,
  50987,
  30368,
  136257,
  31830,
  46549,
  15119,
  169876,
  23788,
  17462,
  249887,
  57377,
  1949,
  35448,
  14791,
  43769,
  210091,
  3783,
  34612,
  282103,
  88380,
  245190,
  5457,
  20491,
  98908,
  11402,
  86899,
  117916,
  16028,
  162584,
  60644,
  320177,
  156096,
  31065,
  55876,
  22e3,
  77655,
  9992,
  23397,
  13757,
  317623,
  63978,
  215255,
  2443,
  17648,
  93231,
  27388,
  104529,
  93807,
  55505,
  140477,
  12046,
  112040,
  70887,
  40152,
  94365,
  112353,
  25063,
  114679,
  266061,
  71248,
  119555,
  15589,
  2244,
  617,
  14129,
  211431,
  70110,
  100652,
  7777,
  4383,
  85911,
  89221,
  21010,
  120615,
  58357,
  86405,
  37554,
  41647,
  18,
  15143,
  69662,
  60491,
  14714,
  186134,
  148344,
  42347,
  5410,
  168175,
  44535,
  42449,
  343894,
  129417,
  99682,
  20659,
  27272,
  140483,
  63455,
  222159,
  17536,
  13722,
  42637,
  62324,
  11976,
  114691,
  148109,
  2283,
  32057,
  182393,
  4295,
  147364,
  33705,
  2075,
  44303,
  30274,
  28331,
  63740,
  69740,
  29148,
  10346,
  44862,
  33716,
  73937,
  153333,
  12930,
  38784,
  247159,
  2515,
  41053,
  20256,
  83368,
  256189,
  54639,
  115240,
  5096,
  24661,
  175419,
  153552,
  26516,
  141,
  138176,
  63885,
  34115,
  47222,
  55709,
  2765,
  28479,
  38875,
  236608,
  12229,
  22921,
  77291,
  54426,
  45388,
  2860,
  57787,
  114579,
  295139,
  105782,
  17826,
  71066,
  19119,
  54364,
  69385,
  16568,
  12323,
  28057,
  33346,
  34919,
  124763,
  155533,
  101386,
  31644,
  8627,
  49001,
  303600,
  29868,
  63213,
  9103,
  77280,
  71333,
  9696,
  138789,
  37059,
  24823,
  5057,
  21352,
  32368,
  114208,
  56803,
  19424,
  10445,
  58514,
  8661,
  209508,
  26187,
  171838,
  10460,
  63454,
  14016,
  122504,
  41328,
  21329,
  46618,
  32493,
  38225,
  7855,
  31763,
  7945,
  29876,
  8734,
  6438,
  24205,
  97490,
  139977,
  130740,
  47323,
  33195,
  85390,
  57194,
  13813,
  60600,
  21313,
  96251,
  7699,
  27584,
  170521,
  139271,
  1363,
  4402,
  336738,
  129223,
  84983,
  69150,
  13147,
  3590,
  163929,
  207225,
  155260,
  55916,
  20288,
  4503,
  8398,
  98490,
  11773,
  27512,
  37113,
  84976,
  86558,
  28365,
  11756,
  116005,
  182148,
  13733,
  115313,
  47644,
  67208,
  85069,
  9347,
  14995,
  226141,
  14704,
  101835,
  41159,
  35314,
  13113,
  63526,
  214039,
  29978,
  50446,
  83339,
  17440,
  129441,
  72522,
  118641,
  97816,
  24907,
  73844,
  15717,
  118884,
  167255,
  96509,
  162793,
  30847,
  36849,
  51297,
  78974,
  77793,
  10427,
  1873,
  2972,
  9999,
  35074,
  28190,
  64297,
  146836,
  46298,
  60038,
  163007,
  108919,
  61219,
  2403,
  75022,
  127339,
  4233,
  110389,
  69022,
  9833,
  128097,
  88016,
  79390,
  222936,
  22570,
  94657,
  28462,
  56956,
  38803,
  81536,
  30474,
  152794,
  19566,
  16481,
  147408,
  74574,
  81895,
  20731,
  1918,
  1366,
  76367,
  187321,
  54494,
  24366,
  21690,
  61696,
  33283,
  107477,
  77499,
  31112,
  414383,
  74362,
  18463,
  218441,
  120929,
  59848,
  258629,
  201924,
  69269,
  454,
  19989,
  13054,
  59894,
  3623,
  58908,
  20681,
  35723,
  78523,
  102680,
  38988,
  184112,
  108087,
  50944,
  132704,
  52966,
  21699,
  18860,
  96349,
  201411,
  82697,
  85395,
  95658,
  5093,
  6427,
  177894,
  44191,
  32755,
  26961,
  155739,
  6249,
  31310,
  81030,
  26574,
  84311,
  120155,
  86730,
  113535,
  7424,
  48888,
  13516,
  45747,
  98098,
  20077,
  183995,
  81945,
  43210,
  26704,
  40420,
  75831,
  45648,
  11180,
  6855,
  57927,
  65528,
  124096,
  34851,
  2598,
  156633,
  107572,
  127352,
  38169,
  123845,
  60142,
  62722,
  105584,
  232364,
  23211,
  68120,
  1601,
  22169,
  89299,
  747,
  258039,
  80572,
  7258,
  152249,
  11862,
  101204,
  8834,
  121434,
  33761,
  19175,
  133142,
  46343,
  40178,
  48723,
  3589,
  41977,
  30210,
  38868,
  62257,
  10087,
  82658,
  87827,
  90646,
  16415,
  47552,
  351723,
  28298,
  72225,
  91146,
  272760,
  1701,
  11295,
  1652,
  109651,
  300747,
  51863,
  198800,
  29446,
  11794,
  32345,
  37538,
  22356,
  33102,
  37590,
  113544,
  37970,
  11478,
  179743,
  25454,
  103417,
  59905,
  221970,
  105196,
  145604,
  7817,
  164809,
  102360,
  16974,
  75840,
  255333,
  56902,
  6659,
  1954,
  645,
  59400,
  67769,
  7689,
  18675,
  5215,
  13793,
  20536,
  27852,
  3387,
  29523,
  259718,
  16860,
  94625,
  43143,
  29245,
  15848,
  233581,
  22685,
  63631,
  78557,
  22836,
  133302,
  84513,
  1348,
  51826,
  47129,
  98836,
  58284,
  1830,
  1749,
  94642,
  10933,
  6145,
  12506,
  10975,
  13879,
  103781,
  144434,
  10268,
  28409,
  32346,
  52968,
  121567,
  107374,
  77268,
  23686,
  35097,
  10501,
  155275,
  15303,
  47136,
  21102,
  168741,
  55332,
  90385,
  15996,
  84817,
  681,
  137803,
  25054,
  142275,
  6163,
  38175,
  8056,
  124296,
  240642,
  65621,
  4934,
  178205,
  16101,
  62803,
  60964,
  18230,
  100622,
  76465,
  44689,
  14545,
  9543,
  47514,
  16852,
  93380,
  28048,
  12047,
  107106,
  37575,
  101485,
  77047,
  57326,
  34819,
  96137,
  76916,
  6469,
  46264,
  115983,
  75768,
  87668,
  69942,
  13027,
  165,
  8373,
  114231,
  26434,
  52844,
  42799,
  182044,
  23580,
  146254,
  38081,
  43236,
  33883,
  146220,
  382894,
  14606,
  46035,
  36481,
  166621,
  35417,
  95382,
  2957,
  59384,
  60428,
  36358,
  66343,
  75378,
  22267,
  22950,
  83528,
  17577,
  56474,
  25285,
  4619,
  179691,
  75355,
  95836,
  53295,
  34588,
  171410,
  4487,
  14679,
  84208,
  44015,
  18562,
  109133,
  54101,
  11531,
  86052,
  174479,
  303157,
  28095,
  9953,
  35642,
  14564,
  39802,
  16145,
  77606,
  117406,
  53038,
  121117,
  53624,
  22062,
  1212,
  7632,
  127157,
  237292,
  189087,
  10478,
  127345,
  102515,
  181997,
  86752,
  87623,
  10966,
  121602,
  68783,
  68681,
  83042,
  114380,
  138349,
  191305,
  67176,
  50085,
  39016,
  1427,
  42384,
  1412,
  67118,
  122616,
  72389,
  25260,
  2237,
  13576,
  137346,
  19938,
  20304,
  2191,
  68759,
  5373,
  61364,
  238507,
  75814,
  23931,
  69565,
  38993,
  131741,
  38364,
  12528,
  87762,
  5679,
  129853,
  5310,
  186831,
  32653,
  90338,
  260176,
  389531,
  108118,
  26843,
  43985,
  50175,
  30563,
  25106,
  56965,
  18130,
  140428,
  4542,
  165503,
  117991,
  24219,
  229605,
  1819,
  129663,
  1240,
  3797,
  76093,
  18398,
  71339,
  51919,
  93043,
  27175,
  47060,
  216257,
  6483,
  35051,
  1217,
  16512,
  80798,
  129064,
  13225,
  69339,
  8548,
  237079,
  72298,
  2575,
  34280,
  51379,
  117910,
  55671,
  53345,
  247552,
  29486,
  39328,
  140821,
  34681,
  57045,
  60177,
  5004,
  90269,
  78522,
  2479,
  322607,
  48474,
  61296,
  13057,
  31558,
  4678,
  59271,
  6699,
  27044,
  31988,
  35944,
  12503,
  83480,
  4389,
  136508,
  3781,
  114121,
  70279,
  4488,
  155829,
  42214,
  2898,
  68191,
  75695,
  305850,
  45041,
  74344,
  106509,
  30087,
  17429,
  93292,
  12477,
  290,
  23080,
  114802,
  35714,
  18751,
  26554,
  105424,
  17775,
  2144,
  2412,
  100610,
  65192,
  113975,
  52975,
  180272,
  135050,
  129815,
  76238,
  106483,
  21440,
  63186,
  4260,
  46189,
  9711,
  28249,
  4169,
  23429,
  23390,
  8324,
  141585,
  63809,
  67668,
  38457,
  38063,
  39226,
  59972,
  1189,
  203916,
  62368,
  14403,
  16949,
  61767,
  85801,
  1739,
  40147,
  35049,
  76757,
  33124,
  62102,
  15780,
  103593,
  103009,
  53484,
  22952,
  67973,
  114645,
  6566,
  5245,
  50462,
  7601,
  8288,
  3513,
  194571,
  80276,
  1908,
  54592,
  5124,
  58571,
  2513,
  6800,
  273997,
  193904,
  1119,
  17991,
  117245,
  2508,
  129156,
  82366,
  26278,
  71465,
  63341,
  56943,
  39662,
  106116,
  94966,
  156875,
  9736,
  2204,
  122308,
  94418,
  27134,
  1280,
  24539,
  49022,
  45314,
  3764,
  50904,
  46424,
  30699,
  28087,
  293839,
  9400,
  33646,
  40165,
  822,
  147499,
  50263,
  116179,
  29085,
  11863,
  31314,
  5578,
  17797,
  5104,
  12454,
  1604,
  15342,
  219206,
  10232,
  67800,
  94261,
  25872,
  13565,
  90339,
  78971,
  75377,
  26649,
  41184,
  47695,
  11514,
  35369,
  20767,
  14227,
  41953,
  309396,
  148270,
  147938,
  33074,
  14453,
  27499,
  109019,
  39018,
  25738,
  240196,
  158931,
  52820,
  8612,
  95853,
  21524,
  137010,
  84901,
  70869,
  70021,
  116794,
  48404,
  38771,
  6732,
  1070,
  70990,
  187297,
  49140,
  5238,
  576,
  3564,
  253975,
  16027,
  16483,
  2811,
  37775,
  19034,
  25259,
  4053,
  2e3,
  70083,
  95774,
  19713,
  33431,
  92703,
  91314,
  42381,
  288770,
  48194,
  95985,
  3991,
  77418,
  13406,
  241328,
  245086,
  56533,
  35275,
  62725,
  9246,
  51924,
  70181,
  95331,
  16163,
  31410,
  79016,
  39312,
  120878,
  119371,
  275987,
  80124,
  27712,
  9186,
  220,
  23598,
  146167,
  85209,
  68238,
  282190,
  57048,
  31273,
  30555,
  80913,
  17594,
  75779,
  59160,
  135002,
  101219,
  189377,
  29225,
  96735,
  60126,
  62522,
  104e3,
  27620,
  86814,
  17240,
  147533,
  11001,
  5425,
  43682,
  410,
  49460,
  87270,
  69480,
  46315,
  59448,
  1816,
  76201,
  9431,
  11788,
  87960,
  29063,
  65539,
  47347,
  11678,
  33846,
  7008,
  196704,
  9895,
  6753,
  8633,
  120892,
  59970,
  572824,
  115934,
  6646,
  202559,
  892,
  48351,
  37611,
  251282,
  57823,
  67263,
  57750,
  26527,
  34485,
  90747,
  7685,
  88370,
  6144,
  64182,
  1709,
  41969,
  21458,
  62327,
  181657,
  49247,
  225330,
  122600,
  114574,
  107124,
  85361,
  111833,
  63243,
  71420,
  15655,
  191178,
  72430,
  18063,
  51425,
  54002,
  12364,
  53225,
  86557,
  18193,
  97580,
  41232,
  138398,
  67821,
  128724,
  8944,
  233212,
  101353,
  52099,
  42127,
  14006,
  120107,
  32789,
  32132,
  3498,
  18123,
  33758,
  56058,
  5779,
  128760,
  59888,
  98869,
  18445,
  84702,
  51911,
  13234,
  218379,
  20093,
  39031,
  8074,
  70195,
  20708,
  23462,
  24355,
  131384,
  60189,
  26390,
  10403,
  41060,
  7140,
  10781,
  49410,
  42261,
  87202,
  82566,
  41663,
  43105,
  60276,
  2768,
  5733,
  74176,
  28329,
  2297,
  145430,
  131632,
  83615,
  122915,
  105441,
  655,
  224102,
  5284,
  136426,
  67763,
  16294,
  188511,
  32538,
  61049,
  27893,
  3394,
  13951,
  159099,
  28542,
  17930,
  145360,
  9492,
  190122,
  32285,
  78855,
  26440,
  13570,
  58648,
  73908,
  4239,
  124561,
  2444,
  74172,
  53131,
  11468,
  10794,
  73566,
  11623,
  35343,
  64710,
  30481,
  4163,
  10328,
  38309,
  29901,
  10538,
  154377,
  76132,
  92405,
  24839,
  11679,
  3465,
  13449,
  11637,
  7824,
  2337,
  57754,
  1260,
  14458,
  41118,
  19878,
  38661,
  13416,
  159180,
  37074,
  163164,
  54137,
  28627,
  52134,
  184900,
  8520,
  40385,
  29546,
  30502,
  22386,
  66527,
  107458,
  6850,
  24022,
  47983,
  30603,
  35083,
  8934,
  304066,
  39500,
  9,
  28261,
  33026,
  77251,
  9374,
  44833,
  116312,
  34990,
  29236,
  63563,
  125639,
  135405,
  165398,
  159055,
  55690,
  88141,
  69643,
  236964,
  31983,
  25572,
  20436,
  36746,
  60896,
  31850,
  16179,
  11828,
  5888,
  3043,
  66368,
  9750,
  31167,
  7915,
  53111,
  36430,
  1333,
  64344,
  93659,
  20061,
  60596,
  180191,
  51630,
  6792,
  30244,
  43509,
  101058,
  22409,
  420,
  44210,
  109783,
  43223,
  27030,
  72477,
  72831,
  32679,
  29235,
  7675,
  47556,
  12258,
  39907,
  149412,
  84926,
  118247,
  24692,
  71717,
  105038,
  86009,
  45941,
  41189,
  89453,
  29856,
  52543,
  30627,
  226798,
  67303,
  59230,
  67415,
  34408,
  1367,
  99685,
  16867,
  128419,
  52147,
  4111,
  125381,
  117881,
  16173,
  44093,
  102224,
  31575,
  23234,
  24870,
  83790,
  127407,
  239098,
  3200,
  994,
  1255,
  100903,
  242275,
  117266,
  55116,
  38205,
  16140,
  29662,
  11307,
  40414,
  208793,
  123355,
  56470,
  4862,
  75600,
  30119,
  58218,
  70828,
  24075,
  26974,
  7802,
  192353,
  4851,
  5475,
  78720,
  66596,
  3409,
  28573,
  64396,
  30381,
  30690,
  59859,
  88256,
  5406,
  99945,
  103064,
  34463,
  37727,
  24238,
  86643,
  60088,
  4057,
  23741,
  5967,
  162904,
  38240,
  28356,
  93858,
  25510,
  122879,
  6897,
  3278,
  7057,
  11971,
  4400,
  35461,
  211413,
  21395,
  59615,
  39471,
  87233,
  55795,
  128426,
  3051,
  22470,
  41950,
  14705,
  3974,
  180108,
  80476,
  78442,
  204996,
  91987,
  15634,
  67610,
  139015,
  142373,
  35611,
  51134,
  10387,
  4353,
  153456,
  57749,
  181039,
  14183,
  68447,
  151532,
  21107,
  36452,
  20551,
  3186,
  46247,
  46383,
  129666,
  88736,
  140662,
  146243,
  2066,
  8360,
  7978,
  64818,
  106963,
  17896,
  47801,
  10723,
  114821,
  223295,
  74192,
  3293,
  3393,
  16987,
  74064,
  11277,
  91622,
  4270,
  29828,
  27951,
  387869,
  103235,
  1374,
  61988,
  120083,
  477,
  145892,
  128378,
  11779,
  211263,
  61354,
  18221,
  17869,
  46530,
  83061,
  108538,
  157981,
  90608,
  67199,
  95080,
  49064,
  195814,
  12302,
  66307,
  10348,
  231346,
  160732,
  112859,
  63633,
  146558,
  21271,
  31037,
  198802,
  47622,
  12862,
  95710,
  3910,
  77850,
  73961,
  85585,
  34752,
  61e3,
  4082,
  24595,
  103679,
  71107,
  8208,
  79568,
  150019,
  16615,
  24961,
  139857,
  32664,
  197366,
  4559,
  54735,
  32696,
  4126,
  162019,
  75698,
  13916,
  70108,
  159638,
  19834,
  9349,
  24675,
  175560,
  49643,
  18206,
  52459,
  27992,
  10809,
  88865,
  401975,
  133172,
  29e3,
  34558,
  30915,
  3658,
  25834,
  42430,
  36562,
  125265,
  18182,
  10155,
  40149,
  97082,
  208980,
  19575,
  60853,
  90529,
  66545,
  9600,
  789,
  46420,
  2317,
  88593,
  55595,
  98980,
  115302,
  5742,
  169155,
  1073,
  177901,
  3472,
  11189,
  63711,
  78643,
  65472,
  50459,
  127979,
  93,
  42202,
  67053,
  21720,
  157650,
  11145,
  141378,
  42033,
  22824,
  85705,
  79114,
  35584,
  15974,
  1510,
  54172,
  28562,
  12451,
  104226,
  19190,
  97151,
  73024,
  20948,
  5151,
  81741,
  21499,
  29006,
  84183,
  198074,
  54003,
  45120,
  170125,
  26240,
  35177,
  28389,
  64863,
  79974,
  60778,
  176915,
  232183,
  45342,
  2038,
  80253,
  41564,
  40703,
  32689,
  5430,
  100689,
  5366,
  23007,
  134279,
  14266,
  26712,
  73993,
  24934,
  64242,
  52113,
  102887,
  61801,
  46415,
  201049,
  54251,
  62133,
  122757,
  164883,
  30815,
  139966,
  2319,
  30842,
  766,
  13362,
  10287,
  134518,
  86111,
  81665,
  82440,
  28333,
  43019,
  18963,
  8804,
  161944,
  23439,
  102144,
  101145,
  80029,
  39052,
  248708,
  30350,
  117340,
  11878,
  128467,
  974,
  138625,
  63961,
  5237,
  74778,
  61834,
  67040,
  43814,
  13690,
  65947,
  33809,
  232476,
  115258,
  181745,
  28824,
  94013,
  9510,
  10246,
  93722,
  81976,
  7217,
  114383,
  3493,
  16014,
  69045,
  72692,
  12145,
  80981,
  9507,
  6692,
  1620,
  60820,
  330444,
  35474,
  33962,
  4797,
  7053,
  295463,
  46445,
  27026,
  12491,
  77988,
  49524,
  35675,
  90947,
  29114,
  166705,
  101385,
  133782,
  32704,
  6186,
  84595,
  176031,
  185623,
  45966,
  151302,
  63069,
  1699,
  107491,
  947,
  15458,
  74452,
  196212,
  6046,
  10498,
  12163,
  10239,
  35191,
  243951,
  9277,
  9090,
  29539,
  54460,
  22820,
  26514,
  112549,
  60372,
  51753,
  48756,
  21812,
  70861,
  260326,
  41,
  44222,
  10441,
  16961,
  48148,
  138771,
  216194,
  5914,
  52153,
  53400,
  212036,
  56519,
  26245,
  10117,
  45888,
  15294,
  138019,
  90913,
  26368,
  43842,
  42111,
  23348,
  6082,
  194845,
  161089,
  156206,
  51546,
  11647,
  30759,
  302912,
  262094,
  8635,
  78876,
  26535,
  35283,
  54183,
  31183,
  85484,
  147873,
  12989,
  5197,
  6356,
  72894,
  65347,
  20150,
  27370,
  73787,
  1493,
  45918,
  12366,
  190217,
  20724,
  13858,
  10981,
  67449,
  81213,
  7553,
  14115,
  72242,
  271517,
  11842,
  48310,
  88743,
  143726,
  22177,
  3290,
  243231,
  58452,
  62937,
  12592,
  1654,
  40066,
  33477,
  13751,
  9921,
  128442,
  15868,
  7106,
  75236,
  83773,
  10775,
  36938,
  10482,
  170465,
  17368,
  17469,
  161508,
  32752,
  98340,
  800,
  19824,
  264456,
  3901,
  87319,
  2867,
  26782,
  9630,
  113102,
  185815,
  24197,
  44584,
  86366,
  40224,
  3636,
  140916,
  31731,
  267731,
  9567,
  53678,
  72984,
  29389,
  27963,
  17106,
  50282,
  284911,
  60170,
  8322,
  12608,
  23374,
  89652,
  5268,
  39044,
  229766,
  8869,
  151350,
  31436,
  177342,
  12269,
  183212,
  120418,
  116270,
  2843,
  78888,
  69192,
  7865,
  184099,
  1086,
  129897,
  18383,
  70508,
  20242,
  18508,
  229924,
  124569,
  35749,
  50589,
  55626,
  9884,
  83115,
  40971,
  30671,
  18135,
  14452,
  38861,
  17844,
  201826,
  5549,
  26413,
  17189,
  13561,
  38539,
  10679,
  143331,
  3314,
  36785,
  171194,
  49685,
  187713,
  67506,
  4618,
  104039,
  17060,
  195080,
  50648,
  33159,
  19238,
  67559,
  134840,
  28599,
  157523,
  17130,
  38064,
  117398,
  94355,
  31918,
  13575,
  34538,
  40326,
  13997,
  3494,
  348283,
  62481,
  26862,
  3603,
  104426,
  244363,
  153709,
  112487,
  304612,
  199674,
  41239,
  35545,
  54869,
  293005,
  28223,
  26277,
  26899,
  4533,
  18518,
  15492,
  38587,
  80488,
  70485,
  160395,
  263,
  60162,
  11382,
  222152,
  4696,
  250751,
  51921,
  182609,
  10707,
  48463,
  46243,
  1227,
  49111,
  111564,
  46502,
  33342,
  56846,
  68541,
  63559,
  858,
  139927,
  16654,
  229375,
  76759,
  26478,
  33205,
  95828,
  23399,
  92945,
  2637,
  35630,
  28470,
  143992,
  50214,
  14174,
  21456,
  166191,
  65665,
  1711,
  21594,
  78019,
  97599,
  111701,
  36,
  147151,
  110246,
  189022,
  43021,
  30397,
  40757,
  131935,
  42065,
  73335,
  48039,
  26596,
  28984,
  15102,
  2361,
  7421,
  202167,
  69744,
  43766,
  52826,
  3642,
  83304,
  33873,
  75140,
  63169,
  192389,
  36551,
  92748,
  13039,
  123959,
  233220,
  21738,
  84447,
  77230,
  20228,
  187852,
  19095,
  25799,
  92136,
  108774,
  29237,
  53947,
  2299,
  118106,
  2687,
  8830,
  42331,
  202924,
  33667,
  2023,
  73763,
  30704,
  19363,
  19779,
  16737,
  35629,
  48081,
  24068,
  101013,
  162338,
  291912,
  13749,
  24745,
  328289,
  167679,
  70086,
  48299,
  23306,
  16732,
  17801,
  43322,
  54589,
  3586,
  63653,
  43624,
  53474,
  925,
  109177,
  251316,
  43805,
  13082,
  19511,
  86565,
  142182,
  92461,
  17117,
  101033,
  103319,
  64589,
  4022,
  4351,
  235897,
  5352,
  82705,
  107142,
  46391,
  156084,
  5860,
  61365,
  10558,
  13045,
  7717,
  18357,
  33922,
  12590,
  33065,
  6928,
  46993,
  783,
  46937,
  67846,
  8952,
  26295,
  6107,
  119656,
  18799,
  17458,
  50747,
  4229,
  179559,
  112727,
  118080,
  20683,
  41464,
  125468,
  51560,
  49749,
  44231,
  7359,
  35339,
  62988,
  136487,
  67015,
  5208,
  29150,
  24956,
  105186,
  48858,
  6143,
  18097,
  6972,
  16404,
  73489,
  58742,
  97196,
  36357,
  164616,
  5834,
  32267,
  13746,
  147733,
  15113,
  132091,
  34127,
  106298,
  39729,
  106426,
  22294,
  9780,
  15602,
  36213,
  71502,
  42808,
  66802,
  599,
  60755,
  5851,
  39120,
  67363,
  108623,
  126368,
  72770,
  91263,
  32486,
  30596,
  151717,
  7951,
  52002,
  43103,
  11768,
  68942,
  40901,
  39344,
  24037,
  127500,
  116890,
  48403,
  16926,
  86750,
  17745,
  48648,
  159545,
  34460,
  58419,
  5634,
  114317,
  67865,
  31462,
  23352,
  24010,
  98185,
  125708,
  69686,
  68337,
  13610,
  26271,
  70691,
  2980,
  4768,
  27225,
  102402,
  75453,
  28106,
  8104,
  6931,
  1176,
  6274,
  6475,
  112635,
  22498,
  6176,
  238686,
  26832,
  28893,
  90319,
  14441,
  15682,
  15087,
  39517,
  45270,
  109134,
  104440,
  45965,
  47645,
  81772,
  7876,
  52683,
  87720,
  12898,
  4505,
  185665,
  2769,
  113401,
  15664,
  57592,
  105229,
  137381,
  97059,
  119268,
  6876,
  43309,
  33886,
  128363,
  35476,
  144249,
  67013,
  143587,
  83367,
  25703,
  91436,
  59347,
  53236,
  2289,
  16519,
  19844,
  46309,
  58558,
  99834,
  23313,
  218816,
  231303,
  36388,
  51333,
  183535,
  109792,
  139277,
  54306,
  90139,
  18235,
  8275,
  32710,
  37677,
  82464,
  86025,
  92204,
  88842,
  117723,
  37570,
  128723,
  234242,
  76350,
  73795,
  34896,
  148247,
  58424,
  11105,
  11744,
  45746,
  63372,
  17118,
  49772,
  199520,
  81902,
  38004,
  22911,
  33752,
  3125,
  1995,
  53792,
  4689,
  26909,
  108150,
  146062,
  69674,
  41811,
  161444,
  84855,
  8999,
  28561,
  16731,
  93937,
  3189,
  21967,
  24890,
  22943,
  1356,
  145300,
  51569,
  28802,
  517,
  118679,
  31703,
  40607,
  48098,
  108854,
  25003,
  10233,
  73969,
  177495,
  5248,
  24516,
  215347,
  146192,
  48712,
  60626,
  69188,
  40735,
  5866,
  586,
  101541,
  6509,
  47590,
  52129,
  5969,
  222045,
  110933,
  25733,
  24223,
  65339,
  62812,
  2414,
  155418,
  35819,
  16022,
  78423,
  43138,
  20995,
  128255,
  240673,
  46745,
  236093,
  72176,
  57085,
  97841,
  61248,
  107,
  36068,
  193177,
  105427,
  55726,
  215229,
  20446,
  47228,
  100420,
  87091,
  14429,
  121708,
  23605,
  21157,
  187721,
  21880,
  2997,
  203976,
  99166,
  95068,
  25877,
  7724,
  98925,
  83401,
  4829,
  13182,
  18229,
  13718,
  239662,
  38653,
  116505,
  153497,
  30589,
  89029,
  38962,
  181302,
  43853,
  78872,
  180301,
  4786,
  248240,
  7401,
  106136,
  112590,
  77745,
  19731,
  60880,
  77789,
  125748,
  135487,
  5975,
  48627,
  34084,
  12419,
  215770,
  47557,
  254582,
  10364,
  106495,
  21856,
  67539,
  88981,
  38805,
  21428,
  48732,
  42316,
  12149,
  16078,
  52808,
  25327,
  51322,
  33850,
  51147,
  12253,
  122354,
  46077,
  56483,
  254553,
  115417,
  81834,
  150991,
  94662,
  86668,
  7381,
  12841,
  100650,
  18218,
  15741,
  22372,
  68294,
  50705,
  15535,
  84660,
  61887,
  22553,
  72299,
  31361,
  24824,
  17743,
  46820,
  64288,
  31582,
  77006,
  111674,
  116384,
  30760,
  80920,
  86149,
  77192,
  51979,
  79691,
  60342,
  122805,
  103800,
  240873,
  160744,
  233114,
  78962,
  54920,
  8608,
  3484,
  316104,
  72548,
  24337,
  5088,
  230040,
  21926,
  10172,
  36838,
  26,
  86221,
  83458,
  102176,
  12062,
  17571,
  41929,
  41170,
  28428,
  68239,
  41750,
  103930,
  2634,
  18313,
  53019,
  34825,
  97837,
  63115,
  24606,
  73157,
  152474,
  14715,
  91439,
  37033,
  109806,
  140259,
  30668,
  174760,
  380,
  135597,
  95673,
  136073,
  65073,
  134249,
  13829,
  17279,
  122305,
  4420,
  46444,
  10237,
  64848,
  203623,
  70728,
  10349,
  182885,
  65075,
  24519,
  25783,
  40318,
  34139,
  22222,
  63394,
  55266,
  102764,
  41422,
  20126,
  65100,
  90408,
  53640,
  35128,
  48932,
  11192,
  38935,
  96839,
  34782,
  39492,
  19396,
  41332,
  6250,
  5511,
  19492,
  51304,
  25936,
  104466,
  54099,
  73771,
  86115,
  5080,
  7669,
  30891,
  111700,
  13931,
  25276,
  72289,
  135447,
  14820,
  258641,
  25265,
  31005,
  281179,
  75286,
  393,
  95359,
  14623,
  13584,
  6680,
  101227,
  80173,
  44933,
  76666,
  54542,
  13244,
  39348,
  458,
  25379,
  109451,
  134348,
  81143,
  6959,
  65554,
  12027,
  51311,
  8716,
  57589,
  140731,
  28467,
  23316,
  17272,
  30458,
  25980,
  55229,
  77197,
  83798,
  28302,
  114784,
  7428,
  34548,
  26241,
  14712,
  39336,
  103304,
  18928,
  54080,
  12870,
  334,
  87722,
  15208,
  16895,
  142098,
  114262,
  39820,
  83913,
  57817,
  28682,
  7721,
  14900,
  108672,
  11250,
  62246,
  42849,
  415188,
  1724,
  26555,
  24549,
  25505,
  26443,
  107450,
  145899,
  61035,
  43528,
  6901,
  60726,
  65906,
  267741,
  21338,
  147590,
  42079,
  18924,
  73017,
  135236,
  15393,
  5206,
  4026,
  84185,
  1531,
  5988,
  113890,
  82647,
  303391,
  7386,
  69844,
  71611,
  189865,
  76523,
  31877,
  13315,
  19314,
  198575,
  32821,
  1928,
  67641,
  25913,
  104475,
  103489,
  3297,
  70391,
  18406,
  15446,
  113347,
  19295,
  93790,
  27856,
  1792,
  167471,
  116449,
  8541,
  4408,
  41757,
  63233,
  25765,
  86680,
  64501,
  27034,
  24816,
  34975,
  6079,
  4486,
  49693,
  36229,
  16917,
  21581,
  62426,
  27862,
  11612,
  54284,
  35702,
  194034,
  355,
  24277,
  48262,
  87411,
  70504,
  310164,
  118018,
  12516,
  47559,
  43502,
  57433,
  107139,
  9290,
  66533,
  80863,
  14634,
  34312,
  91725,
  28606,
  21342,
  67241,
  72355,
  43244,
  375789,
  37402,
  174015,
  105070,
  8342,
  44167,
  67494,
  1890,
  16365,
  11723,
  271002,
  1865,
  47918,
  8350,
  45564,
  27742,
  25110,
  125803,
  8553,
  49504,
  81925,
  62211,
  4534,
  15491,
  19011,
  80373,
  206920,
  667,
  102405,
  128623,
  245524,
  5553,
  113309,
  192739,
  65766,
  19567,
  22832,
  261958,
  29679,
  21293,
  71134,
  20962,
  105123,
  24721,
  860,
  21752,
  33448,
  18372,
  157167,
  94822,
  35770,
  173224,
  232737,
  75729,
  28937,
  46828,
  28062,
  25453,
  5207,
  140366,
  36665,
  30652,
  6169,
  67920,
  150458,
  92040,
  23186,
  184604,
  92330,
  20891,
  176492,
  49427,
  27828,
  38305,
  42495,
  143982,
  49560,
  25503,
  90043,
  29747,
  65328,
  47830,
  12932,
  11068,
  77721,
  9003,
  25213,
  94205,
  140426,
  46090,
  89945,
  138173,
  192691,
  33329,
  112232,
  129905,
  35709,
  27514,
  1841,
  19957,
  31411,
  127476,
  53572,
  17497,
  173549,
  55063,
  175135,
  19841,
  69314,
  5192,
  237921,
  117660,
  150697,
  4060,
  273045,
  50414,
  98940,
  65348,
  153665,
  164423,
  58804,
  156695,
  48994,
  213928,
  86036,
  28608,
  8355,
  39574,
  34540,
  16927,
  135680,
  18374,
  151587,
  10830,
  53805,
  16878,
  16623,
  4282,
  48030,
  8537,
  14986,
  46102,
  13062,
  72897,
  72,
  33050,
  108227,
  39451,
  45935,
  651,
  113320,
  40535,
  95176,
  57450,
  48843,
  5003,
  19019,
  10407,
  211163,
  3848,
  1068,
  4988,
  32091,
  30095,
  41692,
  15099,
  43602,
  107434,
  50744,
  7627,
  171349,
  16313,
  150832,
  352665,
  207750,
  33937,
  38256,
  51091,
  156e3,
  87889,
  90663,
  84175,
  24908,
  114900,
  50365,
  31494,
  83829,
  5398,
  169342,
  47521,
  54818,
  18935,
  8356,
  43094,
  41212,
  174536,
  10082,
  92550,
  6678,
  60614,
  23355,
  69721,
  14796,
  34149,
  128830,
  58187,
  3179,
  208,
  40325,
  28399,
  225029,
  401412,
  51150,
  31580,
  207268,
  6657,
  10993,
  69818,
  64282,
  289845,
  23308,
  12961,
  38447,
  6681,
  52944,
  31855,
  2572,
  47646,
  120728,
  179148,
  37240,
  45196,
  218274,
  4816,
  3695,
  21961,
  50084,
  35209,
  18073,
  51452,
  27004,
  6100,
  33941,
  1377,
  84831,
  171214,
  85,
  141510,
  9078,
  99227,
  32610,
  6417,
  11718,
  49868,
  65579,
  87902,
  73018,
  49062,
  46280,
  61742,
  21512,
  40862,
  107733,
  15941,
  29168,
  157765,
  144919,
  14487,
  5767,
  158014,
  140070,
  7241,
  573,
  71584,
  16921,
  223566,
  40331,
  179473,
  35081,
  47926,
  140885,
  41508,
  52104,
  59180,
  42310,
  32811,
  29048,
  123517,
  102413,
  80208,
  10104,
  14746,
  12649,
  153641,
  126022,
  37965,
  113017,
  4171,
  83,
  142592,
  2809,
  6362,
  50416,
  71323,
  116894,
  260776,
  16204,
  1524,
  5760,
  30351,
  12658,
  20703,
  54403,
  36083,
  45408,
  74772,
  4946,
  14485,
  50759,
  111222,
  10890,
  2195,
  167147,
  92962,
  130534,
  16283,
  177256,
  35016,
  15472,
  210156,
  151187,
  73922,
  117691,
  43250,
  52051,
  37392,
  24811,
  24358,
  30830,
  5775,
  818,
  21969,
  1476,
  127322,
  151783,
  58392,
  31021,
  106913,
  65215,
  89407,
  90802,
  28531,
  11690,
  20234,
  95249,
  44602,
  37256,
  18707,
  11928,
  5161,
  4410,
  26571,
  51903,
  49768,
  22008,
  25252,
  65780,
  209499,
  68769,
  203726,
  13249,
  137363,
  48845,
  86823,
  6658,
  5674,
  31881,
  1083,
  1823,
  108676,
  34518,
  166752,
  13791,
  14287,
  91576,
  91429,
  8665,
  11529,
  26401,
  16191,
  91972,
  30964,
  5254,
  28486,
  54697,
  79613,
  66520,
  18447,
  22870,
  45203,
  194466,
  22822,
  51703,
  12278,
  76716,
  44595,
  73455,
  33546,
  12235,
  144843,
  36154,
  51247,
  11116,
  33040,
  3180,
  225753,
  60864,
  1972,
  28469,
  12891,
  28879,
  10338,
  144157,
  56294,
  353058,
  38302,
  41447,
  87532,
  110616,
  27065,
  168438,
  6557,
  1213,
  50804,
  144643,
  24817,
  2390,
  136531,
  38174,
  247513,
  16190,
  4059,
  122791,
  131994,
  137430,
  39506,
  57650,
  16305,
  5188,
  54309,
  106128,
  20628,
  88071,
  67394,
  395446,
  250285,
  66176,
  91254,
  1399,
  114196,
  43915,
  60230,
  44853,
  27206,
  106353,
  43013,
  18733,
  345105,
  226453,
  51202,
  16607,
  57106,
  117175,
  35492,
  10476,
  89598,
  127439,
  15187,
  39624,
  13688,
  61570,
  10615,
  31111,
  59370,
  6238,
  175252,
  32143,
  224492,
  41388,
  95408,
  34384,
  148238,
  78307,
  38959,
  9340,
  160091,
  61443,
  15737,
  11216,
  41244,
  170,
  38299,
  102443,
  113097,
  26382,
  14027,
  33707,
  3957,
  76300,
  66160,
  19431,
  18900,
  6952,
  1717,
  108656,
  82206,
  188021,
  257335,
  27295,
  43999,
  41210,
  31777,
  46956,
  57457,
  12657,
  11489,
  15697,
  48060,
  204748,
  53583,
  82422,
  284790,
  30503,
  137341,
  8120,
  19615,
  220311,
  15991,
  10217,
  63424,
  9808,
  67431,
  70976,
  98221,
  4491,
  15177,
  28535,
  144789,
  751,
  13230,
  2394,
  1504,
  33977,
  132104,
  30316,
  22230,
  931,
  97193,
  185240,
  24826,
  22687,
  174322,
  15307,
  22988,
  1390,
  188745,
  180325,
  29580,
  59068,
  74903,
  18994,
  29195,
  79,
  15436,
  7622,
  38462,
  11566,
  138710,
  44828,
  45774,
  37768,
  99236,
  68137,
  84083,
  19282,
  22698,
  17134,
  74807,
  126662,
  173497,
  46248,
  16938,
  119735,
  3212,
  28292,
  213652,
  49013,
  9975,
  32180,
  45660,
  86250,
  4801,
  68788,
  95490,
  77482,
  113751,
  11994,
  44624,
  94452,
  46839,
  128497,
  100316,
  5798,
  58588,
  73184,
  202987,
  65417,
  37790,
  88524,
  1606,
  43156,
  97964,
  105717,
  34947,
  11203,
  100060,
  37742,
  130074,
  93653,
  107799,
  94311,
  196106,
  41347,
  8035,
  10780,
  16390,
  27883,
  118236,
  167395,
  1979,
  25006,
  19375,
  31628,
  18916,
  144723,
  78502,
  114047,
  103107,
  86492,
  107686,
  5844,
  20934,
  206963,
  23556,
  22591,
  16562,
  146333,
  20167,
  10471,
  117434,
  33085,
  2863,
  9740,
  36669,
  41849,
  37271,
  22790,
  18209,
  28979,
  8231,
  12952,
  54408,
  21731,
  25130,
  45208,
  55748,
  138120,
  75826,
  414,
  29593,
  9925,
  292865,
  25999,
  683,
  123149,
  7036,
  92159,
  86055,
  61827,
  103680,
  23176,
  54918,
  58466,
  57578,
  13305,
  5709,
  86479,
  16697,
  31064,
  17660,
  200919,
  10770,
  49793,
  33423,
  32370,
  52047,
  16488,
  62555,
  6459,
  8426,
  83493,
  7763,
  59725,
  82812,
  18628,
  67760,
  79405,
  68557,
  9612,
  7673,
  28102,
  56517,
  69620,
  171797,
  32458,
  29541,
  15870,
  81109,
  32080,
  207644,
  71495,
  21202,
  11039,
  91036,
  61230,
  2810,
  130800,
  32260,
  4613,
  60590,
  37112,
  75214,
  33979,
  126402,
  155062,
  30642,
  63875,
  12810,
  194463,
  82799,
  47664,
  16725,
  36685,
  43367,
  61099,
  449,
  172150,
  102867,
  21691,
  301838,
  36745,
  7130,
  18671,
  57316,
  34852,
  38034,
  54182,
  35578,
  65900,
  99486,
  19771,
  3456,
  2658,
  16914,
  99866,
  28390,
  28109,
  8262,
  21147,
  34353,
  20006,
  4228,
  137085,
  1675,
  203023,
  283196,
  198286,
  214375,
  163329,
  290603,
  152574,
  40471,
  83506,
  30068,
  14730,
  23177,
  131539,
  34759,
  27668,
  32178,
  71896,
  104799,
  116305,
  85430,
  119262,
  42860,
  25160,
  8911,
  23428,
  49437,
  105322,
  6519,
  16203,
  6349,
  74711,
  1230,
  38045,
  8540,
  75165,
  44736,
  25909,
  51026,
  317034,
  4984,
  32281,
  91312,
  27060,
  44431,
  17817,
  45363,
  155937,
  239085,
  35697,
  59784,
  91993,
  29531,
  126740,
  213757,
  76560,
  167776,
  285273,
  24262,
  8237,
  65030,
  41160,
  74437,
  48804,
  118916,
  13159,
  37842,
  1031,
  75349,
  1478,
  11655,
  108777,
  23435,
  277425,
  101734,
  67469,
  70231,
  124711,
  43532,
  28514,
  65526,
  54956,
  1e3,
  21882,
  17728,
  25302,
  40952,
  52214,
  149632,
  1999,
  2111,
  3259,
  63362,
  89961,
  220561,
  39777,
  26335,
  9063,
  10572,
  12416,
  34551,
  34623,
  38604,
  24723,
  5947,
  15588,
  69927,
  66252,
  119177,
  69173,
  46629,
  28714,
  70715,
  212408,
  20521,
  406913,
  74380,
  11716,
  50659,
  50862,
  37009,
  88460,
  130101,
  7210,
  53853,
  538,
  65120,
  151950,
  55806,
  163748,
  52837,
  13153,
  21100,
  16674,
  64536,
  6091,
  138201,
  44837,
  58547,
  3723,
  163,
  2177,
  32288,
  85454,
  34033,
  8497,
  14282,
  25742,
  10535,
  10741,
  79559,
  117493,
  243787,
  49337,
  100718,
  79495,
  40139,
  42956,
  7551,
  55433,
  15421,
  31509,
  23034,
  45081,
  547,
  61176,
  53434,
  328001,
  8470,
  36263,
  30145,
  4519,
  74173,
  53935,
  11845,
  73774,
  60211,
  78025,
  3,
  4102,
  73782,
  109293,
  315332,
  48412,
  26683,
  13714,
  6865,
  20128,
  18490,
  104141,
  325,
  39470,
  171970,
  115860,
  15707,
  7268,
  73301,
  74336,
  31370,
  2368,
  111827,
  107757,
  136231,
  142844,
  97138,
  96638,
  84053,
  38691,
  23801,
  1588,
  10573,
  122098,
  77039,
  240,
  186135,
  146101,
  11996,
  18143,
  112963,
  46171,
  155836,
  348769,
  47795,
  121213,
  116266,
  132515,
  3344,
  144804,
  31286,
  99187,
  255838,
  129694,
  35894,
  48779,
  55235,
  148582,
  71967,
  65282,
  15174,
  13920,
  47080,
  6147,
  108242,
  157593,
  125025,
  7136,
  1286,
  28957,
  127956,
  28402,
  98813,
  20805,
  7532,
  109417,
  40610,
  5041,
  32958,
  15142,
  18408,
  108596,
  33543,
  50517,
  27748,
  80114,
  233434,
  91447,
  487,
  37094,
  100048,
  30541,
  43477,
  10639,
  89862,
  155868,
  37667,
  8726,
  60684,
  237903,
  73408,
  99589,
  12190,
  38739,
  97348,
  3914,
  13594,
  2680,
  149016,
  13907,
  30171,
  28343,
  23530,
  115225,
  61104,
  35821,
  147679,
  14337,
  4297,
  244282,
  24085,
  326976,
  56428,
  7851,
  21303,
  131620,
  71446,
  83253,
  68692,
  111870,
  5224,
  15813,
  38197,
  49026,
  45057,
  13660,
  3306,
  76345,
  40671,
  27905,
  91072,
  996,
  68527,
  62085,
  91351,
  122634,
  55109,
  168209,
  2024,
  27560,
  112707,
  17352,
  8306,
  167115,
  169921,
  166958,
  5031,
  46020,
  11844,
  67284,
  19130,
  76185,
  6920,
  32849,
  5450,
  14610,
  22451,
  21002,
  17392,
  31872,
  66682,
  84796,
  13709,
  40210,
  59898,
  12029,
  8719,
  53564,
  21462,
  91884,
  21647,
  88379,
  194428,
  12754,
  37797,
  132826,
  160016,
  22567,
  54383,
  53186,
  77611,
  31107,
  8339,
  4694,
  19185,
  90355,
  23597,
  17222,
  140675,
  28442,
  23668,
  55977,
  9128,
  61555,
  28774,
  155229,
  17658,
  9390,
  24379,
  69357,
  15752,
  127381,
  239631,
  62460,
  93181,
  55913,
  45133,
  140155,
  18676,
  25249,
  33164,
  29581,
  82837,
  67223,
  22362,
  29975,
  7317,
  52813,
  1943,
  29613,
  20012,
  207130,
  49617,
  49651,
  5636,
  15334,
  36313,
  29226,
  28084,
  95247,
  72072,
  19e3,
  224932,
  15811,
  114,
  32127,
  38097,
  37508,
  88507,
  37225,
  27359,
  91626,
  12193,
  69279,
  20608,
  11055,
  88156,
  92808,
  2152,
  57259,
  55275,
  72789,
  24475,
  104414,
  1708,
  9882,
  3818,
  48661,
  66897,
  1631,
  34806,
  227930,
  85815,
  87753,
  18321,
  250664,
  72733,
  25107,
  206797,
  50891,
  8082,
  196411,
  92596,
  96764,
  152823,
  65514,
  22819,
  387277,
  62176,
  51225,
  40329,
  15563,
  189,
  3659,
  73670,
  64357,
  51793,
  275136,
  33482,
  86653,
  74615,
  67058,
  11318,
  125720,
  15388,
  22388,
  8267,
  1730,
  102663,
  170910,
  40784,
  7144,
  85373,
  13040,
  7088,
  94309,
  583,
  44224,
  140424,
  77439,
  18496,
  164026,
  36578,
  4722,
  9151,
  5824,
  63365,
  26510,
  35199,
  40500,
  79277,
  32495,
  44614,
  35233,
  9566,
  203293,
  152144,
  7097,
  2330,
  183480,
  98629,
  13423,
  330887,
  44130,
  68600,
  30939,
  97829,
  31012,
  345465,
  56747,
  94879,
  4939,
  160027,
  149761,
  99423,
  46099,
  32251,
  15332,
  8761,
  96094,
  128555,
  5763,
  235318,
  222223,
  55729,
  30241,
  55420,
  201746,
  3987,
  81382,
  8259,
  49325,
  23287,
  7719,
  24633,
  251100,
  92311,
  18591,
  110533,
  64759,
  170260,
  393860,
  7175,
  21144,
  132887,
  3593,
  75346,
  101277,
  91109,
  16387,
  259187,
  11627,
  57459,
  173829,
  44694,
  55780,
  49797,
  89192,
  120443,
  62622,
  3904,
  14814,
  23887,
  1027,
  112258,
  64955,
  99800,
  11132,
  66353,
  36202,
  48624,
  18158,
  88481,
  96882,
  43059,
  11040,
  2455,
  7077,
  21651,
  181159,
  99126,
  100434,
  61388,
  68186,
  19161,
  110468,
  120052,
  8819,
  55324,
  41494,
  7014,
  37689,
  3618,
  87729,
  92615,
  207943,
  9823,
  128657,
  12587,
  15857,
  6379,
  67628,
  51216,
  71775,
  157617,
  63244,
  1503,
  3864,
  218754,
  110864,
  5769,
  21492,
  7243,
  1192,
  87921,
  85529,
  31512,
  18537,
  42698,
  35350,
  73510,
  84474,
  34301,
  8991,
  21013,
  35034,
  566,
  38832,
  19838,
  35586,
  37216,
  39413,
  55006,
  12178,
  59742,
  856,
  84563,
  6900,
  25632,
  17437,
  49786,
  30723,
  13847,
  70845,
  4044,
  7843,
  23944,
  235976,
  55530,
  48942,
  6518,
  20939,
  73769,
  192653,
  52936,
  95207,
  23895,
  132542,
  142982,
  22632,
  87452,
  48042,
  54018,
  178468,
  10728,
  26230,
  23559,
  363,
  81269,
  142012,
  5718,
  346258,
  31456,
  84333,
  246476,
  51018,
  66692,
  101804,
  120570,
  39962,
  30373,
  70593,
  2864,
  60541,
  19425,
  54209,
  104092,
  7201,
  31545,
  48018,
  25865,
  15442,
  46257,
  40443,
  8328,
  6451,
  111782,
  47527,
  97754,
  33046,
  470,
  245116,
  31095,
  39,
  91934,
  87208,
  73470,
  36708,
  36521,
  12801,
  70624,
  36272,
  8892,
  79768,
  12427,
  55454,
  103756,
  5908,
  52390,
  62962,
  22720,
  141138,
  94634,
  41689,
  128402,
  126390,
  6628,
  106394,
  35527,
  134394,
  82727,
  254651,
  194502,
  148064,
  89549,
  3202,
  28359,
  957,
  21954,
  27906,
  49840,
  142747,
  8307,
  24206,
  48978,
  1186,
  71728,
  133038,
  71474,
  91306,
  6333,
  110959,
  74600,
  70387,
  18983,
  62609,
  56057,
  22970,
  1147,
  135850,
  1321,
  28834,
  3578,
  59715,
  102227,
  32827,
  81415,
  99952,
  55636,
  257598,
  390,
  22702,
  35701,
  85872,
  402916,
  39216,
  189795,
  14929,
  19467,
  10112,
  144422,
  61514,
  5279,
  63421,
  134686,
  41436,
  8424,
  51925,
  10598,
  132295,
  124416,
  4604,
  194739,
  210929,
  57866,
  31829,
  51626,
  50007,
  9976,
  91878,
  61906,
  56168,
  81906,
  60918,
  61859,
  40017,
  23059,
  16887,
  40927,
  62064,
  12785,
  32893,
  32913,
  21782,
  93965,
  20169,
  44387,
  79084,
  38463,
  11457,
  93950,
  27127,
  157050,
  2697,
  337088,
  5116,
  54128,
  48255,
  33279,
  8821,
  27352,
  25515,
  124022,
  65710,
  28906,
  38557,
  33390,
  1722,
  104435,
  72215,
  38551,
  12094,
  30978,
  25113,
  6671,
  37355,
  175109,
  42862,
  98024,
  65406,
  221276,
  59624,
  118012,
  64637,
  78760,
  86697,
  21426,
  1639,
  40350,
  12584,
  67193,
  84144,
  31396,
  7863,
  143011,
  69629,
  63112,
  9454,
  28666,
  65798,
  46372,
  134721,
  6314,
  51402,
  30837,
  151922,
  2847,
  38676,
  38008,
  92823,
  136245,
  17540,
  5504,
  109295,
  205242,
  37606,
  5211,
  214892,
  1586,
  20670,
  208711,
  137743,
  19328,
  40652,
  16995,
  20023,
  14657,
  154919,
  34422,
  12996,
  13918,
  38221,
  47690,
  16398,
  2959,
  37680,
  89122,
  6721,
  198469,
  91876,
  172043,
  83898,
  101992,
  26084,
  94570,
  3635,
  76958,
  22853,
  76497,
  38266,
  176590,
  168403,
  44464,
  142840,
  79180,
  184594,
  1984,
  41806,
  83147,
  11985,
  6546,
  366068,
  59732,
  24533,
  271505,
  8736,
  39084,
  222992,
  93429,
  28962,
  58985,
  86665,
  8432,
  30028,
  14548,
  32439,
  54424,
  165029,
  55175,
  27458,
  69046,
  121277,
  46168,
  33732,
  20661,
  24581,
  135574,
  123110,
  37556,
  79260,
  72611,
  16957,
  12939,
  46162,
  58238,
  44907,
  72936,
  253758,
  41324,
  32518,
  96480,
  11949,
  124438,
  65280,
  43256,
  34107,
  53533,
  43531,
  37037,
  28366,
  45970,
  32741,
  173438,
  6121,
  194202,
  62969,
  26355,
  30314,
  58370,
  28455,
  1848,
  50519,
  82830,
  90393,
  21761,
  295490,
  10936,
  256940,
  133568,
  44050,
  20269,
  4089,
  27457,
  21610,
  219460,
  36743,
  14821,
  101388,
  52005,
  13124,
  30979,
  140816,
  167362,
  26054,
  18458,
  60789,
  34917,
  40447,
  26606,
  33422,
  9066,
  3452,
  83614,
  5761,
  20263,
  137238,
  25038,
  91310,
  101,
  52322,
  74548,
  42572,
  38084,
  214054,
  186568,
  31802,
  17665,
  30620,
  141936,
  37730,
  14420,
  4265,
  187218,
  49640,
  188208,
  51441,
  55388,
  96452,
  66659,
  40869,
  42039,
  60967,
  221027,
  19234,
  178581,
  29105,
  96050,
  9165,
  196118,
  157335,
  3738,
  40354,
  117436,
  2965,
  34136,
  59659,
  15570,
  50843,
  230035,
  31444,
  71260,
  43886,
  18316,
  5387,
  38500,
  168508,
  17406,
  32174,
  8828,
  103373,
  143806,
  90367,
  3560,
  18719,
  122310,
  16508,
  26719,
  2541,
  105429,
  6645,
  37998,
  73190,
  10591,
  235916,
  49737,
  87112,
  233941,
  53188,
  32193,
  79154,
  4544,
  52905,
  126477,
  7580,
  63501,
  57314,
  3216,
  31337,
  6541,
  103083,
  60846,
  49,
  9756,
  15481,
  1355,
  43840,
  14319,
  13743,
  27486,
  10222,
  73114,
  230718,
  418644,
  16706,
  6674,
  279748,
  23058,
  45273,
  295831,
  86306,
  2743,
  5535,
  88773,
  21829,
  35253,
  120938,
  31153,
  3169,
  16839,
  42847,
  8751,
  80974,
  33942,
  36867,
  35514,
  16485,
  26474,
  77775,
  56877,
  5391,
  48346,
  3882,
  108713,
  31403,
  27804,
  55248,
  26235,
  43821,
  136104,
  40118,
  175507,
  28034,
  203908,
  18732,
  1788,
  34030,
  106427,
  36958,
  54359,
  7251,
  44936,
  15356,
  69139,
  455,
  157915,
  22173,
  140291,
  50348,
  43275,
  82066,
  49621,
  54952,
  15216,
  36226,
  96695,
  66855,
  6936,
  1987,
  8227,
  196087,
  4631,
  68827,
  99004,
  47541,
  110265,
  17953,
  147605,
  110242,
  58520,
  31312,
  38724,
  329975,
  642,
  3155,
  34497,
  75937,
  6207,
  73843,
  6120,
  17249,
  51429,
  117746,
  3218,
  910,
  68961,
  319671,
  14938,
  29555,
  34700,
  1649,
  66673,
  72268,
  9655,
  76800,
  153087,
  6941,
  210168,
  27130,
  35398,
  1780,
  73242,
  3135,
  56689,
  19556,
  165307,
  8765,
  35967,
  121458,
  13333,
  70453,
  17350,
  117253,
  22265,
  13340,
  44265,
  39869,
  441,
  3742,
  135025,
  23581,
  33309,
  16543,
  17731,
  13291,
  157637,
  283005,
  21408,
  101360,
  63887,
  52312,
  83873,
  5338,
  233779,
  23759,
  186949,
  34531,
  177320,
  38069,
  156465,
  91004,
  19353,
  59852,
  68160,
  14891,
  1338,
  1072,
  29823,
  1950,
  28901,
  81407,
  313445,
  73038,
  84807,
  162348,
  240257,
  37162,
  138934,
  16111,
  58013,
  41253,
  102951,
  16457,
  96056,
  19541,
  56402,
  67217,
  41638,
  94381,
  89674,
  29481,
  37456,
  80815,
  151579,
  13937,
  13683,
  132537,
  19699,
  134545,
  67020,
  29816,
  222341,
  141235,
  427578,
  48868,
  129557,
  233342,
  23077,
  87871,
  16213,
  18728,
  16184,
  9469,
  37913,
  19680,
  2798,
  171356,
  178328,
  13216,
  50049,
  72690,
  71904,
  124644,
  55455,
  7504,
  29052,
  41036,
  266546,
  19899,
  30391,
  188755,
  8659,
  59469,
  16,
  104298,
  112943,
  53865,
  76203,
  138226,
  68857,
  139953,
  14125,
  107625,
  119795,
  173133,
  4398,
  50273,
  48808,
  54390,
  16466,
  122086,
  31835,
  67035,
  50971,
  48859,
  7508,
  46427,
  66477,
  73021,
  84615,
  39985,
  83076,
  46779,
  201569,
  53336,
  36443,
  60865,
  168164,
  143810,
  51393,
  25548,
  169307,
  32896,
  24485,
  38424,
  21837,
  29087,
  275813,
  51674,
  6714,
  64883,
  46169,
  187369,
  55186,
  76192,
  12852,
  12018,
  62134,
  31067,
  118303,
  16542,
  12125,
  10579,
  4928,
  26291,
  43854,
  7091,
  10946,
  253716,
  109062,
  39283,
  17261,
  113012,
  258512,
  47764,
  125126,
  32646,
  55892,
  80279,
  201623,
  149872,
  3192,
  385,
  1208,
  48750,
  5376,
  58738,
  22335,
  5427,
  82416,
  47811,
  32435,
  143086,
  38930,
  94128,
  59975,
  156037,
  37977,
  38224,
  62485,
  7698,
  50405,
  71027,
  16462,
  21559,
  136153,
  34131,
  107506,
  162069,
  63703,
  3101,
  215029,
  40407,
  4178,
  3774,
  9187,
  80019,
  17880,
  97926,
  67579,
  2600,
  18405,
  8351,
  47924,
  86638,
  70820,
  92206,
  86453,
  29610,
  42241,
  119200,
  3198,
  15466,
  67813,
  57863,
  35454,
  4779,
  99518,
  4649,
  104641,
  144269,
  33730,
  38073,
  65864,
  6838,
  109456,
  193298,
  154007,
  5623,
  45741,
  30846,
  182578,
  25573,
  157224,
  1543,
  58575,
  138703,
  146140,
  44971,
  49356,
  18275,
  59064,
  20300,
  13122,
  11848,
  24453,
  11973,
  9797,
  86843,
  2919,
  25530,
  49210,
  1130,
  161220,
  76788,
  75373,
  85604,
  34926,
  36014,
  17777,
  17255,
  51533,
  11676,
  92226,
  51845,
  119859,
  21525,
  5936,
  18507,
  28050,
  1140,
  31418,
  14857,
  34207,
  47859,
  10750,
  36382,
  32079,
  106909,
  59426,
  87757,
  38393,
  110042,
  15965,
  97104,
  33757,
  35344,
  97993,
  53979,
  33651,
  45407,
  41884,
  82515,
  173089,
  7177,
  58371,
  35365,
  47543,
  51927,
  35587,
  10670,
  23544,
  29306,
  84233,
  39976,
  76076,
  62097,
  9007,
  8668,
  28119,
  78281,
  120790,
  19835,
  143020,
  54968,
  18670,
  64959,
  20649,
  34469,
  42570,
  33001,
  136570,
  87796,
  120044,
  1106,
  58700,
  63951,
  127623,
  12805,
  83057,
  40212,
  31773,
  49850,
  7361,
  54336,
  347524,
  101314,
  23751,
  19569,
  48791,
  29174,
  49369,
  20467,
  7465,
  75842,
  38281,
  623,
  112457,
  60210,
  28849,
  51003,
  94720,
  6426,
  90047,
  85560,
  43761,
  3579,
  85105,
  34607,
  90410,
  118528,
  7224,
  42907,
  111163,
  18168,
  6960,
  161135,
  191298,
  5247,
  100584,
  127552,
  171568,
  20121,
  91173,
  12636,
  54615,
  20199,
  63730,
  98105,
  2396,
  40387,
  14438,
  125012,
  4765,
  33235,
  12865,
  45299,
  37728,
  82098,
  77872,
  114037,
  59253,
  19675,
  24838,
  398016,
  102561,
  11446,
  17069,
  57508,
  178277,
  65836,
  99941,
  26114,
  2585,
  271882,
  136866,
  50126,
  11027,
  155648,
  118367,
  14585,
  8910,
  123015,
  335383,
  40434,
  41016,
  53021,
  14439,
  87098,
  176860,
  201543,
  121888,
  2358,
  9286,
  5739,
  22666,
  54270,
  37884,
  169381,
  33984,
  93859,
  16124,
  89364,
  72207,
  51639,
  76366,
  99029,
  65812,
  2198,
  12147,
  174891,
  194289,
  6986,
  30252,
  88822,
  21284,
  11445,
  288337,
  160821,
  33034,
  100869,
  43852,
  25761,
  52882,
  1144,
  103809,
  1924,
  84458,
  86079,
  43411,
  13542,
  139276,
  18141,
  34978,
  41298,
  7276,
  26481,
  173800,
  33210,
  17951,
  142652,
  33616,
  33677,
  2210,
  19941,
  98568,
  2486,
  192414,
  80136,
  12058,
  235883,
  50963,
  249638,
  29572,
  27221,
  47034,
  6124,
  72107,
  63346,
  97620,
  158513,
  299699,
  40388,
  23235,
  37176,
  224244,
  198386,
  121323,
  67992,
  23827,
  63170,
  17838,
  106622,
  158590,
  26807,
  5345,
  23489,
  91891,
  55474,
  74834,
  37981,
  13058,
  5977,
  72552,
  34706,
  26828,
  145172,
  19904,
  21367,
  34043,
  960,
  77092,
  91381,
  4733,
  47446,
  7680,
  41697,
  5170,
  16960,
  14741,
  46101,
  13656,
  473,
  51842,
  37433,
  11103,
  11551,
  121951,
  13191,
  97536,
  165932,
  50397,
  51628,
  129028,
  9069,
  44885,
  6590,
  59195,
  47045,
  32940,
  225472,
  90345,
  21833,
  13303,
  29407,
  96615,
  141951,
  5198,
  6028,
  18395,
  7181,
  3861,
  14966,
  156358,
  167182,
  36529,
  55253,
  25942,
  173153,
  30959,
  27261,
  50691,
  150176,
  162201,
  38467,
  48462,
  80602,
  42163,
  118482,
  168,
  108756,
  26011,
  17166,
  54149,
  456538,
  22512,
  91374,
  13816,
  90358,
  131615,
  18132,
  226707,
  1824,
  28139,
  26860,
  42253,
  93877,
  77351,
  65575,
  8980,
  80574,
  22020,
  27948,
  40422,
  91324,
  76376,
  13528,
  39281,
  91685,
  82215,
  122541,
  144066,
  1983,
  193851,
  17283,
  26320,
  2739,
  194978,
  4790,
  26845,
  42627,
  61300,
  65815,
  174612,
  55133,
  4200,
  191130,
  79771,
  158321,
  52280,
  166796,
  221620,
  62461,
  11278,
  4067,
  88152,
  83409,
  31717,
  121367,
  13522,
  47325,
  37945,
  10406,
  174348,
  249321,
  154101,
  64912,
  29938,
  51775,
  17220,
  15776,
  166138,
  78890,
  84425,
  54121,
  42861,
  16368,
  24572,
  291647,
  10197,
  32073,
  22651,
  11677,
  97509,
  26952,
  35787,
  18424,
  41910,
  71614,
  94977,
  72318,
  41594,
  70024,
  275419,
  37702,
  60199,
  7335,
  39107,
  61315,
  18271,
  18394,
  33768,
  87884,
  104277,
  123724,
  7277,
  56288,
  71981,
  189803,
  49320,
  3352,
  6798,
  14240,
  8954,
  69220,
  94433,
  57372,
  28620,
  68863,
  193727,
  85575,
  42309,
  41667,
  67689,
  42081,
  22543,
  44824,
  12719,
  28540,
  114236,
  101553,
  27638,
  27296,
  4300,
  5353,
  4663,
  19379,
  94098,
  3758,
  95888,
  95144,
  80344,
  87320,
  28447,
  259518,
  12718,
  71391,
  152731,
  37063,
  24132,
  31911,
  104896,
  15672,
  103782,
  1521,
  4945,
  72541,
  23717,
  122632,
  15619,
  87175,
  206120,
  29428,
  189780,
  61416,
  28350,
  44457,
  972,
  1175,
  47233,
  198738,
  95789,
  41907,
  21953,
  97034,
  59341,
  22864,
  53713,
  16873,
  32971,
  20693,
  20954,
  31336,
  21477,
  16169,
  38370,
  16412,
  9019,
  3841,
  24599,
  21938,
  17085,
  6484,
  81198,
  76413,
  5849,
  72514,
  12320,
  65247,
  276175,
  37234,
  59796,
  52642,
  16312,
  57349,
  198507,
  94148,
  46134,
  18958,
  125552,
  1747,
  18725,
  151873,
  14901,
  5490,
  68287,
  29470,
  3689,
  64794,
  40814,
  26018,
  25692,
  54450,
  2703,
  88278,
  124886,
  173087,
  174e3,
  24159,
  179477,
  24276,
  46004,
  201876,
  209202,
  445,
  52876,
  31948,
  30206,
  157610,
  39180,
  18439,
  44124,
  50469,
  5774,
  96278,
  222758,
  200216,
  50290,
  45486,
  20435,
  46986,
  46276,
  140133,
  142326,
  15569,
  13363,
  47522,
  92583,
  2182,
  7135,
  16853,
  22998,
  30272,
  4952,
  63263,
  35623,
  39096,
  53789,
  44864,
  20053,
  110392,
  124213,
  4630,
  16087,
  28221,
  127787,
  25839,
  77481,
  44693,
  13464,
  113146,
  6983,
  27069,
  55717,
  50102,
  4760,
  7107,
  26186,
  66507,
  59145,
  36032,
  104182,
  71328,
  29425,
  64317,
  50781,
  47465,
  94298,
  69706,
  74899,
  22754,
  120756,
  25108,
  93077,
  56834,
  73286,
  39928,
  16218,
  41699,
  176763,
  7555,
  70819,
  50083,
  26895,
  23315,
  26014,
  16773,
  123079,
  41712,
  5719,
  31516,
  90427,
  158540,
  85051,
  183128,
  40864,
  27505,
  55392,
  9058,
  45224,
  96857,
  30901,
  136622,
  96557,
  56304,
  120061,
  11501,
  151448,
  5773,
  89743,
  7769,
  86069,
  2935,
  18471,
  41628,
  10114,
  33660,
  110170,
  49479,
  26745,
  92846,
  33221,
  26731,
  18795,
  87076,
  8550,
  2100,
  29972,
  120289,
  3077,
  72490,
  33784,
  2630,
  208722,
  50861,
  63483,
  79029,
  6419,
  39467,
  14302,
  45286,
  64207,
  9686,
  67513,
  44170,
  1050,
  77246,
  59266,
  17055,
  53801,
  7150,
  11111,
  42432,
  4278,
  94579,
  362117,
  36175,
  42902,
  41933,
  39002,
  98489,
  22913,
  74161,
  84773,
  57036,
  17556,
  162288,
  74485,
  178760,
  93867,
  73635,
  128860,
  50362,
  261,
  67455,
  80001,
  46080,
  35662,
  4368,
  25247,
  19230,
  74393,
  22588,
  1822,
  27682,
  235324,
  13798,
  85998,
  13194,
  235067,
  23514,
  71669,
  147632,
  23191,
  134748,
  214683,
  105101,
  1518,
  25489,
  247114,
  7380,
  54842,
  26922,
  3971,
  26361,
  20844,
  68642,
  170517,
  77339,
  123255,
  8963,
  77818,
  150998,
  48466,
  36806,
  2732,
  23261,
  11741,
  236162,
  18243,
  126216,
  28690,
  50546,
  16385,
  92760,
  197383,
  246558,
  201295,
  88255,
  67588,
  71687,
  176076,
  172653,
  169058,
  33906,
  63747,
  24835,
  157621,
  43338,
  30050,
  46152,
  132741,
  2770,
  51371,
  94835,
  6614,
  15112,
  11749,
  56936,
  1250,
  19027,
  399017,
  58036,
  100215,
  23388,
  55815,
  308768,
  124152,
  94803,
  9521,
  64186,
  8971,
  28,
  30427,
  62163,
  7616,
  103838,
  35079,
  29203,
  131235,
  7743,
  17389,
  10882,
  37420,
  61460,
  228512,
  85363,
  41581,
  131077,
  62822,
  119647,
  10130,
  54445,
  26925,
  19968,
  29016,
  24446,
  74028,
  24176,
  61448,
  67185,
  9254,
  8563,
  119129,
  9771,
  99184,
  37716,
  39514,
  10532,
  221512,
  258753,
  218630,
  55980,
  23394,
  32141,
  61924,
  66749,
  32411,
  3741,
  36475,
  26678,
  77010,
  44946,
  91203,
  128749,
  116953,
  20476,
  49625,
  53116,
  13735,
  102335,
  29376,
  51946,
  83407,
  67892,
  59212,
  34685,
  21083,
  1546,
  112982,
  32972,
  74397,
  1078,
  190545,
  16082,
  86140,
  58591,
  89611,
  101531,
  10061,
  105104,
  76319,
  20035,
  17551,
  52611,
  169061,
  190842,
  100780,
  23907,
  90413,
  115619,
  9675,
  34710,
  193435,
  49443,
  129734,
  11183,
  258877,
  16318,
  136182,
  126808,
  44635,
  27304,
  192375,
  2599,
  125648,
  47051,
  12091,
  23814,
  721,
  58800,
  40137,
  66726,
  97930,
  60877,
  74487,
  7942,
  54326,
  9841,
  41428,
  13762,
  8211,
  85383,
  6950,
  99177,
  79806,
  201786,
  296464,
  124087,
  13144,
  29741,
  41721,
  47634,
  55088,
  254286,
  106408,
  17041,
  99064,
  12942,
  64086,
  45233,
  14005,
  2612,
  55827,
  255,
  7984,
  13980,
  38574,
  12776,
  46654,
  73499,
  249951,
  2101,
  26676,
  25996,
  132326,
  116415,
  119062,
  50449,
  31033,
  23038,
  11589,
  179252,
  20007,
  14860,
  129270,
  21143,
  17796,
  144715,
  60106,
  70758,
  69842,
  34674,
  282133,
  44014,
  16774,
  57268,
  38528,
  24053,
  46373,
  201667,
  28327,
  471023,
  51889,
  102667,
  21193,
  114909,
  84132,
  69317,
  96723,
  67969,
  16134,
  68145,
  15058,
  28765,
  32035,
  2524,
  101089,
  98664,
  25045,
  76571,
  14957,
  86040,
  118506,
  262428,
  154764,
  81573,
  39681,
  283900,
  73287,
  127825,
  544,
  80448,
  52347,
  38512,
  175971,
  15180,
  45467,
  33086,
  46552,
  48894,
  81107,
  43213,
  36672,
  54025,
  76703,
  8053,
  7608,
  13299,
  56619,
  20752,
  238099,
  54164,
  105133,
  1444,
  32942,
  953,
  37564,
  8e3,
  66316,
  119463,
  106817,
  404,
  13667,
  149108,
  128597,
  31267,
  10269,
  49836,
  106150,
  1484,
  52330,
  76965,
  160486,
  171648,
  38456,
  31263,
  22424,
  37738,
  66245,
  67467,
  143369,
  60471,
  75610,
  20895,
  115528,
  86070,
  60854,
  40796,
  49347,
  18989,
  15030,
  11371,
  37578,
  15779,
  79867,
  10187,
  86462,
  46402,
  155626,
  93200,
  40229,
  7090,
  57547,
  108053,
  99598,
  11088,
  47505,
  41218,
  206017,
  2173,
  20988,
  30219,
  22919,
  80563,
  57566,
  42369,
  93141,
  41675,
  2407,
  182519,
  120495,
  27154,
  16702,
  29456,
  14349,
  7958,
  16688,
  117177,
  140375,
  42467,
  261919,
  74916,
  153569,
  10836,
  34742,
  49526,
  7621,
  105997,
  12212,
  2270,
  392377,
  7755,
  17959,
  25086,
  232152,
  138791,
  33847,
  13860,
  35316,
  5811,
  1344,
  71259,
  50452,
  207539,
  92635,
  50359,
  5821,
  33674,
  30255,
  2086,
  2587,
  96264,
  17543,
  42,
  6029,
  9580,
  43007,
  139248,
  82831,
  12917,
  29607,
  25786,
  51467,
  42137,
  85161,
  100698,
  31561,
  88989,
  121990,
  278500,
  3602,
  109344,
  37982,
  15279,
  116442,
  28936,
  30880,
  87894,
  58079,
  128661,
  126731,
  67392,
  28051,
  146885,
  4861,
  16216,
  97344,
  42827,
  147561,
  153948,
  22684,
  21335,
  47685,
  1853,
  43349,
  15185,
  59642,
  10229,
  25520,
  187921,
  108972,
  5579,
  98037,
  24945,
  6697,
  19193,
  63734,
  137934,
  75056,
  89740,
  19767,
  224268,
  56138,
  63643,
  151661,
  39313,
  70618,
  84031,
  89723,
  84074,
  13703,
  85626,
  35460,
  8867,
  64845,
  3439,
  57906,
  99776,
  63968,
  49270,
  81130,
  34356,
  16210,
  23547,
  36446,
  34090,
  140028,
  72439,
  2221,
  22163,
  57058,
  363492,
  113754,
  18913,
  95451,
  48663,
  54464,
  54037,
  176097,
  68425,
  3023,
  34906,
  29482,
  117389,
  341780,
  80431,
  58330,
  16753,
  92616,
  60907,
  94846,
  147486,
  4498,
  48646,
  7773,
  46801,
  7778,
  18946,
  464978,
  47558,
  33223,
  177444,
  7328,
  15626,
  63337,
  94700,
  11743,
  9351,
  255024,
  39098,
  16447,
  42647,
  96230,
  39769,
  58840,
  10068,
  63439,
  35800,
  65843,
  58823,
  413844,
  9156,
  51258,
  7434,
  61791,
  85018,
  6872,
  3692,
  28096,
  7121,
  33024,
  6009,
  75532,
  31997,
  192535,
  9661,
  3304,
  9547,
  14753,
  31987,
  25314,
  55689,
  15896,
  20430,
  39472,
  31340,
  99744,
  25398,
  115569,
  54883,
  28719,
  205423,
  23071,
  57855,
  64638,
  149867,
  25671,
  82403,
  37616,
  20668,
  39989,
  77996,
  74948,
  140555,
  175248,
  64810,
  36515,
  46595,
  4958,
  248773,
  24045,
  28728,
  136673,
  168704,
  20804,
  114833,
  100325,
  27135,
  21205,
  96151,
  153134,
  45992,
  7093,
  13992,
  76047,
  1980,
  19432,
  145001,
  75159,
  87462,
  17710,
  1013,
  45556,
  34297,
  144882,
  20648,
  26061,
  11319,
  129567,
  108555,
  18872,
  464580,
  33386,
  22717,
  65948,
  167189,
  5603,
  135042,
  79542,
  8801,
  202632,
  18114,
  91882,
  5973,
  5239,
  67315,
  4431,
  60916,
  47819,
  71693,
  32597,
  32606,
  18183,
  45072,
  80329,
  76385,
  24749,
  51305,
  40314,
  156514,
  14693,
  130345,
  13168,
  66214,
  18029,
  12858,
  34801,
  27628,
  14544,
  10823,
  40522,
  40185,
  33739,
  148694,
  23548,
  9923,
  61012,
  28859,
  17933,
  19442,
  34364,
  99849,
  164107,
  141167,
  30629,
  21054,
  6744,
  36491,
  8096,
  42474,
  41706,
  155060,
  30650,
  10600,
  163442,
  1143,
  96655,
  61390,
  52359,
  7559,
  51568,
  64256,
  203854,
  4467,
  22453,
  14504,
  436398,
  7878,
  6980,
  8293,
  63610,
  293747,
  16167,
  35763,
  19627,
  147603,
  15419,
  18032,
  110744,
  51346,
  33681,
  54571,
  40472,
  48615,
  39073,
  21604,
  13754,
  173027,
  92560,
  11083,
  47299,
  63062,
  11813,
  52007,
  29883,
  9734,
  139722,
  15953,
  1550,
  20651,
  13616,
  49306,
  16113,
  90089,
  92326,
  7584,
  30712,
  72424,
  164858,
  6831,
  152871,
  55746,
  197721,
  34167,
  196442,
  6022,
  112107,
  55215,
  7538,
  123381,
  4920,
  43539,
  77165,
  8939,
  50392,
  34192,
  20225,
  79762,
  22505,
  58667,
  40770,
  29788,
  97180,
  82835,
  4568,
  8579,
  13273,
  363569,
  35898,
  49983,
  436,
  36598,
  3237,
  131691,
  62418,
  35591,
  8101,
  4073,
  379438,
  65218,
  76072,
  33887,
  2968,
  27573,
  212619,
  288680,
  68278,
  72851,
  150504,
  217896,
  6913,
  121339,
  22017,
  35340,
  51072,
  43616,
  75043,
  31437,
  10833,
  81487,
  4364,
  22968,
  41454,
  106687,
  85446,
  19863,
  109625,
  149241,
  524,
  141850,
  214404,
  54376,
  657,
  237023,
  9401,
  108137,
  53800,
  32474,
  49712,
  53334,
  126876,
  27337,
  45552,
  177696,
  8269,
  15036,
  12097,
  42240,
  2328,
  125374,
  119295,
  99715,
  2500,
  19624,
  39441,
  27220,
  102691,
  60957,
  94543,
  39101,
  18566,
  67362,
  13975,
  78230,
  25017,
  34017,
  239007,
  90027,
  39351,
  41681,
  35354,
  43822,
  1043,
  916,
  58587,
  141983,
  94818,
  38799,
  75459,
  41114,
  67432,
  16195,
  36606,
  59568,
  22272,
  126769,
  31424,
  68659,
  12287,
  134302,
  257977,
  5756,
  207285,
  95637,
  47248,
  117689,
  19583,
  77451,
  22373,
  12200,
  54993,
  117118,
  34244,
  29386,
  34562,
  53819,
  71267,
  64172,
  77665,
  49368,
  7716,
  59301,
  25749,
  45426,
  194789,
  17297,
  2650,
  1766,
  32501,
  45198,
  20403,
  20984,
  6600,
  14171,
  94604,
  19037,
  5402,
  29896,
  9938,
  59935,
  109708,
  88081,
  145182,
  44844,
  39167,
  352626,
  164173,
  35374,
  45982,
  6122,
  154,
  73419,
  220487,
  53834,
  53601,
  17992,
  8609,
  229321,
  5610,
  68098,
  66815,
  71012,
  95069,
  140968,
  27396,
  8957,
  134489,
  24656,
  86659,
  56598,
  134852,
  17316,
  123838,
  255436,
  6613,
  41610,
  138033,
  81452,
  32023,
  32396,
  123687,
  63398,
  8693,
  29712,
  30407,
  19296,
  121188,
  3551,
  36099,
  20032,
  111948,
  56624,
  16547,
  27453,
  35916,
  15378,
  52039,
  56849,
  13489,
  22214,
  73177,
  53097,
  277349,
  2157,
  14029,
  187886,
  10260,
  141743,
  246460,
  91880,
  50869,
  3788,
  49486,
  133566,
  54950,
  33120,
  129337,
  53768,
  18333,
  9525,
  26902,
  312251,
  10297,
  9020,
  70759,
  16647,
  112432,
  59260,
  84609,
  9818,
  82766,
  73569,
  468,
  46001,
  75780,
  55028,
  52106,
  11498,
  43645,
  108069,
  17150,
  17753,
  29417,
  16705,
  31799,
  9606,
  289,
  122254,
  115975,
  8620,
  6133,
  255357,
  56908,
  14456,
  133464,
  43554,
  79224,
  11247,
  29630,
  160,
  12756,
  25464,
  65960,
  350428,
  62521,
  321796,
  100359,
  67358,
  35169,
  46172,
  113128,
  48988,
  88868,
  31094,
  33266,
  6847,
  60887,
  98188,
  49659,
  69117,
  92977,
  220228,
  13947,
  80181,
  35103,
  62170,
  97351,
  13475,
  2440,
  199768,
  19498,
  36597,
  46971,
  25234,
  67806,
  62881,
  84717,
  73648,
  181966,
  10488,
  94149,
  21550,
  26655,
  63436,
  48375,
  14405,
  165650,
  9621,
  24439,
  28043,
  42735,
  4490,
  29963,
  56674,
  45373,
  1934,
  262446,
  50855,
  67098,
  26898,
  5261,
  52696,
  40644,
  33900,
  9440,
  180286,
  87162,
  22940,
  19704,
  26936,
  69769,
  10254,
  101759,
  27406,
  12243,
  48e3,
  73926,
  113215,
  54935,
  5726,
  192787,
  4312,
  106216,
  9366,
  11550,
  52949,
  23457,
  212271,
  277152,
  133895,
  108374,
  6191,
  96477,
  29980,
  218916,
  58024,
  54696,
  40853,
  91124,
  65894,
  91170,
  65908,
  252552,
  6793,
  29212,
  15389,
  44516,
  122515,
  52617,
  35058,
  9017,
  103536,
  39510,
  49136,
  19242,
  130652,
  662077,
  74699,
  47024,
  31422,
  8517,
  73351,
  24399,
  13867,
  128360,
  4810,
  4434,
  61779,
  111983,
  61036,
  17798,
  110240,
  59722,
  102960,
  39688,
  10001,
  23803,
  23039,
  176498,
  56659,
  44814,
  134295,
  17188,
  77577,
  74466,
  226175,
  102472,
  154333,
  63900,
  111747,
  18062,
  41171,
  79669,
  32773,
  408933,
  42562,
  28931,
  30907,
  107388,
  43487,
  2946,
  240310,
  23938,
  24354,
  319,
  184983,
  7927,
  6488,
  1422,
  10790,
  68809,
  68209,
  64775,
  4361,
  202,
  17123,
  59634,
  51200,
  44391,
  18188,
  17843,
  2619,
  74278,
  3230,
  9540,
  47187,
  21702,
  36274,
  56894,
  43907,
  16310,
  34790,
  16866,
  6150,
  5561,
  13587,
  107545,
  108873,
  126867,
  86986,
  28640,
  33427,
  19017,
  5762,
  80637,
  17430,
  46903,
  2047,
  131055,
  25958,
  13558,
  5444,
  47152,
  13900,
  44563,
  122857,
  45348,
  70863,
  39593,
  54332,
  38068,
  33637,
  318,
  40310,
  143467,
  18502,
  24520,
  11377,
  62013,
  28942,
  27246,
  28269,
  83545,
  17999,
  59015,
  90707,
  30065,
  15161,
  34720,
  1263,
  37008,
  2012,
  6060,
  98575,
  92933,
  5721,
  299,
  199555,
  24578,
  29223,
  2985,
  743,
  115825,
  109523,
  136657,
  47454,
  26378,
  53586,
  3733,
  174945,
  93340,
  244456,
  5693,
  37386,
  28782,
  89767,
  27545,
  23573,
  18798,
  136425,
  34320,
  84778,
  20041,
  48453,
  38215,
  7477,
  71958,
  40621,
  8773,
  5874,
  187927,
  105965,
  51100,
  43533,
  18083,
  8443,
  10180,
  43597,
  2003,
  183999,
  69689,
  12216,
  129696,
  146188,
  62389,
  34044,
  68410,
  12765,
  43273,
  26949,
  266807,
  3345,
  34477,
  79197,
  5688,
  47539,
  213110,
  21634,
  22257,
  50092,
  32222,
  42346,
  39530,
  63668,
  98,
  134978,
  74022,
  5152,
  59088,
  174145,
  37220,
  9934,
  9545,
  118937,
  5724,
  87240,
  19875,
  15784,
  40143,
  23263,
  87513,
  181654,
  285152,
  37881,
  263241,
  4966,
  43934,
  10433,
  186657,
  6470,
  74416,
  225854,
  25908,
  142677,
  246262,
  32280,
  6192,
  75890,
  45546,
  143264,
  135305,
  29742,
  47013,
  77787,
  11732,
  126658,
  8763,
  37950,
  21806,
  57557,
  113464,
  89465,
  108995,
  164574,
  23894,
  22996,
  23169,
  15369,
  23117,
  17642,
  130607,
  40503,
  36239,
  280990,
  44666,
  9981,
  40427,
  147487,
  26869,
  168452,
  32886,
  32991,
  46798,
  240839,
  15111,
  70502,
  65697,
  88548,
  44145,
  28701,
  48767,
  31139,
  206777,
  35659,
  181164,
  166262,
  14554,
  171445,
  31786,
  66523,
  76607,
  17956,
  6507,
  31279,
  90476,
  116611,
  167918,
  6560,
  1243,
  115324,
  80128,
  41867,
  55897,
  187323,
  37069,
  32596,
  189444,
  145931,
  13390,
  105530,
  65709,
  26805,
  6999,
  55714,
  41300,
  22915,
  68951,
  22138,
  21120,
  22264,
  10058,
  19945,
  33635,
  56123,
  99085,
  10032,
  5818,
  6016,
  46649,
  57476,
  35264,
  94413,
  112522,
  262288,
  93686,
  83038,
  14341,
  23204,
  28807,
  66084,
  77987,
  6101,
  126673,
  7133,
  38126,
  5923,
  122091,
  170240,
  97772,
  46874,
  215746,
  43948,
  41622,
  3272,
  55596,
  8332,
  146411,
  251315,
  13533,
  8561,
  81521,
  115449,
  48616,
  175175,
  2063,
  186556,
  3036,
  134537,
  75772,
  29728,
  82360,
  22973,
  186559,
  86348,
  89100,
  38388,
  82297,
  45610,
  2613,
  87082,
  9986,
  177812,
  57884,
  23591,
  47485,
  42543,
  33582,
  44713,
  74439,
  257444,
  252451,
  31825,
  35631,
  38540,
  33066,
  5147,
  13973,
  4343,
  51830,
  70378,
  22827,
  26448,
  95560,
  36896,
  241741,
  48067,
  203953,
  298860,
  61620,
  20450,
  3220,
  67272,
  6586,
  107662,
  100160,
  108684,
  6929,
  57226,
  4762,
  7457,
  1320,
  40404,
  77204,
  99309,
  62750,
  208653,
  59977,
  44e3,
  74315,
  34332,
  5819,
  172217,
  64904,
  114077,
  18147,
  84012,
  1791,
  98456,
  90930,
  21446,
  116669,
  103938,
  7422,
  85140,
  59713,
  5768,
  326211,
  16239,
  75411,
  13229,
  29398,
  10758,
  236107,
  1539,
  112472,
  95979,
  152154,
  151294,
  306,
  21196,
  38146,
  10700,
  6891,
  84282,
  109646,
  56492,
  40539,
  6589,
  119491,
  51354,
  30685,
  140209,
  136906,
  29622,
  73617,
  49553,
  70525,
  51671,
  166869,
  139616,
  74395,
  37439,
  49595,
  45678,
  11959,
  33211,
  86560,
  52434,
  9282,
  62690,
  112155,
  130810,
  5243,
  108261,
  99970,
  265613,
  72551,
  80049,
  6391,
  33365,
  90721,
  66737,
  69872,
  87011,
  1860,
  9032,
  112544,
  60905,
  37371,
  89015,
  140351,
  19076,
  850,
  373531,
  2802,
  36725,
  218795,
  72062,
  28990,
  16550,
  24614,
  7815,
  6187,
  26336,
  33373,
  32162,
  42791,
  73555,
  32062,
  23386,
  10244,
  56392,
  49442,
  27076,
  136262,
  12412,
  14883,
  1134,
  33675,
  97153,
  199281,
  15608,
  100152,
  74072,
  47942,
  254301,
  36451,
  16026,
  10687,
  65067,
  56708,
  254030,
  30290,
  50490,
  13864,
  57941,
  259331,
  35588,
  23485,
  43486,
  24869,
  21620,
  92971,
  22072,
  88645,
  1048,
  182050,
  13343,
  32452,
  14825,
  19509,
  3325,
  216938,
  45740,
  99716,
  189082,
  53740,
  78245,
  25609,
  24311,
  176777,
  47340,
  308354,
  40669,
  66085,
  14102,
  125339,
  9225,
  128709,
  97207,
  1271,
  200933,
  78439,
  113451,
  88975,
  18324,
  46521,
  11819,
  18570,
  141756,
  72512,
  170020,
  52754,
  63550,
  118515,
  103073,
  93330,
  32736,
  50499,
  14722,
  31600,
  68452,
  398867,
  29316,
  172786,
  18417,
  104924,
  2606,
  5670,
  84818,
  16288,
  67106,
  59580,
  82929,
  607401,
  291,
  85829,
  359,
  15897,
  35830,
  50696,
  65630,
  52672,
  22115,
  356968,
  29895,
  40837,
  231192,
  34024,
  38957,
  26722,
  406,
  23335,
  124952,
  72068,
  68804,
  13268,
  147101,
  164740,
  276569,
  162596,
  66943,
  11569,
  26654,
  66358,
  4777,
  23229,
  102127,
  5848,
  978,
  2921,
  59666,
  5371,
  28212,
  90108,
  42938,
  39320,
  2499,
  4271,
  108792,
  33510,
  125072,
  71653,
  65239,
  38250,
  66357,
  38577,
  13964,
  86251,
  35708,
  50755,
  36010,
  29448,
  12209,
  3844,
  38222,
  206337,
  100876,
  67827,
  137088,
  14167,
  252225,
  84163,
  195270,
  1306,
  5703,
  54198,
  779,
  46802,
  22028,
  51124,
  86759,
  70560,
  113164,
  35685,
  162145,
  45471,
  34561,
  422,
  2611,
  6464,
  47486,
  19223,
  38246,
  9191,
  18331,
  89942,
  243642,
  212364,
  15893,
  17518,
  22617,
  6409,
  30046,
  126182,
  59716,
  36560,
  104428,
  18846,
  26592,
  19458,
  50793,
  147333,
  30826,
  1388,
  27647,
  10922,
  14495,
  33545,
  19269,
  135828,
  39727,
  41601,
  46931,
  233379,
  49169,
  131130,
  182112,
  16276,
  82381,
  118209,
  142445,
  128310,
  19672,
  28740,
  82907,
  33436,
  3118,
  102206,
  28723,
  24819,
  41937,
  38854,
  5157,
  3881,
  111491,
  1142,
  9776,
  421673,
  152241,
  29309,
  14961,
  87854,
  6054,
  15424,
  3796,
  82656,
  54996,
  2108,
  55367,
  239450,
  154525,
  9643,
  118103,
  106041,
  64601,
  68549,
  48707,
  30266,
  25772,
  18740,
  9462,
  229669,
  91798,
  112152,
  191327,
  14493,
  72828,
  8175,
  66636,
  236474,
  25817,
  87351,
  129027,
  76653,
  20422,
  22983,
  71240,
  27846,
  44661,
  12399,
  46158,
  77704,
  53101,
  35032,
  11072,
  17300,
  109294,
  33638,
  24408,
  1895,
  11241,
  760,
  17584,
  82479,
  125877,
  63150,
  141075,
  34259,
  23274,
  81698,
  15732,
  43577,
  48340,
  91584,
  14688,
  16379,
  24481,
  150280,
  96420,
  262050,
  48635,
  43727,
  61819,
  56268,
  72003,
  88178,
  17281,
  79912,
  13218,
  122519,
  125295,
  166396,
  11811,
  2171,
  118930,
  67746,
  17636,
  178278,
  174656,
  95661,
  173039,
  83845,
  79689,
  17473,
  98555,
  127696,
  203415,
  54730,
  22925,
  232239,
  9309,
  12136,
  175026,
  20740,
  180188,
  10747,
  39816,
  314017,
  266131,
  10040,
  175732,
  112550,
  220651,
  31974,
  37393,
  888,
  23008,
  86799,
  4303,
  64905,
  148467,
  75337,
  251,
  3284,
  370102,
  50264,
  9835,
  5438,
  23655,
  4481,
  29851,
  329,
  12855,
  7162,
  64931,
  78141,
  12804,
  42372,
  296771,
  83547,
  18624,
  34874,
  86271,
  3360,
  48665,
  77735,
  88767,
  11463,
  63527,
  28889,
  22258,
  29140,
  194315,
  113924,
  25499,
  6406,
  31334,
  1845,
  4802,
  49184,
  43455,
  35469,
  127594,
  92970,
  61038,
  115005,
  38840,
  87761,
  106838,
  8811,
  20572,
  55637,
  11162,
  96721,
  132425,
  108925,
  2948,
  125457,
  36356,
  3502,
  75270,
  27622,
  127192,
  2561,
  123095,
  49394,
  61155,
  16897,
  110064,
  9699,
  89448,
  53356,
  19628,
  220310,
  21622,
  83036,
  9885,
  112214,
  6087,
  26713,
  17901,
  161912,
  91492,
  3440,
  68594,
  9266,
  92238,
  8087,
  6866,
  150194,
  72175,
  80701,
  13459,
  31836,
  43243,
  239700,
  95846,
  44749,
  50647,
  21945,
  230538,
  120612,
  132371,
  244604,
  5193,
  105637,
  34661,
  41341,
  68775,
  85393,
  1874,
  8771,
  33718,
  49672,
  77403,
  595452,
  99507,
  6490,
  58895,
  128742,
  7704,
  39239,
  73217,
  43816,
  62824,
  37804,
  199976,
  22361,
  80005,
  87514,
  94832,
  14089,
  4574,
  139975,
  59142,
  75523,
  100268,
  43906,
  53442,
  15152,
  2547,
  186002,
  17011,
  19513,
  204282,
  3343,
  60568,
  128318,
  119250,
  4298,
  51871,
  41336,
  71759,
  21921,
  45074,
  98169,
  145889,
  99427,
  11350,
  1237,
  5520,
  28799,
  7803,
  53702,
  21026,
  136352,
  38293,
  128690,
  12158,
  90132,
  44600,
  10184,
  26957,
  39459,
  126025,
  78904,
  82999,
  59373,
  39301,
  150198,
  120529,
  153042,
  20177,
  50089,
  14764,
  271571,
  30530,
  123161,
  38975,
  101562,
  22941,
  5648,
  124654,
  109243,
  69817,
  71675,
  49162,
  106884,
  21241,
  107795,
  30258,
  16572,
  188262,
  141456,
  7688,
  60718,
  8271,
  11044,
  32440,
  104608,
  103419,
  236109,
  93156,
  43293,
  128929,
  42107,
  67180,
  25201,
  115254,
  185488,
  130954,
  72813,
  167547,
  20537,
  39969,
  38432,
  22582,
  184022,
  1139,
  27199,
  5655,
  17767,
  97412,
  122606,
  209377,
  27070,
  35871,
  326617,
  188954,
  42680,
  73512,
  80911,
  22629,
  3011,
  95021,
  315242,
  157737,
  383,
  41821,
  41808,
  19335,
  27950,
  15674,
  25677,
  110950,
  35375,
  76835,
  59108,
  57370,
  35262,
  16569,
  160415,
  37706,
  78086,
  32041,
  49691,
  137143,
  9782,
  172080,
  50148,
  77917,
  6323,
  10110,
  69172,
  17711,
  21795,
  59511,
  76184,
  135114,
  31046,
  132319,
  59105,
  157578,
  20549,
  80778,
  57649,
  158421,
  65143,
  4575,
  72235,
  21899,
  10797,
  92745,
  34035,
  106079,
  80159,
  4508,
  78304,
  25350,
  75457,
  46458,
  32937,
  25623,
  47,
  8531,
  104751,
  84953,
  8138,
  36508,
  187199,
  66310,
  115274,
  13253,
  32461,
  38536,
  1916,
  42007,
  187160,
  35055,
  26325,
  84394,
  35963,
  94216,
  45590,
  97782
];

// node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
var MAX_COMMON_PREFIX_LENGTH = 15;
var RoutingTableRefresh = class {
  constructor(components, init) {
    __publicField(this, "log");
    __publicField(this, "peerRouting");
    __publicField(this, "routingTable");
    __publicField(this, "refreshInterval");
    __publicField(this, "refreshQueryTimeout");
    __publicField(this, "commonPrefixLengthRefreshedAt");
    __publicField(this, "refreshTimeoutId");
    const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
    this.peerRouting = peerRouting;
    this.routingTable = routingTable;
    this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
    this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
    this.commonPrefixLengthRefreshedAt = [];
    this.refreshTable = this.refreshTable.bind(this);
  }
  async afterStart() {
    this.log(`refreshing routing table every ${this.refreshInterval}ms`);
    this.refreshTable(true);
  }
  async stop() {
    if (this.refreshTimeoutId != null) {
      clearTimeout(this.refreshTimeoutId);
    }
  }
  /**
   * To speed lookups, we seed the table with random PeerIds. This means
   * when we are asked to locate a peer on the network, we can find a KadId
   * that is close to the requested peer ID and query that, then network
   * peers will tell us who they know who is close to the fake ID
   */
  refreshTable(force = false) {
    this.log("refreshing routing table");
    const prefixLength = this._maxCommonPrefix();
    const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
    this.log(`max common prefix length ${prefixLength}`);
    this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
    Promise.all(refreshCpls.map(async (lastRefresh, index) => {
      try {
        await this._refreshCommonPrefixLength(index, lastRefresh, force);
        if (this._numPeersForCpl(prefixLength) === 0) {
          const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
          for (let n = index + 1; n < lastCpl + 1; n++) {
            try {
              await this._refreshCommonPrefixLength(n, lastRefresh, force);
            } catch (err) {
              this.log.error(err);
            }
          }
        }
      } catch (err) {
        this.log.error(err);
      }
    })).catch((err) => {
      this.log.error(err);
    }).then(() => {
      this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
      if (this.refreshTimeoutId.unref != null) {
        this.refreshTimeoutId.unref();
      }
    }).catch((err) => {
      this.log.error(err);
    });
  }
  async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
    if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
      this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
      return;
    }
    const peerId = await this._generateRandomPeerId(cpl);
    this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId, this.routingTable.size);
    const signal = AbortSignal.timeout(this.refreshQueryTimeout);
    setMaxListeners(Infinity, signal);
    const peers = await src_default10(this.peerRouting.getClosestPeers(peerId.toMultihash().bytes, {
      signal
    }));
    this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId);
    this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId, this.routingTable.size);
  }
  _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
    if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
      maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
    }
    const dates = [];
    for (let i = 0; i <= maxCommonPrefix; i++) {
      dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? /* @__PURE__ */ new Date();
    }
    return dates;
  }
  async _generateRandomPeerId(targetCommonPrefixLength) {
    if (this.routingTable.kb == null) {
      throw new Error("Routing table not started");
    }
    if (this.routingTable.kb.localPeer == null) {
      throw new Error("Local peer not set");
    }
    const randomData = randomBytes(2);
    const randomUint16 = (randomData[1] << 8) + randomData[0];
    const key = await this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
    const multihash = decode(key);
    return peerIdFromMultihash(multihash);
  }
  async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
    if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
      throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
    }
    const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
    const localPrefix = view.getUint16(0, false);
    const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
    const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
    const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
    const keyPrefix2 = generated_prefix_list_browser_default[targetPrefix];
    const keyBuffer = new ArrayBuffer(34);
    const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
    keyView.setUint8(0, sha256.code);
    keyView.setUint8(1, 32);
    keyView.setUint32(2, keyPrefix2, false);
    return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
  }
  /**
   * returns the maximum common prefix length between any peer in the table
   * and the current peer
   */
  _maxCommonPrefix() {
    let prefixLength = 0;
    for (const length2 of this._prefixLengths()) {
      if (length2 > prefixLength) {
        prefixLength = length2;
      }
    }
    return prefixLength;
  }
  /**
   * Returns the number of peers in the table with a given prefix length
   */
  _numPeersForCpl(prefixLength) {
    let count = 0;
    for (const length2 of this._prefixLengths()) {
      if (length2 === prefixLength) {
        count++;
      }
    }
    return count;
  }
  /**
   * Yields the common prefix length of every peer in the table
   */
  *_prefixLengths() {
    var _a13;
    if (((_a13 = this.routingTable.kb) == null ? void 0 : _a13.localPeer) == null) {
      return;
    }
    for (const { kadId } of this.routingTable.kb.toIterable()) {
      const distance = xor(this.routingTable.kb.localPeer.kadId, kadId);
      let leadingZeros = 0;
      for (const byte of distance) {
        if (byte === 0) {
          leadingZeros++;
        } else {
          break;
        }
      }
      yield leadingZeros;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
var AddProviderHandler = class {
  constructor(components, init) {
    __publicField(this, "peerId");
    __publicField(this, "providers");
    __publicField(this, "peerStore");
    __publicField(this, "log");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
    this.peerId = components.peerId;
    this.providers = init.providers;
    this.peerStore = components.peerStore;
  }
  async handle(peerId, msg) {
    if (msg.key == null || msg.key.length === 0) {
      throw new InvalidMessageError("Missing key");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError("Invalid CID");
    }
    if (msg.providers == null || msg.providers.length === 0) {
      this.log.error("no providers found in message");
    }
    this.log("%p asked us, %p to store provider record for for %c", peerId, this.peerId, cid);
    await Promise.all(msg.providers.map(async (pi) => {
      const digest = decode(pi.id);
      const providerId = peerIdFromMultihash(digest);
      const providerMultiaddrs = pi.multiaddrs.map((buf) => multiaddr(buf));
      if (!peerId.equals(providerId)) {
        this.log("invalid provider peer %p from %p", pi.id, peerId);
        return;
      }
      if (pi.multiaddrs.length < 1) {
        this.log("no valid addresses for provider %p. Ignore", peerId);
        return;
      }
      this.log.trace("received provider %p for %s (addrs %s)", peerId, cid, providerMultiaddrs);
      await this.providers.addProvider(cid, providerId);
      await this.peerStore.merge(providerId, {
        multiaddrs: providerMultiaddrs
      });
    }));
    return void 0;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
var FindNodeHandler = class {
  constructor(components, init) {
    __publicField(this, "peerRouting");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "peerId");
    __publicField(this, "addressManager");
    __publicField(this, "log");
    const { peerRouting, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
    this.peerId = components.peerId;
    this.addressManager = components.addressManager;
    this.peerRouting = peerRouting;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  /**
   * Process `FindNode` DHT messages
   */
  async handle(peerId, msg) {
    this.log("incoming request from %p for peers closer to %b", peerId, msg.key);
    if (msg.key == null) {
      throw new InvalidMessageError("Invalid FIND_NODE message received - key was missing");
    }
    const closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId);
    if (equals(this.peerId.toMultihash().bytes, msg.key)) {
      closer.push({
        id: this.peerId,
        multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
    }
    const response = {
      type: MessageType.FIND_NODE,
      clusterLevel: msg.clusterLevel,
      closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: []
    };
    if (response.closer.length === 0) {
      this.log("could not find any peers closer to %b than %p", msg.key, peerId);
    }
    return response;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
var GetProvidersHandler = class {
  constructor(components, init) {
    __publicField(this, "peerId");
    __publicField(this, "peerRouting");
    __publicField(this, "providers");
    __publicField(this, "peerStore");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "log");
    const { peerRouting, providers, logPrefix } = init;
    this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.peerRouting = peerRouting;
    this.providers = providers;
    this.peerInfoMapper = init.peerInfoMapper;
  }
  async handle(peerId, msg) {
    if (msg.key == null) {
      throw new InvalidMessageError("Invalid GET_PROVIDERS message received - key was missing");
    }
    let cid;
    try {
      cid = CID.decode(msg.key);
    } catch (err) {
      throw new InvalidMessageError("Invalid CID");
    }
    this.log("%p asking for providers for %s", peerId, cid);
    const [providerPeers, closerPeers] = await Promise.all([
      src_default4(src_default6(await this.providers.getProviders(cid), async (peerId2) => {
        const peer = await this.peerStore.get(peerId2);
        const info = {
          id: peer.id,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        };
        return info;
      })),
      this.peerRouting.getCloserPeersOffline(msg.key, this.peerId)
    ]);
    const response = {
      type: MessageType.GET_PROVIDERS,
      key: msg.key,
      clusterLevel: msg.clusterLevel,
      closer: closerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      })),
      providers: providerPeers.map(this.peerInfoMapper).filter(({ id, multiaddrs }) => multiaddrs.length > 0).map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }))
    };
    this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
    return response;
  }
  async _getAddresses(peerId) {
    return [];
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
var GetValueHandler = class {
  constructor(components, init) {
    __publicField(this, "peerStore");
    __publicField(this, "datastore");
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "datastorePrefix");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.peerStore = components.peerStore;
    this.datastore = components.datastore;
    this.peerRouting = init.peerRouting;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked for key %b", peerId, key);
    if (key == null || key.length === 0) {
      throw new InvalidMessageError("Invalid key");
    }
    const response = {
      type: MessageType.GET_VALUE,
      key,
      clusterLevel: msg.clusterLevel,
      closer: [],
      providers: []
    };
    if (isPublicKeyKey(key)) {
      this.log("is public key");
      const idFromKey = fromPublicKeyKey(key);
      let pubKey;
      try {
        const peer = await this.peerStore.get(idFromKey);
        if (peer.id.publicKey == null) {
          throw new NotFoundError("No public key found in key book");
        }
        pubKey = publicKeyToProtobuf(peer.id.publicKey);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (pubKey != null) {
        this.log("returning found public key");
        response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
        return response;
      }
    }
    const [record, closer] = await Promise.all([
      this._checkLocalDatastore(key),
      this.peerRouting.getCloserPeersOffline(key, peerId)
    ]);
    if (record != null) {
      this.log("had record for %b in local datastore", key);
      response.record = record.serialize();
    }
    if (closer.length > 0) {
      this.log("had %s closer peers in routing table", closer.length);
      response.closer = closer.map((peerInfo) => ({
        id: peerInfo.id.toMultihash().bytes,
        multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
      }));
    }
    return response;
  }
  /**
   * Try to fetch a given record by from the local datastore.
   * Returns the record if it is still valid, meaning
   * - it was either authored by this node, or
   * - it was received less than `MAX_RECORD_AGE` ago.
   */
  async _checkLocalDatastore(key) {
    this.log("checkLocalDatastore looking for %b", key);
    const dsKey = bufferToRecordKey(this.datastorePrefix, key);
    let rawRecord;
    try {
      rawRecord = await this.datastore.get(dsKey);
    } catch (err) {
      if (err.name === "NotFoundError") {
        return void 0;
      }
      throw err;
    }
    const record = Libp2pRecord.deserialize(rawRecord);
    if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
      await this.datastore.delete(dsKey);
      return void 0;
    }
    return record;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
var PingHandler = class {
  constructor(components, init) {
    __publicField(this, "log");
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
  }
  async handle(peerId, msg) {
    this.log("ping from %p", peerId);
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
var PutValueHandler = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "validators");
    __publicField(this, "log");
    __publicField(this, "datastorePrefix");
    const { validators: validators2 } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
    this.datastorePrefix = `${init.datastorePrefix}/record`;
    this.validators = validators2;
  }
  async handle(peerId, msg) {
    const key = msg.key;
    this.log("%p asked us to store value for key %b", peerId, key);
    if (msg.record == null) {
      const errMsg = `Empty record from: ${peerId.toString()}`;
      this.log.error(errMsg);
      throw new InvalidMessageError(errMsg);
    }
    try {
      const deserializedRecord = Libp2pRecord.deserialize(msg.record);
      await verifyRecord(this.validators, deserializedRecord);
      deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
      const recordKey = bufferToRecordKey(this.datastorePrefix, deserializedRecord.key);
      await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
      this.log("put record for %b into datastore under key %k", key, recordKey);
    } catch (err) {
      this.log("did not put record for key %b into datastore %o", key, err);
    }
    return msg;
  }
};

// node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
var RPC = class {
  constructor(components, init) {
    __publicField(this, "handlers");
    __publicField(this, "routingTable");
    __publicField(this, "log");
    __publicField(this, "metrics");
    var _a13, _b9;
    this.metrics = {
      operations: (_a13 = components.metrics) == null ? void 0 : _a13.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_requests_total`),
      errors: (_b9 = components.metrics) == null ? void 0 : _b9.registerCounterGroup(`${init.metricsPrefix}_inbound_rpc_errors_total`)
    };
    this.log = components.logger.forComponent(`${init.logPrefix}:rpc`);
    this.routingTable = init.routingTable;
    this.handlers = {
      [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, init),
      [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, init),
      [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, init),
      [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, init),
      [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, init),
      [MessageType.PING.toString()]: new PingHandler(components, init)
    };
  }
  /**
   * Process incoming DHT messages
   */
  async handleMessage(peerId, msg) {
    var _a13, _b9;
    const handler = this.handlers[msg.type];
    if (handler == null) {
      this.log.error(`no handler found for message type: ${msg.type}`);
      return;
    }
    try {
      (_a13 = this.metrics.operations) == null ? void 0 : _a13.increment({
        [msg.type]: true
      });
      return await handler.handle(peerId, msg);
    } catch {
      (_b9 = this.metrics.errors) == null ? void 0 : _b9.increment({
        [msg.type]: true
      });
    }
  }
  /**
   * Handle incoming streams on the dht protocol
   */
  onIncomingStream(data) {
    let message2 = "unknown";
    Promise.resolve().then(async () => {
      const { stream, connection } = data;
      const peerId = connection.remotePeer;
      const self2 = this;
      await pipe(stream, (source) => decode3(source), async function* (source) {
        for await (const msg of source) {
          const desMessage = Message2.decode(msg);
          message2 = desMessage.type;
          self2.log("incoming %s from %p", desMessage.type, peerId);
          const res = await self2.handleMessage(peerId, desMessage);
          if (res != null) {
            yield Message2.encode(res);
          }
        }
      }, (source) => encode2(source), stream);
    }).catch((err) => {
      this.log.error("error handling %s RPC message from %p - %e", message2, data.connection.remotePeer, err);
    });
  }
};

// node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
var TopologyListener = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "protocol");
    __publicField(this, "running");
    __publicField(this, "registrarId");
    const { protocol, logPrefix } = init;
    this.components = components;
    this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
    this.running = false;
    this.protocol = protocol;
  }
  isStarted() {
    return this.running;
  }
  /**
   * Start the network
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    this.registrarId = await this.components.registrar.register(this.protocol, {
      onConnect: (peerId) => {
        this.log("observed peer %p with protocol %s", peerId, this.protocol);
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerId
        }));
      }
    });
  }
  /**
   * Stop all network activity
   */
  async stop() {
    this.running = false;
    if (this.registrarId != null) {
      this.components.registrar.unregister(this.registrarId);
      this.registrarId = void 0;
    }
  }
};

// node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
var DHTContentRouting = class {
  constructor(dht) {
    __publicField(this, "dht");
    this.dht = dht;
  }
  async provide(cid, options2 = {}) {
    await src_default7(this.dht.provide(cid, options2));
  }
  async cancelReprovide(key) {
    await this.dht.cancelReprovide(key);
  }
  async *findProviders(cid, options2 = {}) {
    for await (const event of this.dht.findProviders(cid, options2)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value, options2) {
    await src_default7(this.dht.put(key, value, options2));
  }
  async get(key, options2) {
    for await (const event of this.dht.get(key, options2)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw new NotFoundError("Could not find value for key");
  }
};
var DHTPeerRouting = class {
  constructor(dht) {
    __publicField(this, "dht");
    this.dht = dht;
  }
  async findPeer(peerId, options2 = {}) {
    for await (const event of this.dht.findPeer(peerId, options2)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw new NotFoundError("Peer not found");
  }
  async *getClosestPeers(key, options2 = {}) {
    for await (const event of this.dht.getClosestPeers(key, options2)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};
var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
var _a7, _b4, _c2;
var KadDHT = class extends TypedEventEmitter {
  /**
   * Create a new KadDHT
   */
  constructor(components, init = {}) {
    var _a13, _b9, _c5, _d2;
    super();
    __publicField(this, "protocol");
    __publicField(this, "routingTable");
    __publicField(this, "providers");
    __publicField(this, "network");
    __publicField(this, "peerRouting");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "running");
    __publicField(this, "kBucketSize");
    __publicField(this, "clientMode");
    __publicField(this, "validators");
    __publicField(this, "selectors");
    __publicField(this, "queryManager");
    __publicField(this, "contentFetching");
    __publicField(this, "contentRouting");
    __publicField(this, "routingTableRefresh");
    __publicField(this, "rpc");
    __publicField(this, "topologyListener");
    __publicField(this, "querySelf");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "dhtContentRouting");
    __publicField(this, "dhtPeerRouting");
    __publicField(this, "peerInfoMapper");
    __publicField(this, "reprovider");
    __publicField(this, _a7, "@libp2p/kad-dht");
    __publicField(this, _b4, [
      "@libp2p/content-routing",
      "@libp2p/peer-routing",
      "@libp2p/peer-discovery"
    ]);
    __publicField(this, _c2, [
      "@libp2p/identify"
    ]);
    const logPrefix = init.logPrefix ?? "libp2p:kad-dht";
    const datastorePrefix = init.datastorePrefix ?? "/dht";
    const metricsPrefix = init.metricsPrefix ?? "libp2p_kad_dht";
    const operationMetrics = {
      queries: (_a13 = components.metrics) == null ? void 0 : _a13.registerMetricGroup(`${metricsPrefix}_operations_total`, { label: "operation" }),
      errors: (_b9 = components.metrics) == null ? void 0 : _b9.registerCounterGroup(`${metricsPrefix}_operation_errors_total`, { label: "operation" }),
      queryTime: (_c5 = components.metrics) == null ? void 0 : _c5.registerMetricGroup(`${metricsPrefix}_operation_time_seconds`, { label: "operation" }),
      errorTime: (_d2 = components.metrics) == null ? void 0 : _d2.registerMetricGroup(`${metricsPrefix}_operation_error_time_seconds`, { label: "operation" })
    };
    this.running = false;
    this.components = components;
    this.log = components.logger.forComponent(logPrefix);
    this.protocol = init.protocol ?? PROTOCOL;
    this.kBucketSize = init.kBucketSize ?? 20;
    this.clientMode = init.clientMode ?? true;
    this.maxInboundStreams = init.maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = init.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
    this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
    const providerLock = createMortice();
    this.providers = new Providers(components, {
      ...init.providers,
      logPrefix,
      datastorePrefix,
      lock: providerLock
    });
    this.validators = {
      ...validators,
      ...init.validators
    };
    this.selectors = {
      ...selectors,
      ...init.selectors
    };
    this.network = new Network2(components, {
      protocol: this.protocol,
      logPrefix,
      metricsPrefix
    });
    this.routingTable = new RoutingTable(components, {
      kBucketSize: init.kBucketSize,
      pingOldContactTimeout: init.pingOldContactTimeout,
      pingOldContactConcurrency: init.pingOldContactConcurrency,
      pingOldContactMaxQueueSize: init.pingOldContactMaxQueueSize,
      pingNewContactTimeout: init.pingNewContactTimeout,
      pingNewContactConcurrency: init.pingNewContactConcurrency,
      pingNewContactMaxQueueSize: init.pingNewContactMaxQueueSize,
      protocol: this.protocol,
      logPrefix,
      metricsPrefix,
      prefixLength: init.prefixLength,
      splitThreshold: init.kBucketSplitThreshold,
      network: this.network
    });
    const initialQuerySelfHasRun = pDefer();
    if (init.allowQueryWithZeroPeers === true) {
      initialQuerySelfHasRun.resolve();
    }
    this.queryManager = new QueryManager(components, {
      // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper
      disjointPaths: Math.ceil(this.kBucketSize / 2),
      logPrefix,
      metricsPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable
    });
    this.peerRouting = new PeerRouting(components, {
      routingTable: this.routingTable,
      network: this.network,
      validators: this.validators,
      queryManager: this.queryManager,
      logPrefix
    });
    this.contentFetching = new ContentFetching(components, {
      validators: this.validators,
      selectors: this.selectors,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      network: this.network,
      logPrefix,
      datastorePrefix
    });
    this.contentRouting = new ContentRouting(components, {
      network: this.network,
      peerRouting: this.peerRouting,
      queryManager: this.queryManager,
      routingTable: this.routingTable,
      providers: this.providers,
      logPrefix
    });
    this.routingTableRefresh = new RoutingTableRefresh(components, {
      peerRouting: this.peerRouting,
      routingTable: this.routingTable,
      logPrefix
    });
    this.rpc = new RPC(components, {
      routingTable: this.routingTable,
      providers: this.providers,
      peerRouting: this.peerRouting,
      validators: this.validators,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      peerInfoMapper: this.peerInfoMapper
    });
    this.topologyListener = new TopologyListener(components, {
      protocol: this.protocol,
      logPrefix
    });
    this.querySelf = new QuerySelf(components, {
      peerRouting: this.peerRouting,
      interval: init.querySelfInterval,
      initialInterval: init.initialQuerySelfInterval,
      logPrefix,
      initialQuerySelfHasRun,
      routingTable: this.routingTable,
      operationMetrics
    });
    this.reprovider = new Reprovider(components, {
      ...init.reprovide,
      logPrefix,
      metricsPrefix,
      datastorePrefix,
      contentRouting: this.contentRouting,
      lock: providerLock,
      operationMetrics
    });
    this.network.addEventListener("peer", (evt) => {
      const peerData = evt.detail;
      this.onPeerConnect(peerData).catch((err) => {
        this.log.error("could not add %p to routing table", peerData.id, err);
      });
      this.dispatchEvent(new CustomEvent("peer", {
        detail: peerData
      }));
    });
    this.topologyListener.addEventListener("peer", (evt) => {
      const peerId = evt.detail;
      Promise.resolve().then(async () => {
        const peer = await this.components.peerStore.get(peerId);
        const peerData = {
          id: peerId,
          multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
          protocols: peer.protocols
        };
        await this.onPeerConnect(peerData);
      }).catch((err) => {
        this.log.error("could not add %p to routing table - %e", peerId, err);
      });
    });
    this.dhtPeerRouting = new DHTPeerRouting(this);
    this.dhtContentRouting = new DHTContentRouting(this);
    if (init.clientMode == null) {
      components.events.addEventListener("self:peer:update", (evt) => {
        this.log("received update of self-peer info");
        void Promise.resolve().then(async () => {
          const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => multiaddrIsPublic(multiaddr2));
          const mode = this.getMode();
          if (hasPublicAddress && mode === "client") {
            await this.setMode("server");
          } else if (mode === "server" && !hasPublicAddress) {
            await this.setMode("client");
          }
        }).catch((err) => {
          this.log.error("error setting dht server mode", err);
        });
      });
    }
    this.get = timeOperationGenerator(this.get.bind(this), operationMetrics, "GET_VALUE");
    this.findProviders = timeOperationGenerator(this.findProviders.bind(this), operationMetrics, "FIND_PROVIDERS");
    this.findPeer = timeOperationGenerator(this.findPeer.bind(this), operationMetrics, "FIND_PEER");
    this.getClosestPeers = timeOperationGenerator(this.getClosestPeers.bind(this), operationMetrics, "GET_CLOSEST_PEERS");
    this.provide = timeOperationGenerator(this.provide.bind(this), operationMetrics, "PROVIDE");
    this.put = timeOperationGenerator(this.put.bind(this), operationMetrics, "PUT_VALUE");
  }
  get [(_a7 = Symbol.toStringTag, _b4 = serviceCapabilities, _c2 = serviceDependencies, contentRoutingSymbol)]() {
    return this.dhtContentRouting;
  }
  get [peerRoutingSymbol]() {
    return this.dhtPeerRouting;
  }
  get [peerDiscoverySymbol]() {
    return this;
  }
  async onPeerConnect(peerData) {
    this.log.trace("peer %p connected", peerData.id);
    peerData = this.peerInfoMapper(peerData);
    if (peerData.multiaddrs.length === 0) {
      this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
      return;
    }
    try {
      await this.routingTable.add(peerData.id);
    } catch (err) {
      this.log.error("could not add %p to routing table", peerData.id, err);
    }
  }
  /**
   * Is this DHT running.
   */
  isStarted() {
    return this.running;
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  getMode() {
    return this.clientMode ? "client" : "server";
  }
  /**
   * If 'server' this node will respond to DHT queries, if 'client' this node will not
   */
  async setMode(mode, force = false) {
    if (mode === this.getMode() && !force) {
      this.log("already in %s mode", mode);
      return;
    }
    await this.components.registrar.unhandle(this.protocol);
    if (mode === this.getMode() && !force) {
      this.log("already in %s mode", mode);
      return;
    }
    if (mode === "client") {
      this.log("enabling client mode while in %s mode", this.getMode());
      this.clientMode = true;
    } else {
      this.log("enabling server mode while in %s mode", this.getMode());
      this.clientMode = false;
      await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams
      });
    }
  }
  /**
   * Start listening to incoming connections.
   */
  async start() {
    if (this.running) {
      return;
    }
    this.running = true;
    await this.setMode(this.clientMode ? "client" : "server", true);
    await start(this.routingTable, this.queryManager, this.network, this.topologyListener, this.routingTableRefresh, this.reprovider);
    await start(this.querySelf);
  }
  /**
   * Stop accepting incoming connections and sending outgoing
   * messages.
   */
  async stop() {
    this.running = false;
    await stop(this.querySelf, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener, this.reprovider);
  }
  /**
   * Store the given key/value pair in the DHT
   */
  async *put(key, value, options2 = {}) {
    yield* this.contentFetching.put(key, value, options2);
  }
  /**
   * Get the value that corresponds to the passed key
   */
  async *get(key, options2 = {}) {
    yield* this.contentFetching.get(key, options2);
  }
  // ----------- Content Routing
  /**
   * Announce to the network that we can provide given key's value
   */
  async *provide(key, options2 = {}) {
    yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options2);
  }
  /**
   * Provider records must be re-published every 24 hours - pass a previously
   * provided CID here to not re-publish a record for it any more
   */
  async cancelReprovide(key) {
    await this.providers.removeProvider(key, this.components.peerId);
  }
  /**
   * Search the dht for providers of the given CID
   */
  async *findProviders(key, options2 = {}) {
    yield* this.contentRouting.findProviders(key, options2);
  }
  // ----------- Peer Routing -----------
  /**
   * Search for a peer with the given ID
   */
  async *findPeer(id, options2 = {}) {
    yield* this.peerRouting.findPeer(id, options2);
  }
  /**
   * Kademlia 'node lookup' operation
   */
  async *getClosestPeers(key, options2 = {}) {
    yield* this.peerRouting.getClosestPeers(key, options2);
  }
  async refreshRoutingTable() {
    this.routingTableRefresh.refreshTable(true);
  }
};

// node_modules/@libp2p/kad-dht/dist/src/index.js
var EventTypes;
(function(EventTypes2) {
  EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
  EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
  EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
  EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
  EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
  EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
  EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
  EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
})(EventTypes || (EventTypes = {}));
function kadDHT(init = {}) {
  return (components) => new KadDHT(components, init);
}

// node_modules/@libp2p/keychain/dist/src/keychain.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/@libp2p/crypto/dist/src/ciphers/aes-gcm.browser.js
var aes_gcm_browser_exports = {};
__export(aes_gcm_browser_exports, {
  create: () => create2,
  derivedEmptyPasswordKey: () => derivedEmptyPasswordKey
});
var derivedEmptyPasswordKey = { alg: "A128GCM", ext: true, k: "scm9jmO_4BJAgdwWGVulLg", key_ops: ["encrypt", "decrypt"], kty: "oct" };
function create2(opts) {
  const algorithm = (opts == null ? void 0 : opts.algorithm) ?? "AES-GCM";
  let keyLength = (opts == null ? void 0 : opts.keyLength) ?? 16;
  const nonceLength = (opts == null ? void 0 : opts.nonceLength) ?? 12;
  const digest = (opts == null ? void 0 : opts.digest) ?? "SHA-256";
  const saltLength = (opts == null ? void 0 : opts.saltLength) ?? 16;
  const iterations = (opts == null ? void 0 : opts.iterations) ?? 32767;
  const crypto2 = webcrypto_default.get();
  keyLength *= 8;
  async function encrypt(data, password) {
    const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
    const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["encrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["encrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
    }
    const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
  }
  async function decrypt(data, password) {
    const salt = data.subarray(0, saltLength);
    const nonce = data.subarray(saltLength, saltLength + nonceLength);
    const ciphertext = data.subarray(saltLength + nonceLength);
    const aesGcm = { name: algorithm, iv: nonce };
    if (typeof password === "string") {
      password = fromString(password);
    }
    let cryptoKey;
    if (password.length === 0) {
      try {
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
        const runtimeDerivedEmptyPassword = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
        cryptoKey = await crypto2.subtle.deriveKey(deriveParams, runtimeDerivedEmptyPassword, { name: algorithm, length: keyLength }, true, ["decrypt"]);
      } catch {
        cryptoKey = await crypto2.subtle.importKey("jwk", derivedEmptyPasswordKey, { name: "AES-GCM" }, true, ["decrypt"]);
      }
    } else {
      const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
      const rawKey = await crypto2.subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveKey"]);
      cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
    }
    const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
    return new Uint8Array(plaintext);
  }
  const cipher = {
    encrypt,
    decrypt
  };
  return cipher;
}

// node_modules/@libp2p/keychain/dist/src/utils/constants.js
var SALT_LENGTH = 16;
var KEY_SIZE = 32;
var ITERATIONS = 1e4;

// node_modules/@libp2p/keychain/dist/src/utils/export.js
async function exporter(privateKey, password) {
  const cipher = aes_gcm_browser_exports.create();
  const encryptedKey = await cipher.encrypt(privateKey, password);
  return base64.encode(encryptedKey);
}
async function exportPrivateKey(key, password, format) {
  if (key.type === "RSA") {
    return exportRSAPrivateKey(key, password, format);
  }
  if (key.type === "Ed25519") {
    return exportEd25519PrivateKey(key, password, format);
  }
  if (key.type === "secp256k1") {
    return exportSecp256k1PrivateKey(key, password, format);
  }
  throw new UnsupportedKeyTypeError();
}
async function exportEd25519PrivateKey(key, password, format = "libp2p-key") {
  if (format === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError(`export format '${format}' is not supported`);
  }
}
async function exportSecp256k1PrivateKey(key, password, format = "libp2p-key") {
  if (format === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError("Export format is not supported");
  }
}
async function exportRSAPrivateKey(key, password, format = "pkcs-8") {
  if (format === "pkcs-8") {
    return exportToPem(key, password);
  } else if (format === "libp2p-key") {
    return exporter(privateKeyToProtobuf(key), password);
  } else {
    throw new InvalidParametersError("Export format is not supported");
  }
}
async function exportToPem(privateKey, password) {
  const crypto2 = webcrypto_default.get();
  const keyWrapper = new Sequence({
    value: [
      // version (0)
      new Integer({ value: 0 }),
      // privateKeyAlgorithm
      new Sequence({
        value: [
          // rsaEncryption OID
          new ObjectIdentifier({
            value: "1.2.840.113549.1.1.1"
          }),
          new Null()
        ]
      }),
      // PrivateKey
      new OctetString({
        valueHex: privateKey.raw
      })
    ]
  });
  const keyBuf = keyWrapper.toBER();
  const keyArr = new Uint8Array(keyBuf, 0, keyBuf.byteLength);
  const salt = randomBytes(SALT_LENGTH);
  const encryptionKey = await pbkdf2Async(sha512, password, salt, {
    c: ITERATIONS,
    dkLen: KEY_SIZE
  });
  const iv = randomBytes(16);
  const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["encrypt"]);
  const encrypted = await crypto2.subtle.encrypt({
    name: "AES-CBC",
    iv
  }, cryptoKey, keyArr);
  const pbkdf2Params = new Sequence({
    value: [
      // salt
      new OctetString({ valueHex: salt }),
      // iteration count
      new Integer({ value: ITERATIONS }),
      // key length
      new Integer({ value: KEY_SIZE }),
      // AlgorithmIdentifier
      new Sequence({
        value: [
          // hmacWithSHA512
          new ObjectIdentifier({ value: "1.2.840.113549.2.11" }),
          new Null()
        ]
      })
    ]
  });
  const encryptionAlgorithm = new Sequence({
    value: [
      // pkcs5PBES2
      new ObjectIdentifier({
        value: "1.2.840.113549.1.5.13"
      }),
      new Sequence({
        value: [
          // keyDerivationFunc
          new Sequence({
            value: [
              // pkcs5PBKDF2
              new ObjectIdentifier({
                value: "1.2.840.113549.1.5.12"
              }),
              // PBKDF2-params
              pbkdf2Params
            ]
          }),
          // encryptionScheme
          new Sequence({
            value: [
              // aes256-CBC
              new ObjectIdentifier({
                value: "2.16.840.1.101.3.4.1.42"
              }),
              // iv
              new OctetString({
                valueHex: iv
              })
            ]
          })
        ]
      })
    ]
  });
  const finalWrapper = new Sequence({
    value: [
      encryptionAlgorithm,
      new OctetString({ valueHex: encrypted })
    ]
  });
  const finalWrapperBuf = finalWrapper.toBER();
  const finalWrapperArr = new Uint8Array(finalWrapperBuf, 0, finalWrapperBuf.byteLength);
  return [
    "-----BEGIN ENCRYPTED PRIVATE KEY-----",
    ...toString(finalWrapperArr, "base64pad").split(/(.{64})/).filter(Boolean),
    "-----END ENCRYPTED PRIVATE KEY-----"
  ].join("\n");
}

// node_modules/@libp2p/keychain/dist/src/utils/import.js
async function importPrivateKey(encryptedKey, password) {
  try {
    const key = await importer(encryptedKey, password);
    return privateKeyFromProtobuf(key);
  } catch {
  }
  if (!encryptedKey.includes("BEGIN")) {
    throw new InvalidParametersError("Encrypted key was not a libp2p-key or a PEM file");
  }
  return importFromPem(encryptedKey, password);
}
async function importer(privateKey, password) {
  const encryptedKey = base64.decode(privateKey);
  const cipher = aes_gcm_browser_exports.create();
  return cipher.decrypt(encryptedKey, password);
}
async function importFromPem(pem, password) {
  const crypto2 = webcrypto_default.get();
  let plaintext;
  if (pem.includes("-----BEGIN ENCRYPTED PRIVATE KEY-----")) {
    const key2 = fromString(pem.replace("-----BEGIN ENCRYPTED PRIVATE KEY-----", "").replace("-----END ENCRYPTED PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key2);
    const { iv, salt, iterations, keySize, cipherText } = findEncryptedPEMData(result);
    const encryptionKey = await pbkdf2Async(sha512, password, salt, {
      c: iterations,
      dkLen: keySize
    });
    const cryptoKey = await crypto2.subtle.importKey("raw", encryptionKey, "AES-CBC", false, ["decrypt"]);
    const decrypted = toUint8Array(await crypto2.subtle.decrypt({
      name: "AES-CBC",
      iv
    }, cryptoKey, cipherText));
    const { result: decryptedResult } = fromBER(decrypted);
    plaintext = findPEMData(decryptedResult);
  } else if (pem.includes("-----BEGIN PRIVATE KEY-----")) {
    const key2 = fromString(pem.replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "").replace(/\n/g, "").trim(), "base64pad");
    const { result } = fromBER(key2);
    plaintext = findPEMData(result);
  } else {
    throw new InvalidParametersError("Could not parse private key from PEM data");
  }
  const key = privateKeyFromRaw(plaintext);
  if (key.type !== "RSA") {
    throw new InvalidParametersError("Could not parse RSA private key from PEM data");
  }
  return key;
}
function findEncryptedPEMData(root) {
  const encryptionAlgorithm = root.valueBlock.value[0];
  const scheme = encryptionAlgorithm.valueBlock.value[0].toString();
  if (scheme !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.13") {
    throw new InvalidParametersError("Only pkcs5PBES2 encrypted private keys are supported");
  }
  const keyDerivationFunc = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[0];
  const keyDerivationFuncName = keyDerivationFunc.valueBlock.value[0].toString();
  if (keyDerivationFuncName !== "OBJECT IDENTIFIER : 1.2.840.113549.1.5.12") {
    throw new InvalidParametersError("Only pkcs5PBKDF2 key derivation functions are supported");
  }
  const pbkdf2Params = keyDerivationFunc.valueBlock.value[1];
  const salt = toUint8Array(pbkdf2Params.valueBlock.value[0].getValue());
  let iterations = ITERATIONS;
  let keySize = KEY_SIZE;
  if (pbkdf2Params.valueBlock.value.length === 3) {
    iterations = Number(pbkdf2Params.valueBlock.value[1].toBigInt());
    keySize = Number(pbkdf2Params.valueBlock.value[2].toBigInt());
  } else if (pbkdf2Params.valueBlock.value.length === 2) {
    throw new InvalidParametersError("Could not derive key size and iterations from PEM file - please use @libp2p/rsa to re-import your key");
  }
  const encryptionScheme = encryptionAlgorithm.valueBlock.value[1].valueBlock.value[1];
  const encryptionSchemeName = encryptionScheme.valueBlock.value[0].toString();
  if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.2.840.113549.3.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 1.3.14.3.2.7") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.2") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.22") {
  } else if (encryptionSchemeName === "OBJECT IDENTIFIER : 2.16.840.1.101.3.4.1.42") {
  } else {
    throw new InvalidParametersError("Only AES-CBC encryption schemes are supported");
  }
  const iv = toUint8Array(encryptionScheme.valueBlock.value[1].getValue());
  return {
    cipherText: toUint8Array(root.valueBlock.value[1].getValue()),
    salt,
    iterations,
    keySize,
    iv
  };
}
function findPEMData(seq) {
  return toUint8Array(seq.valueBlock.value[2].getValue());
}
function toUint8Array(buf) {
  return new Uint8Array(buf, 0, buf.byteLength);
}

// node_modules/@libp2p/keychain/dist/src/keychain.js
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions = {
  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name3) {
  if (name3 == null) {
    return false;
  }
  if (typeof name3 !== "string") {
    return false;
  }
  return name3 === (0, import_sanitize_filename.default)(name3.trim()) && name3.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay));
}
function DsName(name3) {
  return new Key(keyPrefix + name3);
}
function DsInfoName(name3) {
  return new Key(infoPrefix + name3);
}
async function keyId(key) {
  const pb = privateKeyToProtobuf(key);
  const hash = await sha256.digest(pb);
  return base58btc.encode(hash.bytes).substring(1);
}
var _a8, _b5;
var Keychain = class {
  /**
   * Creates a new instance of a key chain
   */
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "init");
    __publicField(this, "log");
    __publicField(this, _a8, "@libp2p/keychain");
    __publicField(this, _b5, [
      "@libp2p/keychain"
    ]);
    var _a13, _b9, _c5, _d2, _e, _f, _g, _h, _i, _j;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:keychain");
    this.init = merge_options_default(defaultOptions, init);
    if (this.init.pass != null && ((_a13 = this.init.pass) == null ? void 0 : _a13.length) < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (((_b9 = this.init.dek) == null ? void 0 : _b9.keyLength) != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (((_d2 = (_c5 = this.init.dek) == null ? void 0 : _c5.salt) == null ? void 0 : _d2.length) != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (((_e = this.init.dek) == null ? void 0 : _e.iterationCount) != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && ((_f = this.init.dek) == null ? void 0 : _f.salt) != null ? pbkdf2(this.init.pass, (_g = this.init.dek) == null ? void 0 : _g.salt, (_h = this.init.dek) == null ? void 0 : _h.iterationCount, (_i = this.init.dek) == null ? void 0 : _i.keyLength, (_j = this.init.dek) == null ? void 0 : _j.hash) : "";
    privates.set(this, { dek });
  }
  /**
   * Generates the options for a keychain.  A random salt is produced.
   *
   * @returns {object}
   */
  static generateOptions() {
    const options2 = Object.assign({}, defaultOptions);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options2.dek.salt = toString(randomBytes(saltLength), "base64");
    return options2;
  }
  /**
   * Gets an object that can encrypt/decrypt protected data.
   * The default options for a keychain.
   *
   * @returns {object}
   */
  static get options() {
    return defaultOptions;
  }
  async findKeyByName(name3) {
    if (!validateKeyName(name3)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name3}'`);
    }
    const dsname = DsInfoName(name3);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString(res));
    } catch (err) {
      await randomDelay();
      this.log.error(err);
      throw new NotFoundError(`Key '${name3}' does not exist.`);
    }
  }
  async findKeyById(id) {
    try {
      const query = {
        prefix: infoPrefix
      };
      for await (const value of this.components.datastore.query(query)) {
        const key = JSON.parse(toString(value.value));
        if (key.id === id) {
          return key;
        }
      }
      throw new InvalidParametersError(`Key with id '${id}' does not exist.`);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async importKey(name3, key) {
    if (!validateKeyName(name3)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name3}'`);
    }
    if (key == null) {
      await randomDelay();
      throw new InvalidParametersError("Key is required");
    }
    const dsname = DsName(name3);
    const exists = await this.components.datastore.has(dsname);
    if (exists) {
      await randomDelay();
      throw new InvalidParametersError(`Key '${name3}' already exists`);
    }
    let kid;
    let pem;
    try {
      kid = await keyId(key);
      const cached = privates.get(this);
      if (cached == null) {
        throw new InvalidParametersError("dek missing");
      }
      const dek = cached.dek;
      pem = await exportPrivateKey(key, dek, key.type === "RSA" ? "pkcs-8" : "libp2p-key");
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name3,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(dsname, fromString(pem));
    batch.put(DsInfoName(name3), fromString(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  async exportKey(name3) {
    if (!validateKeyName(name3)) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name3}'`);
    }
    const dsname = DsName(name3);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString(res);
      const cached = privates.get(this);
      if (cached == null) {
        throw new InvalidParametersError("dek missing");
      }
      const dek = cached.dek;
      return await importPrivateKey(pem, dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async removeKey(name3) {
    if (!validateKeyName(name3) || name3 === "self") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid key name '${name3}'`);
    }
    const dsname = DsName(name3);
    const keyInfo = await this.findKeyByName(name3);
    const batch = this.components.datastore.batch();
    batch.delete(dsname);
    batch.delete(DsInfoName(name3));
    await batch.commit();
    return keyInfo;
  }
  /**
   * List all the keys.
   *
   * @returns {Promise<KeyInfo[]>}
   */
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString(value.value)));
    }
    return info;
  }
  /**
   * Rename a key
   *
   * @param {string} oldName - The old local key name; must already exist.
   * @param {string} newName - The new local key name; must not already exist.
   * @returns {Promise<KeyInfo>}
   */
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid old key name '${oldName}'`);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid new key name '${newName}'`);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists = await this.components.datastore.has(newDsname);
    if (exists) {
      await randomDelay();
      throw new InvalidParametersError(`Key '${newName}' already exists`);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDsname, pem);
      batch.put(newInfoName, fromString(JSON.stringify(keyInfo)));
      batch.delete(oldDsname);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  /**
   * Rotate keychain password and re-encrypt all associated keys
   */
  async rotateKeychainPass(oldPass, newPass) {
    var _a13, _b9, _c5, _d2;
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid old pass type '${typeof oldPass}'`);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw new InvalidParametersError(`Invalid new pass type '${typeof newPass}'`);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw new InvalidParametersError(`Invalid pass length ${newPass.length}`);
    }
    this.log("recreating keychain");
    const cached = privates.get(this);
    if (cached == null) {
      throw new InvalidParametersError("dek missing");
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && ((_a13 = this.init.dek) == null ? void 0 : _a13.salt) != null ? pbkdf2(newPass, this.init.dek.salt, (_b9 = this.init.dek) == null ? void 0 : _b9.iterationCount, (_c5 = this.init.dek) == null ? void 0 : _c5.keyLength, (_d2 = this.init.dek) == null ? void 0 : _d2.hash) : "";
    privates.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString(res);
      const privateKey = await importPrivateKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await exportPrivateKey(privateKey, password, privateKey.type === "RSA" ? "pkcs-8" : "libp2p-key");
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    this.log("keychain reconstructed");
  }
};
_a8 = Symbol.toStringTag, _b5 = serviceCapabilities;

// node_modules/@libp2p/keychain/dist/src/index.js
function keychain(init = {}) {
  return (components) => {
    return new Keychain(components, init);
  };
}

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/decode.js
var MAX_MSG_SIZE = 1 << 20;
var MAX_MSG_QUEUE_SIZE = 4 << 20;
var Decoder = class {
  constructor(maxMessageSize = MAX_MSG_SIZE, maxUnprocessedMessageQueueSize = MAX_MSG_QUEUE_SIZE) {
    __publicField(this, "_buffer");
    __publicField(this, "_headerInfo");
    __publicField(this, "_maxMessageSize");
    __publicField(this, "_maxUnprocessedMessageQueueSize");
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
    this._maxMessageSize = maxMessageSize;
    this._maxUnprocessedMessageQueueSize = maxUnprocessedMessageQueueSize;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    if (this._buffer.byteLength > this._maxUnprocessedMessageQueueSize) {
      throw new InvalidMessageError("Unprocessed message queue size too large!");
    }
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (err) {
          if (err.name === "InvalidMessageError") {
            throw err;
          }
          break;
        }
      }
      const { id, type, length: length2, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length2) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length2);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length2);
      this._headerInfo = null;
    }
    return msgs;
  }
  /**
   * Attempts to decode the message header from the buffer
   */
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length2, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    if (length2 > this._maxMessageSize) {
      throw new InvalidMessageError("Message size too large");
    }
    return { id: h >> 3, type, offset: offset + end, length: length2 };
  }
};
var MSB = 128;
var REST = 127;
function readVarInt(buf, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf.get(counter++);
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder = class {
  constructor() {
    __publicField(this, "_pool");
    __publicField(this, "_poolOffset");
    this._pool = allocUnsafe(POOL_SIZE);
    this._poolOffset = 0;
  }
  /**
   * Encodes the given message and adds it to the passed list
   */
  write(msg, list) {
    const pool = this._pool;
    let offset = this._poolOffset;
    encode(msg.id << 3 | msg.type, pool, offset);
    offset += encodingLength(msg.id << 3 | msg.type);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      encode(msg.data.length, pool, offset);
      offset += encodingLength(msg.data.length);
    } else {
      encode(0, pool, offset);
      offset += encodingLength(0);
    }
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    list.append(header);
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      list.append(msg.data);
    }
  }
};
var encoder = new Encoder();
async function* encode4(source) {
  for await (const message2 of source) {
    const list = new Uint8ArrayList();
    encoder.write(message2, list);
    yield list;
  }
}

// node_modules/@libp2p/mplex/dist/src/errors.js
var StreamInputBufferError = class extends Error {
  constructor(message2 = "Stream input buffer error") {
    super(message2);
    this.name = "StreamInputBufferError";
  }
};

// node_modules/@libp2p/mplex/dist/src/stream.js
var MplexStream = class extends AbstractStream {
  constructor(init) {
    super(init);
    __publicField(this, "name");
    __publicField(this, "streamId");
    __publicField(this, "send");
    __publicField(this, "types");
    __publicField(this, "maxDataSize");
    this.types = init.direction === "outbound" ? InitiatorMessageTypes : ReceiverMessageTypes;
    this.send = init.send;
    this.name = init.name;
    this.streamId = init.streamId;
    this.maxDataSize = init.maxDataSize;
  }
  async sendNewStream() {
    await this.send({ id: this.streamId, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString(this.name)) });
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxDataSize);
      await this.send({
        id: this.streamId,
        type: this.types.MESSAGE,
        data: data.sublist(0, toSend)
      });
      data.consume(toSend);
    }
  }
  async sendReset() {
    await this.send({ id: this.streamId, type: this.types.RESET });
  }
  async sendCloseWrite() {
    await this.send({ id: this.streamId, type: this.types.CLOSE });
  }
  async sendCloseRead() {
  }
};
function createStream(options2) {
  const { id, name: name3, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options2;
  return new MplexStream({
    id: type === "initiator" ? `i${id}` : `r${id}`,
    streamId: id,
    name: `${name3 ?? id}`,
    direction: type === "initiator" ? "outbound" : "inbound",
    maxDataSize: maxMsgSize,
    onEnd,
    send,
    log: options2.logger.forComponent(`libp2p:mplex:stream:${type}:${id}`)
  });
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
var CLOSE_TIMEOUT = 500;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(components, init) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "sink");
    __publicField(this, "source");
    __publicField(this, "log");
    __publicField(this, "_streamId");
    __publicField(this, "_streams");
    __publicField(this, "_init");
    __publicField(this, "_source");
    __publicField(this, "closeController");
    __publicField(this, "rateLimiter");
    __publicField(this, "closeTimeout");
    __publicField(this, "logger");
    init = init ?? {};
    this.log = components.logger.forComponent("libp2p:mplex");
    this.logger = components.logger;
    this._streamId = 0;
    this._streams = {
      /**
       * Stream to ids map
       */
      initiators: /* @__PURE__ */ new Map(),
      /**
       * Stream to ids map
       */
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.closeTimeout = init.closeTimeout ?? CLOSE_TIMEOUT;
    this.sink = this._createSink();
    this._source = pushable({
      objectMode: true,
      onEnd: () => {
        for (const stream of this._streams.initiators.values()) {
          stream.destroy();
        }
        for (const stream of this._streams.receivers.values()) {
          stream.destroy();
        }
      }
    });
    this.source = pipe(this._source, (source) => encode4(source));
    this.closeController = new AbortController();
    this.rateLimiter = new RateLimiter({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  /**
   * Returns a Map of streams and their ids
   */
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  /**
   * Initiate a new stream with the given name. If no name is
   * provided, the id of the stream will be used.
   */
  newStream(name3) {
    if (this.closeController.signal.aborted) {
      throw new MuxerClosedError("Muxer already closed");
    }
    const id = this._streamId++;
    name3 = name3 == null ? id.toString() : name3.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name: name3, type: "initiator", registry });
  }
  /**
   * Close or abort all tracked streams and stop the muxer
   */
  async close(options2) {
    if (this.closeController.signal.aborted) {
      return;
    }
    const signal = (options2 == null ? void 0 : options2.signal) ?? AbortSignal.timeout(this.closeTimeout);
    try {
      await Promise.all(this.streams.map(async (s) => s.close({
        signal
      })));
      this._source.end();
      await this._source.onEmpty({
        signal
      });
      this.closeController.abort();
    } catch (err) {
      this.abort(err);
    }
  }
  abort(err) {
    if (this.closeController.signal.aborted) {
      return;
    }
    this.streams.forEach((s) => {
      s.abort(err);
    });
    this.closeController.abort(err);
  }
  /**
   * Called whenever an inbound stream is created
   */
  _newReceiverStream(options2) {
    const { id, name: name3 } = options2;
    const registry = this._streams.receivers;
    return this._newStream({ id, name: name3, type: "receiver", registry });
  }
  _newStream(options2) {
    const { id, name: name3, type, registry } = options2;
    this.log("new %s stream %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw new TooManyOutboundProtocolStreamsError("Too many outbound streams open");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = async (msg) => {
      if (this.log.enabled) {
        this.log.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      this.log("%s stream with id %s and protocol %s ended", type, id, stream.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name: name3, send, type, onEnd, maxMsgSize: this._init.maxMsgSize, logger: this.logger });
    registry.set(id, stream);
    return stream;
  }
  /**
   * Creates a sink with an abortable source. Incoming messages will
   * also have their size restricted. All messages will be varint decoded.
   */
  _createSink() {
    const sink = async (source) => {
      const abortListener = () => {
        closeSource(source, this.log);
      };
      this.closeController.signal.addEventListener("abort", abortListener);
      try {
        const decoder = new Decoder(this._init.maxMsgSize, this._init.maxUnprocessedMessageQueueSize);
        for await (const chunk of source) {
          for (const msg of decoder.write(chunk)) {
            await this._handleIncoming(msg);
          }
        }
        this._source.end();
      } catch (err) {
        this.log("error in sink", err);
        this._source.end(err);
      } finally {
        this.closeController.signal.removeEventListener("abort", abortListener);
      }
    };
    return sink;
  }
  async _handleIncoming(message2) {
    const { id, type } = message2;
    if (this.log.enabled) {
      this.log.trace("incoming message", printMessage(message2));
    }
    if (message2.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        this.log("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          this.log("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this.abort(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString(message2.data instanceof Uint8Array ? message2.data : message2.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      this.log("missing stream %s for message type %s", id, MessageTypeNames[type]);
      try {
        await this.rateLimiter.consume("missing-stream", 1);
      } catch {
        this.log("rate limit hit when receiving messages for streams that do not exist - closing remote connection");
        this.abort(new Error("Too many messages for missing streams"));
        return;
      }
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    try {
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          if (stream.sourceReadableLength() > maxBufferSize) {
            this._source.push({
              id: message2.id,
              type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
            });
            throw new StreamInputBufferError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers");
          }
          stream.sourcePush(message2.data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.remoteCloseWrite();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          this.log("unknown message type %s", type);
      }
    } catch (err) {
      this.log.error("error while processing message", err);
      stream.abort(err);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var _a9, _b6;
var Mplex = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol", "/mplex/6.7.0");
    __publicField(this, "_init");
    __publicField(this, "components");
    __publicField(this, _a9, "@libp2p/mplex");
    __publicField(this, _b6, [
      "@libp2p/stream-multiplexing"
    ]);
    this.components = components;
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer(this.components, {
      ...init,
      ...this._init
    });
  }
};
_a9 = Symbol.toStringTag, _b6 = serviceCapabilities;
function mplex(init = {}) {
  return (components) => new Mplex(components, init);
}

// node_modules/@libp2p/ping/dist/src/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";
var PROTOCOL_PREFIX2 = "ipfs";
var TIMEOUT2 = 1e4;
var MAX_INBOUND_STREAMS2 = 2;
var MAX_OUTBOUND_STREAMS2 = 1;

// node_modules/@libp2p/ping/dist/src/ping.js
var _a10;
var PingService = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "started");
    __publicField(this, "timeout");
    __publicField(this, "maxInboundStreams");
    __publicField(this, "maxOutboundStreams");
    __publicField(this, "runOnLimitedConnection");
    __publicField(this, "log");
    __publicField(this, _a10, "@libp2p/ping");
    this.components = components;
    this.log = components.logger.forComponent("libp2p:ping");
    this.started = false;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX2}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.timeout = init.timeout ?? TIMEOUT2;
    this.maxInboundStreams = init.maxInboundStreams ?? MAX_INBOUND_STREAMS2;
    this.maxOutboundStreams = init.maxOutboundStreams ?? MAX_OUTBOUND_STREAMS2;
    this.runOnLimitedConnection = init.runOnLimitedConnection ?? true;
    this.handleMessage = this.handleMessage.bind(this);
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnLimitedConnection: this.runOnLimitedConnection
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * A handler to register with Libp2p to process ping messages
   */
  handleMessage(data) {
    this.log("incoming ping from %p", data.connection.remotePeer);
    const { stream } = data;
    const start2 = Date.now();
    const bytes = byteStream(stream);
    let pinged = false;
    Promise.resolve().then(async () => {
      while (true) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        signal.addEventListener("abort", () => {
          stream == null ? void 0 : stream.abort(new TimeoutError("ping timeout"));
        });
        const buf = await bytes.read(PING_LENGTH, {
          signal
        });
        await bytes.write(buf, {
          signal
        });
        pinged = true;
      }
    }).catch((err) => {
      if (pinged && err.name === "UnexpectedEOFError" && stream.readStatus !== "ready") {
        return;
      }
      this.log.error("incoming ping from %p failed with error - %e", data.connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
    }).finally(() => {
      const ms = Date.now() - start2;
      this.log("incoming ping from %p complete in %dms", data.connection.remotePeer, ms);
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      stream.close({
        signal
      }).catch((err) => {
        this.log.error("error closing ping stream from %p - %e", data.connection.remotePeer, err);
        stream == null ? void 0 : stream.abort(err);
      });
    });
  }
  /**
   * Ping a given peer and wait for its response, getting the operation latency.
   */
  async ping(peer, options2 = {}) {
    this.log("pinging %p", peer);
    const start2 = Date.now();
    const data = randomBytes(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options2);
    let stream;
    if (options2.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      options2 = {
        ...options2,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.protocol, {
        ...options2,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      const bytes = byteStream(stream);
      const [, result] = await Promise.all([
        bytes.write(data, options2),
        bytes.read(PING_LENGTH, options2)
      ]);
      const ms = Date.now() - start2;
      if (!equals(data, result.subarray())) {
        throw new ProtocolError(`Received wrong ping ack after ${ms}ms`);
      }
      this.log("ping %p complete in %dms", connection.remotePeer, ms);
      return ms;
    } catch (err) {
      this.log.error("error while pinging %p", connection.remotePeer, err);
      stream == null ? void 0 : stream.abort(err);
      throw err;
    } finally {
      if (stream != null) {
        await stream.close(options2);
      }
    }
  }
};
_a10 = Symbol.toStringTag;

// node_modules/@libp2p/ping/dist/src/index.js
function ping(init = {}) {
  return (components) => new PingService(components, init);
}

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name3, version3, os) {
      this.name = name3;
      this.version = version3;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version3) {
      this.version = version3;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name3, version3, os, bot) {
      this.name = name3;
      this.version = version3;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a13) {
    var browser2 = _a13[0], regex = _a13[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name3 = matchedRule[0], match = matchedRule[1];
  if (name3 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version3 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name3, version3, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name3, version3, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a13 = operatingSystemRules[ii], os = _a13[0], regex = _a13[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@libp2p/webrtc/dist/src/constants.js
var DEFAULT_ICE_SERVERS = [
  "stun:stun.l.google.com:19302",
  "stun:global.stun.twilio.com:3478",
  "stun:stun.cloudflare.com:3478",
  "stun:stun.services.mozilla.com:3478"
];

// node_modules/@libp2p/webrtc/dist/src/util.js
var browser = detect();
var isFirefox = browser != null && browser.name === "firefox";
var nopSource = async function* nop() {
};
var nopSink = async (_) => {
};
var DATA_CHANNEL_DRAIN_TIMEOUT = 30 * 1e3;
function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options2) {
  if (channel.readyState !== "open") {
    return;
  }
  void Promise.resolve().then(async () => {
    if (channel.bufferedAmount > 0) {
      options2.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
      const deferred = pDefer();
      let drained = false;
      channel.bufferedAmountLowThreshold = 0;
      const closeListener = () => {
        if (!drained) {
          options2.log("%s drain channel closed before drain", direction);
          deferred.resolve();
        }
      };
      channel.addEventListener("close", closeListener, {
        once: true
      });
      channel.addEventListener("bufferedamountlow", () => {
        drained = true;
        channel.removeEventListener("close", closeListener);
        deferred.resolve();
      });
      await pTimeout(deferred.promise, {
        milliseconds: drainTimeout
      });
    }
  }).then(async () => {
    if (channel.readyState === "open") {
      channel.close();
    }
  }).catch((err) => {
    options2.log.error("error closing outbound stream", err);
  });
}
async function getRtcConfiguration(config) {
  config = config ?? {};
  if (typeof config === "function") {
    config = await config();
  }
  config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
    urls: [
      url
    ]
  }));
  return config;
}

// node_modules/@libp2p/webrtc/dist/src/maconn.js
var WebRTCMultiaddrConnection = class {
  constructor(components, init) {
    __publicField(this, "log");
    /**
     * WebRTC Peer Connection
     */
    __publicField(this, "peerConnection");
    /**
     * The multiaddr address used to communicate with the remote peer
     */
    __publicField(this, "remoteAddr");
    /**
     * Holds the lifecycle times of the connection
     */
    __publicField(this, "timeline");
    /**
     * Optional metrics counter group for this connection
     */
    __publicField(this, "metrics");
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    __publicField(this, "source", nopSource());
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    __publicField(this, "sink", nopSink);
    this.log = components.logger.forComponent("libp2p:webrtc:maconn");
    this.remoteAddr = init.remoteAddr;
    this.timeline = init.timeline;
    this.peerConnection = init.peerConnection;
    const initialState = this.peerConnection.connectionState;
    this.peerConnection.onconnectionstatechange = () => {
      this.log.trace("peer connection state change", this.peerConnection.connectionState, "initial state", initialState);
      if (this.peerConnection.connectionState === "disconnected" || this.peerConnection.connectionState === "failed" || this.peerConnection.connectionState === "closed") {
        this.timeline.close = Date.now();
      }
    };
  }
  async close(options2) {
    var _a13;
    this.log.trace("closing connection");
    this.peerConnection.close();
    this.timeline.close = Date.now();
    (_a13 = this.metrics) == null ? void 0 : _a13.increment({ close: true });
  }
  abort(err) {
    var _a13;
    this.log.error("closing connection due to error", err);
    this.peerConnection.close();
    this.timeline.close = Date.now();
    (_a13 = this.metrics) == null ? void 0 : _a13.increment({ abort: true });
  }
};

// node_modules/@libp2p/webrtc/dist/src/pb/message.js
var Message3;
(function(Message5) {
  let Flag;
  (function(Flag2) {
    Flag2["FIN"] = "FIN";
    Flag2["STOP_SENDING"] = "STOP_SENDING";
    Flag2["RESET"] = "RESET";
    Flag2["FIN_ACK"] = "FIN_ACK";
  })(Flag = Message5.Flag || (Message5.Flag = {}));
  let __FlagValues;
  (function(__FlagValues2) {
    __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
    __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
    __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
    __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
  })(__FlagValues || (__FlagValues = {}));
  (function(Flag2) {
    Flag2.codec = () => {
      return enumeration(__FlagValues);
    };
  })(Flag = Message5.Flag || (Message5.Flag = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.flag != null) {
          w.uint32(8);
          Message5.Flag.codec().encode(obj.flag, w);
        }
        if (obj.message != null) {
          w.uint32(18);
          w.bytes(obj.message);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.flag = Message5.Flag.codec().decode(reader);
              break;
            }
            case 2: {
              obj.message = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message3 || (Message3 = {}));

// node_modules/@libp2p/webrtc/dist/src/stream.js
var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
var BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1e3;
var MAX_MESSAGE_SIZE2 = 16 * 1024;
function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE2) {
  const messageLength = encodingLength(maxMessageSize - encodingLength(maxMessageSize));
  const flagField = 1 + encodingLength(Object.keys(Message3.Flag).length - 1);
  const messageFieldIdType = 1;
  const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
  const messageFieldLengthLength = encodingLength(available);
  return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
}
var PROTOBUF_OVERHEAD = calculateProtobufOverhead();
var FIN_ACK_TIMEOUT = 5e3;
var OPEN_TIMEOUT = 5e3;
var WebRTCStream = class extends AbstractStream {
  constructor(init) {
    const originalOnEnd = init.onEnd;
    init.onEnd = (err) => {
      this.log.trace("readable and writeable ends closed", this.status);
      void Promise.resolve(async () => {
        if (this.timeline.abort != null || this.timeline.reset !== null) {
          return;
        }
        try {
          await pTimeout(this.receiveFinAck.promise, {
            milliseconds: this.finAckTimeout
          });
        } catch (err2) {
          this.log.error("error receiving FIN_ACK", err2);
        }
      }).then(() => {
        this.incomingData.end();
        originalOnEnd == null ? void 0 : originalOnEnd(err);
      }).catch((err2) => {
        this.log.error("error ending stream", err2);
      });
    };
    super(init);
    /**
     * The data channel used to send and receive data
     */
    __publicField(this, "channel");
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    __publicField(this, "incomingData");
    __publicField(this, "maxBufferedAmount");
    __publicField(this, "bufferedAmountLowEventTimeout");
    /**
     * The maximum size of a message in bytes
     */
    __publicField(this, "maxMessageSize");
    /**
     * When this promise is resolved, the remote has sent us a FIN flag
     */
    __publicField(this, "receiveFinAck");
    __publicField(this, "finAckTimeout");
    __publicField(this, "openTimeout");
    this.channel = init.channel;
    this.channel.binaryType = "arraybuffer";
    this.incomingData = pushable();
    this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
    this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
    this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE2) - PROTOBUF_OVERHEAD;
    this.receiveFinAck = pDefer();
    this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
    this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT;
    switch (this.channel.readyState) {
      case "open":
        this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
        break;
      case "closed":
      case "closing":
        if (this.timeline.close === void 0 || this.timeline.close === 0) {
          this.timeline.close = Date.now();
        }
        break;
      case "connecting":
        break;
      default:
        this.log.error("unknown datachannel state %s", this.channel.readyState);
        throw new StreamStateError("Unknown datachannel state");
    }
    this.channel.onopen = (_evt) => {
      this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
    };
    this.channel.onclose = (_evt) => {
      this.receiveFinAck.resolve();
      void this.close().catch((err) => {
        this.log.error("error closing stream after channel closed", err);
      });
    };
    this.channel.onerror = (evt) => {
      const err = evt.error;
      this.abort(err);
    };
    this.channel.onmessage = async (event) => {
      const { data } = event;
      if (data === null || data.byteLength === 0) {
        return;
      }
      this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
    };
    const self2 = this;
    Promise.resolve().then(async () => {
      for await (const buf of decode3(this.incomingData)) {
        const message2 = self2.processIncomingProtobuf(buf);
        if (message2 != null) {
          self2.sourcePush(new Uint8ArrayList(message2));
        }
      }
    }).catch((err) => {
      this.log.error("error processing incoming data channel messages", err);
    });
  }
  sendNewStream() {
  }
  async _sendMessage(data, checkBuffer = true) {
    if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {
      try {
        this.log('channel buffer is %d, wait for "bufferedamountlow" event', this.channel.bufferedAmount);
        await pEvent(this.channel, "bufferedamountlow", { timeout: this.bufferedAmountLowEventTimeout });
      } catch (err) {
        if (err instanceof TimeoutError) {
          throw new TimeoutError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`);
        }
        throw err;
      }
    }
    if (this.channel.readyState === "closed" || this.channel.readyState === "closing") {
      throw new StreamStateError(`Invalid datachannel state - ${this.channel.readyState}`);
    }
    if (this.channel.readyState !== "open") {
      this.log('channel state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
      await pEvent(this.channel, "open", { timeout: this.openTimeout });
      this.log('channel state is now "%s", sending data', this.channel.readyState);
    }
    this.channel.send(data.subarray());
  }
  async sendData(data) {
    data = data.sublist();
    while (data.byteLength > 0) {
      const toSend = Math.min(data.byteLength, this.maxMessageSize);
      const buf = data.subarray(0, toSend);
      const msgbuf = Message3.encode({ message: buf });
      const sendbuf = encode2.single(msgbuf);
      await this._sendMessage(sendbuf);
      data.consume(toSend);
    }
  }
  async sendReset() {
    try {
      await this._sendFlag(Message3.Flag.RESET);
    } catch (err) {
      this.log.error("failed to send reset - %e", err);
    }
  }
  async sendCloseWrite(options2) {
    const sent = await this._sendFlag(Message3.Flag.FIN);
    if (sent) {
      this.log.trace("awaiting FIN_ACK");
      try {
        await raceSignal(this.receiveFinAck.promise, options2 == null ? void 0 : options2.signal, {
          errorMessage: "sending close-write was aborted before FIN_ACK was received",
          errorName: "FinAckNotReceivedError"
        });
      } catch (err) {
        this.log.error("failed to await FIN_ACK", err);
      }
    } else {
      this.log.trace("sending FIN failed, not awaiting FIN_ACK");
    }
    this.receiveFinAck.resolve();
  }
  async sendCloseRead() {
    await this._sendFlag(Message3.Flag.STOP_SENDING);
  }
  /**
   * Handle incoming
   */
  processIncomingProtobuf(buffer) {
    const message2 = Message3.decode(buffer);
    if (message2.flag !== void 0) {
      this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
      if (message2.flag === Message3.Flag.FIN) {
        this.remoteCloseWrite();
        this.log.trace("sending FIN_ACK");
        void this._sendFlag(Message3.Flag.FIN_ACK).catch((err) => {
          this.log.error("error sending FIN_ACK immediately", err);
        });
      }
      if (message2.flag === Message3.Flag.RESET) {
        this.reset();
      }
      if (message2.flag === Message3.Flag.STOP_SENDING) {
        this.remoteCloseRead();
      }
      if (message2.flag === Message3.Flag.FIN_ACK) {
        this.log.trace("received FIN_ACK");
        this.receiveFinAck.resolve();
      }
    }
    if (this.readStatus === "ready") {
      return message2.message;
    }
  }
  async _sendFlag(flag) {
    if (this.channel.readyState !== "open") {
      this.log.trace('not sending flag %s because channel is "%s" and not "open"', this.channel.readyState, flag.toString());
      return false;
    }
    this.log.trace("sending flag %s", flag.toString());
    const msgbuf = Message3.encode({ flag });
    const prefixedBuf = encode2.single(msgbuf);
    try {
      await this._sendMessage(prefixedBuf, false);
      return true;
    } catch (err) {
      this.log.error("could not send flag %s - %e", flag.toString(), err);
    }
    return false;
  }
};
function createStream2(options2) {
  const { channel, direction } = options2;
  return new WebRTCStream({
    id: direction === "inbound" ? `i${channel.id}` : `r${channel.id}`,
    log: options2.logger.forComponent(`libp2p:webrtc:stream:${direction}:${channel.id}`),
    ...options2
  });
}

// node_modules/@libp2p/webrtc/dist/src/muxer.js
var PROTOCOL2 = "/webrtc";
var DataChannelMuxerFactory = class {
  constructor(components, init) {
    __publicField(this, "protocol");
    /**
     * WebRTC Peer Connection
     */
    __publicField(this, "peerConnection");
    __publicField(this, "bufferedStreams", []);
    __publicField(this, "metrics");
    __publicField(this, "dataChannelOptions");
    __publicField(this, "components");
    __publicField(this, "log");
    this.components = components;
    this.peerConnection = init.peerConnection;
    this.metrics = init.metrics;
    this.protocol = init.protocol ?? PROTOCOL2;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.log = components.logger.forComponent("libp2p:webrtc:datachannelmuxerfactory");
    this.peerConnection.ondatachannel = ({ channel }) => {
      this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
      if (channel.label === "init") {
        this.log.trace("closing early init channel");
        channel.close();
        return;
      }
      const bufferedStream = {};
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: (err) => {
          bufferedStream.onEnd(err);
        },
        logger: components.logger,
        ...this.dataChannelOptions
      });
      bufferedStream.stream = stream;
      bufferedStream.channel = channel;
      bufferedStream.onEnd = () => {
        this.bufferedStreams = this.bufferedStreams.filter((s) => s.stream.id !== stream.id);
      };
      this.bufferedStreams.push(bufferedStream);
    };
  }
  createStreamMuxer(init) {
    return new DataChannelMuxer(this.components, {
      ...init,
      peerConnection: this.peerConnection,
      dataChannelOptions: this.dataChannelOptions,
      metrics: this.metrics,
      streams: this.bufferedStreams,
      protocol: this.protocol
    });
  }
};
var _onStreamEnd, onStreamEnd_fn;
var DataChannelMuxer = class {
  constructor(components, init) {
    __privateAdd(this, _onStreamEnd);
    __publicField(this, "init");
    /**
     * Array of streams in the data channel
     */
    __publicField(this, "streams");
    __publicField(this, "protocol");
    __publicField(this, "log");
    __publicField(this, "peerConnection");
    __publicField(this, "dataChannelOptions");
    __publicField(this, "metrics");
    __publicField(this, "logger");
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    __publicField(this, "source", nopSource());
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    __publicField(this, "sink", nopSink);
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc:muxer");
    this.logger = components.logger;
    this.streams = init.streams.map((s) => s.stream);
    this.peerConnection = init.peerConnection;
    this.protocol = init.protocol ?? PROTOCOL2;
    this.metrics = init.metrics;
    this.dataChannelOptions = init.dataChannelOptions ?? {};
    this.peerConnection.ondatachannel = ({ channel }) => {
      var _a13, _b9;
      this.log.trace("incoming datachannel with channel id %d", channel.id);
      if (channel.label === "init") {
        this.log.trace("closing init channel");
        channel.close();
        return;
      }
      const id = channel.id;
      const stream = createStream2({
        channel,
        direction: "inbound",
        onEnd: () => {
          __privateMethod(this, _onStreamEnd, onStreamEnd_fn).call(this, stream, channel);
          this.log("incoming channel %s ended", id);
        },
        logger: this.logger,
        ...this.dataChannelOptions
      });
      this.streams.push(stream);
      (_a13 = this.metrics) == null ? void 0 : _a13.increment({ incoming_stream: true });
      (_b9 = init == null ? void 0 : init.onIncomingStream) == null ? void 0 : _b9.call(init, stream);
    };
    if (this.init.streams.length > 0) {
      queueMicrotask(() => {
        this.init.streams.forEach((bufferedStream) => {
          var _a13, _b9, _c5;
          bufferedStream.onEnd = () => {
            this.log("incoming early channel %s ended with state %s", bufferedStream.channel.id, bufferedStream.channel.readyState);
            __privateMethod(this, _onStreamEnd, onStreamEnd_fn).call(this, bufferedStream.stream, bufferedStream.channel);
          };
          (_a13 = this.metrics) == null ? void 0 : _a13.increment({ incoming_stream: true });
          (_c5 = (_b9 = this.init) == null ? void 0 : _b9.onIncomingStream) == null ? void 0 : _c5.call(_b9, bufferedStream.stream);
        });
      });
    }
  }
  /**
   * Gracefully close all tracked streams and stop the muxer
   */
  async close(options2) {
    try {
      await Promise.all(this.streams.map(async (stream) => stream.close(options2)));
    } catch (err) {
      this.abort(err);
    }
  }
  /**
   * Abort all tracked streams and stop the muxer
   */
  abort(err) {
    for (const stream of this.streams) {
      stream.abort(err);
    }
  }
  newStream() {
    var _a13;
    const channel = this.peerConnection.createDataChannel("");
    const id = channel.id;
    this.log.trace("opened outgoing datachannel with channel id %s", id);
    const stream = createStream2({
      channel,
      direction: "outbound",
      onEnd: () => {
        __privateMethod(this, _onStreamEnd, onStreamEnd_fn).call(this, stream, channel);
        this.log("outgoing channel %s ended", id);
      },
      logger: this.logger,
      ...this.dataChannelOptions
    });
    this.streams.push(stream);
    (_a13 = this.metrics) == null ? void 0 : _a13.increment({ outgoing_stream: true });
    return stream;
  }
};
_onStreamEnd = new WeakSet();
onStreamEnd_fn = function(stream, channel) {
  var _a13, _b9, _c5;
  this.log.trace("stream %s %s %s onEnd", stream.direction, stream.id, stream.protocol);
  drainAndClose(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
    log: this.log
  });
  this.streams = this.streams.filter((s) => s.id !== stream.id);
  (_a13 = this.metrics) == null ? void 0 : _a13.increment({ stream_end: true });
  (_c5 = (_b9 = this.init) == null ? void 0 : _b9.onStreamEnd) == null ? void 0 : _c5.call(_b9, stream);
};

// node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
var RTCPeerConnection = globalThis.RTCPeerConnection;
var RTCSessionDescription = globalThis.RTCSessionDescription;
var RTCIceCandidate = globalThis.RTCIceCandidate;

// node_modules/@libp2p/webrtc/dist/src/error.js
var WebRTCTransportError = class extends Error {
  constructor(msg) {
    super(`WebRTC transport error: ${msg}`);
    this.name = "WebRTCTransportError";
  }
};
var SDPHandshakeFailedError = class extends WebRTCTransportError {
  constructor(message2 = "SDP handshake failed") {
    super(message2);
    this.name = "SDPHandshakeFailedError";
  }
};
var DataChannelError = class extends WebRTCTransportError {
  constructor(streamLabel, msg) {
    super(`[stream: ${streamLabel}] data channel error: ${msg}`);
    this.name = "WebRTC/DataChannelError";
  }
};
var InvalidFingerprintError = class extends WebRTCTransportError {
  constructor(fingerprint, source) {
    super(`Invalid fingerprint "${fingerprint}" within ${source}`);
    this.name = "WebRTC/InvalidFingerprintError";
  }
};
var UnimplementedError = class extends WebRTCTransportError {
  constructor(methodName) {
    super(`A method (${methodName}) was called though it has been intentionally left unimplemented.`);
    this.name = "WebRTC/UnimplementedError";
  }
};
var UnsupportedHashAlgorithmError = class extends WebRTCTransportError {
  constructor(algo) {
    super(`unsupported hash algorithm code: ${algo} please see the codes at https://github.com/multiformats/multicodec/blob/master/table.csv `);
    this.name = "WebRTC/UnsupportedHashAlgorithmError";
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
var Message4;
(function(Message5) {
  let Type;
  (function(Type2) {
    Type2["SDP_OFFER"] = "SDP_OFFER";
    Type2["SDP_ANSWER"] = "SDP_ANSWER";
    Type2["ICE_CANDIDATE"] = "ICE_CANDIDATE";
  })(Type = Message5.Type || (Message5.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
    __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
    __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = Message5.Type || (Message5.Type = {}));
  let _codec;
  Message5.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          Message5.Type.codec().encode(obj.type, w);
        }
        if (obj.data != null) {
          w.uint32(18);
          w.string(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length2, opts = {}) => {
        const obj = {};
        const end = length2 == null ? reader.len : reader.pos + length2;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.type = Message5.Type.codec().decode(reader);
              break;
            }
            case 2: {
              obj.data = reader.string();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Message5.encode = (obj) => {
    return encodeMessage(obj, Message5.codec());
  };
  Message5.decode = (buf, opts) => {
    return decodeMessage(buf, Message5.codec(), opts);
  };
})(Message4 || (Message4 = {}));

// node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
var readCandidatesUntilConnected = async (pc, stream, options2) => {
  var _a13, _b9, _c5, _d2;
  try {
    const connectedPromise = pDefer();
    resolveOnConnected(pc, connectedPromise);
    while (true) {
      const message2 = await Promise.race([
        connectedPromise.promise,
        stream.read({
          signal: options2.signal
        }).catch(() => {
        })
      ]);
      if (message2 == null) {
        (_a13 = options2.signal) == null ? void 0 : _a13.throwIfAborted();
        break;
      }
      if (message2.type !== Message4.Type.ICE_CANDIDATE) {
        throw new InvalidMessageError("ICE candidate message expected");
      }
      const candidateInit = JSON.parse(message2.data ?? "null");
      if (candidateInit === "" || candidateInit === null) {
        (_b9 = options2.onProgress) == null ? void 0 : _b9.call(options2, new CustomProgressEvent("webrtc:end-of-ice-candidates"));
        options2.log.trace("end-of-candidates received");
        continue;
      }
      const candidate = new RTCIceCandidate(candidateInit);
      options2.log.trace("%s received new ICE candidate %o", options2.direction, candidateInit);
      try {
        (_c5 = options2.onProgress) == null ? void 0 : _c5.call(options2, new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
        await pc.addIceCandidate(candidate);
      } catch (err) {
        options2.log.error("%s bad candidate received", options2.direction, candidateInit, err);
      }
    }
  } catch (err) {
    options2.log.error("%s error parsing ICE candidate", options2.direction, err);
    if (((_d2 = options2.signal) == null ? void 0 : _d2.aborted) === true && getConnectionState(pc) !== "connected") {
      throw err;
    }
  }
};
function getConnectionState(pc) {
  return isFirefox ? pc.iceConnectionState : pc.connectionState;
}
function resolveOnConnected(pc, promise) {
  pc[isFirefox ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_) => {
    switch (getConnectionState(pc)) {
      case "connected":
        promise.resolve();
        break;
      case "failed":
      case "disconnected":
      case "closed":
        promise.reject(new ConnectionFailedError("RTCPeerConnection was closed"));
        break;
      default:
        break;
    }
  };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log7, logger: logger2, onProgress }) {
  const { baseAddr } = splitAddr(ma);
  metrics == null ? void 0 : metrics.dialerEvents.increment({ open: true });
  log7.trace("dialing base address: %a", baseAddr);
  const relayPeer = baseAddr.getPeerId();
  if (relayPeer == null) {
    throw new InvalidParametersError("Relay peer was missing");
  }
  const connections = connectionManager.getConnections(peerIdFromString(relayPeer));
  let connection;
  let shouldCloseConnection = false;
  if (connections.length === 0) {
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:dial-relay"));
    connection = await transportManager.dial(baseAddr, {
      signal,
      onProgress
    });
    shouldCloseConnection = true;
  } else {
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:reuse-relay-connection"));
    connection = connections[0];
  }
  try {
    onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:open-signaling-stream"));
    const stream = await connection.newStream(SIGNALING_PROTO_ID, {
      signal,
      runOnLimitedConnection: true
    });
    const messageStream = pbStream(stream).pb(Message4);
    const peerConnection = new RTCPeerConnection(rtcConfiguration);
    const muxerFactory = new DataChannelMuxerFactory({
      logger: logger2
    }, {
      peerConnection,
      dataChannelOptions: dataChannel
    });
    try {
      const channel = peerConnection.createDataChannel("init");
      peerConnection.onicecandidate = ({ candidate }) => {
        const data = JSON.stringify((candidate == null ? void 0 : candidate.toJSON()) ?? null);
        log7.trace("initiator sending ICE candidate %o", candidate);
        void messageStream.write({
          type: Message4.Type.ICE_CANDIDATE,
          data
        }, {
          signal
        }).catch((err) => {
          log7.error("error sending ICE candidate", err);
        });
      };
      peerConnection.onicecandidateerror = (event) => {
        log7.error("initiator ICE candidate error", event);
      };
      const offerSdp = await peerConnection.createOffer().catch((err) => {
        log7.error("could not execute createOffer", err);
        throw new SDPHandshakeFailedError("Failed to set createOffer");
      });
      log7.trace("initiator send SDP offer %s", offerSdp.sdp);
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:send-sdp-offer"));
      await messageStream.write({ type: Message4.Type.SDP_OFFER, data: offerSdp.sdp }, {
        signal
      });
      await peerConnection.setLocalDescription(offerSdp).catch((err) => {
        log7.error("could not execute setLocalDescription", err);
        throw new SDPHandshakeFailedError("Failed to set localDescription");
      });
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:read-sdp-answer"));
      log7.trace("initiator read SDP answer");
      const answerMessage = await messageStream.read({
        signal
      });
      if (answerMessage.type !== Message4.Type.SDP_ANSWER) {
        throw new SDPHandshakeFailedError("Remote should send an SDP answer");
      }
      log7.trace("initiator received SDP answer %s", answerMessage.data);
      const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
      await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
        log7.error("could not execute setRemoteDescription", err);
        throw new SDPHandshakeFailedError("Failed to set remoteDescription");
      });
      log7.trace("initiator read candidates until connected");
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:read-ice-candidates"));
      await readCandidatesUntilConnected(peerConnection, messageStream, {
        direction: "initiator",
        signal,
        log: log7,
        onProgress
      });
      log7.trace("initiator connected, closing init channel");
      channel.close();
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:close-signaling-stream"));
      log7.trace("closing signaling channel");
      await stream.close({
        signal
      });
      log7.trace("initiator connected to remote address %s", ma);
      return {
        remoteAddress: ma,
        peerConnection,
        muxerFactory
      };
    } catch (err) {
      log7.error("outgoing signaling error", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    } finally {
      peerConnection.onicecandidate = null;
      peerConnection.onicecandidateerror = null;
    }
  } finally {
    if (shouldCloseConnection) {
      try {
        await connection.close({
          signal
        });
      } catch (err) {
        connection.abort(err);
      }
    }
  }
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
var Circuit2 = fmt(P2P.matchers[0], literal("p2p-circuit"));
var WebRTCPeerListener = class extends TypedEventEmitter {
  constructor(components, init) {
    super();
    __publicField(this, "transportManager");
    __publicField(this, "shutdownController");
    this.transportManager = components.transportManager;
    this.shutdownController = init.shutdownController;
  }
  async listen() {
    queueMicrotask(() => {
      this.safeDispatchEvent("listening");
    });
  }
  getAddrs() {
    return this.transportManager.getListeners().filter((l) => l !== this).map((l) => l.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
      return ma.encapsulate("/webrtc");
    })).flat();
  }
  async close() {
    this.shutdownController.abort();
    queueMicrotask(() => {
      this.safeDispatchEvent("close");
    });
  }
};

// node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
async function handleIncomingStream({ peerConnection, stream, signal, connection, log: log7 }) {
  log7.trace("new inbound signaling stream");
  const messageStream = pbStream(stream).pb(Message4);
  try {
    peerConnection.onicecandidate = ({ candidate }) => {
      const data = JSON.stringify((candidate == null ? void 0 : candidate.toJSON()) ?? null);
      log7.trace("recipient sending ICE candidate %s", data);
      messageStream.write({
        type: Message4.Type.ICE_CANDIDATE,
        data
      }, {
        signal
      }).catch((err) => {
        log7.error("error sending ICE candidate", err);
      });
    };
    log7.trace("recipient read SDP offer");
    const pbOffer = await messageStream.read({
      signal
    });
    if (pbOffer.type !== Message4.Type.SDP_OFFER) {
      throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
    }
    log7.trace("recipient received SDP offer %s", pbOffer.data);
    const offer = new RTCSessionDescription({
      type: "offer",
      sdp: pbOffer.data
    });
    await peerConnection.setRemoteDescription(offer).catch((err) => {
      log7.error("could not execute setRemoteDescription", err);
      throw new SDPHandshakeFailedError("Failed to set remoteDescription");
    });
    const answer = await peerConnection.createAnswer().catch((err) => {
      log7.error("could not execute createAnswer", err);
      throw new SDPHandshakeFailedError("Failed to create answer");
    });
    log7.trace("recipient send SDP answer %s", answer.sdp);
    await messageStream.write({ type: Message4.Type.SDP_ANSWER, data: answer.sdp }, {
      signal
    });
    await peerConnection.setLocalDescription(answer).catch((err) => {
      log7.error("could not execute setLocalDescription", err);
      throw new SDPHandshakeFailedError("Failed to set localDescription");
    });
    log7.trace("recipient read candidates until connected");
    await readCandidatesUntilConnected(peerConnection, messageStream, {
      direction: "recipient",
      signal,
      log: log7
    });
  } catch (err) {
    if (getConnectionState(peerConnection) !== "connected") {
      log7.error("error while handling signaling stream from peer %a", connection.remoteAddr, err);
      peerConnection.close();
      throw err;
    } else {
      log7("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
    }
  }
  const remoteAddress = multiaddr(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`);
  log7.trace("recipient connected to remote address %s", remoteAddress);
  return { remoteAddress };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
var WEBRTC_TRANSPORT = "/webrtc";
var CIRCUIT_RELAY_TRANSPORT = "/p2p-circuit";
var SIGNALING_PROTO_ID = "/webrtc-signaling/0.0.1";
var INBOUND_CONNECTION_TIMEOUT = 30 * 1e3;
var _a11, _b7, _c3, _d;
var WebRTCTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "components");
    __publicField(this, "init");
    __publicField(this, "log");
    __publicField(this, "_started", false);
    __publicField(this, "metrics");
    __publicField(this, "shutdownController");
    __publicField(this, _a11, true);
    __publicField(this, _b7, "@libp2p/webrtc");
    __publicField(this, _c3, [
      "@libp2p/transport"
    ]);
    __publicField(this, _d, [
      "@libp2p/identify",
      "@libp2p/circuit-relay-v2-transport"
    ]);
    this.components = components;
    this.init = init;
    this.log = components.logger.forComponent("libp2p:webrtc");
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC dialer events by type"
        }),
        listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
          label: "event",
          help: "Total count of WebRTC listener events by type"
        })
      };
    }
  }
  isStarted() {
    return this._started;
  }
  async start() {
    await this.components.registrar.handle(SIGNALING_PROTO_ID, (data) => {
      this._onProtocol(data).catch((err) => {
        this.log.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
      });
    }, {
      runOnLimitedConnection: true
    });
    this._started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(SIGNALING_PROTO_ID);
    this._started = false;
  }
  createListener(options2) {
    return new WebRTCPeerListener(this.components, {
      shutdownController: this.shutdownController
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTC.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /*
   * dial connects to a remote via the circuit relay or any other protocol
   * and proceeds to upgrade to a webrtc connection.
   * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
   * For a circuit relay, this will be of the form
   * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
  */
  async dial(ma, options2) {
    var _a13;
    this.log.trace("dialing address: %a", ma);
    const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
      rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
      dataChannel: this.init.dataChannel,
      multiaddr: ma,
      dataChannelOptions: this.init.dataChannel,
      signal: options2.signal,
      connectionManager: this.components.connectionManager,
      transportManager: this.components.transportManager,
      log: this.log,
      logger: this.components.logger,
      onProgress: options2.onProgress
    });
    const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
      peerConnection,
      timeline: { open: Date.now() },
      remoteAddr: remoteAddress,
      metrics: (_a13 = this.metrics) == null ? void 0 : _a13.dialerEvents
    });
    const connection = await options2.upgrader.upgradeOutbound(webRTCConn, {
      skipProtection: true,
      skipEncryption: true,
      muxerFactory,
      onProgress: options2.onProgress
    });
    this._closeOnShutdown(peerConnection, webRTCConn);
    return connection;
  }
  async _onProtocol({ connection, stream }) {
    var _a13;
    const signal = AbortSignal.timeout(this.init.inboundConnectionTimeout ?? INBOUND_CONNECTION_TIMEOUT);
    const peerConnection = new RTCPeerConnection(await getRtcConfiguration(this.init.rtcConfiguration));
    const muxerFactory = new DataChannelMuxerFactory(this.components, {
      peerConnection,
      dataChannelOptions: this.init.dataChannel
    });
    try {
      const { remoteAddress } = await handleIncomingStream({
        peerConnection,
        connection,
        stream,
        signal,
        log: this.log
      });
      await stream.close({
        signal
      });
      const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        timeline: { open: (/* @__PURE__ */ new Date()).getTime() },
        remoteAddr: remoteAddress,
        metrics: (_a13 = this.metrics) == null ? void 0 : _a13.listenerEvents
      });
      await this.components.upgrader.upgradeInbound(webRTCConn, {
        skipEncryption: true,
        skipProtection: true,
        muxerFactory
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
    } catch (err) {
      this.log.error("incoming signaling error", err);
      peerConnection.close();
      stream.abort(err);
      throw err;
    }
  }
  _closeOnShutdown(pc, webRTCConn) {
    const shutDownListener = () => {
      webRTCConn.close().catch((err) => {
        this.log.error("could not close WebRTCMultiaddrConnection", err);
      });
    };
    this.shutdownController.signal.addEventListener("abort", shutDownListener);
    pc.addEventListener("close", () => {
      this.shutdownController.signal.removeEventListener("abort", shutDownListener);
    });
  }
};
_a11 = transportSymbol, _b7 = Symbol.toStringTag, _c3 = serviceCapabilities, _d = serviceDependencies;
function splitAddr(ma) {
  const addrs = ma.toString().split(WEBRTC_TRANSPORT + "/");
  if (addrs.length !== 2) {
    throw new InvalidParametersError("webrtc protocol was not present in multiaddr");
  }
  if (!addrs[0].includes(CIRCUIT_RELAY_TRANSPORT)) {
    throw new InvalidParametersError("p2p-circuit protocol was not present in multiaddr");
  }
  let remoteAddr = multiaddr(addrs[0]);
  const destination = multiaddr("/" + addrs[1]);
  const destinationIdString = destination.getPeerId();
  if (destinationIdString == null) {
    throw new InvalidParametersError("destination peer id was missing");
  }
  const lastProtoInRemote = remoteAddr.protos().pop();
  if (lastProtoInRemote === void 0) {
    throw new InvalidParametersError("invalid multiaddr");
  }
  if (lastProtoInRemote.name !== "p2p") {
    remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
  }
  return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/sdp.js
var mbdecoder = Object.values(bases).map((b) => b.decoder).reduce((d, b) => d.or(b));
function getLocalFingerprint(pc, options2) {
  var _a13;
  const localCert = (_a13 = pc.getConfiguration().certificates) == null ? void 0 : _a13.at(0);
  if ((localCert == null ? void 0 : localCert.getFingerprints) == null) {
    options2.log.trace("fetching fingerprint from local SDP");
    const localDescription = pc.localDescription;
    if (localDescription == null) {
      return void 0;
    }
    return getFingerprintFromSdp(localDescription.sdp);
  }
  options2.log.trace("fetching fingerprint from local certificate");
  if (localCert.getFingerprints().length === 0) {
    return void 0;
  }
  const fingerprint = localCert.getFingerprints()[0].value;
  if (fingerprint == null) {
    throw new InvalidFingerprintError("", "no fingerprint on local certificate");
  }
  return fingerprint;
}
var fingerprintRegex = /^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;
function getFingerprintFromSdp(sdp) {
  var _a13;
  const searchResult = sdp.match(fingerprintRegex);
  return (_a13 = searchResult == null ? void 0 : searchResult.groups) == null ? void 0 : _a13.fingerprint;
}
function ipv(ma) {
  for (const proto of ma.protoNames()) {
    if (proto.startsWith("ip")) {
      return proto.toUpperCase();
    }
  }
  return "IP6";
}
function certhash(ma) {
  const tups = ma.stringTuples();
  const certhash2 = tups.filter((tup) => tup[0] === CERTHASH_CODE).map((tup) => tup[1])[0];
  if (certhash2 === void 0 || certhash2 === "") {
    throw new InvalidParametersError(`Couldn't find a certhash component of multiaddr: ${ma.toString()}`);
  }
  return certhash2;
}
function decodeCerthash(certhash2) {
  return digest_exports.decode(mbdecoder.decode(certhash2));
}
function ma2Fingerprint(ma) {
  const mhdecoded = decodeCerthash(certhash(ma));
  const prefix = toSupportedHashFunction(mhdecoded.code);
  const fingerprint = mhdecoded.digest.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
  const sdp = fingerprint.match(/.{1,2}/g);
  if (sdp == null) {
    throw new InvalidFingerprintError(fingerprint, ma.toString());
  }
  return [`${prefix} ${sdp.join(":").toUpperCase()}`, fingerprint];
}
function toSupportedHashFunction(code6) {
  switch (code6) {
    case 17:
      return "SHA-1";
    case 18:
      return "SHA-256";
    case 19:
      return "SHA-512";
    default:
      throw new UnsupportedHashAlgorithmError(code6);
  }
}
function ma2sdp(ma, ufrag) {
  const { host, port } = ma.toOptions();
  const ipVersion = ipv(ma);
  const [CERTFP] = ma2Fingerprint(ma);
  return `v=0
o=- 0 0 IN ${ipVersion} ${host}
s=-
c=IN ${ipVersion} ${host}
t=0 0
a=ice-lite
m=application ${port} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${ufrag}
a=ice-pwd:${ufrag}
a=fingerprint:${CERTFP}
a=sctp-port:5000
a=max-message-size:${MAX_MESSAGE_SIZE2}
a=candidate:1467250027 1 UDP 1467250027 ${host} ${port} typ host\r
`;
}
function fromMultiAddr(ma, ufrag) {
  return {
    type: "answer",
    sdp: ma2sdp(ma, ufrag)
  };
}
function munge(desc, ufrag) {
  if (desc.sdp === void 0) {
    throw new InvalidParametersError("Can't munge a missing SDP");
  }
  desc.sdp = desc.sdp.replace(/\na=ice-ufrag:[^\n]*\n/, "\na=ice-ufrag:" + ufrag + "\n").replace(/\na=ice-pwd:[^\n]*\n/, "\na=ice-pwd:" + ufrag + "\n");
  return desc;
}

// node_modules/@libp2p/webrtc/dist/src/private-to-public/util.js
var charset = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var genUfrag = (len) => [...Array(len)].map(() => charset.at(Math.floor(Math.random() * charset.length))).join("");

// node_modules/@libp2p/webrtc/dist/src/private-to-public/transport.js
var HANDSHAKE_TIMEOUT_MS = 1e4;
var WEBRTC_CODE = getProtocol("webrtc-direct").code;
var CERTHASH_CODE = getProtocol("certhash").code;
var _a12, _b8, _c4;
var WebRTCDirectTransport = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, "init");
    __publicField(this, _a12, true);
    __publicField(this, _b8, "@libp2p/webrtc-direct");
    __publicField(this, _c4, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:webrtc-direct");
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc-direct_dialer_events_total", {
          label: "event",
          help: "Total count of WebRTC-direct dial events by type"
        })
      };
    }
  }
  /**
   * Dial a given multiaddr
   */
  async dial(ma, options2) {
    const rawConn = await this._connect(ma, options2);
    this.log("dialing address: %a", ma);
    return rawConn;
  }
  /**
   * Create transport listeners no supported by browsers
   */
  createListener(options2) {
    throw new UnimplementedError("WebRTCTransport.createListener");
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    return multiaddrs.filter(WebRTCDirect.exactMatch);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /**
   * Connect to a peer using a multiaddr
   */
  async _connect(ma, options2) {
    var _a13, _b9, _c5;
    const controller = new AbortController();
    const signal = controller.signal;
    let remotePeer;
    const remotePeerString = ma.getPeerId();
    if (remotePeerString != null) {
      remotePeer = peerIdFromString(remotePeerString);
    }
    const remoteCerthash = decodeCerthash(certhash(ma));
    const certificate = await RTCPeerConnection.generateCertificate({
      name: "ECDSA",
      namedCurve: "P-256",
      hash: toSupportedHashFunction(remoteCerthash.code)
    });
    const peerConnection = new RTCPeerConnection({
      ...await getRtcConfiguration(this.init.rtcConfiguration),
      certificates: [certificate]
    });
    try {
      const dataChannelOpenPromise = new Promise((resolve, reject) => {
        const handshakeDataChannel2 = peerConnection.createDataChannel("", { negotiated: true, id: 0 });
        const handshakeTimeout = setTimeout(() => {
          var _a14;
          const error = `Data channel was never opened: state: ${handshakeDataChannel2.readyState}`;
          this.log.error(error);
          (_a14 = this.metrics) == null ? void 0 : _a14.dialerEvents.increment({ open_error: true });
          reject(new DataChannelError("data", error));
        }, HANDSHAKE_TIMEOUT_MS);
        handshakeDataChannel2.onopen = (_) => {
          clearTimeout(handshakeTimeout);
          resolve(handshakeDataChannel2);
        };
        handshakeDataChannel2.onerror = (event) => {
          var _a14, _b10;
          clearTimeout(handshakeTimeout);
          const errorTarget = ((_a14 = event.target) == null ? void 0 : _a14.toString()) ?? "not specified";
          const error = `Error opening a data channel for handshaking: ${errorTarget}`;
          this.log.error(error);
          (_b10 = this.metrics) == null ? void 0 : _b10.dialerEvents.increment({ unknown_error: true });
          reject(new DataChannelError("data", error));
        };
      });
      const ufrag = "libp2p+webrtc+v1/" + genUfrag(32);
      const offerSdp = await peerConnection.createOffer();
      const mungedOfferSdp = munge(offerSdp, ufrag);
      await peerConnection.setLocalDescription(mungedOfferSdp);
      const answerSdp = fromMultiAddr(ma, ufrag);
      await peerConnection.setRemoteDescription(answerSdp);
      const handshakeDataChannel = await dataChannelOpenPromise;
      const fingerprintsPrologue = this.generateNoisePrologue(peerConnection, remoteCerthash.code, ma);
      const connectionEncrypter = noise({ prologueBytes: fingerprintsPrologue })(this.components);
      const wrappedChannel = createStream2({
        channel: handshakeDataChannel,
        direction: "inbound",
        logger: this.components.logger,
        ...this.init.dataChannel ?? {}
      });
      const wrappedDuplex = {
        ...wrappedChannel,
        sink: wrappedChannel.sink.bind(wrappedChannel),
        source: async function* () {
          for await (const list of wrappedChannel.source) {
            for (const buf of list) {
              yield buf;
            }
          }
        }()
      };
      const maConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        remoteAddr: ma,
        timeline: {
          open: Date.now()
        },
        metrics: (_a13 = this.metrics) == null ? void 0 : _a13.dialerEvents
      });
      const eventListeningName = isFirefox ? "iceconnectionstatechange" : "connectionstatechange";
      peerConnection.addEventListener(eventListeningName, () => {
        switch (peerConnection.connectionState) {
          case "failed":
          case "disconnected":
          case "closed":
            maConn.close().catch((err) => {
              this.log.error("error closing connection", err);
            }).finally(() => {
              controller.abort();
            });
            break;
          default:
            break;
        }
      }, { signal });
      (_b9 = this.metrics) == null ? void 0 : _b9.dialerEvents.increment({ peer_connection: true });
      const muxerFactory = new DataChannelMuxerFactory(this.components, {
        peerConnection,
        metrics: (_c5 = this.metrics) == null ? void 0 : _c5.dialerEvents,
        dataChannelOptions: this.init.dataChannel
      });
      await connectionEncrypter.secureInbound(wrappedDuplex, {
        signal,
        remotePeer
      });
      return await options2.upgrader.upgradeOutbound(maConn, { skipProtection: true, skipEncryption: true, muxerFactory });
    } catch (err) {
      peerConnection.close();
      throw err;
    }
  }
  /**
   * Generate a noise prologue from the peer connection's certificate.
   * noise prologue = bytes('libp2p-webrtc-noise:') + noise-responder fingerprint + noise-initiator fingerprint
   */
  generateNoisePrologue(pc, hashCode, ma) {
    var _a13;
    if (((_a13 = pc.getConfiguration().certificates) == null ? void 0 : _a13.length) === 0) {
      throw new InvalidParametersError("no local certificate");
    }
    const localFingerprint = getLocalFingerprint(pc, {
      log: this.log
    });
    if (localFingerprint == null) {
      throw new InvalidParametersError("no local fingerprint found");
    }
    const localFpString = localFingerprint.trim().toLowerCase().replaceAll(":", "");
    const localFpArray = fromString(localFpString, "hex");
    const local = create(hashCode, localFpArray);
    const remote = mbdecoder.decode(certhash(ma));
    const prefix = fromString("libp2p-webrtc-noise:");
    return concat([prefix, local.bytes, remote]);
  }
};
_a12 = transportSymbol, _b8 = Symbol.toStringTag, _c4 = serviceCapabilities;

// node_modules/@libp2p/webrtc/dist/src/index.js
function webRTCDirect(init) {
  return (components) => new WebRTCDirectTransport(components, init);
}
function webRTC(init) {
  return (components) => new WebRTCTransport(components, init);
}

// node_modules/ipns/dist/src/selector.js
var import_timestamp_nano3 = __toESM(require_timestamp_min());
function ipnsSelector(key, data) {
  const entries = data.map((buf, index) => ({
    record: unmarshalIPNSRecord(buf),
    index
  }));
  entries.sort((a, b) => {
    const aSeq = a.record.sequence;
    const bSeq = b.record.sequence;
    if (aSeq > bSeq) {
      return -1;
    } else if (aSeq < bSeq) {
      return 1;
    }
    if (a.record.validityType === IpnsEntry.ValidityType.EOL && b.record.validityType === IpnsEntry.ValidityType.EOL) {
      const recordAValidityDate = import_timestamp_nano3.default.fromString(a.record.validity).toDate();
      const recordBValidityDate = import_timestamp_nano3.default.fromString(b.record.validity).toDate();
      if (recordAValidityDate.getTime() > recordBValidityDate.getTime()) {
        return -1;
      }
      if (recordAValidityDate.getTime() < recordBValidityDate.getTime()) {
        return 1;
      }
    }
    return 0;
  });
  return entries[0].index;
}

// node_modules/helia/dist/src/version.js
var version2 = "5.2.0";
var name2 = "helia";

// node_modules/helia/dist/src/utils/bootstrappers.js
var bootstrapConfig = {
  list: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    // va1 is not in the TXT records for _dnsaddr.bootstrap.libp2p.io yet
    // so use the host name directly
    "/dnsaddr/va1.bootstrap.libp2p.io/p2p/12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8",
    "/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"
  ]
};

// node_modules/helia/dist/src/utils/libp2p-defaults.browser.js
function libp2pDefaults(options2 = {}) {
  const agentVersion = `${name2}/${version2} ${name}/${version} UserAgent=${globalThis.navigator.userAgent}`;
  return {
    privateKey: options2.privateKey,
    dns: options2.dns,
    addresses: {
      listen: [
        "/p2p-circuit",
        "/webrtc"
      ]
    },
    transports: [
      circuitRelayTransport(),
      webRTC(),
      webRTCDirect(),
      webSockets()
    ],
    connectionEncrypters: [
      noise()
    ],
    streamMuxers: [
      yamux(),
      mplex()
    ],
    peerDiscovery: [
      bootstrap(bootstrapConfig)
    ],
    services: {
      autoNAT: autoNAT(),
      dcutr: dcutr(),
      delegatedRouting: () => createDelegatedRoutingV1HttpApiClient("https://delegated-ipfs.dev", delegatedHTTPRoutingDefaults()),
      dht: kadDHT({
        clientMode: true,
        validators: {
          ipns: ipnsValidator
        },
        selectors: {
          ipns: ipnsSelector
        }
      }),
      identify: identify({
        agentVersion
      }),
      identifyPush: identifyPush({
        agentVersion
      }),
      keychain: keychain(options2.keychain),
      ping: ping()
    }
  };
}

// node_modules/@libp2p/config/dist/src/load-private-key.js
async function loadOrCreateSelfKey(datastore, init = {}) {
  const chain = keychain(init)({
    datastore,
    logger: defaultLogger()
  });
  const selfKey = new Key("/pkcs8/self");
  let privateKey;
  if (await datastore.has(selfKey)) {
    privateKey = await chain.exportKey("self");
  } else {
    privateKey = await generateKeyPair(init.keyType ?? "Ed25519");
    await chain.importKey("self", privateKey);
  }
  return privateKey;
}

// node_modules/helia/dist/src/utils/libp2p.js
async function createLibp2p2(options2) {
  const libp2pOptions = options2.libp2p ?? {};
  if (libp2pOptions.privateKey == null && options2.datastore != null) {
    libp2pOptions.privateKey = await loadOrCreateSelfKey(options2.datastore, options2.keychain);
  }
  const defaults3 = libp2pDefaults(libp2pOptions);
  defaults3.datastore = defaults3.datastore ?? options2.datastore;
  const node = await createLibp2p({
    ...defaults3,
    ...libp2pOptions,
    start: false
  });
  return node;
}

// node_modules/helia/dist/src/index.js
async function createHelia(init = {}) {
  const datastore = init.datastore ?? new MemoryDatastore();
  const blockstore = init.blockstore ?? new MemoryBlockstore();
  let libp2p;
  if (isLibp2p(init.libp2p)) {
    libp2p = init.libp2p;
  } else {
    libp2p = await createLibp2p2({
      ...init,
      libp2p: {
        dns: init.dns,
        ...init.libp2p,
        // ignore the libp2p start parameter as it should be on the main init
        // object instead
        start: void 0
      },
      datastore
    });
  }
  const helia = new HeliaP2P({
    ...init,
    libp2p,
    datastore,
    blockstore,
    blockBrokers: init.blockBrokers ?? [
      trustlessGateway(),
      bitswap()
    ],
    routers: init.routers ?? [
      libp2pRouting(libp2p),
      httpGatewayRouting()
    ],
    metrics: libp2p.metrics
  });
  if (init.start !== false) {
    await helia.start();
  }
  return helia;
}
function isLibp2p(obj) {
  if (obj == null) {
    return false;
  }
  const funcs = ["dial", "dialProtocol", "hangUp", "handle", "unhandle", "getMultiaddrs", "getProtocols"];
  return funcs.every((m) => typeof obj[m] === "function");
}
export {
  DEFAULT_SESSION_MAX_PROVIDERS,
  DEFAULT_SESSION_MIN_PROVIDERS,
  InsufficientProvidersError,
  NoRoutersAvailableError,
  UnknownCodecError,
  UnknownHashAlgorithmError,
  createHelia,
  libp2pDefaults
};
//# sourceMappingURL=helia.js.map
