{
  "version": 3,
  "sources": ["../../sparse-array/index.js", "../../rabin-wasm/src/rabin.js", "../../@assemblyscript/loader/index.js", "../../rabin-wasm/dist/rabin-wasm.js", "../../rabin-wasm/src/index.js", "../../it-batch/src/index.ts", "../../it-parallel-batch/src/index.ts", "../../ipfs-unixfs-importer/src/chunker/fixed-size.ts", "../../ipfs-unixfs/src/errors.ts", "../../ipfs-unixfs/src/unixfs.ts", "../../ipfs-unixfs/src/index.ts", "../../ipfs-unixfs-importer/src/utils/persist.ts", "../../ipfs-unixfs-importer/src/dag-builder/buffer-importer.ts", "../../ipfs-unixfs-importer/src/errors.ts", "../../ipfs-unixfs-importer/src/dag-builder/dir.ts", "../../ipfs-unixfs-importer/src/dag-builder/file.ts", "../../ipfs-unixfs-importer/src/dag-builder/index.ts", "../../ipfs-unixfs-importer/src/dag-builder/validate-chunks.ts", "../../ipfs-unixfs-importer/src/layout/balanced.ts", "../../ipfs-unixfs-importer/src/dir.ts", "../../ipfs-unixfs-importer/src/dir-flat.ts", "../../@multiformats/murmur3/src/index.js", "../../hamt-sharding/src/bucket.ts", "../../hamt-sharding/src/consumable-buffer.ts", "../../hamt-sharding/src/consumable-hash.ts", "../../hamt-sharding/src/index.ts", "../../ipfs-unixfs-importer/src/dir-sharded.ts", "../../ipfs-unixfs-importer/src/flat-to-shard.ts", "../../ipfs-unixfs-importer/src/utils/to-path-components.ts", "../../ipfs-unixfs-importer/src/tree-builder.ts", "../../ipfs-unixfs-importer/src/index.ts", "../../ipfs-unixfs-importer/src/chunker/rabin.ts", "../../@helia/unixfs/src/commands/add.ts", "../../it-last/src/index.ts", "../../ipfs-unixfs-exporter/src/errors.ts", "../../ipfs-unixfs-exporter/src/utils/resolve-object-path.ts", "../../ipfs-unixfs-exporter/src/resolvers/dag-cbor.ts", "../../ipfs-unixfs-exporter/src/resolvers/dag-json.ts", "../../ipfs-unixfs-exporter/src/utils/extract-data-from-block.ts", "../../ipfs-unixfs-exporter/src/utils/validate-offset-and-length.ts", "../../ipfs-unixfs-exporter/src/resolvers/identity.ts", "../../ipfs-unixfs-exporter/src/resolvers/json.ts", "../../ipfs-unixfs-exporter/src/resolvers/raw.ts", "../../ipfs-unixfs-exporter/src/utils/find-cid-in-shard.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts", "../../ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.ts", "../../ipfs-unixfs-exporter/src/resolvers/index.ts", "../../ipfs-unixfs-exporter/src/index.ts", "../../@helia/unixfs/src/errors.ts", "../../@helia/unixfs/src/commands/utils/add-link.ts", "../../@helia/unixfs/src/commands/utils/consumable-hash.ts", "../../@helia/unixfs/src/commands/utils/hamt-constants.ts", "../../@helia/unixfs/src/commands/utils/hamt-utils.ts", "../../@helia/unixfs/src/commands/utils/persist.ts", "../../@helia/unixfs/src/commands/utils/dir-sharded.ts", "../../@helia/unixfs/src/commands/utils/is-over-shard-threshold.ts", "../../@helia/unixfs/src/commands/utils/cid-to-directory.ts", "../../@helia/unixfs/src/commands/utils/cid-to-pblink.ts", "../../@helia/unixfs/src/commands/utils/resolve.ts", "../../@helia/unixfs/src/commands/cat.ts", "../../@helia/unixfs/src/commands/utils/constants.ts", "../../@helia/unixfs/src/commands/chmod.ts", "../../@helia/unixfs/src/commands/cp.ts", "../../@helia/unixfs/src/commands/ls.ts", "../../@helia/unixfs/src/commands/mkdir.ts", "../../@helia/unixfs/src/commands/utils/remove-link.ts", "../../@helia/unixfs/src/commands/rm.ts", "../../@helia/unixfs/src/commands/stat.ts", "../../@helia/unixfs/src/commands/touch.ts", "../../@helia/unixfs/src/unixfs.ts", "../../@helia/unixfs/src/utils/glob-source.browser.ts", "../../@helia/unixfs/src/utils/url-source.ts", "../../@helia/unixfs/src/index.ts"],
  "sourcesContent": ["'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}", "/**\n * Rabin fingerprinting\n *\n * @class Rabin\n */\nclass Rabin {\n    /**\n     * Creates an instance of Rabin.\n     * @param { import(\"./../dist/rabin-wasm\") } asModule\n     * @param {number} [bits=12]\n     * @param {number} [min=8 * 1024]\n     * @param {number} [max=32 * 1024]\n     * @param {number} polynomial\n     * @memberof Rabin\n     */\n    constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {\n        this.bits = bits\n        this.min = min\n        this.max = max\n        this.asModule = asModule\n        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial)\n        this.polynomial = polynomial\n    }\n\n    /**\n     * Fingerprints the buffer\n     *\n     * @param {Uint8Array} buf\n     * @returns {Array<number>}\n     * @memberof Rabin\n     */\n    fingerprint(buf) {\n        const {\n            __retain,\n            __release,\n            __allocArray,\n            __getInt32Array,\n            Int32Array_ID,\n            Uint8Array_ID\n        } = this.asModule\n\n        const lengths = new Int32Array(Math.ceil(buf.length/this.min))\n        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths))\n        const pointer = __retain(__allocArray(Uint8Array_ID, buf))\n\n        const out = this.rabin.fingerprint(pointer, lengthsPtr)\n        const processed = __getInt32Array(out)\n\n        __release(pointer)\n        __release(lengthsPtr)\n\n        const end = processed.indexOf(0);\n        return end >= 0 ? processed.subarray(0, end) : processed;\n    }\n}\n\nmodule.exports = Rabin", "\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n", "\nconst { instantiate } = require(\"@assemblyscript/loader\");\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (imp = {}) {\n  if (!loadWebAssembly.supported) return null\n  \n  var wasm = new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112])\n  // make it work async because browsers throw when a wasm module is bigger than 4kb and load sync\n  return instantiate(new Response(new Blob([wasm], {type: 'application/wasm'})), imp)\n}\nmodule.exports = loadWebAssembly\n", "const Rabin = require('./rabin')\nconst getRabin = require('../dist/rabin-wasm.node.js')\n\nconst create = async (avg, min, max, windowSize, polynomial) => {\n    const compiled = await getRabin()\n    return new Rabin(compiled, avg, min, max, windowSize, polynomial)\n}\n\nmodule.exports = {\n    Rabin,\n    create\n}\n", "/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches\n */\nfunction batch <T> (source: Iterable<T>, size?: number): Generator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size?: number): AsyncGenerator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size: number = 1): Generator<T[], void, undefined> | AsyncGenerator<T[], void, undefined> {\n  size = Number(size)\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let things: T[] = []\n\n      if (size < 1) {\n        size = 1\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      for await (const thing of source) {\n        things.push(thing)\n\n        while (things.length >= size) {\n          yield things.slice(0, size)\n\n          things = things.slice(size)\n        }\n      }\n\n      while (things.length > 0) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }())\n  }\n\n  return (function * () {\n    let things: T[] = []\n\n    if (size < 1) {\n      size = 1\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    for (const thing of source) {\n      things.push(thing)\n\n      while (things.length >= size) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }\n\n    while (things.length > 0) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }())\n}\n\nexport default batch\n", "/**\n * @packageDocumentation\n *\n * Takes an async iterator that emits promise-returning functions, invokes them in parallel and emits the results in the same order as the input.\n *\n * The final batch may be smaller than the batch size.\n *\n * @example\n *\n * ```javascript\n * import parallelBatch from 'it-parallel-batch'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     await delay(500)\n *\n *     return 1\n *   },\n *   async () => {\n *     await delay(200)\n *\n *     return 2\n *   },\n *   async () => {\n *     await delay(100)\n *\n *     return 3\n *   }\n * ]\n *\n * const batchSize = 2\n *\n * const result = await all(parallelBatch(input, batchSize))\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport batch from 'it-batch'\n\ninterface Success<T> {\n  ok: true\n  value: T\n}\n\ninterface Failure {\n  ok: false\n  err: Error\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallelBatch <T> (source: AsyncIterable<() => Promise<T>> | Iterable<() => Promise<T>>, size: number = 1): AsyncGenerator<T, void, undefined> {\n  for await (const tasks of batch(source, size)) {\n    const things: Array<Promise<Success<T> | Failure>> = tasks.map(\n      async (p: () => Promise<T>) => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Chunker } from './index.js'\n\nexport interface FixedSizeOptions {\n  chunkSize?: number\n}\n\nconst DEFAULT_CHUNK_SIZE = 262144\n\nexport const fixedSize = (options: FixedSizeOptions = {}): Chunker => {\n  const chunkSize = options.chunkSize ?? DEFAULT_CHUNK_SIZE\n\n  return async function * fixedSizeChunker (source) {\n    let list = new Uint8ArrayList()\n    let currentLength = 0\n    let emitted = false\n\n    for await (const buffer of source) {\n      list.append(buffer)\n\n      currentLength += buffer.length\n\n      while (currentLength >= chunkSize) {\n        yield list.slice(0, chunkSize)\n        emitted = true\n\n        // throw away consumed bytes\n        if (chunkSize === list.length) {\n          list = new Uint8ArrayList()\n          currentLength = 0\n        } else {\n          const newBl = new Uint8ArrayList()\n          newBl.append(list.sublist(chunkSize))\n          list = newBl\n\n          // update our offset\n          currentLength -= chunkSize\n        }\n      }\n    }\n\n    if (!emitted || currentLength > 0) {\n      // return any remaining bytes\n      yield list.subarray(0, currentLength)\n    }\n  }\n}\n", "export class InvalidTypeError extends Error {\n  static name = 'InvalidTypeError'\n  static code = 'ERR_INVALID_TYPE'\n  name = InvalidTypeError.name\n  code = InvalidTypeError.code\n\n  constructor (message = 'Invalid type') {\n    super(message)\n  }\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```JavaScript\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256) // add the size of each block\n * data.addBlockSize(256)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```JavaScript\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```JavaScript\n * const data = new UnixFS([options])\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```JavaScript\n * data.addBlockSize(<size in bytes>)\n * ```\n *\n * ```JavaScript\n * data.removeBlockSize(<index>)\n * ```\n *\n * @example Get total fileSize\n *\n * ```JavaScript\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```javascript\n * const marshaled = data.marshal()\n * const unmarshaled = Unixfs.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```JavaScript\n * const dir = new Data({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new Data({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```JavaScript\n * const file = new Data({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new Data({ type: 'dir', mtime: new Date() })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\nimport { InvalidTypeError } from './errors.js'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nconst types: Record<string, string> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\nexport interface UnixFSOptions {\n  type?: string\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined,\n      fanout: message.fanout\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw new InvalidTypeError('Type: ' + type + ' is not valid')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw new InvalidTypeError(`Type: ${type} is not valid`)\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\nexport * from './errors.js'\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { WritableStorage } from '../index.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PersistOptions extends ProgressOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: WritableStorage, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, options)\n\n  return cid\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport * as raw from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist, type PersistOptions } from '../utils/persist.js'\nimport type { BufferImporter } from '../index.js'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportWriteProgress {\n  /**\n   * How many bytes we have written for this source so far - this may be\n   * bigger than the file size due to the DAG-PB wrappers of each block\n   */\n  bytesWritten: bigint\n\n  /**\n   * The CID of the block that has been written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type BufferImportProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:write', ImportWriteProgress>\n\nexport interface BufferImporterOptions extends ProgressOptions<BufferImportProgressEvents> {\n  cidVersion: Version\n  rawLeaves: boolean\n  leafType: 'file' | 'raw'\n}\n\nexport function defaultBufferImporter (options: BufferImporterOptions): BufferImporter {\n  return async function * bufferImporter (file, blockstore) {\n    let bytesWritten = 0n\n\n    for await (let block of file.content) {\n      yield async () => { // eslint-disable-line no-loop-func\n        let unixfs\n\n        const opts: PersistOptions = {\n          codec: dagPb,\n          cidVersion: options.cidVersion,\n          onProgress: options.onProgress\n        }\n\n        if (options.rawLeaves) {\n          opts.codec = raw\n          opts.cidVersion = 1\n        } else {\n          unixfs = new UnixFS({\n            type: options.leafType,\n            data: block\n          })\n\n          block = dagPb.encode({\n            Data: unixfs.marshal(),\n            Links: []\n          })\n        }\n\n        const cid = await persist(block, blockstore, opts)\n\n        bytesWritten += BigInt(block.byteLength)\n\n        options.onProgress?.(new CustomProgressEvent<ImportWriteProgress>('unixfs:importer:progress:file:write', {\n          bytesWritten,\n          cid,\n          path: file.path\n        }))\n\n        return {\n          cid,\n          unixfs,\n          size: BigInt(block.length),\n          block\n        }\n      }\n    }\n  }\n}\n", "export class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n\nexport class InvalidAvgChunkSizeError extends Error {\n  static name = 'InvalidAvgChunkSizeError'\n  static code = 'ERR_INVALID_AVG_CHUNK_SIZE'\n  name = InvalidAvgChunkSizeError.name\n  code = InvalidAvgChunkSizeError.code\n\n  constructor (message = 'Invalid avg chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidChunkSizeError extends Error {\n  static name = 'InvalidChunkSizeError'\n  static code = 'ERR_INVALID_CHUNK_SIZE'\n  name = InvalidChunkSizeError.name\n  code = InvalidChunkSizeError.code\n\n  constructor (message = 'Invalid chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidMinChunkSizeError extends Error {\n  static name = 'InvalidMinChunkSizeError'\n  static code = 'ERR_INVALID_MIN_CHUNK_SIZE'\n  name = InvalidMinChunkSizeError.name\n  code = InvalidMinChunkSizeError.code\n\n  constructor (message = 'Invalid min chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidContentError extends Error {\n  static name = 'InvalidContentError'\n  static code = 'ERR_INVALID_CONTENT'\n  name = InvalidContentError.name\n  code = InvalidContentError.code\n\n  constructor (message = 'Invalid content') {\n    super(message)\n  }\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { persist } from '../utils/persist.js'\nimport type { Directory, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { Version } from 'multiformats/cid'\n\nexport interface DirBuilderOptions {\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nexport const dirBuilder = async (dir: Directory, blockstore: WritableStorage, options: DirBuilderOptions): Promise<InProgressImportResult> => {\n  const unixfs = new UnixFS({\n    type: 'directory',\n    mtime: dir.mtime,\n    mode: dir.mode\n  })\n\n  const block = encode(prepare({ Data: unixfs.marshal() }))\n  const cid = await persist(block, blockstore, options)\n  const path = dir.path\n\n  return {\n    cid,\n    path,\n    unixfs,\n    size: BigInt(block.length),\n    originalPath: dir.originalPath,\n    block\n  }\n}\n", "import { encode, type PBLink, type PBNode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport parallelBatch from 'it-parallel-batch'\nimport * as rawCodec from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist } from '../utils/persist.js'\nimport type { BufferImporter, File, InProgressImportResult, WritableStorage, SingleBlockImportResult, ImporterProgressEvents } from '../index.js'\nimport type { FileLayout, Reducer } from '../layout/index.js'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\ninterface BuildFileBatchOptions {\n  bufferImporter: BufferImporter\n  blockWriteConcurrency: number\n}\n\nasync function * buildFileBatch (file: File, blockstore: WritableStorage, options: BuildFileBatchOptions): AsyncGenerator<InProgressImportResult> {\n  let count = -1\n  let previous: SingleBlockImportResult | undefined\n\n  for await (const entry of parallelBatch(options.bufferImporter(file, blockstore), options.blockWriteConcurrency)) {\n    count++\n\n    if (count === 0) {\n      // cache the first entry if case there aren't any more\n      previous = {\n        ...entry,\n        single: true\n      }\n\n      continue\n    } else if (count === 1 && (previous != null)) {\n      // we have the second block of a multiple block import so yield the first\n      yield {\n        ...previous,\n        block: undefined,\n        single: undefined\n      }\n      previous = undefined\n    }\n\n    // yield the second or later block of a multiple block import\n    yield {\n      ...entry,\n      block: undefined\n    }\n  }\n\n  if (previous != null) {\n    yield previous\n  }\n}\n\nexport interface LayoutLeafProgress {\n  /**\n   * The CID of the leaf being written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type ReducerProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:layout', LayoutLeafProgress>\n\ninterface ReduceOptions extends ProgressOptions<ImporterProgressEvents> {\n  reduceSingleLeafToSelf: boolean\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nfunction isSingleBlockImport (result: any): result is SingleBlockImportResult {\n  return result.single === true\n}\n\nconst reduce = (file: File, blockstore: WritableStorage, options: ReduceOptions): Reducer => {\n  const reducer: Reducer = async function (leaves) {\n    if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0]\n      let node: Uint8Array | PBNode = leaf.block\n\n      if (isSingleBlockImport(leaf) && (file.mtime !== undefined || file.mode !== undefined)) {\n        // only one leaf node which is a raw leaf - we have metadata so convert it into a\n        // UnixFS entry otherwise we'll have nowhere to store the metadata\n        leaf.unixfs = new UnixFS({\n          type: 'file',\n          mtime: file.mtime,\n          mode: file.mode,\n          data: leaf.block\n        })\n\n        node = { Data: leaf.unixfs.marshal(), Links: [] }\n\n        leaf.block = encode(prepare(node))\n\n        leaf.cid = await persist(leaf.block, blockstore, {\n          ...options,\n          cidVersion: options.cidVersion\n        })\n        leaf.size = BigInt(leaf.block.length)\n      }\n\n      options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n        cid: leaf.cid,\n        path: leaf.originalPath\n      }))\n\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        unixfs: leaf.unixfs,\n        size: leaf.size,\n        originalPath: leaf.originalPath\n      }\n    }\n\n    // create a parent node and add all the leaves\n    const f = new UnixFS({\n      type: 'file',\n      mtime: file.mtime,\n      mode: file.mode\n    })\n\n    const links: PBLink[] = leaves\n      .filter(leaf => {\n        if (leaf.cid.code === rawCodec.code && leaf.size > 0) {\n          return true\n        }\n\n        if ((leaf.unixfs != null) && (leaf.unixfs.data == null) && leaf.unixfs.fileSize() > 0n) {\n          return true\n        }\n\n        return Boolean(leaf.unixfs?.data?.length)\n      })\n      .map((leaf) => {\n        if (leaf.cid.code === rawCodec.code) {\n          // node is a leaf buffer\n          f.addBlockSize(leaf.size)\n\n          return {\n            Name: '',\n            Tsize: Number(leaf.size),\n            Hash: leaf.cid\n          }\n        }\n\n        if ((leaf.unixfs?.data == null)) {\n          // node is an intermediate node\n          f.addBlockSize(leaf.unixfs?.fileSize() ?? 0n)\n        } else {\n          // node is a unixfs 'file' leaf node\n          f.addBlockSize(BigInt(leaf.unixfs.data.length))\n        }\n\n        return {\n          Name: '',\n          Tsize: Number(leaf.size),\n          Hash: leaf.cid\n        }\n      })\n\n    const node = {\n      Data: f.marshal(),\n      Links: links\n    }\n    const block = encode(prepare(node))\n    const cid = await persist(block, blockstore, options)\n\n    options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n      cid,\n      path: file.originalPath\n    }))\n\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),\n      originalPath: file.originalPath,\n      block\n    }\n  }\n\n  return reducer\n}\n\nexport interface FileBuilderOptions extends BuildFileBatchOptions, ReduceOptions {\n  layout: FileLayout\n}\n\nexport const fileBuilder = async (file: File, block: WritableStorage, options: FileBuilderOptions): Promise<InProgressImportResult> => {\n  return options.layout(buildFileBatch(file, block, options), reduce(file, block, options))\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { InvalidContentError } from '../errors.js'\nimport { dirBuilder, type DirBuilderOptions } from './dir.js'\nimport { fileBuilder, type FileBuilderOptions } from './file.js'\nimport type { ChunkValidator } from './validate-chunks.js'\nimport type { Chunker } from '../chunker/index.js'\nimport type { Directory, File, FileCandidate, ImportCandidate, ImporterProgressEvents, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportReadProgress {\n  /**\n   * How many bytes we have read from this source so far\n   */\n  bytesRead: bigint\n\n  /**\n   * The size of the current chunk\n   */\n  chunkSize: bigint\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type DagBuilderProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:read', ImportReadProgress>\n\nfunction isIterable (thing: any): thing is Iterable<any> {\n  return Symbol.iterator in thing\n}\n\nfunction isAsyncIterable (thing: any): thing is AsyncIterable<any> {\n  return Symbol.asyncIterator in thing\n}\n\nfunction contentAsAsyncIterable (content: Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>): AsyncIterable<Uint8Array> {\n  try {\n    if (content instanceof Uint8Array) {\n      return (async function * () {\n        yield content\n      }())\n    } else if (isIterable(content)) {\n      return (async function * () {\n        yield * content\n      }())\n    } else if (isAsyncIterable(content)) {\n      return content\n    }\n  } catch {\n    throw new InvalidContentError('Content was invalid')\n  }\n\n  throw new InvalidContentError('Content was invalid')\n}\n\nexport interface DagBuilderOptions extends FileBuilderOptions, DirBuilderOptions, ProgressOptions<ImporterProgressEvents> {\n  chunker: Chunker\n  chunkValidator: ChunkValidator\n  wrapWithDirectory: boolean\n}\n\nexport type ImporterSourceStream = AsyncIterable<ImportCandidate> | Iterable<ImportCandidate>\n\nexport interface DAGBuilder {\n  (source: ImporterSourceStream, blockstore: WritableStorage): AsyncIterable<() => Promise<InProgressImportResult>>\n}\n\nexport function defaultDagBuilder (options: DagBuilderOptions): DAGBuilder {\n  return async function * dagBuilder (source, blockstore) {\n    for await (const entry of source) {\n      let originalPath: string | undefined\n\n      if (entry.path != null) {\n        originalPath = entry.path\n        entry.path = entry.path\n          .split('/')\n          .filter(path => path != null && path !== '.')\n          .join('/')\n      }\n\n      if (isFileCandidate(entry)) {\n        const file: File = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          content: (async function * () {\n            let bytesRead = 0n\n\n            for await (const chunk of options.chunker(options.chunkValidator(contentAsAsyncIterable(entry.content)))) {\n              const currentChunkSize = BigInt(chunk.byteLength)\n              bytesRead += currentChunkSize\n\n              options.onProgress?.(new CustomProgressEvent<ImportReadProgress>('unixfs:importer:progress:file:read', {\n                bytesRead,\n                chunkSize: currentChunkSize,\n                path: entry.path\n              }))\n\n              yield chunk\n            }\n          })(),\n          originalPath\n        }\n\n        yield async () => fileBuilder(file, blockstore, options)\n      } else if (entry.path != null) {\n        const dir: Directory = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          originalPath\n        }\n\n        yield async () => dirBuilder(dir, blockstore, options)\n      } else {\n        throw new Error('Import candidate must have content or path or both')\n      }\n    }\n  }\n}\n\nfunction isFileCandidate (entry: any): entry is FileCandidate {\n  return entry.content != null\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { InvalidContentError } from '../errors.js'\n\nexport interface ChunkValidator { (source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array> }\n\nexport const defaultChunkValidator = (): ChunkValidator => {\n  return async function * validateChunks (source) {\n    for await (const content of source) {\n      if (content.length === undefined) {\n        throw new InvalidContentError('Content was invalid')\n      }\n\n      if (typeof content === 'string' || content instanceof String) {\n        yield uint8ArrayFromString(content.toString())\n      } else if (Array.isArray(content)) {\n        yield Uint8Array.from(content)\n      } else if (content instanceof Uint8Array) {\n        yield content\n      } else {\n        throw new InvalidContentError('Content was invalid')\n      }\n    }\n  }\n}\n", "import batch from 'it-batch'\nimport type { FileLayout } from './index.js'\nimport type { InProgressImportResult } from '../index.js'\n\nconst DEFAULT_MAX_CHILDREN_PER_NODE = 174\n\nexport interface BalancedOptions {\n  maxChildrenPerNode?: number\n}\n\nexport function balanced (options?: BalancedOptions): FileLayout {\n  const maxChildrenPerNode = options?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE\n\n  return async function balancedLayout (source, reduce): Promise<InProgressImportResult> {\n    const roots = []\n\n    for await (const chunked of batch(source, maxChildrenPerNode)) {\n      roots.push(await reduce(chunked))\n    }\n\n    if (roots.length > 1) {\n      return balancedLayout(roots, reduce)\n    }\n\n    return roots[0]\n  }\n}\n", "import { CID } from 'multiformats/cid'\nimport type { WritableStorage, ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { Mtime, UnixFS } from 'ipfs-unixfs'\n\nexport interface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nexport abstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): AsyncIterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: WritableStorage): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import { encode, type PBNode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1, type DirProps } from './dir.js'\nimport { persist, type PersistOptions } from './utils/persist.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { CID } from 'multiformats/cid'\n\nexport class DirFlat extends Dir {\n  private readonly _children: Map<string, InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._children = new Map()\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    this._children.set(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return Promise.resolve(this._children.get(name))\n  }\n\n  childCount (): number {\n    return this._children.size\n  }\n\n  directChildrenCount (): number {\n    return this.childCount()\n  }\n\n  onlyChild (): InProgressImportResult | Dir {\n    return this._children.values().next().value\n  }\n\n  async * eachChildSeries (): AsyncGenerator<{ key: string, child: InProgressImportResult | Dir }, void, undefined> {\n    for (const [key, child] of this._children.entries()) {\n      yield {\n        key,\n        child\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = 0\n\n    // estimate size only based on DAGLink name and CID byte lengths\n    // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n    for (const [name, child] of this._children.entries()) {\n      if (child.size != null && (child.cid != null)) {\n        this.nodeSize += name.length + (this.options.cidVersion === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength)\n      }\n    }\n\n    return this.nodeSize\n  }\n\n  async * flush (block: Blockstore): AsyncGenerator<ImportResult> {\n    const links = []\n\n    for (const [name, child] of this._children.entries()) {\n      let result: { size?: bigint | number, cid?: CID } = child\n\n      if (child instanceof Dir) {\n        for await (const entry of child.flush(block)) {\n          result = entry\n\n          yield entry\n        }\n      }\n\n      if (result.size != null && (result.cid != null)) {\n        links.push({\n          Name: name,\n          Tsize: Number(result.size),\n          Hash: result.cid\n        })\n      }\n    }\n\n    const unixfs = new UnixFS({\n      type: 'directory',\n      mtime: this.mtime,\n      mode: this.mode\n    })\n\n    const node: PBNode = { Data: unixfs.marshal(), Links: links }\n    const buffer = encode(prepare(node))\n    const cid = await persist(buffer, block, this.options)\n    const size = buffer.length + node.Links.reduce(\n      /**\n       * @param {number} acc\n       * @param {PBLink} curr\n       */\n      (acc, curr) => acc + (curr.Tsize ?? 0),\n      0)\n\n    this.cid = cid\n    this.size = size\n\n    yield {\n      cid,\n      unixfs,\n      path: this.path,\n      size: BigInt(size)\n    }\n  }\n}\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray(): B[]\n  get(i: number): B\n  set(i: number, value: B): void\n  reduce <A> (fn: (acc: A, curr: B, index: number) => A, initial: A): B\n  find(fn: (item: B) => boolean): B | undefined\n  bitField(): number[]\n  unset(i: number): void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash(value: Uint8Array | InfiniteHash): InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T): Promise<void> {\n    const place = await this._findNewBucketAndPos(key)\n\n    place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string): Promise<T | undefined> {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string): Promise<void> {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount (): number {\n    return this._children.length\n  }\n\n  onlyChild (): Bucket<T> | BucketChild<T> {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize <M> (map: (value: BucketChild<T>, index: number) => M, reduce: (reduced: Bucket<T> | BucketChild<T>) => M): M {\n    const acc: M[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform <R = T> (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON (): Record<string, any> {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint (): string {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize (): number {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string): Promise<BucketChild<T> | undefined> {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T): void {\n    this._putObjectAt(place.pos, {\n      key,\n      value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>): void {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number): void {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level (): void {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number): Bucket<T> | BucketChild<T> {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any): boolean {\n  return Boolean(o)\n}\n\nfunction mapNode (node: { key: string }, _: number): string {\n  return node.key\n}\n\nfunction reduceNodes <T> (nodes: T): any {\n  return nodes\n}\n\nasync function asyncTransformBucket <T, R = T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n", "const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { ConsumableBuffer } from './consumable-buffer.js'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\nimport { Bucket } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\n\ninterface UserBucketOptions {\n  hashFn(value: Uint8Array): Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions): Bucket<T> {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n", "import { encode, type PBLink, prepare } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { createHAMT, Bucket, type BucketChild } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1, type DirProps } from './dir.js'\nimport { persist, type PersistOptions } from './utils/persist.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { Blockstore } from 'interface-blockstore'\n\nasync function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst HAMT_HASH_CODE = BigInt(0x22)\nconst DEFAULT_FANOUT_BITS = 8\n\nexport interface DirShardedOptions extends PersistOptions {\n  shardFanoutBits: number\n}\n\nclass DirSharded extends Dir {\n  private readonly _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: DirShardedOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: options.shardFanoutBits ?? DEFAULT_FANOUT_BITS\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries (): AsyncGenerator<{ key: string, child: InProgressImportResult | Dir }> {\n    for await (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: Blockstore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nexport default DirSharded\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: Blockstore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n", "import { DirFlat } from './dir-flat.js'\nimport DirSharded, { type DirShardedOptions } from './dir-sharded.js'\nimport type { Dir } from './dir.js'\n\nexport async function flatToShard (child: Dir | null, dir: Dir, threshold: number, options: DirShardedOptions): Promise<DirSharded> {\n  let newDir = dir as DirSharded\n\n  if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {\n    newDir = await convertToShard(dir, options)\n  }\n\n  const parent = newDir.parent\n\n  if (parent != null) {\n    if (newDir !== dir) {\n      if (child != null) {\n        child.parent = newDir\n      }\n\n      if (newDir.parentKey == null) {\n        throw new Error('No parent key found')\n      }\n\n      await parent.put(newDir.parentKey, newDir)\n    }\n\n    return flatToShard(newDir, parent, threshold, options)\n  }\n\n  return newDir\n}\n\nasync function convertToShard (oldDir: DirFlat, options: DirShardedOptions): Promise<DirSharded> {\n  const newDir = new DirSharded({\n    root: oldDir.root,\n    dir: true,\n    parent: oldDir.parent,\n    parentKey: oldDir.parentKey,\n    path: oldDir.path,\n    dirty: oldDir.dirty,\n    flat: false,\n    mtime: oldDir.mtime,\n    mode: oldDir.mode\n  }, options)\n\n  for await (const { key, child } of oldDir.eachChildSeries()) {\n    await newDir.put(key, child)\n  }\n\n  return newDir\n}\n", "export const toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return path.split(/(?<!\\\\)\\//).filter(Boolean)\n}\n", "import { DirFlat } from './dir-flat.js'\nimport { Dir } from './dir.js'\nimport { flatToShard } from './flat-to-shard.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport type { ImportResult, InProgressImportResult, TreeBuilder, WritableStorage } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\n\nexport interface AddToTreeOptions extends PersistOptions {\n  shardSplitThresholdBytes: number\n  shardFanoutBits: number\n}\n\nasync function addToTree (elem: InProgressImportResult, tree: Dir, options: AddToTreeOptions): Promise<Dir> {\n  const pathElems = toPathComponents(elem.path ?? '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath !== '' ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = undefined\n    parent.size = undefined\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThresholdBytes, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if ((dir == null) || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir?.unixfs?.mtime,\n          mode: dir?.unixfs?.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\nasync function * flushAndYield (tree: Dir | InProgressImportResult, blockstore: WritableStorage): AsyncGenerator<ImportResult> {\n  if (!(tree instanceof Dir)) {\n    if (tree.unixfs?.isDirectory() === true) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(blockstore)\n}\n\nexport interface TreeBuilderOptions extends AddToTreeOptions {\n  wrapWithDirectory: boolean\n}\n\nexport function defaultTreeBuilder (options: TreeBuilderOptions): TreeBuilder {\n  return async function * treeBuilder (source, block) {\n    let tree: Dir = new DirFlat({\n      root: true,\n      dir: true,\n      path: '',\n      dirty: true,\n      flat: true\n    }, options)\n\n    let rootDir: string | undefined\n    let singleRoot = false\n\n    for await (const entry of source) {\n      if (entry == null) {\n        continue\n      }\n\n      // if all paths are from the same root directory, we should\n      // wrap them all in that root directory\n      const dir = `${entry.originalPath ?? ''}`.split('/')[0]\n\n      if (dir != null && dir !== '') {\n        if (rootDir == null) {\n          rootDir = dir\n          singleRoot = true\n        } else if (rootDir !== dir) {\n          singleRoot = false\n        }\n      }\n\n      tree = await addToTree(entry, tree, options)\n\n      if (entry.unixfs?.isDirectory() !== true) {\n        yield entry\n      }\n    }\n\n    if (options.wrapWithDirectory || (singleRoot && tree.childCount() > 1)) {\n      yield * flushAndYield(tree, block)\n    } else {\n      for await (const unwrapped of tree.eachChildSeries()) {\n        if (unwrapped == null) {\n          continue\n        }\n\n        yield * flushAndYield(unwrapped.child, block)\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * @example\n *\n * Let's create a little directory to import:\n *\n * ```console\n * > cd /tmp\n * > mkdir foo\n * > echo 'hello' > foo/bar\n * > echo 'world' > foo/quux\n * ```\n *\n * And write the importing logic:\n *\n * ```js\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n * import * as fs from 'node:fs'\n *\n * // Where the blocks will be stored\n * const blockstore = new MemoryBlockstore()\n *\n * // Import path /tmp/foo/\n * const source = [{\n *   path: '/tmp/foo/bar',\n *   content: fs.createReadStream('/tmp/foo/bar')\n * }, {\n *   path: '/tmp/foo/quxx',\n *   content: fs.createReadStream('/tmp/foo/quux')\n * }]\n *\n * for await (const entry of importer(source, blockstore)) {\n *   console.info(entry)\n * }\n * ```\n *\n * When run, metadata about DAGNodes in the created tree is printed until the root:\n *\n * ```js\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/bar',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/quxx',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * ```\n */\n\nimport first from 'it-first'\nimport parallelBatch from 'it-parallel-batch'\nimport { fixedSize } from './chunker/fixed-size.js'\nimport { type BufferImportProgressEvents, defaultBufferImporter } from './dag-builder/buffer-importer.js'\nimport { type DAGBuilder, type DagBuilderProgressEvents, defaultDagBuilder } from './dag-builder/index.js'\nimport { type ChunkValidator, defaultChunkValidator } from './dag-builder/validate-chunks.js'\nimport { InvalidParametersError } from './errors.js'\nimport { balanced, type FileLayout } from './layout/index.js'\nimport { defaultTreeBuilder } from './tree-builder.js'\nimport type { Chunker } from './chunker/index.js'\nimport type { ReducerProgressEvents } from './dag-builder/file.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { AwaitIterable } from 'interface-store'\nimport type { UnixFS, Mtime } from 'ipfs-unixfs'\nimport type { CID, Version as CIDVersion } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport * from './errors.js'\n\nexport type ByteStream = AwaitIterable<Uint8Array>\nexport type ImportContent = ByteStream | Uint8Array\n\nexport type WritableStorage = Pick<Blockstore, 'put'>\n\nexport interface FileCandidate<T extends ImportContent = ImportContent> {\n  path?: string\n  content: T\n  mtime?: Mtime\n  mode?: number\n}\n\nexport interface DirectoryCandidate {\n  path: string\n  mtime?: Mtime\n  mode?: number\n}\n\nexport type ImportCandidate = FileCandidate | DirectoryCandidate\n\nexport interface File {\n  content: AsyncIterable<Uint8Array>\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface Directory {\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\nexport interface MultipleBlockImportResult extends ImportResult {\n  originalPath?: string\n}\n\nexport interface SingleBlockImportResult extends ImportResult {\n  single: true\n  originalPath?: string\n  block: Uint8Array\n}\n\nexport type InProgressImportResult = SingleBlockImportResult | MultipleBlockImportResult\n\nexport interface BufferImporterResult extends ImportResult {\n  block: Uint8Array\n}\n\nexport interface HamtHashFn { (value: Uint8Array): Promise<Uint8Array> }\nexport interface TreeBuilder { (source: AsyncIterable<InProgressImportResult>, blockstore: WritableStorage): AsyncIterable<ImportResult> }\nexport interface BufferImporter { (file: File, blockstore: WritableStorage): AsyncIterable<() => Promise<BufferImporterResult>> }\n\nexport type ImporterProgressEvents =\n  BufferImportProgressEvents |\n  DagBuilderProgressEvents |\n  ReducerProgressEvents\n\n/**\n * Options to control the importer's behaviour\n */\nexport interface ImporterOptions extends ProgressOptions<ImporterProgressEvents> {\n  /**\n   * When a file would span multiple DAGNodes, if this is true the leaf nodes\n   * will not be wrapped in `UnixFS` protobufs and will instead contain the\n   * raw file bytes. Default: true\n   */\n  rawLeaves?: boolean\n\n  /**\n   * If the file being imported is small enough to fit into one DAGNodes, store\n   * the file data in the root node along with the UnixFS metadata instead of\n   * in a leaf node which would then require additional I/O to load. Default: true\n   */\n  reduceSingleLeafToSelf?: boolean\n\n  /**\n   * What type of UnixFS node leaves should be - can be `'file'` or `'raw'`\n   * (ignored when `rawLeaves` is `true`).\n   *\n   * This option exists to simulate kubo's trickle dag which uses a combination\n   * of `'raw'` UnixFS leaves and `reduceSingleLeafToSelf: false`.\n   *\n   * For modern code the `rawLeaves: true` option should be used instead so leaves\n   * are plain Uint8Arrays without a UnixFS/Protobuf wrapper.\n   */\n  leafType?: 'file' | 'raw'\n\n  /**\n   * the CID version to use when storing the data. Default: 1\n   */\n  cidVersion?: CIDVersion\n\n  /**\n   * If the serialized node is larger than this it might be converted to a HAMT\n   * sharded directory. Default: 256KiB\n   */\n  shardSplitThresholdBytes?: number\n\n  /**\n   * The number of bits of a hash digest used at each level of sharding to\n   * the child index. 2**shardFanoutBits will dictate the maximum number of\n   * children for any shard in the HAMT. Default: 8\n   */\n  shardFanoutBits?: number\n\n  /**\n   * How many files to import concurrently. For large numbers of small files this\n   * should be high (e.g. 50). Default: 10\n   */\n  fileImportConcurrency?: number\n\n  /**\n   * How many blocks to hash and write to the block store concurrently. For small\n   * numbers of large files this should be high (e.g. 50). Default: 50\n   */\n  blockWriteConcurrency?: number\n\n  /**\n   * If true, all imported files and folders will be contained in a directory that\n   * will correspond to the CID of the final entry yielded. Default: false\n   */\n  wrapWithDirectory?: boolean\n\n  /**\n   * The chunking strategy. See [./src/chunker/index.ts](./src/chunker/index.ts)\n   * for available chunkers. Default: fixedSize\n   */\n  chunker?: Chunker\n\n  /**\n   * How the DAG that represents files are created. See\n   * [./src/layout/index.ts](./src/layout/index.ts) for available layouts. Default: balanced\n   */\n  layout?: FileLayout\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ path, content }` entries from `source` and turn them\n   * into DAGs\n   * It should yield a `function` that returns a `Promise` that resolves to\n   * `{ cid, path, unixfs, node }` where `cid` is a `CID`, `path` is a string, `unixfs`\n   * is a UnixFS entry and `node` is a `DAGNode`.\n   * Values will be pulled from this generator in parallel - the amount of parallelisation\n   * is controlled by the `fileImportConcurrency` option (default: 50)\n   */\n  dagBuilder?: DAGBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ cid, path, unixfs, node }` entries from `source` and\n   * place them in a directory structure\n   * It should yield an object with the properties `{ cid, path, unixfs, size }` where\n   * `cid` is a `CID`, `path` is a string, `unixfs` is a UnixFS entry and `size` is a `Number`.\n   */\n  treeBuilder?: TreeBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `Buffer`s from `source` and persist them using `blockstore.put`\n   * or similar\n   * `entry` is the `{ path, content }` entry, where `entry.content` is an async\n   * generator that yields Buffers\n   * It should yield functions that return a Promise that resolves to an object with\n   * the properties `{ cid, unixfs, size }` where `cid` is a [CID], `unixfs` is a [UnixFS] entry and `size` is a `Number` that represents the serialized size of the [IPLD] node that holds the buffer data.\n   * Values will be pulled from this generator in parallel - the amount of\n   * parallelisation is controlled by the `blockWriteConcurrency` option (default: 10)\n   */\n  bufferImporter?: BufferImporter\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function takes input from the `content` field of imported entries.\n   * It should transform them into `Buffer`s, throwing an error if it cannot.\n   * It should yield `Buffer` objects constructed from the `source` or throw an\n   * `Error`\n   */\n  chunkValidator?: ChunkValidator\n}\n\nexport type ImportCandidateStream = AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n/**\n * The importer creates UnixFS DAGs and stores the blocks that make\n * them up in the passed blockstore.\n *\n * @example\n *\n * ```typescript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [{\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }, {\n *   path: './bar.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }]\n *\n * for await (const entry of importer(input, blockstore)) {\n *   console.info(entry)\n *   // { cid: CID(), ... }\n * }\n * ```\n */\nexport async function * importer (source: ImportCandidateStream, blockstore: WritableStorage, options: ImporterOptions = {}): AsyncGenerator<ImportResult, void, unknown> {\n  let candidates: AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n  if (Symbol.asyncIterator in source || Symbol.iterator in source) {\n    candidates = source\n  } else {\n    candidates = [source]\n  }\n\n  const wrapWithDirectory = options.wrapWithDirectory ?? false\n  const shardSplitThresholdBytes = options.shardSplitThresholdBytes ?? 262144\n  const shardFanoutBits = options.shardFanoutBits ?? 8\n  const cidVersion = options.cidVersion ?? 1\n  const rawLeaves = options.rawLeaves ?? true\n  const leafType = options.leafType ?? 'file'\n  const fileImportConcurrency = options.fileImportConcurrency ?? 50\n  const blockWriteConcurrency = options.blockWriteConcurrency ?? 10\n  const reduceSingleLeafToSelf = options.reduceSingleLeafToSelf ?? true\n\n  const chunker = options.chunker ?? fixedSize()\n  const chunkValidator = options.chunkValidator ?? defaultChunkValidator()\n  const buildDag: DAGBuilder = options.dagBuilder ?? defaultDagBuilder({\n    chunker,\n    chunkValidator,\n    wrapWithDirectory,\n    layout: options.layout ?? balanced(),\n    bufferImporter: options.bufferImporter ?? defaultBufferImporter({\n      cidVersion,\n      rawLeaves,\n      leafType,\n      onProgress: options.onProgress\n    }),\n    blockWriteConcurrency,\n    reduceSingleLeafToSelf,\n    cidVersion,\n    onProgress: options.onProgress\n  })\n  const buildTree: TreeBuilder = options.treeBuilder ?? defaultTreeBuilder({\n    wrapWithDirectory,\n    shardSplitThresholdBytes,\n    shardFanoutBits,\n    cidVersion,\n    onProgress: options.onProgress\n  })\n\n  for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {\n    yield {\n      cid: entry.cid,\n      path: entry.path,\n      unixfs: entry.unixfs,\n      size: entry.size\n    }\n  }\n}\n\n/**\n * `importFile` is similar to `importer` except it accepts a single\n * `FileCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importFile } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: FileCandidate = {\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }\n *\n * const entry = await importFile(input, blockstore)\n * ```\n */\nexport async function importFile (content: FileCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importDir` is similar to `importer` except it accepts a single\n * `DirectoryCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importDirectory } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: DirectoryCandidate = {\n *   path: './foo.txt'\n * }\n *\n * const entry = await importDirectory(input, blockstore)\n * ```\n */\nexport async function importDirectory (content: DirectoryCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importBytes` accepts a single Uint8Array and returns a promise\n * of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importBytes } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = Uint8Array.from([0, 1, 2, 3, 4])\n *\n * const entry = await importBytes(input, blockstore)\n * ```\n */\nexport async function importBytes (buf: ImportContent, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: buf\n  }, blockstore, options)\n}\n\n/**\n * `importByteStream` accepts a single stream of Uint8Arrays and\n * returns a promise of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importByteStream } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ]\n *\n * const entry = await importByteStream(input, blockstore)\n * ```\n */\nexport async function importByteStream (bufs: ByteStream, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: bufs\n  }, blockstore, options)\n}\n", "// @ts-expect-error no types\nimport { create } from 'rabin-wasm'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidAvgChunkSizeError, InvalidChunkSizeError, InvalidMinChunkSizeError } from '../errors.js'\nimport type { Chunker } from './index.js'\n\nconst DEFAULT_MIN_CHUNK_SIZE = 262144\nconst DEFAULT_MAX_CHUNK_SIZE = 262144\nconst DEFAULT_AVG_CHUNK_SIZE = 262144\nconst DEFAULT_WINDOW = 16\n\nasync function * chunker (source: AsyncIterable<Uint8Array>, r: any): AsyncGenerator<Uint8Array> {\n  const buffers = new Uint8ArrayList()\n\n  for await (const chunk of source) {\n    buffers.append(chunk)\n\n    const sizes = r.fingerprint(chunk)\n\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i]\n      const buf = buffers.slice(0, size)\n      buffers.consume(size)\n\n      yield buf\n    }\n  }\n\n  if (buffers.length > 0) {\n    yield buffers.subarray(0)\n  }\n}\n\nexport interface RabinOptions {\n  minChunkSize?: number\n  maxChunkSize?: number\n  avgChunkSize?: number\n  window?: number\n}\n\nexport const rabin = (options: RabinOptions = {}): Chunker => {\n  let min = options.minChunkSize ?? DEFAULT_MIN_CHUNK_SIZE\n  let max = options.maxChunkSize ?? DEFAULT_MAX_CHUNK_SIZE\n  let avg = options.avgChunkSize ?? DEFAULT_AVG_CHUNK_SIZE\n  const window = options.window ?? DEFAULT_WINDOW\n\n  // if only avg was passed, calculate min/max from that\n  if (options.avgChunkSize != null && options.minChunkSize == null && options.maxChunkSize == null) {\n    min = avg / 3\n    max = avg + (avg / 2)\n  }\n\n  const isInvalidChunkSizes = [min, avg, max].some((size) => size == null || isNaN(size))\n\n  if (isInvalidChunkSizes) {\n    if (options.avgChunkSize != null) {\n      throw new InvalidAvgChunkSizeError('please specify a valid average chunk size number')\n    }\n\n    throw new InvalidChunkSizeError('please specify valid numbers for (min|max|avg)ChunkSize')\n  }\n\n  // validate min/max/avg in the same way as go\n  if (min < 16) {\n    throw new InvalidMinChunkSizeError('rabin min must be greater than 16')\n  }\n\n  if (max < min) {\n    max = min\n  }\n\n  if (avg < min) {\n    avg = min\n  }\n\n  const sizepow = Math.floor(Math.log2(avg))\n\n  return async function * rabinChunker (source) {\n    const r = await create(sizepow, min, max, window)\n\n    for await (const chunk of chunker(source, r)) {\n      yield chunk\n    }\n  }\n}\n", "import { type ByteStream, type DirectoryCandidate, type FileCandidate, importBytes, importByteStream, type ImportCandidateStream, importDirectory, importer, type ImporterOptions, importFile, type ImportResult } from 'ipfs-unixfs-importer'\nimport { fixedSize } from 'ipfs-unixfs-importer/chunker'\nimport { balanced } from 'ipfs-unixfs-importer/layout'\nimport type { PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Default importer settings match Filecoin\n */\nconst defaultImporterSettings: ImporterOptions = {\n  cidVersion: 1,\n  rawLeaves: true,\n  layout: balanced({\n    maxChildrenPerNode: 1024\n  }),\n  chunker: fixedSize({\n    chunkSize: 1048576\n  })\n}\n\nexport async function * addAll (source: ImportCandidateStream, blockstore: PutStore, options: Partial<ImporterOptions> = {}): AsyncGenerator<ImportResult, void, unknown> {\n  yield * importer(source, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n}\n\nexport async function addBytes (bytes: Uint8Array, blockstore: PutStore, options: Partial<ImporterOptions> = {}): Promise<CID> {\n  const { cid } = await importBytes(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addByteStream (bytes: ByteStream, blockstore: PutStore, options: Partial<ImporterOptions> = {}): Promise<CID> {\n  const { cid } = await importByteStream(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addFile (file: FileCandidate, blockstore: PutStore, options: Partial<ImporterOptions> = {}): Promise<CID> {\n  const { cid } = await importFile(file, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addDirectory (dir: Partial<DirectoryCandidate>, blockstore: PutStore, options: Partial<ImporterOptions> = {}): Promise<CID> {\n  const { cid } = await importDirectory({\n    ...dir,\n    path: dir.path ?? '-'\n  }, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n", "/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n", "export class BadPathError extends Error {\n  static name = 'BadPathError'\n  static code = 'ERR_BAD_PATH'\n  name = BadPathError.name\n  code = BadPathError.code\n\n  constructor (message = 'Bad path') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not found') {\n    super(message)\n  }\n}\n\nexport class NoResolverError extends Error {\n  static name = 'NoResolverError'\n  static code = 'ERR_NO_RESOLVER'\n  name = NoResolverError.name\n  code = NoResolverError.code\n\n  constructor (message = 'No resolver') {\n    super(message)\n  }\n}\n\nexport class NotUnixFSError extends Error {\n  static name = 'NotUnixFSError'\n  static code = 'ERR_NOT_UNIXFS'\n  name = NotUnixFSError.name\n  code = NotUnixFSError.code\n\n  constructor (message = 'Not UnixFS') {\n    super(message)\n  }\n}\n\nexport class OverReadError extends Error {\n  static name = 'OverReadError'\n  static code = 'ERR_OVER_READ'\n  name = OverReadError.name\n  code = OverReadError.code\n\n  constructor (message = 'Over read') {\n    super(message)\n  }\n}\n\nexport class UnderReadError extends Error {\n  static name = 'UnderReadError'\n  static code = 'ERR_UNDER_READ'\n  name = UnderReadError.name\n  code = UnderReadError.code\n\n  constructor (message = 'Under read') {\n    super(message)\n  }\n}\n\nexport class NoPropError extends Error {\n  static name = 'NoPropError'\n  static code = 'ERR_NO_PROP'\n  name = NoPropError.name\n  code = NoPropError.code\n\n  constructor (message = 'No Property found') {\n    super(message)\n  }\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n", "import { CID } from 'multiformats/cid'\nimport { NoPropError } from '../errors.js'\nimport type { ResolveResult } from '../index.js'\n\nexport function resolveObjectPath (object: any, block: Uint8Array, cid: CID, name: string, path: string, toResolve: string[], depth: number): ResolveResult {\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw new NoPropError(`No property named ${prop} found in node ${cid}`)\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import * as dagJson from '@ipld/dag-json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagJson.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n", "import { InvalidParametersError } from '../errors.js'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw new InvalidParametersError('Offset must be greater than or equal to 0')\n  }\n\n  if (start > fileSize) {\n    throw new InvalidParametersError('Offset must be less than the file size')\n  }\n\n  if (end < 0n) {\n    throw new InvalidParametersError('Length must be greater than or equal to 0')\n  }\n\n  if (end > fileSize) {\n    throw new InvalidParametersError('Length must be less than the file size')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n", "import * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n", "import * as json from 'multiformats/codecs/json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = json.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n", "import { decode, type PBLink, type PBNode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, type BucketPosition, createHAMT } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotUnixFSError } from '../errors.js'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === padLength) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number, padLength: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(padLength, '0')\n    .substring(0, padLength)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    if (node.Data == null) {\n      throw new NotUnixFSError('no data in PBNode')\n    }\n\n    let dir: UnixFS\n    try {\n      dir = UnixFS.unmarshal(node.Data)\n    } catch (err: any) {\n      throw new NotUnixFSError(err.message)\n    }\n\n    if (dir.type !== 'hamt-sharded-directory') {\n      throw new NotUnixFSError('not a HAMT')\n    }\n    if (dir.fanout == null) {\n      throw new NotUnixFSError('missing fanout')\n    }\n\n    const rootBucket = createHAMT<boolean>({\n      hashFn,\n      bits: Math.log2(Number(dir.fanout))\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos, padLength)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent, padLength)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, padLength)\n    const entryName = link.Name.substring(padLength)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(padLength) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n", "import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n      }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { type Pushable, pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError, OverReadError, UnderReadError } from '../../../errors.js'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw new NotUnixFSError('Inconsistent block sizes and dag links')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(new NotUnixFSError(`Unsupported codec: ${link.Hash.code}`))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw new OverReadError('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw new UnderReadError('Traversed entire DAG but did not read enough bytes')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n", "import { decode, type PBNode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError } from '../../../errors.js'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let dir: UnixFS\n  try {\n    dir = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (dir.fanout == null) {\n    throw new NotUnixFSError('missing fanout')\n  }\n\n  const padLength = (dir.fanout - 1n).toString(16).length\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(padLength) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n", "import { decode, type PBNode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotFoundError, NotUnixFSError } from '../../errors.js'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw new NotFoundError('file does not exist')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw new NotFoundError('could not find content exporter')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagJson from '@ipld/dag-json'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as json from 'multiformats/codecs/json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport { NoResolverError } from '../errors.js'\nimport dagCborResolver from './dag-cbor.js'\nimport dagJsonResolver from './dag-json.js'\nimport identifyResolver from './identity.js'\nimport jsonResolver from './json.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [dagJson.code]: dagJsonResolver,\n  [identity.code]: identifyResolver,\n  [json.code]: jsonResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw new NoResolverError(`No resolver for code ${cid.code}`)\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n", "/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```js\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(size)\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += chunk.length\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport { BadPathError, NotFoundError } from './errors.js'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport * from './errors.js'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  /**\n   * An optional offset to start reading at.\n   *\n   * If the CID resolves to a file this will be a byte offset within that file,\n   * otherwise if it's a directory it will be a directory entry offset within\n   * the directory listing. (default: undefined)\n   */\n  offset?: number\n\n  /**\n   * An optional length to read.\n   *\n   * If the CID resolves to a file this will be the number of bytes read from\n   * the file, otherwise if it's a directory it will be the number of directory\n   * entries read from the directory listing. (default: undefined)\n   */\n  length?: number\n\n  /**\n   * This signal can be used to abort any long-lived operations such as fetching\n   * blocks from the network. (default: undefined)\n   */\n  signal?: AbortSignal\n\n  /**\n   * When a DAG layer is encountered, all child nodes are loaded in parallel but\n   * processed as they arrive. This allows us to load sibling nodes in advance\n   * of yielding their bytes. Pass a value here to control the number of blocks\n   * loaded in parallel. If a strict depth-first traversal is required, this\n   * value should be set to `1`, otherwise the traversal order will tend to\n   * resemble a breadth-first fan-out and yield a have stable ordering.\n   * (default: undefined)\n   */\n  blockReadConcurrency?: number\n}\n\nexport interface Exportable<T> {\n  /**\n   * A disambiguator to allow TypeScript to work out the type of the entry.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * if (entry.type === 'file') {\n   *   // access UnixFSFile properties safely\n   * }\n   *\n   * if (entry.type === 'directory') {\n   *   // access UnixFSDirectory properties safely\n   * }\n   * ```\n   */\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n\n  /**\n   * The name of the entry\n   */\n  name: string\n\n  /**\n   * The path of the entry within the DAG in which it was encountered\n   */\n  path: string\n\n  /**\n   * The CID of the entry\n   */\n  cid: CID\n\n  /**\n   * How far down the DAG the entry is\n   */\n  depth: number\n\n  /**\n   * The size of the entry\n   */\n  size: bigint\n\n  /**\n   * @example File content\n   *\n   * When `entry` is a file or a `raw` node, `offset` and/or `length` arguments can be passed to `entry.content()` to return slices of data:\n   *\n   * ```javascript\n   * const length = 5\n   * const data = new Uint8Array(length)\n   * let offset = 0\n   *\n   * for await (const chunk of entry.content({\n   *   offset: 0,\n   *   length\n   * })) {\n   *   data.set(chunk, offset)\n   *   offset += chunk.length\n   * }\n   *\n   * // `data` contains the first 5 bytes of the file\n   * return data\n   * ```\n   *\n   * @example Directory content\n   *\n   * If `entry` is a directory, passing `offset` and/or `length` to `entry.content()` will limit the number of files returned from the directory.\n   *\n   * ```javascript\n   * const entries = []\n   *\n   * for await (const entry of dir.content({\n   *   offset: 0,\n   *   length: 5\n   * })) {\n   *   entries.push(entry)\n   * }\n   *\n   * // `entries` contains the first 5 files/directories in the directory\n   * ```\n   */\n  content(options?: ExporterOptions): AsyncGenerator<T, void, unknown>\n}\n\n/**\n * If the entry is a file, `entry.content()` returns an async iterator that yields one or more Uint8Arrays containing the file content:\n *\n * ```javascript\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Buffer\n *   }\n * }\n * ```\n */\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * If the entry is a directory, `entry.content()` returns further `entry` objects:\n *\n * ```javascript\n * if (entry.type === 'directory') {\n *   for await (const entry of dir.content()) {\n *     console.info(entry.name)\n *   }\n * }\n * ```\n */\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * Entries with a `dag-cbor` or `dag-json` codec {@link CID} return JavaScript object entries\n */\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `raw` codec {@link CID} return raw entries.\n *\n * `entry.content()` returns an async iterator that yields a buffer containing the node content:\n *\n * ```javascript\n * for await (const chunk of entry.content()) {\n *   // chunk is a Buffer\n * }\n * ```\n *\n * Unless you an options object containing `offset` and `length` keys as an argument to `entry.content()`, `chunk` will be equal to `entry.node`.\n */\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `identity` codec {@link CID} return identity entries.\n *\n * These are entries where the data payload is stored in the CID itself,\n * otherwise they are identical to {@link RawNode}s.\n */\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\n/**\n * A UnixFSEntry is a representation of the types of node that can be\n * encountered in a DAG.\n */\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\n/**\n * A subset of the {@link Blockstore} interface that just contains the get\n * method.\n */\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw new BadPathError(`Unknown path type ${path}`)\n}\n\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```javascript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw new NotFoundError(`Could not resolve ${path}`)\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw new NotFoundError(`Could not resolve ${path}`)\n  }\n\n  return result\n}\n\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n", "export abstract class UnixFSError extends Error {\n  public readonly name: string\n  public readonly code: string\n\n  constructor (message: string, name: string, code: string) {\n    super(message)\n\n    this.name = name\n    this.code = code\n  }\n}\n\nexport class NotUnixFSError extends UnixFSError {\n  constructor (message = 'not a Unixfs node') {\n    super(message, 'NotUnixFSError', 'ERR_NOT_UNIXFS')\n  }\n}\n\nexport class InvalidPBNodeError extends UnixFSError {\n  constructor (message = 'invalid PBNode') {\n    super(message, 'InvalidPBNodeError', 'ERR_INVALID_PBNODE')\n  }\n}\n\nexport class UnknownError extends UnixFSError {\n  constructor (message = 'unknown error') {\n    super(message, 'InvalidPBNodeError', 'ERR_UNKNOWN_ERROR')\n  }\n}\n\nexport class AlreadyExistsError extends UnixFSError {\n  constructor (message = 'path already exists') {\n    super(message, 'AlreadyExistsError', 'ERR_ALREADY_EXISTS')\n  }\n}\n\nexport class DoesNotExistError extends UnixFSError {\n  constructor (message = 'path does not exist') {\n    super(message, 'DoesNotExistError', 'ERR_DOES_NOT_EXIST')\n  }\n}\n\nexport class NoContentError extends UnixFSError {\n  constructor (message = 'no content') {\n    super(message, 'NoContentError', 'ERR_NO_CONTENT')\n  }\n}\n\nexport class NotAFileError extends UnixFSError {\n  constructor (message = 'not a file') {\n    super(message, 'NotAFileError', 'ERR_NOT_A_FILE')\n  }\n}\n\nexport class NotADirectoryError extends UnixFSError {\n  constructor (message = 'not a directory') {\n    super(message, 'NotADirectoryError', 'ERR_NOT_A_DIRECTORY')\n  }\n}\n\nexport class InvalidParametersError extends UnixFSError {\n  constructor (message = 'invalid parameters') {\n    super(message, 'InvalidParametersError', 'ERR_INVALID_PARAMETERS')\n  }\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID, type Version } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AlreadyExistsError, InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport { wrapHash } from './consumable-hash.js'\nimport { hamtBucketBits, hamtHashFn } from './hamt-constants.js'\nimport {\n  createShard,\n  recreateShardedDirectory,\n  toPrefix,\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb/interface'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\n\nconst log = logger('helia:unixfs:components:utils:add-link')\n\nexport interface AddLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport interface AddLinkOptions extends AbortOptions {\n  allowOverwriting: boolean\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport async function addLink (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to addLink')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log('adding link to sharded directory')\n\n    return addToShardedDirectory(parent, child, blockstore, options)\n  }\n\n  log(`adding ${child.Name} (${child.Hash}) to regular directory`)\n\n  const result = await addToDirectory(parent, child, blockstore, options)\n\n  if (await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options)) {\n    log('converting directory to sharded directory')\n\n    const converted = await convertToShardedDirectory(result, blockstore)\n    result.cid = converted.cid\n    result.node = dagPB.decode(await blockstore.get(converted.cid, options))\n  }\n\n  return result\n}\n\nconst convertToShardedDirectory = async (parent: Directory, blockstore: PutStore): Promise<ImportResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToShardedDirectory')\n  }\n\n  const unixfs = UnixFS.unmarshal(parent.node.Data)\n\n  const result = await createShard(blockstore, parent.node.Links.map(link => ({\n    name: (link.Name ?? ''),\n    size: BigInt(link.Tsize ?? 0),\n    cid: link.Hash\n  })), {\n    mode: unixfs.mode,\n    mtime: unixfs.mtime,\n    cidVersion: parent.cid.version\n  })\n\n  log(`converted directory to sharded directory ${result.cid}`)\n\n  return result\n}\n\nconst addToDirectory = async (parent: Directory, child: PBLink, blockstore: PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  // Remove existing link if it exists\n  const parentLinks = parent.node.Links.filter((link) => {\n    const matches = link.Name === child.Name\n\n    if (matches && !options.allowOverwriting) {\n      throw new AlreadyExistsError()\n    }\n\n    return !matches\n  })\n  parentLinks.push(child)\n\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node with no data passed to addToDirectory')\n  }\n\n  const node = UnixFS.unmarshal(parent.node.Data)\n\n  let data\n  if (node.mtime != null) {\n    // Update mtime if previously set\n    const ms = Date.now()\n    const secs = Math.floor(ms / 1000)\n\n    node.mtime = {\n      secs: BigInt(secs),\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n\n    data = node.marshal()\n  } else {\n    data = parent.node.Data\n  }\n  parent.node = dagPB.prepare({\n    Data: data,\n    Links: parentLinks\n  })\n\n  // Persist the new parent PbNode\n  const buf = dagPB.encode(parent.node)\n  const hash = await sha256.digest(buf)\n  const cid = CID.create(parent.cid.version, dagPB.code, hash)\n\n  await blockstore.put(cid, buf)\n\n  return {\n    node: parent.node,\n    cid\n  }\n}\n\nconst addToShardedDirectory = async (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  const { path, hash } = await recreateShardedDirectory(parent.cid, child.Name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  // find the next prefix\n  // const index = await hash.take(hamtBucketBits)\n  const prefix = finalSegment.prefix\n  const index = parseInt(prefix, 16)\n\n  log('next prefix for %s is %s', child.Name, prefix)\n\n  const linkName = `${prefix}${child.Name}`\n  const existingLink = finalSegment.node.Links.find(l => (l.Name ?? '').startsWith(prefix))\n\n  if (existingLink != null) {\n    log('link %s was present in shard', linkName)\n    // link is already present in shard\n\n    if (existingLink.Name === linkName) {\n      // file with same name is already present in shard\n      if (!options.allowOverwriting) {\n        throw new AlreadyExistsError()\n      }\n\n      log('overwriting %s in subshard', child.Name)\n      finalSegment.node.Links = finalSegment.node.Links.filter(l => l.Name !== linkName)\n      finalSegment.node.Links.push({\n        Name: linkName,\n        Hash: child.Hash,\n        Tsize: child.Tsize\n      })\n    } else if (existingLink.Name?.length === 2) {\n      throw new Error('Existing link was subshard?!')\n    } else {\n      // conflict, add a new HAMT segment\n      log('prefix %s already exists, creating new subshard', prefix)\n      // find the sibling we are going to replace\n      const index = finalSegment.node.Links.findIndex(l => l.Name?.startsWith(prefix))\n      const sibling = finalSegment.node.Links.splice(index, 1)[0]\n\n      // give the sibling a new HAMT prefix\n      const siblingName = (sibling.Name ?? '').substring(2)\n      const wrapped = wrapHash(hamtHashFn)\n      const siblingHash = wrapped(uint8ArrayFromString(siblingName))\n\n      // discard hash bits until we reach the subshard depth\n      for (let i = 0; i < path.length; i++) {\n        await siblingHash.take(hamtBucketBits)\n      }\n\n      while (true) {\n        const siblingIndex = await siblingHash.take(hamtBucketBits)\n        const siblingPrefix = toPrefix(siblingIndex)\n        sibling.Name = `${siblingPrefix}${siblingName}`\n\n        // calculate the target file's HAMT prefix in the new sub-shard\n        const newIndex = await hash.take(hamtBucketBits)\n        const newPrefix = toPrefix(newIndex)\n\n        if (siblingPrefix === newPrefix) {\n          // the two sibling names have caused another conflict - add an intermediate node to\n          // the HAMT and try again\n\n          // create the child locations\n          const children = new SparseArray()\n          children.set(newIndex, true)\n\n          path.push({\n            prefix: newPrefix,\n            children,\n            node: {\n              Links: []\n            }\n          })\n\n          continue\n        }\n\n        // create the child locations\n        const children = new SparseArray()\n        children.set(newIndex, true)\n        children.set(siblingIndex, true)\n\n        // add our new segment\n        path.push({\n          prefix,\n          children,\n          node: {\n            Links: [\n              sibling, {\n                Name: `${newPrefix}${child.Name}`,\n                Hash: child.Hash,\n                Tsize: child.Tsize\n              }\n            ]\n          }\n        })\n\n        break\n      }\n    }\n  } else {\n    log('link %s was not present in sub-shard', linkName)\n\n    // add new link to shard\n    child.Name = linkName\n    finalSegment.node.Links.push(child)\n    finalSegment.children.set(index, true)\n\n    log('adding %s to existing sub-shard', linkName)\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { murmur3128 } from '@multiformats/murmur3'\n\nexport const hamtHashCode = BigInt(murmur3128.code)\nexport const hamtBucketBits = 8\n\nexport async function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .subarray(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport last from 'it-last'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type InfiniteHash, wrapHash } from './consumable-hash.js'\nimport { DirSharded } from './dir-sharded.js'\nimport {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} from './hamt-constants.js'\nimport { persist } from './persist.js'\nimport type { PersistOptions } from './persist.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime } from 'ipfs-unixfs'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:commands:utils:hamt-utils')\n\nexport interface UpdateHamtDirectoryOptions extends AbortOptions {\n  cidVersion: Version\n}\n\nexport const toPrefix = (position: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nexport interface CreateShardOptions {\n  mtime?: Mtime\n  mode?: number\n  cidVersion: Version\n}\n\nexport const createShard = async (blockstore: PutStore, contents: Array<{ name: string, size: bigint, cid: CID }>, options: CreateShardOptions): Promise<ImportResult> => {\n  const shard = new DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options)\n\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    })\n  }\n\n  const res = await last(shard.flush(blockstore))\n\n  if (res == null) {\n    throw new Error('Flushing shard yielded no result')\n  }\n\n  return res\n}\n\nexport interface HAMTPath {\n  prefix: string\n  children: SparseArray\n  node: dagPB.PBNode\n}\n\nexport const updateShardedDirectory = async (path: HAMTPath[], blockstore: GetStore & PutStore, options: PersistOptions): Promise<{ cid: CID, node: dagPB.PBNode }> => {\n  // persist any metadata on the shard root\n  const shardRoot = UnixFS.unmarshal(path[0].node.Data ?? new Uint8Array(0))\n\n  // this is always the same\n  const fanout = BigInt(Math.pow(2, hamtBucketBits))\n\n  // start from the leaf and ascend to the root\n  path.reverse()\n\n  let cid: CID | undefined\n  let node: dagPB.PBNode | undefined\n\n  for (let i = 0; i < path.length; i++) {\n    const isRoot = i === path.length - 1\n    const segment = path[i]\n\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(segment.children.bitField().reverse())\n    const dir = new UnixFS({\n      type: 'hamt-sharded-directory',\n      data,\n      fanout,\n      hashType: hamtHashCode\n    })\n\n    if (isRoot) {\n      dir.mtime = shardRoot.mtime\n      dir.mode = shardRoot.mode\n    }\n\n    node = {\n      Data: dir.marshal(),\n      Links: segment.node.Links\n    }\n\n    const block = dagPB.encode(dagPB.prepare(node))\n\n    cid = await persist(block, blockstore, options)\n\n    if (!isRoot) {\n      // update link in parent sub-shard\n      const nextSegment = path[i + 1]\n\n      if (nextSegment == null) {\n        throw new Error('Was not operating on shard root but also had no parent?')\n      }\n\n      log('updating link in parent sub-shard with prefix %s', nextSegment.prefix)\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => l.Name !== nextSegment.prefix)\n      nextSegment.node.Links.push({\n        Name: nextSegment.prefix,\n        Hash: cid,\n        Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)\n      })\n    }\n  }\n\n  if (cid == null || node == null) {\n    throw new Error('Noting persisted')\n  }\n\n  return { cid, node }\n}\n\nexport const recreateShardedDirectory = async (cid: CID, fileName: string, blockstore: Pick<Blockstore, 'get'>, options: AbortOptions): Promise<{ path: HAMTPath[], hash: InfiniteHash }> => {\n  const wrapped = wrapHash(hamtHashFn)\n  const hash = wrapped(uint8ArrayFromString(fileName))\n  const path: HAMTPath[] = []\n\n  // descend the HAMT, loading each layer as we head towards the target child\n  while (true) {\n    const block = await blockstore.get(cid, options)\n    const node = dagPB.decode(block)\n    const children = new SparseArray()\n    const index = await hash.take(hamtBucketBits)\n    const prefix = toPrefix(index)\n\n    path.push({\n      prefix,\n      children,\n      node\n    })\n\n    let childLink: dagPB.PBLink | undefined\n\n    // update sparsearray child layout - the bitfield is used as the data field for the\n    // intermediate DAG node so this is required to generate consistent hashes\n    for (const link of node.Links) {\n      const linkName = link.Name ?? ''\n\n      if (linkName.length < 2) {\n        throw new Error('Invalid HAMT - link name was too short')\n      }\n\n      const position = parseInt(linkName.substring(0, 2), 16)\n      children.set(position, true)\n\n      // we found the child we are looking for\n      if (linkName.startsWith(prefix)) {\n        childLink = link\n      }\n    }\n\n    if (childLink == null) {\n      log('no link found with prefix %s for %s', prefix, fileName)\n      // hash.untake(hamtBucketBits)\n      break\n    }\n\n    const linkName = childLink.Name ?? ''\n\n    if (linkName.length < 2) {\n      throw new Error('Invalid HAMT - link name was too short')\n    }\n\n    if (linkName.length === 2) {\n      // found sub-shard\n      cid = childLink.Hash\n      log('descend into sub-shard with prefix %s', linkName)\n\n      continue\n    }\n\n    break\n  }\n\n  return { path, hash }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { PutStore } from '../../unixfs.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\n\nexport interface PersistOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: PutStore, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, {\n    ...options,\n    signal: options.signal\n  })\n\n  return cid\n}\n", "import { encode, type PBLink, prepare } from '@ipld/dag-pb'\nimport { createHAMT, Bucket, type BucketChild } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID } from 'multiformats/cid'\nimport {\n  hamtHashCode,\n  hamtHashFn\n} from './hamt-constants.js'\nimport { persist, type PersistOptions } from './persist.js'\nimport type { PutStore } from '../../unixfs.js'\nimport type { Mtime } from 'ipfs-unixfs'\n\ninterface InProgressImportResult extends ImportResult {\n  single?: boolean\n  originalPath?: string\n}\n\ninterface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\ninterface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nabstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): AsyncIterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: PutStore): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\nexport class DirSharded extends Dir {\n  public _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: 8\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries (): AsyncGenerator<{ key: string, child: InProgressImportResult | Dir }> {\n    for await (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: PutStore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: PutStore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID_V0, CID_V1 } from './dir-sharded.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Estimate node size only based on DAGLink name and CID byte lengths\n * https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n *\n * If the node is a hamt sharded directory the calculation is based on if it was a regular directory.\n */\nexport async function isOverShardThreshold (node: PBNode, blockstore: GetStore, threshold: number, options: AbortOptions): Promise<boolean> {\n  if (node.Data == null) {\n    throw new Error('DagPB node had no data')\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n  let size: number\n\n  if (unixfs.type === 'directory') {\n    size = estimateNodeSize(node)\n  } else if (unixfs.type === 'hamt-sharded-directory') {\n    size = await estimateShardSize(node, 0, threshold, blockstore, options)\n  } else {\n    throw new Error('Can only estimate the size of directories or shards')\n  }\n\n  return size > threshold\n}\n\nfunction estimateNodeSize (node: PBNode): number {\n  let size = 0\n\n  // estimate size only based on DAGLink name and CID byte lengths\n  // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n  for (const link of node.Links) {\n    size += (link.Name ?? '').length\n    size += link.Hash.version === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength\n  }\n\n  return size\n}\n\nasync function estimateShardSize (node: PBNode, current: number, max: number, blockstore: GetStore, options: AbortOptions): Promise<number> {\n  if (current > max) {\n    return max\n  }\n\n  if (node.Data == null) {\n    return current\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n\n  if (!unixfs.isDirectory()) {\n    return current\n  }\n\n  for (const link of node.Links) {\n    let name = link.Name ?? ''\n\n    // remove hamt hash prefix from name\n    name = name.substring(2)\n\n    current += name.length\n    current += link.Hash.bytes.byteLength\n\n    if (link.Hash.code === dagPb.code) {\n      const block = await blockstore.get(link.Hash, options)\n      const node = dagPb.decode(block)\n\n      current += await estimateShardSize(node, current, max, blockstore, options)\n    }\n  }\n\n  return current\n}\n", "import { exporter, type ExporterOptions } from 'ipfs-unixfs-exporter'\nimport { NotADirectoryError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { CID } from 'multiformats/cid'\n\nexport interface Directory {\n  cid: CID\n  node: PBNode\n}\n\nexport async function cidToDirectory (cid: CID, blockstore: GetStore, options: ExporterOptions = {}): Promise<Directory> {\n  const entry = await exporter(cid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${cid.toString()} was not a UnixFS directory`)\n  }\n\n  return {\n    cid,\n    node: entry.node\n  }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { exporter, type ExporterOptions } from 'ipfs-unixfs-exporter'\nimport { NotUnixFSError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\nimport type { CID } from 'multiformats/cid'\n\nexport async function cidToPBLink (cid: CID, name: string, blockstore: GetStore, options?: ExporterOptions): Promise<Required<PBLink>> {\n  const sourceEntry = await exporter(cid, blockstore, options)\n\n  if (sourceEntry.type !== 'directory' && sourceEntry.type !== 'file' && sourceEntry.type !== 'raw') {\n    throw new NotUnixFSError(`${cid.toString()} was not a UnixFS node`)\n  }\n\n  return {\n    Name: name,\n    Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),\n    Hash: cid\n  }\n}\n\nfunction dagNodeTsize (node: PBNode): number {\n  const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)\n\n  return dagPb.encode(node).byteLength + linkSizes\n}\n", "import { logger } from '@libp2p/logger'\nimport { walkPath } from 'ipfs-unixfs-exporter'\nimport all from 'it-all'\nimport { DoesNotExistError } from '../../errors.js'\nimport { addLink } from './add-link.js'\nimport { cidToDirectory } from './cid-to-directory.js'\nimport { cidToPBLink } from './cid-to-pblink.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:components:utils:resolve')\n\nexport interface Segment {\n  name: string\n  cid: CID\n  size: bigint\n}\n\nexport interface ResolveResult {\n  /**\n   * The CID at the end of the path\n   */\n  cid: CID\n\n  path?: string\n\n  /**\n   * If present, these are the CIDs and path segments that were traversed through to reach the final CID\n   *\n   * If not present, there was no path passed or the path was an empty string\n   */\n  segments?: Segment[]\n}\n\nexport async function resolve (cid: CID, path: string | undefined, blockstore: GetStore, options: AbortOptions): Promise<ResolveResult> {\n  if (path == null || path === '') {\n    return { cid }\n  }\n\n  const p = `/ipfs/${cid}${path == null ? '' : `/${path}`}`\n  const segments = await all(walkPath(p, blockstore, options))\n\n  if (segments.length === 0) {\n    throw new DoesNotExistError('Could not find path in directory')\n  }\n\n  log('resolved %s to %c', path, cid)\n\n  return {\n    cid: segments[segments.length - 1].cid,\n    path,\n    segments\n  }\n}\n\nexport interface UpdatePathCidsOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n}\n\n/**\n * Where we have descended into a DAG to update a child node, ascend up the DAG creating\n * new hashes and blocks for the changed content\n */\nexport async function updatePathCids (cid: CID, result: ResolveResult, blockstore: PutStore & GetStore, options: UpdatePathCidsOptions): Promise<CID> {\n  if (result.segments == null || result.segments.length === 0) {\n    return cid\n  }\n\n  let child = result.segments.pop()\n\n  if (child == null) {\n    throw new Error('Insufficient segments')\n  }\n\n  child.cid = cid\n\n  result.segments.reverse()\n\n  for (const parent of result.segments) {\n    const [\n      directory,\n      pblink\n    ] = await Promise.all([\n      cidToDirectory(parent.cid, blockstore, options),\n      cidToPBLink(child.cid, child.name, blockstore, options)\n    ])\n\n    const result = await addLink(directory, pblink, blockstore, {\n      ...options,\n      allowOverwriting: true,\n      cidVersion: cid.version\n    })\n\n    cid = result.cid\n    parent.cid = cid\n    child = parent\n  }\n\n  return cid\n}\n", "import { exporter } from 'ipfs-unixfs-exporter'\nimport mergeOpts from 'merge-options'\nimport { NoContentError, NotAFileError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { CatOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: CatOptions = {\n\n}\n\nexport async function * cat (cid: CID, blockstore: GetStore, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n  const opts: CatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type !== 'file' && result.type !== 'raw') {\n    throw new NotAFileError()\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  yield * result.content(opts)\n}\n", "export const SHARD_SPLIT_THRESHOLD_BYTES = 262144\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { ChmodOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:chmod')\n\nconst defaultOptions: ChmodOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function chmod (cid: CID, mode: number, blockstore: PutStore & GetStore, options: Partial<ChmodOptions> = {}): Promise<CID> {\n  const opts: ChmodOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, options)\n\n  log('chmod %c %d', resolved.cid, mode)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore, options)) {\n          let metadata: UnixFS\n          let links: PBLink[] = []\n\n          if (entry.type === 'raw') {\n            // convert to UnixFS\n            metadata = new UnixFS({ type: 'file', data: entry.node })\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mode = mode\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error cannot combine progress types\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    // convert to UnixFS\n    metadata = new UnixFS({ type: 'file', data: block })\n  } else {\n    const node = dagPB.decode(block)\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    links = node.Links\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mode = mode\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { logger } from '@libp2p/logger'\nimport mergeOpts from 'merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { CpOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:cp')\n\nconst defaultOptions: CpOptions = {\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function cp (source: CID, target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<CpOptions> = {}): Promise<CID> {\n  const opts: CpOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(target, blockstore, opts),\n    cidToPBLink(source, name, blockstore, opts)\n  ])\n\n  log('Adding %c as \"%s\" to %c', source, name, target)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    allowOverwriting: opts.force,\n    cidVersion: target.version,\n    ...opts\n  })\n\n  return result.cid\n}\n", "import { exporter, type UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport mergeOpts from 'merge-options'\nimport { NoContentError, NotADirectoryError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { LsOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: LsOptions = {\n\n}\n\nexport async function * ls (cid: CID, blockstore: GetStore, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n  const opts: LsOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore)\n\n  if (result.type === 'file' || result.type === 'raw') {\n    yield result\n    return\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  if (result.type !== 'directory') {\n    throw new NotADirectoryError()\n  }\n\n  yield * result.content({\n    offset: options.offset,\n    length: options.length\n  })\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidParametersError, NotADirectoryError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { MkdirOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:mkdir')\n\nconst defaultOptions: MkdirOptions = {\n  cidVersion: 1,\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function mkdir (parentCid: CID, dirname: string, blockstore: GetStore & PutStore, options: Partial<MkdirOptions> = {}): Promise<CID> {\n  const opts: MkdirOptions = mergeOptions(defaultOptions, options)\n\n  if (dirname.includes('/')) {\n    throw new InvalidParametersError('Path must not have slashes')\n  }\n\n  const entry = await exporter(parentCid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`)\n  }\n\n  log('creating %s', dirname)\n\n  const metadata = new UnixFS({\n    type: 'directory',\n    mode: opts.mode,\n    mtime: opts.mtime\n  })\n\n  // Persist the new parent PBNode\n  const node = {\n    Data: metadata.marshal(),\n    Links: []\n  }\n  const buf = dagPB.encode(node)\n  const hash = await sha256.digest(buf)\n  const emptyDirCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n  await blockstore.put(emptyDirCid, buf)\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(parentCid, blockstore, opts),\n    cidToPBLink(emptyDirCid, dirname, blockstore, opts)\n  ])\n\n  log('adding empty dir called %s to %c', dirname, parentCid)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    ...opts,\n    allowOverwriting: opts.force\n  })\n\n  return result.cid\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport {\n  recreateShardedDirectory,\n  type UpdateHamtDirectoryOptions,\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport { persist } from './persist.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:utils:remove-link')\n\nexport interface RmLinkOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport interface RemoveLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport async function removeLink (parent: Directory, name: string, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node had no data')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`removing ${name} from sharded directory`)\n\n    const result = await removeFromShardedDirectory(parent, name, blockstore, options)\n\n    if (!(await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options))) {\n      log('converting shard to flat directory %c', parent.cid)\n\n      return convertToFlatDirectory(result, blockstore, options)\n    }\n\n    return result\n  }\n\n  log(`removing link ${name} regular directory`)\n\n  return removeFromDirectory(parent, name, blockstore, options)\n}\n\nconst removeFromDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: AbortOptions): Promise<RemoveLinkResult> => {\n  // Remove existing link if it exists\n  parent.node.Links = parent.node.Links.filter((link) => {\n    return link.Name !== name\n  })\n\n  const parentBlock = dagPB.encode(parent.node)\n  const parentCid = await persist(parentBlock, blockstore, {\n    ...options,\n    cidVersion: parent.cid.version\n  })\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: parent.node,\n    cid: parentCid\n  }\n}\n\nconst removeFromShardedDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: UpdateHamtDirectoryOptions): Promise<{ cid: CID, node: PBNode }> => {\n  const { path } = await recreateShardedDirectory(parent.cid, name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  const linkName = finalSegment.node.Links.filter(l => (l.Name ?? '').substring(2) === name).map(l => l.Name).pop()\n\n  if (linkName == null) {\n    throw new Error('File not found')\n  }\n\n  const prefix = linkName.substring(0, 2)\n  const index = parseInt(prefix, 16)\n\n  // remove the file from the shard\n  finalSegment.node.Links = finalSegment.node.Links.filter(link => link.Name !== linkName)\n  finalSegment.children.unset(index)\n\n  if (finalSegment.node.Links.length === 1) {\n    // replace the subshard with the last remaining file in the parent\n    while (true) {\n      if (path.length === 1) {\n        break\n      }\n\n      const segment = path[path.length - 1]\n\n      if (segment == null || segment.node.Links.length > 1) {\n        break\n      }\n\n      // remove final segment\n      path.pop()\n\n      const nextSegment = path[path.length - 1]\n\n      if (nextSegment == null) {\n        break\n      }\n\n      const link = segment.node.Links[0]\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => !(l.Name ?? '').startsWith(nextSegment.prefix))\n      nextSegment.node.Links.push({\n        Hash: link.Hash,\n        Name: `${nextSegment.prefix}${(link.Name ?? '').substring(2)}`,\n        Tsize: link.Tsize\n      })\n    }\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n\nconst convertToFlatDirectory = async (parent: Directory, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToFlatDirectory')\n  }\n\n  const rootNode: PBNode = {\n    Links: []\n  }\n  const dir = await exporter(parent.cid, blockstore)\n\n  if (dir.type !== 'directory') {\n    throw new Error('Unexpected node type')\n  }\n\n  for await (const entry of dir.content()) {\n    let tsize = 0\n\n    if (entry.node instanceof Uint8Array) {\n      tsize = entry.node.byteLength\n    } else {\n      tsize = dagPB.encode(entry.node).length\n    }\n\n    rootNode.Links.push({\n      Hash: entry.cid,\n      Name: entry.name,\n      Tsize: tsize\n    })\n  }\n\n  // copy mode/mtime over if set\n  const oldUnixfs = UnixFS.unmarshal(parent.node.Data)\n  rootNode.Data = new UnixFS({ type: 'directory', mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal()\n  const block = dagPB.encode(dagPB.prepare(rootNode))\n\n  const cid = await persist(block, blockstore, {\n    codec: dagPB,\n    cidVersion: parent.cid.version,\n    signal: options.signal\n  })\n\n  return {\n    cid,\n    node: rootNode\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport mergeOpts from 'merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { removeLink } from './utils/remove-link.js'\nimport type { RmOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:rm')\n\nconst defaultOptions: RmOptions = {\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function rm (target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<RmOptions> = {}): Promise<CID> {\n  const opts: RmOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const directory = await cidToDirectory(target, blockstore, opts)\n\n  log('Removing %s from %c', name, target)\n\n  const result = await removeLink(directory, name, blockstore, {\n    ...opts,\n    cidVersion: target.version\n  })\n\n  return result.cid\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport mergeOpts from 'merge-options'\nimport * as raw from 'multiformats/codecs/raw'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { StatOptions, UnixFSStats } from '../index.js'\nimport type { GetStore, HasStore } from '../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Mtime } from 'ipfs-unixfs'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:stat')\n\nconst defaultOptions: StatOptions = {\n\n}\n\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options: Partial<StatOptions> = {}): Promise<UnixFSStats> {\n  const opts: StatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, options.path, blockstore, opts)\n\n  log('stat %c', resolved.cid)\n\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type !== 'file' && result.type !== 'directory' && result.type !== 'raw') {\n    throw new NotUnixFSError()\n  }\n\n  let fileSize: bigint = 0n\n  let dagSize: bigint = 0n\n  let localFileSize: bigint = 0n\n  let localDagSize: bigint = 0n\n  let blocks: number = 0\n  let mode: number | undefined\n  let mtime: Mtime | undefined\n  const type = result.type\n  let unixfs: UnixFS | undefined\n\n  if (result.type === 'raw') {\n    fileSize = BigInt(result.node.byteLength)\n    dagSize = BigInt(result.node.byteLength)\n    localFileSize = BigInt(result.node.byteLength)\n    localDagSize = BigInt(result.node.byteLength)\n    blocks = 1\n  }\n\n  if (result.type === 'directory') {\n    fileSize = 0n\n    dagSize = BigInt(result.unixfs.marshal().byteLength)\n    localFileSize = 0n\n    localDagSize = dagSize\n    blocks = 1\n    mode = result.unixfs.mode\n    mtime = result.unixfs.mtime\n    unixfs = result.unixfs\n  }\n\n  if (result.type === 'file') {\n    const results = await inspectDag(resolved.cid, blockstore, opts)\n\n    fileSize = result.unixfs.fileSize()\n    dagSize = BigInt((result.node.Data?.byteLength ?? 0) + result.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0))\n    localFileSize = BigInt(results.localFileSize)\n    localDagSize = BigInt(results.localDagSize)\n    blocks = results.blocks\n    mode = result.unixfs.mode\n    mtime = result.unixfs.mtime\n    unixfs = result.unixfs\n  }\n\n  return {\n    cid: resolved.cid,\n    mode,\n    mtime,\n    fileSize,\n    dagSize,\n    localFileSize,\n    localDagSize,\n    blocks,\n    type,\n    unixfs\n  }\n}\n\ninterface InspectDagResults {\n  localFileSize: number\n  localDagSize: number\n  blocks: number\n}\n\nasync function inspectDag (cid: CID, blockstore: GetStore & HasStore, options: AbortOptions): Promise<InspectDagResults> {\n  const results = {\n    localFileSize: 0,\n    localDagSize: 0,\n    blocks: 0\n  }\n\n  if (await blockstore.has(cid, options)) {\n    const block = await blockstore.get(cid, options)\n    results.blocks++\n    results.localDagSize += block.byteLength\n\n    if (cid.code === raw.code) {\n      results.localFileSize += block.byteLength\n    } else if (cid.code === dagPb.code) {\n      const pbNode = dagPb.decode(block)\n\n      if (pbNode.Links.length > 0) {\n        // intermediate node\n        for (const link of pbNode.Links) {\n          const linkResult = await inspectDag(link.Hash, blockstore, options)\n\n          results.localFileSize += linkResult.localFileSize\n          results.localDagSize += linkResult.localDagSize\n          results.blocks += linkResult.blocks\n        }\n      } else {\n        // leaf node\n        if (pbNode.Data == null) {\n          throw new InvalidPBNodeError(`PBNode ${cid.toString()} had no data`)\n        }\n\n        const unixfs = UnixFS.unmarshal(pbNode.Data)\n\n        if (unixfs.data == null) {\n          throw new InvalidPBNodeError(`UnixFS node ${cid.toString()} had no data`)\n        }\n\n        results.localFileSize += unixfs.data.byteLength ?? 0\n      }\n    } else {\n      throw new UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`)\n    }\n  }\n\n  return results\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport mergeOpts from 'merge-options'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { TouchOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:touch')\n\nconst defaultOptions: TouchOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function touch (cid: CID, blockstore: GetStore & PutStore, options: Partial<TouchOptions> = {}): Promise<CID> {\n  const opts: TouchOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const mtime = opts.mtime ?? {\n    secs: BigInt(Math.round(Date.now() / 1000)),\n    nsecs: 0\n  }\n\n  log('touch %c %o', resolved.cid, mtime)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore)) {\n          let metadata: UnixFS\n          let links: PBLink[]\n\n          if (entry.type === 'raw') {\n            metadata = new UnixFS({ data: entry.node })\n            links = []\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mtime = mtime\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error blockstore types are incompatible\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    metadata = new UnixFS({ data: block })\n  } else {\n    const node = dagPB.decode(block)\n    links = node.Links\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mtime = mtime\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { addAll, addBytes, addByteStream, addDirectory, addFile } from './commands/add.js'\nimport { cat } from './commands/cat.js'\nimport { chmod } from './commands/chmod.js'\nimport { cp } from './commands/cp.js'\nimport { ls } from './commands/ls.js'\nimport { mkdir } from './commands/mkdir.js'\nimport { rm } from './commands/rm.js'\nimport { stat } from './commands/stat.js'\nimport { touch } from './commands/touch.js'\nimport type { AddOptions, CatOptions, ChmodOptions, CpOptions, LsOptions, MkdirOptions, RmOptions, StatOptions, TouchOptions, UnixFSComponents, UnixFS as UnixFSInterface, UnixFSStats } from './index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, FileCandidate, ImportCandidateStream, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID } from 'multiformats/cid'\n\nexport type PutStore = Pick<Blockstore, 'put'>\nexport type GetStore = Pick<Blockstore, 'get'>\nexport type HasStore = Pick<Blockstore, 'has'>\n\nexport class UnixFS implements UnixFSInterface {\n  private readonly components: UnixFSComponents\n\n  constructor (components: UnixFSComponents) {\n    this.components = components\n  }\n\n  async * addAll (source: ImportCandidateStream, options: Partial<AddOptions> = {}): AsyncIterable<ImportResult> {\n    yield * addAll(source, this.components.blockstore, options)\n  }\n\n  async addBytes (bytes: Uint8Array, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addBytes(bytes, this.components.blockstore, options)\n  }\n\n  async addByteStream (bytes: ByteStream, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addByteStream(bytes, this.components.blockstore, options)\n  }\n\n  async addFile (file: FileCandidate, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addFile(file, this.components.blockstore, options)\n  }\n\n  async addDirectory (dir: Partial<DirectoryCandidate> = {}, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addDirectory(dir, this.components.blockstore, options)\n  }\n\n  async * cat (cid: CID, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n    yield * cat(cid, this.components.blockstore, options)\n  }\n\n  async chmod (cid: CID, mode: number, options: Partial<ChmodOptions> = {}): Promise<CID> {\n    return chmod(cid, mode, this.components.blockstore, options)\n  }\n\n  async cp (source: CID, target: CID, name: string, options: Partial<CpOptions> = {}): Promise<CID> {\n    return cp(source, target, name, this.components.blockstore, options)\n  }\n\n  async * ls (cid: CID, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n    yield * ls(cid, this.components.blockstore, options)\n  }\n\n  async mkdir (cid: CID, dirname: string, options: Partial<MkdirOptions> = {}): Promise<CID> {\n    return mkdir(cid, dirname, this.components.blockstore, options)\n  }\n\n  async rm (cid: CID, path: string, options: Partial<RmOptions> = {}): Promise<CID> {\n    return rm(cid, path, this.components.blockstore, options)\n  }\n\n  async stat (cid: CID, options: Partial<StatOptions> = {}): Promise<UnixFSStats> {\n    return stat(cid, this.components.blockstore, options)\n  }\n\n  async touch (cid: CID, options: Partial<TouchOptions> = {}): Promise<CID> {\n    return touch(cid, this.components.blockstore, options)\n  }\n}\n", "// eslint-disable-next-line require-yield\nexport async function * globSource (): AsyncGenerator<any> {\n  throw new Error('Not supported in browsers')\n}\n", "import { UnknownError } from '../errors.js'\nimport type { FileCandidate } from 'ipfs-unixfs-importer'\n\nexport function urlSource (url: URL, options?: RequestInit): FileCandidate<AsyncGenerator<Uint8Array, void, unknown>> {\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n    content: readURLContent(url, options)\n  }\n}\n\nasync function * readURLContent (url: URL, options?: RequestInit): AsyncGenerator<Uint8Array, void, unknown> {\n  const response = await globalThis.fetch(url, options)\n\n  if (response.body == null) {\n    throw new UnknownError('HTTP response did not have a body')\n  }\n\n  const reader = response.body.getReader()\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done) {\n        return\n      }\n\n      if (value != null) {\n        yield value\n      }\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * `@helia/unixfs` is an implementation of a {@link https://github.com/ipfs/specs/blob/main/UNIXFS.md UnixFS filesystem} compatible with {@link https://github.com/ipfs/helia Helia}.\n *\n * See the [API docs](https://ipfs.github.io/helia/modules/_helia_unixfs.html) for all available operations.\n *\n * @example Creating files and directories\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * // create an empty dir and a file, then add the file to the dir\n * const emptyDirCid = await fs.addDirectory()\n * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n * const updateDirCid = await fs.cp(fileCid, emptyDirCid, 'foo.txt')\n *\n * // or doing the same thing as a stream\n * for await (const entry of fs.addAll([{\n *   path: 'foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3])\n * }])) {\n *   console.info(entry)\n * }\n * ```\n *\n * @example Recursively adding a directory\n *\n * Node.js-compatibly environments only:\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n * import { globSource } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * for await (const entry of fs.addAll(globSource('path/to/containing/dir', 'glob-pattern'))) {\n *   console.info(entry)\n * }\n * ```\n */\n\nimport { UnixFS as UnixFSClass } from './unixfs.js'\nimport type { GetBlockProgressEvents, PutBlockProgressEvents } from '@helia/interface/blocks'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime, UnixFS as IPFSUnixFS } from 'ipfs-unixfs'\nimport type { ExporterProgressEvents, UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, FileCandidate, ImportCandidateStream, ImporterOptions, ImporterProgressEvents, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface UnixFSComponents {\n  blockstore: Pick<Blockstore, 'get' | 'put' | 'has'>\n}\n\nexport type AddEvents = PutBlockProgressEvents\n| ImporterProgressEvents\n\nexport interface AddOptions extends AbortOptions, Omit<ImporterOptions, 'onProgress'>, ProgressOptions<AddEvents> {\n\n}\n\nexport type GetEvents = GetBlockProgressEvents\n| ExporterProgressEvents\n\n/**\n * Options to pass to the cat command\n */\nexport interface CatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Start reading the file at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the file after this many bytes\n   */\n  length?: number\n\n  /**\n   * An optional path to allow reading files inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the chmod command\n */\nexport interface ChmodOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If the target of the operation is a directory and this is true,\n   * apply the new mode to all directory contents\n   */\n  recursive: boolean\n\n  /**\n   * Optional path to set the mode on directory contents\n   */\n  path?: string\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the cp command\n */\nexport interface CpOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the ls command\n */\nexport interface LsOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Optional path to list subdirectory contents if the target CID resolves to\n   * a directory\n   */\n  path?: string\n\n  /**\n   * Start reading the directory entries at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the directory contents after this many directory entries\n   */\n  length?: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the mkdir command\n */\nexport interface MkdirOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * The CID version to create the new directory with - defaults to the same\n   * version as the containing directory\n   */\n  cidVersion: Version\n\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * An optional mode to set on the new directory\n   */\n  mode?: number\n\n  /**\n   * An optional mtime to set on the new directory\n   */\n  mtime?: Mtime\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the rm command\n */\nexport interface RmOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the stat command\n */\nexport interface StatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * An optional path to allow statting paths inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Statistics relating to a UnixFS DAG\n */\nexport interface UnixFSStats {\n  /**\n   * The file or directory CID\n   */\n  cid: CID\n\n  /**\n   * The file or directory mode\n   */\n  mode?: number\n\n  /**\n   * The file or directory mtime\n   */\n  mtime?: Mtime\n\n  /**\n   * The size of the file in bytes\n   */\n  fileSize: bigint\n\n  /**\n   * The size of the DAG that holds the file in bytes\n   */\n  dagSize: bigint\n\n  /**\n   * How much of the file is in the local block store\n   */\n  localFileSize: bigint\n\n  /**\n   * How much of the DAG that holds the file is in the local blockstore\n   */\n  localDagSize: bigint\n\n  /**\n   * How many blocks make up the DAG - nb. this will only be accurate\n   * if all blocks are present in the local blockstore\n   */\n  blocks: number\n\n  /**\n   * The type of file\n   */\n  type: 'file' | 'directory' | 'raw'\n\n  /**\n   * UnixFS metadata about this file or directory. Will not be present\n   * if the node is a `raw` type.\n   */\n  unixfs?: IPFSUnixFS\n}\n\n/**\n * Options to pass to the touch command\n */\nexport interface TouchOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * Optional mtime to set on the DAG root, defaults to the current time\n   */\n  mtime?: Mtime\n\n  /**\n   * Optional path to set mtime on directory contents\n   */\n  path?: string\n\n  /**\n   * If the DAG is a directory and this is true, update the mtime on all contents\n   */\n  recursive: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * The UnixFS interface provides familiar filesystem operations to make working with\n * UnixFS DAGs simple and intuitive.\n */\nexport interface UnixFS {\n  /**\n   * Add all files and directories from the passed stream. This method wraps the\n   * `importer` export from the `ipfs-unixfs-importer` module - please see the docs\n   * for input/output types.\n   *\n   * @example\n   *\n   * ```typescript\n   * const source = [{\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3])\n   * }, {\n   *   path: './bar.txt',\n   *   content: Uint8Array.from([4, 5, 6, 7])\n   * }]\n   *\n   * for await (const entry of fs.import(source)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  addAll(source: ImportCandidateStream, options?: Partial<AddOptions>): AsyncIterable<ImportResult>\n\n  /**\n   * Add a single `Uint8Array` to your Helia node as a file.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * console.info(cid)\n   * ```\n   */\n  addBytes(bytes: Uint8Array, options?: Partial<AddOptions>): Promise<CID>\n\n  /**\n   * Add a stream of `Uint8Array` to your Helia node as a file.\n   *\n   * @example\n   *\n   * ```typescript\n   * import fs from 'fs'\n   *\n   * const stream = fs.createReadStream('./foo.txt')\n   * const cid = await fs.addByteStream(stream)\n   *\n   * console.info(cid)\n   * ```\n   */\n  addByteStream(bytes: ByteStream, options?: Partial<AddOptions>): Promise<CID>\n\n  /**\n   * Add a file to your Helia node with optional metadata.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addFile({\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3]),\n   *   mode: 0x755,\n   *   mtime: {\n   *     secs: 10n,\n   *     nsecs: 0\n   *   }\n   * })\n   *\n   * console.info(cid)\n   * ```\n   */\n  addFile(file: FileCandidate, options?: Partial<AddOptions>): Promise<CID>\n\n  /**\n   * Add a directory to your Helia node.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addDirectory()\n   *\n   * console.info(cid)\n   * ```\n   */\n  addDirectory(dir?: Partial<DirectoryCandidate>, options?: Partial<AddOptions>): Promise<CID>\n\n  /**\n   * Retrieve the contents of a file from your Helia node.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const buf of fs.cat(cid)) {\n   *   console.info(buf)\n   * }\n   * ```\n   */\n  cat(cid: CID, options?: Partial<CatOptions>): AsyncIterable<Uint8Array>\n\n  /**\n   * Change the permissions on a file or directory in a DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.chmod(cid, 0x755)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  chmod(cid: CID, mode: number, options?: Partial<ChmodOptions>): Promise<CID>\n\n  /**\n   * Add a file or directory to a target directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.cp(fileCid, directoryCid, 'foo.txt')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  cp(source: CID, target: CID, name: string, options?: Partial<CpOptions>): Promise<CID>\n\n  /**\n   * List directory contents.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const entry of fs.ls(directoryCid)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  ls(cid: CID, options?: Partial<LsOptions>): AsyncIterable<UnixFSEntry>\n\n  /**\n   * Make a new directory under an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  mkdir(cid: CID, dirname: string, options?: Partial<MkdirOptions>): Promise<CID>\n\n  /**\n   * Remove a file or directory from an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * const finalCid = await fs.rm(updatedCid, 'new-dir')\n   *\n   * console.info(finalCid)\n   * ```\n   */\n  rm(cid: CID, path: string, options?: Partial<RmOptions>): Promise<CID>\n\n  /**\n   * Return statistics about a UnixFS DAG.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * const stats = await fs.stat(fileCid)\n   *\n   * console.info(stats)\n   * ```\n   */\n  stat(cid: CID, options?: Partial<StatOptions>): Promise<UnixFSStats>\n\n  /**\n   * Update the mtime of a UnixFS DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.touch(beforeCid)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  touch(cid: CID, options?: Partial<TouchOptions>): Promise<CID>\n}\n\n/**\n * Create a {@link UnixFS} instance for use with {@link https://github.com/ipfs/helia Helia}\n */\nexport function unixfs (helia: { blockstore: Pick<Blockstore, 'get' | 'put' | 'has'> }): UnixFS {\n  return new UnixFSClass(helia)\n}\n\nexport { globSource } from './utils/glob-source.js'\nexport type { GlobSourceResult, GlobSourceOptions } from './utils/glob-source.js'\nexport { urlSource } from './utils/url-source.js'\n"],
  "mappings": "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,GAAE,KAAI,IAAG,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,GAAE,GAAE,GAAE,GAAE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",
  "names": ["last", "exists", "last", "exports", "module", "name", "create", "src_default", "src_default", "message", "Data", "DataType", "__DataTypeValues", "UnixTime", "Metadata", "message", "unixfs", "message", "message", "unixfs", "node", "_a", "_b", "code", "isAsyncIterable", "reduce", "src_default", "unixfs", "mur", "SparseArray", "reduce", "acc", "hashFn", "dir", "size", "last", "isAsyncIterable", "res", "src_default", "message", "_InvalidParametersError", "InvalidParametersError", "resolve", "decode", "resolve", "decode", "InvalidParametersError", "resolve", "resolve", "decode", "rawContent", "resolve", "link", "decode", "unixfs", "resolve", "src_default", "src_default", "code", "decode", "unixfs", "resolve", "unixfs", "resolve", "src_default", "decode", "link", "unixfs", "resolve", "decode", "code", "resolve", "toPathComponents", "src_default", "node", "options", "message", "code", "NotUnixFSError", "InvalidParametersError", "import_sparse_array", "wrapHash", "hashFn", "InfiniteHash", "ConsumableBuffer", "START_MASKS", "STOP_MASKS", "byteBitsToInt", "maskFor", "hamtHashFn", "import_sparse_array", "persist", "Dir", "DirSharded", "hamtHashFn", "calculateSize", "flush", "isDir", "dir", "size", "persist", "CID_V0", "CID_V1", "toPrefix", "DirSharded", "src_default", "persist", "wrapHash", "hamtHashFn", "decode", "SparseArray", "linkName", "unixfs", "CID_V1", "CID_V0", "code", "node", "decode", "log", "InvalidParametersError", "decode", "unixfs", "code", "index", "_a", "wrapHash", "hamtHashFn", "toPrefix", "children", "SparseArray", "NotUnixFSError", "log", "resolve", "src_default", "result", "resolve", "mergeOptions", "log", "defaultOptions", "resolve", "metadata", "links", "NotUnixFSError", "source", "block", "updatedCid", "persist", "unixfs", "src_default", "code", "decode", "mergeOptions", "log", "defaultOptions", "InvalidParametersError", "mergeOptions", "defaultOptions", "resolve", "mergeOptions", "log", "defaultOptions", "InvalidParametersError", "code", "log", "persist", "InvalidParametersError", "mergeOptions", "log", "defaultOptions", "InvalidParametersError", "mergeOptions", "log", "defaultOptions", "resolve", "NotUnixFSError", "unixfs", "code", "decode", "mergeOptions", "log", "defaultOptions", "resolve", "metadata", "links", "NotUnixFSError", "source", "block", "updatedCid", "persist", "unixfs", "src_default", "code", "decode", "UnixFS", "UnixFS"]
}
