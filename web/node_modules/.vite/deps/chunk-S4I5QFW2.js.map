{
  "version": 3,
  "sources": ["../../hashlru/index.js", "../../netmask/lib/netmask.js", "../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../@multiformats/dns/src/utils/get-types.ts", "../../@multiformats/dns/src/utils/to-dns-response.ts", "../../@multiformats/dns/src/resolvers/dns-json-over-https.ts", "../../@multiformats/dns/src/resolvers/default.browser.ts", "../../@multiformats/dns/src/utils/cache.ts", "../../@multiformats/dns/src/dns.ts", "../../@multiformats/dns/src/index.ts", "../../@multiformats/multiaddr/src/resolvers/dnsaddr.ts", "../../libp2p/src/config.ts", "../../@libp2p/peer-collections/src/util.ts", "../../@libp2p/peer-collections/src/map.ts", "../../@libp2p/peer-collections/src/set.ts", "../../@libp2p/peer-collections/src/list.ts", "../../@noble/hashes/src/pbkdf2.ts", "../../@noble/hashes/src/sha1.ts", "../../@libp2p/crypto/src/pbkdf2.ts", "../../@libp2p/utils/src/filters/bloom-filter.ts", "../../@libp2p/utils/src/filters/fingerprint.ts", "../../@libp2p/utils/src/filters/utils.ts", "../../@libp2p/utils/src/filters/bucket.ts", "../../@sindresorhus/fnv1a/index.js", "../../@libp2p/utils/src/filters/hashes.ts", "../../@libp2p/utils/src/filters/cuckoo-filter.ts", "../../@libp2p/utils/src/filters/scalable-cuckoo-filter.ts", "../../@libp2p/peer-collections/src/filter.ts", "../../@libp2p/peer-collections/src/tracked-map.ts", "../../@libp2p/peer-record/src/envelope/envelope.ts", "../../@libp2p/peer-record/src/envelope/errors.ts", "../../@libp2p/peer-record/src/envelope/index.ts", "../../@libp2p/utils/src/array-equals.ts", "../../@libp2p/peer-record/src/peer-record/consts.ts", "../../@libp2p/peer-record/src/peer-record/peer-record.ts", "../../@libp2p/peer-record/src/peer-record/index.ts", "../../observable-webworkers/src/index.ts", "../../mortice/src/constants.ts", "../../mortice/src/utils.ts", "../../mortice/src/browser.ts", "../../mortice/src/index.ts", "../../@libp2p/peer-store/src/pb/peer.ts", "../../@libp2p/peer-store/src/utils/bytes-to-peer.ts", "../../interface-datastore/src/key.ts", "../../@libp2p/peer-store/src/utils/peer-id-to-datastore-key.ts", "../../@libp2p/peer-store/src/utils/dedupe-addresses.ts", "../../@libp2p/peer-store/src/utils/to-peer-pb.ts", "../../@libp2p/peer-store/src/store.ts", "../../@libp2p/peer-store/src/index.ts", "../../interface-store/src/errors.ts", "../../it-drain/src/index.ts", "../../it-sort/src/index.ts", "../../it-take/src/index.ts", "../../datastore-core/src/base.ts", "../../datastore-core/src/memory.ts", "../../@libp2p/utils/src/debounce.ts", "../../@libp2p/utils/src/private-ip.ts", "../../libp2p/src/address-manager/dns-mappings.ts", "../../libp2p/src/address-manager/ip-mappings.ts", "../../@libp2p/utils/src/multiaddr/is-link-local.ts", "../../@libp2p/utils/src/multiaddr/is-private.ts", "../../libp2p/src/address-manager/observed-addresses.ts", "../../libp2p/src/address-manager/transport-addresses.ts", "../../libp2p/src/address-manager/index.ts", "../../libp2p/src/errors.ts", "../../libp2p/src/components.ts", "../../libp2p/src/config/connection-gater.browser.ts", "../../delay/index.js", "../../@libp2p/utils/src/errors.ts", "../../@libp2p/utils/src/rate-limiter.ts", "../../libp2p/src/get-peer.ts", "../../@libp2p/utils/src/close.ts", "../../libp2p/src/connection-manager/constants.defaults.ts", "../../libp2p/src/connection-manager/constants.browser.ts", "../../libp2p/src/connection-manager/utils.ts", "../../libp2p/src/connection-manager/connection-pruner.ts", "../../race-event/src/index.ts", "../../@libp2p/utils/src/queue/recipient.ts", "../../@libp2p/utils/src/queue/job.ts", "../../@libp2p/utils/src/queue/index.ts", "../../@libp2p/utils/src/priority-queue.ts", "../../any-signal/src/index.ts", "../../libp2p/src/connection-manager/address-sorter.ts", "../../libp2p/src/connection-manager/dial-queue.ts", "../../@libp2p/utils/src/peer-queue.ts", "../../p-retry/index.js", "../../is-network-error/index.js", "../../libp2p/src/connection-manager/reconnect-queue.ts", "../../libp2p/src/connection-manager/index.ts", "../../@libp2p/utils/src/moving-average.ts", "../../@libp2p/utils/src/adaptive-timeout.ts", "../../libp2p/src/connection-monitor.ts", "../../libp2p/src/content-routing.ts", "../../libp2p/src/peer-routing.ts", "../../libp2p/src/random-walk.ts", "../../libp2p/src/registrar.ts", "../../@libp2p/utils/src/tracked-map.ts", "../../libp2p/src/transport-manager.ts", "../../@libp2p/multistream-select/src/constants.ts", "../../@libp2p/multistream-select/src/multistream.ts", "../../@libp2p/multistream-select/src/select.ts", "../../@libp2p/multistream-select/src/handle.ts", "../../libp2p/src/connection/index.ts", "../../libp2p/src/upgrader.ts", "../../libp2p/src/version.ts", "../../libp2p/src/libp2p.ts", "../../libp2p/src/index.ts"],
  "sourcesContent": ["module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n", "// Generated by CoffeeScript 1.12.7\n(function() {\n  var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;\n\n  long2ip = function(long) {\n    var a, b, c, d;\n    a = (long & (0xff << 24)) >>> 24;\n    b = (long & (0xff << 16)) >>> 16;\n    c = (long & (0xff << 8)) >>> 8;\n    d = long & 0xff;\n    return [a, b, c, d].join('.');\n  };\n\n  ip2long = function(ip) {\n    var b, c, i, j, n, ref;\n    b = [];\n    for (i = j = 0; j <= 3; i = ++j) {\n      if (ip.length === 0) {\n        break;\n      }\n      if (i > 0) {\n        if (ip[0] !== '.') {\n          throw new Error('Invalid IP');\n        }\n        ip = ip.substring(1);\n      }\n      ref = atob(ip), n = ref[0], c = ref[1];\n      ip = ip.substring(c);\n      b.push(n);\n    }\n    if (ip.length !== 0) {\n      throw new Error('Invalid IP');\n    }\n    switch (b.length) {\n      case 1:\n        if (b[0] > 0xFFFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return b[0] >>> 0;\n      case 2:\n        if (b[0] > 0xFF || b[1] > 0xFFFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1]) >>> 0;\n      case 3:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFFFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;\n      case 4:\n        if (b[0] > 0xFF || b[1] > 0xFF || b[2] > 0xFF || b[3] > 0xFF) {\n          throw new Error('Invalid IP');\n        }\n        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;\n      default:\n        throw new Error('Invalid IP');\n    }\n  };\n\n  chr = function(b) {\n    return b.charCodeAt(0);\n  };\n\n  chr0 = chr('0');\n\n  chra = chr('a');\n\n  chrA = chr('A');\n\n  atob = function(s) {\n    var base, dmax, i, n, start;\n    n = 0;\n    base = 10;\n    dmax = '9';\n    i = 0;\n    if (s.length > 1 && s[i] === '0') {\n      if (s[i + 1] === 'x' || s[i + 1] === 'X') {\n        i += 2;\n        base = 16;\n      } else if ('0' <= s[i + 1] && s[i + 1] <= '9') {\n        i++;\n        base = 8;\n        dmax = '7';\n      }\n    }\n    start = i;\n    while (i < s.length) {\n      if ('0' <= s[i] && s[i] <= dmax) {\n        n = (n * base + (chr(s[i]) - chr0)) >>> 0;\n      } else if (base === 16) {\n        if ('a' <= s[i] && s[i] <= 'f') {\n          n = (n * base + (10 + chr(s[i]) - chra)) >>> 0;\n        } else if ('A' <= s[i] && s[i] <= 'F') {\n          n = (n * base + (10 + chr(s[i]) - chrA)) >>> 0;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n      if (n > 0xFFFFFFFF) {\n        throw new Error('too large');\n      }\n      i++;\n    }\n    if (i === start) {\n      throw new Error('empty octet');\n    }\n    return [n, i];\n  };\n\n  Netmask = (function() {\n    function Netmask(net, mask) {\n      var error, i, j, ref;\n      if (typeof net !== 'string') {\n        throw new Error(\"Missing `net' parameter\");\n      }\n      if (!mask) {\n        ref = net.split('/', 2), net = ref[0], mask = ref[1];\n      }\n      if (!mask) {\n        mask = 32;\n      }\n      if (typeof mask === 'string' && mask.indexOf('.') > -1) {\n        try {\n          this.maskLong = ip2long(mask);\n        } catch (error1) {\n          error = error1;\n          throw new Error(\"Invalid mask: \" + mask);\n        }\n        for (i = j = 32; j >= 0; i = --j) {\n          if (this.maskLong === (0xffffffff << (32 - i)) >>> 0) {\n            this.bitmask = i;\n            break;\n          }\n        }\n      } else if (mask || mask === 0) {\n        this.bitmask = parseInt(mask, 10);\n        this.maskLong = 0;\n        if (this.bitmask > 0) {\n          this.maskLong = (0xffffffff << (32 - this.bitmask)) >>> 0;\n        }\n      } else {\n        throw new Error(\"Invalid mask: empty\");\n      }\n      try {\n        this.netLong = (ip2long(net) & this.maskLong) >>> 0;\n      } catch (error1) {\n        error = error1;\n        throw new Error(\"Invalid net address: \" + net);\n      }\n      if (!(this.bitmask <= 32)) {\n        throw new Error(\"Invalid mask for ip4: \" + mask);\n      }\n      this.size = Math.pow(2, 32 - this.bitmask);\n      this.base = long2ip(this.netLong);\n      this.mask = long2ip(this.maskLong);\n      this.hostmask = long2ip(~this.maskLong);\n      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;\n      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);\n      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;\n    }\n\n    Netmask.prototype.contains = function(ip) {\n      if (typeof ip === 'string' && (ip.indexOf('/') > 0 || ip.split('.').length !== 4)) {\n        ip = new Netmask(ip);\n      }\n      if (ip instanceof Netmask) {\n        return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);\n      } else {\n        return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;\n      }\n    };\n\n    Netmask.prototype.next = function(count) {\n      if (count == null) {\n        count = 1;\n      }\n      return new Netmask(long2ip(this.netLong + (this.size * count)), this.mask);\n    };\n\n    Netmask.prototype.forEach = function(fn) {\n      var index, lastLong, long;\n      long = ip2long(this.first);\n      lastLong = ip2long(this.last);\n      index = 0;\n      while (long <= lastLong) {\n        fn(long2ip(long), long, index);\n        index++;\n        long++;\n      }\n    };\n\n    Netmask.prototype.toString = function() {\n      return this.base + \"/\" + this.bitmask;\n    };\n\n    return Netmask;\n\n  })();\n\n  exports.ip2long = ip2long;\n\n  exports.long2ip = long2ip;\n\n  exports.Netmask = Netmask;\n\n}).call(this);\n", "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "import { RecordType } from '../index.js'\n\nexport function getTypes (types?: RecordType | RecordType[]): RecordType[] {\n  const DEFAULT_TYPES = [\n    RecordType.A\n  ]\n\n  if (types == null) {\n    return DEFAULT_TYPES\n  }\n\n  if (Array.isArray(types)) {\n    if (types.length === 0) {\n      return DEFAULT_TYPES\n    }\n\n    return types\n  }\n\n  return [\n    types\n  ]\n}\n", "import { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RecordType, type DNSResponse } from '../index.js'\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nexport const DEFAULT_TTL = 60\n\nexport function toDNSResponse (obj: any): DNSResponse {\n  return {\n    Status: obj.Status ?? 0,\n    TC: obj.TC ?? obj.flag_tc ?? false,\n    RD: obj.RD ?? obj.flag_rd ?? false,\n    RA: obj.RA ?? obj.flag_ra ?? false,\n    AD: obj.AD ?? obj.flag_ad ?? false,\n    CD: obj.CD ?? obj.flag_cd ?? false,\n    Question: (obj.Question ?? obj.questions ?? []).map((question: any) => {\n      return {\n        name: question.name,\n        type: RecordType[question.type]\n      }\n    }),\n    Answer: (obj.Answer ?? obj.answers ?? []).map((answer: any) => {\n      return {\n        name: answer.name,\n        type: RecordType[answer.type],\n        TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n        data: answer.data instanceof Uint8Array ? uint8ArrayToString(answer.data) : answer.data\n      }\n    })\n  }\n}\n", "/* eslint-env browser */\n\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { RecordType, type DNSResponse } from '../index.js'\nimport { getTypes } from '../utils/get-types.js'\nimport { toDNSResponse } from '../utils/to-dns-response.js'\nimport type { DNSResolver } from './index.js'\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nexport const DEFAULT_QUERY_CONCURRENCY = 4\n\nexport interface DNSJSONOverHTTPSOptions {\n  queryConcurrency?: number\n}\n\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nexport function dnsJsonOverHttps (url: string, init: DNSJSONOverHTTPSOptions = {}): DNSResolver {\n  const httpQueue = new PQueue({\n    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n  })\n\n  return async (fqdn, options = {}) => {\n    const searchParams = new URLSearchParams()\n    searchParams.set('name', fqdn)\n\n    getTypes(options.types).forEach(type => {\n      // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n      searchParams.append('type', RecordType[type])\n    })\n\n    options.onProgress?.(new CustomProgressEvent<string>('dns:query', { detail: fqdn }))\n\n    // query DNS-JSON over HTTPS server\n    const response = await httpQueue.add(async () => {\n      const res = await fetch(`${url}?${searchParams}`, {\n        headers: {\n          accept: 'application/dns-json'\n        },\n        signal: options?.signal\n      })\n\n      if (res.status !== 200) {\n        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`)\n      }\n\n      const response = toDNSResponse(await res.json())\n\n      options.onProgress?.(new CustomProgressEvent<DNSResponse>('dns:response', { detail: response }))\n\n      return response\n    }, {\n      signal: options.signal\n    })\n\n    if (response == null) {\n      throw new Error('No DNS response received')\n    }\n\n    return response\n  }\n}\n", "import { dnsJsonOverHttps } from './dns-json-over-https.js'\nimport type { DNSResolver } from './index.js'\n\nexport function defaultResolver (): DNSResolver[] {\n  return [\n    dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n    dnsJsonOverHttps('https://dns.google/resolve')\n  ]\n}\n", "import hashlru from 'hashlru'\nimport { RecordType } from '../index.js'\nimport { DEFAULT_TTL, toDNSResponse } from './to-dns-response.js'\nimport type { Answer, DNSResponse } from '../index.js'\n\ninterface CachedAnswer {\n  expires: number\n  value: Answer\n}\n\nexport interface AnswerCache {\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined\n  add (domain: string, answer: Answer): void\n  remove (domain: string, type: ResponseType): void\n  clear (): void\n}\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n  private readonly lru: ReturnType<typeof hashlru>\n\n  constructor (maxSize: number) {\n    this.lru = hashlru(maxSize)\n  }\n\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined {\n    let foundAllAnswers = true\n    const answers: Answer[] = []\n\n    for (const type of types) {\n      const cached = this.getAnswers(fqdn, type)\n\n      if (cached.length === 0) {\n        foundAllAnswers = false\n        break\n      }\n\n      answers.push(...cached)\n    }\n\n    if (foundAllAnswers) {\n      return toDNSResponse({ answers })\n    }\n  }\n\n  private getAnswers (domain: string, type: RecordType): Answer[] {\n    const key = `${domain.toLowerCase()}-${type}`\n    const answers: CachedAnswer[] = this.lru.get(key)\n\n    if (answers != null) {\n      const cachedAnswers = answers\n        .filter((entry) => {\n          return entry.expires > Date.now()\n        })\n        .map(({ expires, value }) => ({\n          ...value,\n          TTL: Math.round((expires - Date.now()) / 1000),\n          type: RecordType[value.type]\n        }))\n\n      if (cachedAnswers.length === 0) {\n        this.lru.remove(key)\n      }\n\n      // @ts-expect-error hashlru stringifies stored types which turns enums\n      // into strings, we convert back into enums above but tsc doesn't know\n      return cachedAnswers\n    }\n\n    return []\n  }\n\n  add (domain: string, answer: Answer): void {\n    const key = `${domain.toLowerCase()}-${answer.type}`\n\n    const answers: CachedAnswer[] = this.lru.get(key) ?? []\n    answers.push({\n      expires: Date.now() + ((answer.TTL ?? DEFAULT_TTL) * 1000),\n      value: answer\n    })\n\n    this.lru.set(key, answers)\n  }\n\n  remove (domain: string, type: ResponseType): void {\n    const key = `${domain.toLowerCase()}-${type}`\n\n    this.lru.remove(key)\n  }\n\n  clear (): void {\n    this.lru.clear()\n  }\n}\n\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nexport function cache (size: number): AnswerCache {\n  return new CachedAnswers(size)\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { defaultResolver } from './resolvers/default.js'\nimport { cache } from './utils/cache.js'\nimport { getTypes } from './utils/get-types.js'\nimport type { DNS as DNSInterface, DNSInit, DNSResponse, QueryOptions } from './index.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { AnswerCache } from './utils/cache.js'\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000\n\nexport class DNS implements DNSInterface {\n  private readonly resolvers: Record<string, DNSResolver[]>\n  private readonly cache: AnswerCache\n\n  constructor (init: DNSInit) {\n    this.resolvers = {}\n    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE)\n\n    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n      if (!Array.isArray(resolver)) {\n        resolver = [resolver]\n      }\n\n      // convert `com` -> `com.`\n      if (!tld.endsWith('.')) {\n        tld = `${tld}.`\n      }\n\n      this.resolvers[tld] = resolver\n    })\n\n    // configure default resolver if none specified\n    if (this.resolvers['.'] == null) {\n      this.resolvers['.'] = defaultResolver()\n    }\n  }\n\n  /**\n   * Queries DNS resolvers for the passed record types for the passed domain.\n   *\n   * If cached records exist for all desired types they will be returned\n   * instead.\n   *\n   * Any new responses will be added to the cache for subsequent requests.\n   */\n  async query (domain: string, options: QueryOptions = {}): Promise<DNSResponse> {\n    const types = getTypes(options.types)\n    const cached = options.cached !== false ? this.cache.get(domain, types) : undefined\n\n    if (cached != null) {\n      options.onProgress?.(new CustomProgressEvent<string>('dns:cache', { detail: cached }))\n\n      return cached\n    }\n\n    const tld = `${domain.split('.').pop()}.`\n    const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n      return (Math.random() > 0.5) ? -1 : 1\n    })\n\n    const errors: Error[] = []\n\n    for (const resolver of resolvers) {\n      // skip further resolutions if the user aborted the signal\n      if (options.signal?.aborted === true) {\n        break\n      }\n\n      try {\n        const result = await resolver(domain, {\n          ...options,\n          types\n        })\n\n        for (const answer of result.Answer) {\n          this.cache.add(domain, answer)\n        }\n\n        return result\n      } catch (err: any) {\n        errors.push(err)\n        options.onProgress?.(new CustomProgressEvent<Error>('dns:error', { detail: err }))\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\nimport { DNS as DNSClass } from './dns.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nexport enum RecordType {\n  A = 1,\n  CNAME = 5,\n  TXT = 16,\n  AAAA = 28\n}\n\nexport interface Question {\n  /**\n   * The record name requested.\n   */\n  name: string\n\n  /**\n   * The type of DNS record requested.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n   */\n  type: RecordType\n}\n\nexport interface Answer {\n  /**\n   * The record owner.\n   */\n  name: string\n\n  /**\n   * The type of DNS record.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4\n   */\n  type: RecordType\n\n  /**\n   * The number of seconds the answer can be stored in cache before it is\n   * considered stale.\n   */\n  TTL: number\n\n  /**\n   * The value of the DNS record for the given name and type. The data will be\n   * in text for standardized record types and in hex for unknown types.\n   */\n  data: string\n}\n\nexport interface DNSResponse {\n  /**\n   * The Response Code of the DNS Query.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6\n   */\n  Status: number\n\n  /**\n   * If true, it means the truncated bit was set. This happens when the DNS\n   * answer is larger than a single UDP or TCP packet.\n   */\n  TC: boolean\n\n  /**\n   * If true, it means the Recursive Desired bit was set.\n   */\n  RD: boolean\n\n  /**\n   * If true, it means the Recursion Available bit was set.\n   */\n  RA: boolean\n\n  /**\n   * If true, it means that every record in the answer was verified with DNSSEC.\n   */\n  AD: boolean\n\n  /**\n   * If true, the client asked to disable DNSSEC validation.\n   */\n  CD: boolean\n\n  /**\n   * The records that were requested.\n   */\n  Question: Question[]\n\n  /**\n   * Values for the records that were requested.\n   */\n  Answer: Answer[]\n}\n\n/**\n * The default maximum amount of recursion allowed during a query\n */\nexport const MAX_RECURSIVE_DEPTH = 32\n\nexport interface QueryOptions extends ProgressOptions<ResolveDnsProgressEvents> {\n  signal?: AbortSignal\n\n  /**\n   * Do not use cached DNS entries\n   *\n   * @default false\n   */\n  cached?: boolean\n\n  /**\n   * The type or types of DNS records to resolve\n   *\n   * @default [RecordType.A, RecordType.AAAA]\n   */\n  types?: RecordType | RecordType[]\n}\n\nexport interface DNS {\n  query(fqdn: string, options?: QueryOptions): Promise<DNSResponse>\n}\n\nexport type ResolveDnsProgressEvents =\n  ProgressEvent<'dns:cache', string> |\n  ProgressEvent<'dns:query', string> |\n  ProgressEvent<'dns:response', DNSResponse> |\n  ProgressEvent<'dns:error', Error>\n\nexport type DNSResolvers = Record<string, DNSResolver | DNSResolver[]>\n\nexport interface DNSInit {\n  /**\n   * A set of resolvers used to answer DNS queries\n   *\n   * String keys control which resolvers are used for which TLDs.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { dns } from '@multiformats/dns'\n   * import { dnsOverHttps } from '@multiformats/dns'\n   *\n   * const resolver = dns({\n   *   resolvers: {\n   *     // only used for .com domains\n   *     'com.': dnsOverHttps('https://example-1.com'),\n   *\n   *     // only used for .net domains, can be an array\n   *     'net.': [\n   *       dnsOverHttps('https://example-2.com'),\n   *       dnsOverHttps('https://example-3.com'),\n   *     ],\n   *\n   *     // used for everything else (can be an array)\n   *     '.': dnsOverHttps('https://example-4.com')\n   *   }\n   * })\n   * ```\n   */\n  resolvers?: DNSResolvers\n\n  /**\n   * To avoid repeating DNS lookups, successful answers are cached according to\n   * their TTL. To avoid exhausting memory, this option controls how many\n   * answers to cache.\n   *\n   * @default 1000\n   */\n  cacheSize?: number\n}\n\nexport function dns (init: DNSInit = {}): DNS {\n  return new DNSClass(init)\n}\n", "import { dns, RecordType } from '@multiformats/dns'\nimport { multiaddr } from '../index.js'\nimport { getProtocol } from '../protocols-table.js'\nimport type { Resolver } from './index.js'\nimport type { AbortOptions, Multiaddr } from '../index.js'\nimport type { DNS } from '@multiformats/dns'\n\nconst MAX_RECURSIVE_DEPTH = 32\nconst { code: dnsaddrCode } = getProtocol('dnsaddr')\n\nclass RecursionLimitError extends Error {\n  constructor (message = 'Max recursive depth reached') {\n    super(message)\n    this.name = 'RecursionLimitError'\n  }\n}\n\nexport interface DNSADDROptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport const dnsaddrResolver: Resolver<DNSADDROptions> = async function dnsaddrResolver (ma: Multiaddr, options: DNSADDROptions = {}): Promise<string[]> {\n  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH\n\n  if (recursionLimit === 0) {\n    throw new RecursionLimitError('Max recursive depth reached')\n  }\n\n  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? []\n\n  const resolver = options?.dns ?? dns()\n  const result = await resolver.query(`_dnsaddr.${hostname}`, {\n    signal: options?.signal,\n    types: [\n      RecordType.TXT\n    ]\n  })\n\n  const peerId = ma.getPeerId()\n  const output: string[] = []\n\n  for (const answer of result.Answer) {\n    const addr = answer.data\n      .replace(/[\"']/g, '')\n      .trim()\n      .split('=')[1]\n\n    if (addr == null) {\n      continue\n    }\n\n    if (peerId != null && !addr.includes(peerId)) {\n      continue\n    }\n\n    const ma = multiaddr(addr)\n\n    if (addr.startsWith('/dnsaddr')) {\n      const resolved = await ma.resolve({\n        ...options,\n        maxRecursiveDepth: recursionLimit - 1\n      })\n\n      output.push(...resolved.map(ma => ma.toString()))\n    } else {\n      output.push(ma.toString())\n    }\n  }\n\n  return output\n}\n", "import { FaultTolerance, InvalidParametersError } from '@libp2p/interface'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport mergeOptions from 'merge-options'\nimport type { Libp2pInit } from './index.js'\nimport type { ServiceMap } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst DefaultConfig: Libp2pInit = {\n  addresses: {\n    listen: [],\n    announce: [],\n    noAnnounce: [],\n    announceFilter: (multiaddrs: Multiaddr[]) => multiaddrs\n  },\n  connectionManager: {\n    resolvers: {\n      dnsaddr: dnsaddrResolver\n    }\n  },\n  transportManager: {\n    faultTolerance: FaultTolerance.FATAL_ALL\n  }\n}\n\nexport async function validateConfig <T extends ServiceMap = Record<string, unknown>> (opts: Libp2pInit<T>): Promise<Libp2pInit<T>> {\n  const resultingOptions: Libp2pInit<T> = mergeOptions(DefaultConfig, opts)\n\n  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n    throw new InvalidParametersError('Private network is enforced, but no protector was provided')\n  }\n\n  return resultingOptions\n}\n", "import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Digest from 'multiformats/hashes/digest'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * Calls the passed map function on every entry of the passed iterable iterator\n */\nexport function mapIterable <T, R> (iter: IterableIterator<T>, map: (val: T) => R): IterableIterator<R> {\n  const iterator: IterableIterator<R> = {\n    [Symbol.iterator]: () => {\n      return iterator\n    },\n    next: () => {\n      const next = iter.next()\n      const val = next.value\n\n      if (next.done === true || val == null) {\n        const result: IteratorReturnResult<any> = {\n          done: true,\n          value: undefined\n        }\n\n        return result\n      }\n\n      return {\n        done: false,\n        value: map(val)\n      }\n    }\n  }\n\n  return iterator\n}\n\nexport function peerIdFromString (str: string): PeerId {\n  const multihash = Digest.decode(base58btc.decode(`z${str}`))\n  return peerIdFromMultihash(multihash)\n}\n", "import { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as map keys because map keys are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerMap } from '@libp2p/peer-collections'\n *\n * const map = peerMap<string>()\n * map.set(peerId, 'value')\n * ```\n */\nexport class PeerMap <T> {\n  private readonly map: Map<string, { key: PeerId, value: T }>\n\n  constructor (map?: PeerMap<T>) {\n    this.map = new Map()\n\n    if (map != null) {\n      for (const [key, value] of map.entries()) {\n        this.map.set(key.toString(), { key, value })\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<[PeerId, T]> {\n    return this.entries()\n  }\n\n  clear (): void {\n    this.map.clear()\n  }\n\n  delete (peer: PeerId): boolean {\n    return this.map.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, T]> {\n    return mapIterable<[string, { key: PeerId, value: T }], [PeerId, T]>(\n      this.map.entries(),\n      (val) => {\n        return [val[1].key, val[1].value]\n      }\n    )\n  }\n\n  forEach (fn: (value: T, key: PeerId, map: PeerMap<T>) => void): void {\n    this.map.forEach((value, key) => {\n      fn(value.value, value.key, this)\n    })\n  }\n\n  get (peer: PeerId): T | undefined {\n    return this.map.get(peer.toString())?.value\n  }\n\n  has (peer: PeerId): boolean {\n    return this.map.has(peer.toString())\n  }\n\n  set (peer: PeerId, value: T): void {\n    this.map.set(peer.toString(), { key: peer, value })\n  }\n\n  keys (): IterableIterator<PeerId> {\n    return mapIterable<{ key: PeerId, value: T }, PeerId>(\n      this.map.values(),\n      (val) => {\n        return val.key\n      }\n    )\n  }\n\n  values (): IterableIterator<T> {\n    return mapIterable(this.map.values(), (val) => val.value)\n  }\n\n  get size (): number {\n    return this.map.size\n  }\n}\n\nexport function peerMap <T> (): PeerMap<T> {\n  return new PeerMap<T>()\n}\n", "import { mapIterable, peerIdFromString } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as set entries because set entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerSet } from '@libp2p/peer-collections'\n *\n * const set = peerSet()\n * set.add(peerId)\n * ```\n */\nexport class PeerSet {\n  private readonly set: Set<string>\n\n  constructor (set?: PeerSet | Iterable<PeerId>) {\n    this.set = new Set()\n\n    if (set != null) {\n      for (const key of set) {\n        this.set.add(key.toString())\n      }\n    }\n  }\n\n  get size (): number {\n    return this.set.size\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return this.values()\n  }\n\n  add (peer: PeerId): void {\n    this.set.add(peer.toString())\n  }\n\n  clear (): void {\n    this.set.clear()\n  }\n\n  delete (peer: PeerId): void {\n    this.set.delete(peer.toString())\n  }\n\n  entries (): IterableIterator<[PeerId, PeerId]> {\n    return mapIterable<[string, string], [PeerId, PeerId]>(\n      this.set.entries(),\n      (val) => {\n        const peerId = peerIdFromString(val[0])\n\n        return [peerId, peerId]\n      }\n    )\n  }\n\n  forEach (predicate: (peerId: PeerId, index: PeerId, set: PeerSet) => void): void {\n    this.set.forEach((str) => {\n      const peerId = peerIdFromString(str)\n\n      predicate(peerId, peerId, this)\n    })\n  }\n\n  has (peer: PeerId): boolean {\n    return this.set.has(peer.toString())\n  }\n\n  values (): IterableIterator<PeerId> {\n    return mapIterable<string, PeerId>(\n      this.set.values(),\n      (val) => {\n        return peerIdFromString(val)\n      }\n    )\n  }\n\n  intersection (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      if (this.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  difference (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of this) {\n      if (!other.has(peerId)) {\n        output.add(peerId)\n      }\n    }\n\n    return output\n  }\n\n  union (other: PeerSet): PeerSet {\n    const output = new PeerSet()\n\n    for (const peerId of other) {\n      output.add(peerId)\n    }\n\n    for (const peerId of this) {\n      output.add(peerId)\n    }\n\n    return output\n  }\n}\n\nexport function peerSet (): PeerSet {\n  return new PeerSet()\n}\n", "import { mapIterable } from './util.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * We can't use PeerIds as list entries because list entries are\n * compared using same-value-zero equality, so this is just\n * a map that stringifies the PeerIds before storing them.\n *\n * PeerIds cache stringified versions of themselves so this\n * should be a cheap operation.\n *\n * @example\n *\n * ```TypeScript\n * import { peerList } from '@libp2p/peer-collections'\n *\n * const list = peerList()\n * list.push(peerId)\n * ```\n */\nexport class PeerList {\n  private list: PeerId[]\n\n  constructor (list?: PeerList | Iterable<PeerId>) {\n    this.list = []\n\n    if (list != null) {\n      for (const value of list) {\n        this.list.push(value)\n      }\n    }\n  }\n\n  [Symbol.iterator] (): IterableIterator<PeerId> {\n    return mapIterable<[number, PeerId], PeerId>(\n      this.list.entries(),\n      (val) => {\n        return val[1]\n      }\n    )\n  }\n\n  concat (list: PeerList): PeerList {\n    const output = new PeerList(this)\n\n    for (const value of list) {\n      output.push(value)\n    }\n\n    return output\n  }\n\n  entries (): IterableIterator<[number, PeerId]> {\n    return mapIterable<[number, PeerId], [number, PeerId]>(\n      this.list.entries(),\n      (val) => {\n        return [val[0], val[1]]\n      }\n    )\n  }\n\n  every (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): boolean {\n    return this.list.every((peerId, index) => {\n      return predicate(peerId, index, this)\n    })\n  }\n\n  filter (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerList {\n    const output = new PeerList()\n\n    this.list.forEach((peerId, index) => {\n      if (predicate(peerId, index, this)) {\n        output.push(peerId)\n      }\n    })\n\n    return output\n  }\n\n  find (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): PeerId | undefined {\n    const peerId = this.list.find((peerId, index) => {\n      return predicate(peerId, index, this)\n    })\n\n    if (peerId == null) {\n      return undefined\n    }\n\n    return peerId\n  }\n\n  findIndex (predicate: (peerId: PeerId, index: number, arr: PeerList) => boolean): number {\n    return this.list.findIndex((peerId, index) => {\n      return predicate(peerId, index, this)\n    })\n  }\n\n  forEach (predicate: (peerId: PeerId, index: number, arr: PeerList) => void): void {\n    this.list.forEach((peerId, index) => {\n      predicate(peerId, index, this)\n    })\n  }\n\n  includes (peerId: PeerId): boolean {\n    return this.includes(peerId)\n  }\n\n  indexOf (peerId: PeerId): number {\n    return this.list.findIndex(id => id.equals(peerId))\n  }\n\n  pop (): PeerId | undefined {\n    const peerId = this.list.pop()\n\n    if (peerId == null) {\n      return undefined\n    }\n\n    return peerId\n  }\n\n  push (...peerIds: PeerId[]): void {\n    for (const peerId of peerIds) {\n      this.list.push(peerId)\n    }\n  }\n\n  shift (): PeerId | undefined {\n    const peerId = this.list.shift()\n\n    if (peerId == null) {\n      return undefined\n    }\n\n    return peerId\n  }\n\n  unshift (...peerIds: PeerId[]): number {\n    let len = this.list.length\n\n    for (let i = peerIds.length - 1; i > -1; i--) {\n      len = this.list.unshift(peerIds[i])\n    }\n\n    return len\n  }\n\n  clear (): void {\n    this.list = []\n  }\n\n  get length (): number {\n    return this.list.length\n  }\n}\n\nexport function peerList (): PeerList {\n  return new PeerList()\n}\n", "/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nimport { ahash, anumber } from './_assert.js';\nimport { hmac } from './hmac.js';\nimport {\n  asyncLoop,\n  checkOpts,\n  createView,\n  Hash,\n  toBytes,\n  type CHash,\n  type Input,\n} from './utils.js';\n\nexport type Pbkdf2Opt = {\n  c: number; // Iterations\n  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n};\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: Input, _salt: Input, _opts: Pbkdf2Opt) {\n  ahash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  anumber(c);\n  anumber(dkLen);\n  anumber(asyncTick);\n  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');\n  const password = toBytes(_password);\n  const salt = toBytes(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  u.fill(0);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: 2 ** 18 });\n */\nexport function pbkdf2(hash: CHash, password: Input, salt: Input, opts: Pbkdf2Opt): Uint8Array {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Ucâˆ’1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nexport async function pbkdf2Async(\n  hash: CHash,\n  password: Input,\n  salt: Input,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, () => {\n      // Uc = PRF(Password, Ucâˆ’1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.js';\nimport { rotl, wrapConstructor, type CHash } from './utils.js';\n\n// Initial state\nconst SHA1_IV = /* @__PURE__ */ new Uint32Array([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    SHA1_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA1());\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { pbkdf2 as pbkdf2Sync } from '@noble/hashes/pbkdf2'\nimport { sha1 } from '@noble/hashes/sha1'\nimport { sha256 } from '@noble/hashes/sha256'\nimport { sha512 } from '@noble/hashes/sha512'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * Maps an IPFS hash name to its @noble/hashes equivalent.\n *\n * See https://github.com/multiformats/multihash/blob/master/hashtable.csv\n *\n * @private\n */\nconst hashName = {\n  sha1,\n  'sha2-256': sha256,\n  'sha2-512': sha512\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n */\nexport default function pbkdf2 (password: string, salt: string | Uint8Array, iterations: number, keySize: number, hash: string): string {\n  if (hash !== 'sha1' && hash !== 'sha2-256' && hash !== 'sha2-512') {\n    const types = Object.keys(hashName).join(' / ')\n    throw new InvalidParametersError(`Hash '${hash}' is unknown or not supported. Must be ${types}`)\n  }\n\n  const hasher = hashName[hash]\n  const dek = pbkdf2Sync(\n    hasher,\n    password,\n    salt, {\n      c: iterations,\n      dkLen: keySize\n    }\n  )\n\n  return base64.encode(dek).substring(1)\n}\n", "// ported from xxbloom - https://github.com/ceejbot/xxbloom/blob/master/LICENSE\nimport { randomBytes } from '@libp2p/crypto'\nimport mur from 'murmurhash3js-revisited'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { alloc } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { Filter } from './index.js'\n\nconst LN2_SQUARED = Math.LN2 * Math.LN2\n\nexport interface BloomFilterOptions {\n  seeds?: number[]\n  hashes?: number\n  bits?: number\n}\n\nexport class BloomFilter implements Filter {\n  public readonly seeds: number[]\n  public readonly bits: number\n  public buffer: Uint8Array\n\n  constructor (options: BloomFilterOptions = {}) {\n    if (options.seeds != null) {\n      this.seeds = options.seeds\n    } else {\n      this.seeds = generateSeeds(options.hashes ?? 8)\n    }\n\n    this.bits = options.bits ?? 1024\n    this.buffer = alloc(Math.ceil(this.bits / 8))\n  }\n\n  /**\n   * Add an item to the filter\n   */\n  add (item: Uint8Array | string): void {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = mur.x86.hash32(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      this.setbit(bit)\n    }\n  }\n\n  /**\n   * Test if the filter has an item. If it returns false it definitely does not\n   * have the item. If it returns true, it probably has the item but there's\n   * an `errorRate` chance it doesn't.\n   */\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.seeds.length; i++) {\n      const hash = mur.x86.hash32(item, this.seeds[i])\n      const bit = hash % this.bits\n\n      const isSet = this.getbit(bit)\n\n      if (!isSet) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Reset the filter\n   */\n  clear (): void {\n    this.buffer.fill(0)\n  }\n\n  setbit (bit: number): void {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    let bitfield = this.buffer[pos]\n    bitfield |= (0x1 << shift)\n    this.buffer[pos] = bitfield\n  }\n\n  getbit (bit: number): boolean {\n    const pos = Math.floor(bit / 8)\n    const shift = bit % 8\n\n    const bitfield = this.buffer[pos]\n    return (bitfield & (0x1 << shift)) !== 0\n  }\n}\n\n/**\n * Create a `BloomFilter` with the smallest `bits` and `hashes` value for the\n * specified item count and error rate.\n */\nexport function createBloomFilter (itemcount: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(itemcount, errorRate)\n  return new BloomFilter(opts)\n}\n\nfunction optimize (itemCount: number, errorRate: number = 0.005): { bits: number, hashes: number } {\n  const bits = Math.round(-1 * itemCount * Math.log(errorRate) / LN2_SQUARED)\n  const hashes = Math.round((bits / itemCount) * Math.LN2)\n\n  return { bits, hashes }\n}\n\nfunction generateSeeds (count: number): number[] {\n  let buf: Uint8ArrayList\n  let j: number\n  const seeds = []\n\n  for (let i = 0; i < count; i++) {\n    buf = new Uint8ArrayList(randomBytes(4))\n    seeds[i] = buf.getUint32(0, true)\n\n    // Make sure we don't end up with two identical seeds,\n    // which is unlikely but possible.\n    for (j = 0; j < i; j++) {\n      if (seeds[i] === seeds[j]) {\n        i--\n        break\n      }\n    }\n  }\n\n  return seeds\n}\n", "import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Hash } from './hashes'\n\nexport const MAX_FINGERPRINT_SIZE = 64\n\nexport class Fingerprint {\n  private readonly fp: Uint8Array\n  private readonly h: Hash\n  private readonly seed: number\n\n  constructor (buf: Uint8Array, hash: Hash, seed: number, fingerprintSize: number = 2) {\n    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {\n      throw new TypeError('Invalid Fingerprint Size')\n    }\n\n    const fnv = hash.hashV(buf, seed)\n    const fp = uint8ArrayAlloc(fingerprintSize)\n\n    for (let i = 0; i < fp.length; i++) {\n      fp[i] = fnv[i]\n    }\n\n    if (fp.length === 0) {\n      fp[0] = 7\n    }\n\n    this.fp = fp\n    this.h = hash\n    this.seed = seed\n  }\n\n  hash (): number {\n    return this.h.hash(this.fp, this.seed)\n  }\n\n  equals (other?: any): boolean {\n    if (!(other?.fp instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.fp, other.fp)\n  }\n}\n", "export function getRandomInt (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n", "import { Fingerprint } from './fingerprint.js'\nimport { getRandomInt } from './utils.js'\n\nexport class Bucket {\n  private readonly contents: Array<Fingerprint | null>\n\n  constructor (size: number) {\n    this.contents = new Array(size).fill(null)\n  }\n\n  has (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    return this.contents.some((fp) => {\n      return fingerprint.equals(fp)\n    })\n  }\n\n  add (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    for (let i = 0; i < this.contents.length; i++) {\n      if (this.contents[i] == null) {\n        this.contents[i] = fingerprint\n        return true\n      }\n    }\n\n    return true\n  }\n\n  swap (fingerprint: Fingerprint): Fingerprint | null {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const i = getRandomInt(0, this.contents.length - 1)\n    const current = this.contents[i]\n    this.contents[i] = fingerprint\n\n    return current\n  }\n\n  remove (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const found = this.contents.findIndex((fp) => {\n      return fingerprint.equals(fp)\n    })\n\n    if (found > -1) {\n      this.contents[found] = null\n      return true\n    } else {\n      return false\n    }\n  }\n}\n", "// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16_777_619n,\n\t64: 1_099_511_628_211n,\n\t128: 309_485_009_821_345_068_724_781_371n,\n\t256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,\n\t512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,\n\t1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n,\n};\n\nconst FNV_OFFSETS = {\n\t32: 2_166_136_261n,\n\t64: 14_695_981_039_346_656_037n,\n\t128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,\n\t256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,\n\t512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,\n\t1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n,\n};\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction fnv1aUint8Array(uint8Array, size) {\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop\n\tfor (let index = 0; index < uint8Array.length; index++) {\n\t\thash ^= BigInt(uint8Array[index]);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nfunction fnv1aEncodeInto(string, size, utf8Buffer) {\n\tif (utf8Buffer.length === 0) {\n\t\tthrow new Error('The `utf8Buffer` option must have a length greater than zero');\n\t}\n\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\tlet remaining = string;\n\n\twhile (remaining.length > 0) {\n\t\tconst result = cachedEncoder.encodeInto(remaining, utf8Buffer);\n\t\tremaining = remaining.slice(result.read);\n\t\tfor (let index = 0; index < result.written; index++) {\n\t\t\thash ^= BigInt(utf8Buffer[index]);\n\t\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t\t}\n\t}\n\n\treturn hash;\n}\n\nexport default function fnv1a(value, {size = 32, utf8Buffer} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (utf8Buffer) {\n\t\t\treturn fnv1aEncodeInto(value, size, utf8Buffer);\n\t\t}\n\n\t\tvalue = cachedEncoder.encode(value);\n\t}\n\n\treturn fnv1aUint8Array(value, size);\n}\n", "import fnv1aHash from '@sindresorhus/fnv1a'\nimport mur from 'murmurhash3js-revisited'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport interface Hash {\n  hash(input: Uint8Array, seed: number): number\n  hashV(input: Uint8Array, seed: number): Uint8Array\n}\n\nexport const murmur3: Hash = {\n  hash: (input, seed) => {\n    return mur.x86.hash32(input, seed)\n  },\n  hashV: (input, seed) => {\n    return numberToBuffer(murmur3.hash(input, seed))\n  }\n}\n\nexport const fnv1a: Hash = {\n  hash: (input) => {\n    return Number(fnv1aHash(input, {\n      size: 32\n    }))\n  },\n  hashV: (input, seed) => {\n    return numberToBuffer(fnv1a.hash(input, seed))\n  }\n}\n\nexport function numberToBuffer (num: bigint | number): Uint8Array {\n  let hex = num.toString(16)\n\n  if (hex.length % 2 === 1) {\n    hex = `0${hex}`\n  }\n\n  return uint8ArrayFromString(hex, 'base16')\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Bucket } from './bucket.js'\nimport { Fingerprint, MAX_FINGERPRINT_SIZE } from './fingerprint.js'\nimport { fnv1a, type Hash } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Filter } from './index.js'\n\nconst maxCuckooCount = 500\n\nexport interface CuckooFilterInit {\n  /**\n   * How many items the filter is expected to contain\n   */\n  filterSize: number\n\n  /**\n   * How many items to put in each bucket\n   */\n  bucketSize?: number\n\n  /**\n   * How many bytes the fingerprint is expected to be\n   */\n  fingerprintSize?: number\n\n  /**\n   * A non-cryptographic hash implementation\n   */\n  hash?: Hash\n\n  /**\n   * A number used to seed the hash\n   */\n  seed?: number\n}\n\nexport class CuckooFilter implements Filter {\n  private readonly bucketSize: number\n  private readonly filterSize: number\n  private readonly fingerprintSize: number\n  private readonly buckets: Bucket[]\n  public count: number\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: CuckooFilterInit) {\n    this.filterSize = init.filterSize\n    this.bucketSize = init.bucketSize ?? 4\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.count = 0\n    this.buckets = []\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    if (this.buckets[j] == null) {\n      this.buckets[j] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[k] == null) {\n      this.buckets[k] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {\n      this.count++\n      return true\n    }\n\n    const rand = [j, k]\n    let i = rand[getRandomInt(0, rand.length - 1)]\n\n    if (this.buckets[i] == null) {\n      this.buckets[i] = new Bucket(this.bucketSize)\n    }\n\n    for (let n = 0; n < maxCuckooCount; n++) {\n      const swapped = this.buckets[i].swap(fingerprint)\n\n      if (swapped == null) {\n        continue\n      }\n\n      i = (i ^ swapped.hash()) % this.filterSize\n\n      if (this.buckets[i] == null) {\n        this.buckets[i] = new Bucket(this.bucketSize)\n      }\n\n      if (this.buckets[i].add(swapped)) {\n        this.count++\n\n        return true\n      } else {\n        continue\n      }\n    }\n\n    return false\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.has(fingerprint) ?? false\n\n    if (inJ) {\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    return this.buckets[k]?.has(fingerprint) ?? false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.remove(fingerprint) ?? false\n\n    if (inJ) {\n      this.count--\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n    const inK = this.buckets[k]?.remove(fingerprint) ?? false\n\n    if (inK) {\n      this.count--\n    }\n\n    return inK\n  }\n\n  get reliable (): boolean {\n    return Math.floor(100 * (this.count / this.filterSize)) <= 90\n  }\n}\n\n// max load constants, defined in the cuckoo paper\nconst MAX_LOAD = {\n  1: 0.5,\n  2: 0.84,\n  4: 0.95,\n  8: 0.98\n}\n\nfunction calculateBucketSize (errorRate: number = 0.001): 2 | 4 | 8 {\n  if (errorRate > 0.002) {\n    return 2\n  }\n\n  if (errorRate > 0.00001) {\n    return 4\n  }\n\n  return 8\n}\n\nexport function optimize (maxItems: number, errorRate: number = 0.001): CuckooFilterInit {\n  // https://www.eecs.harvard.edu/~michaelm/postscripts/cuckoo-conext2014.pdf\n  // Section 5.1 Optimal Bucket Size\n  const bucketSize = calculateBucketSize(errorRate)\n  const load = MAX_LOAD[bucketSize]\n\n  // https://stackoverflow.com/questions/57555236/how-to-size-a-cuckoo-filter/57617208#57617208\n  const filterSize = Math.round(maxItems / load)\n  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE)\n\n  return {\n    filterSize,\n    bucketSize,\n    fingerprintSize\n  }\n}\n\nexport function createCuckooFilter (maxItems: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(maxItems, errorRate)\n  return new CuckooFilter(opts)\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { CuckooFilter, optimize, type CuckooFilterInit } from './cuckoo-filter.js'\nimport { fnv1a, type Hash } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Filter } from './index.js'\n\nexport interface ScalableCuckooFilterInit extends CuckooFilterInit {\n  /**\n   * A number to multiply maxItems by when adding new sub-filters\n   */\n  scale?: number\n}\n\nexport class ScalableCuckooFilter implements Filter {\n  private readonly filterSize: number\n  private readonly bucketSize: number\n  private readonly fingerprintSize: number\n  private readonly scale: number\n  private readonly filterSeries: CuckooFilter[]\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: ScalableCuckooFilterInit) {\n    this.bucketSize = init.bucketSize ?? 4\n    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.scale = init.scale ?? 2\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n    this.filterSeries = [\n      new CuckooFilter({\n        filterSize: this.filterSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n    ]\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    if (this.has(item)) {\n      return true\n    }\n\n    let current = this.filterSeries.find((cuckoo) => {\n      return cuckoo.reliable\n    })\n\n    if (current == null) {\n      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length)\n\n      current = new CuckooFilter({\n        filterSize: curSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n\n      this.filterSeries.push(current)\n    }\n\n    return current.add(item)\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].has(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].remove(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  get count (): number {\n    return this.filterSeries.reduce((acc, curr) => {\n      return acc + curr.count\n    }, 0)\n  }\n}\n\nexport function createScalableCuckooFilter (maxItems: number, errorRate: number = 0.001, options?: Pick<ScalableCuckooFilterInit, 'hash' | 'seed' | 'scale'>): Filter {\n  return new ScalableCuckooFilter({\n    ...optimize(maxItems, errorRate),\n    ...(options ?? {})\n  })\n}\n", "import { createScalableCuckooFilter } from '@libp2p/utils/filters'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Filter } from '@libp2p/utils/filters'\n\n/**\n * Uses a Cuckoo filter to implement a mechanism for deduplicating PeerIds in a\n * way that uses a smaller amount of memory than a PeerSet.\n */\nexport class PeerFilter {\n  private readonly filter: Filter\n\n  constructor (size: number, errorRate?: number) {\n    this.filter = createScalableCuckooFilter(size, errorRate)\n  }\n\n  has (peerId: PeerId): boolean {\n    return this.filter.has(peerId.toMultihash().bytes)\n  }\n\n  add (peerId: PeerId): void {\n    this.filter.add(peerId.toMultihash().bytes)\n  }\n\n  remove (peerId: PeerId): void {\n    this.filter.remove?.(peerId.toMultihash().bytes)\n  }\n}\n\n/**\n * Create and return a PeerFilter\n *\n * @param size - The maximum number of peers expected to be added to the filter\n * @param errorRate - The acceptable error rate\n */\nexport function peerFilter (size: number, errorRate: number = 0.001): PeerFilter {\n  return new PeerFilter(size, errorRate)\n}\n", "import { PeerMap } from './map.js'\nimport type { Metric, Metrics, PeerId } from '@libp2p/interface'\n\nexport interface TrackedPeerMapInit {\n  name: string\n  metrics?: Metrics\n}\n\nclass TrackedPeerMap<V> extends PeerMap<V> {\n  private readonly metric: Metric\n\n  constructor (init: Required<TrackedPeerMapInit>) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: PeerId, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: PeerId): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\n/**\n * Creates a PeerMap that reports it's size to the libp2p Metrics service\n *\n * @example\n *\n * * ```Typescript\n * import { trackedPeerMap } from '@libp2p/peer-collections'\n * import { createLibp2p } from 'libp2p'\n *\n * const libp2p = await createLibp2p()\n *\n * const list = trackedPeerMap({ name: 'my_metric_name', metrics: libp2p.metrics })\n * map.set(peerId, 'value')\n * ```\n */\nexport function trackedPeerMap <V> (config: TrackedPeerMapInit): PeerMap<V> {\n  const { name, metrics } = config\n  let map: PeerMap<V>\n\n  if (metrics != null) {\n    map = new TrackedPeerMap<V>({ name, metrics })\n  } else {\n    map = new PeerMap<V>()\n  }\n\n  return map\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          publicKey: uint8ArrayAlloc(0),\n          payloadType: uint8ArrayAlloc(0),\n          payload: uint8ArrayAlloc(0),\n          signature: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.payloadType = reader.bytes()\n              break\n            }\n            case 3: {\n              obj.payload = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.signature = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Envelope>): Envelope => {\n    return decodeMessage(buf, Envelope.codec(), opts)\n  }\n}\n", "/**\n * The key in the record is not valid for the domain\n */\nexport class InvalidSignatureError extends Error {\n  constructor (message = 'Invalid signature') {\n    super(message)\n    this.name = 'InvalidSignatureError'\n  }\n}\n", "import { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { Envelope as Protobuf } from './envelope.js'\nimport { InvalidSignatureError } from './errors.js'\nimport type { Record, Envelope, PrivateKey, PublicKey } from '@libp2p/interface'\n\nexport interface RecordEnvelopeInit {\n  publicKey: PublicKey\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const publicKey = publicKeyFromProtobuf(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      publicKey,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, privateKey: PrivateKey): Promise<RecordEnvelope> => {\n    if (privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const signature = await privateKey.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      publicKey: privateKey.publicKey,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshalled envelope.\n   * Data is unmarshalled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new InvalidSignatureError('Envelope signature is not valid for the given domain')\n    }\n\n    return envelope\n  }\n\n  public publicKey: PublicKey\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { publicKey, payloadType, payload, signature } = init\n\n    this.publicKey = publicKey\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: publicKeyToProtobuf(this.publicKey),\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    return this.publicKey.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals (a: any[], b: any[]): boolean {\n  const sort = (a: any, b: any): number => a.toString().localeCompare(b.toString())\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  b.sort(sort)\n\n  return a.sort(sort).every((item, index) => b[index].equals(item))\n}\n", "// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record'\n\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1])\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            multiaddr: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.multiaddr = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<AddressInfo>): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          peerId: uint8ArrayAlloc(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.peerId = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.seq = reader.uint64()\n              break\n            }\n            case 3: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerRecord>): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec(), opts)\n  }\n}\n", "import { peerIdFromMultihash } from '@libp2p/peer-id'\nimport { arrayEquals } from '@libp2p/utils/array-equals'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport * as Digest from 'multiformats/hashes/digest'\nimport {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} from './consts.js'\nimport { PeerRecord as Protobuf } from './peer-record.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecordInit {\n  peerId: PeerId\n\n  /**\n   * Addresses of the associated peer.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  seqNumber?: bigint\n}\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n  /**\n   * Unmarshal Peer Record Protobuf\n   */\n  static createFromProtobuf = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    const peerRecord = Protobuf.decode(buf)\n    const peerId = peerIdFromMultihash(Digest.decode(peerRecord.peerId))\n    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr))\n    const seqNumber = peerRecord.seq\n\n    return new PeerRecord({ peerId, multiaddrs, seqNumber })\n  }\n\n  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n  public peerId: PeerId\n  public multiaddrs: Multiaddr[]\n  public seqNumber: bigint\n  public domain = PeerRecord.DOMAIN\n  public codec = PeerRecord.CODEC\n  private marshaled?: Uint8Array\n\n  constructor (init: PeerRecordInit) {\n    const { peerId, multiaddrs, seqNumber } = init\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs ?? []\n    this.seqNumber = seqNumber ?? BigInt(Date.now())\n  }\n\n  /**\n   * Marshal a record to be used in an envelope\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        peerId: this.peerId.toMultihash().bytes,\n        seq: BigInt(this.seqNumber),\n        addresses: this.multiaddrs.map((m) => ({\n          multiaddr: m.bytes\n        }))\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`\n   */\n  equals (other: unknown): boolean {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export const nanoid = (size: number = 21): string => {\n  return Math.random().toString().substring(2)\n}\n", "import observer from 'observable-webworkers'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} from './constants.js'\nimport { nanoid } from './utils.js'\nimport type { MorticeImplementation, MorticeOptions, Release } from './index.js'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: string, requestType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data.type !== requestType) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async (): Promise<void> => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          })\n\n          // wait for worker to finish\n          await new Promise<void>((resolve) => {\n            const releaseEventListener = (event: MessageEvent): void => {\n              if (event?.data == null) {\n                return\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              }\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener)\n                resolve()\n              }\n            }\n\n            worker.addEventListener('message', releaseEventListener)\n          })\n        }\n      }\n    }))\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, grantType: string, releaseType: string) => {\n  return async () => {\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise<Release>((resolve) => {\n      const listener = (event: MessageEvent): void => {\n        if (event?.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\nimport PQueue from 'p-queue'\nimport pTimeout from 'p-timeout'\nimport impl from './node.js'\n\nexport interface MorticeOptions {\n  name?: string\n  timeout?: number\n  concurrency?: number\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock(): Promise<Release>\n  writeLock(): Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nexport interface MorticeImplementation {\n  isWorker: boolean\n  readLock(name: string, options: MorticeOptions): Mortice['readLock']\n  writeLock(name: string, options: MorticeOptions): Mortice['writeLock']\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options: Required<MorticeOptions>): Promise<Release> {\n  let res: (release: Release) => void\n\n  const p = new Promise<Release>((resolve) => {\n    res = resolve\n  })\n\n  void queue.add(async () => pTimeout((async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), {\n    milliseconds: options.timeout\n  }))\n\n  return p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock () {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock () {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler(): Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].readLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].writeLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { type Codec, decodeMessage, type DecodeOptions, encodeMessage, MaxLengthError, MaxSizeError, message } from 'protons-runtime'\nimport { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  publicKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n  metadata: Map<string, Uint8Array>\n  tags: Map<string, Tag>\n}\n\nexport namespace Peer {\n  export interface Peer$metadataEntry {\n    key: string\n    value: Uint8Array\n  }\n\n  export namespace Peer$metadataEntry {\n    let _codec: Codec<Peer$metadataEntry>\n\n    export const codec = (): Codec<Peer$metadataEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$metadataEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if ((obj.value != null && obj.value.byteLength > 0)) {\n            w.uint32(18)\n            w.bytes(obj.value)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: '',\n            value: uint8ArrayAlloc(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$metadataEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$metadataEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$metadataEntry>): Peer$metadataEntry => {\n      return decodeMessage(buf, Peer$metadataEntry.codec(), opts)\n    }\n  }\n\n  export interface Peer$tagsEntry {\n    key: string\n    value?: Tag\n  }\n\n  export namespace Peer$tagsEntry {\n    let _codec: Codec<Peer$tagsEntry>\n\n    export const codec = (): Codec<Peer$tagsEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$tagsEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if (obj.value != null) {\n            w.uint32(18)\n            Tag.codec().encode(obj.value, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            key: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.key = reader.string()\n                break\n              }\n              case 2: {\n                obj.value = Tag.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.value\n                })\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$tagsEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$tagsEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer$tagsEntry>): Peer$tagsEntry => {\n      return decodeMessage(buf, Peer$tagsEntry.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(34)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (obj.metadata != null && obj.metadata.size !== 0) {\n          for (const [key, value] of obj.metadata.entries()) {\n            w.uint32(50)\n            Peer.Peer$metadataEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.tags != null && obj.tags.size !== 0) {\n          for (const [key, value] of obj.tags.entries()) {\n            w.uint32(58)\n            Peer.Peer$tagsEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: new Map<string, Uint8Array>(),\n          tags: new Map<string, undefined>()\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.addresses != null && obj.addresses.length === opts.limits.addresses) {\n                throw new MaxLengthError('Decode error - map field \"addresses\" had too many elements')\n              }\n\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.addresses$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.protocols != null && obj.protocols.length === opts.limits.protocols) {\n                throw new MaxLengthError('Decode error - map field \"protocols\" had too many elements')\n              }\n\n              obj.protocols.push(reader.string())\n              break\n            }\n            case 4: {\n              obj.publicKey = reader.bytes()\n              break\n            }\n            case 5: {\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            }\n            case 6: {\n              if (opts.limits?.metadata != null && obj.metadata.size === opts.limits.metadata) {\n                throw new MaxSizeError('Decode error - map field \"metadata\" had too many elements')\n              }\n\n              const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32())\n              obj.metadata.set(entry.key, entry.value)\n              break\n            }\n            case 7: {\n              if (opts.limits?.tags != null && obj.tags.size === opts.limits.tags) {\n                throw new MaxSizeError('Decode error - map field \"tags\" had too many elements')\n              }\n\n              const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {\n                limits: {\n                  value: opts.limits?.tags$value\n                }\n              })\n              obj.tags.set(entry.key, entry.value)\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Peer>): Peer => {\n    return decodeMessage(buf, Peer.codec(), opts)\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          multiaddr: uint8ArrayAlloc(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.multiaddr = reader.bytes()\n              break\n            }\n            case 2: {\n              obj.isCertified = reader.bool()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Address>): Address => {\n    return decodeMessage(buf, Address.codec(), opts)\n  }\n}\n\nexport interface Tag {\n  value: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.value != null && obj.value !== 0)) {\n          w.uint32(8)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(16)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          value: 0\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.value = reader.uint32()\n              break\n            }\n            case 2: {\n              obj.expiry = reader.uint64()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Tag>): Tag => {\n    return decodeMessage(buf, Tag.codec(), opts)\n  }\n}\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { peerIdFromPublicKey } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Peer, Tag } from '@libp2p/interface'\n\nexport function bytesToPeer (peerId: PeerId, buf: Uint8Array): Peer {\n  const peer = PeerPB.decode(buf)\n\n  if (peer.publicKey != null && peerId.publicKey == null) {\n    const publicKey = publicKeyFromProtobuf(peer.publicKey)\n    peerId = peerIdFromPublicKey(publicKey)\n  }\n\n  const tags = new Map<string, Tag>()\n\n  // remove any expired tags\n  const now = BigInt(Date.now())\n\n  for (const [key, tag] of peer.tags.entries()) {\n    if (tag.expiry != null && tag.expiry < now) {\n      continue\n    }\n\n    tags.set(key, tag)\n  }\n\n  return {\n    ...peer,\n    id: peerId,\n    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {\n      return {\n        multiaddr: multiaddr(ma),\n        isCertified: isCertified ?? false\n      }\n    }),\n    metadata: peer.metadata,\n    peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n    tags\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/344502982398')\n   * ```\n   */\n  static random (): Key {\n    return new Key(Math.random().toString().substring(2))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { isPeerId, type PeerId } from '@libp2p/interface'\nimport { Key } from 'interface-datastore/key'\n\nexport const NAMESPACE_COMMON = '/peers/'\n\nexport function peerIdToDatastoreKey (peerId: PeerId): Key {\n  if (!isPeerId(peerId) || peerId.type == null) {\n    throw new InvalidParametersError('Invalid PeerId')\n  }\n\n  const b32key = peerId.toCID().toString()\n  return new Key(`${NAMESPACE_COMMON}${b32key}`)\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\nimport type { AddressFilter } from '../index.js'\nimport type { Address as AddressPB } from '../pb/peer.js'\nimport type { PeerId, Address } from '@libp2p/interface'\n\nexport async function dedupeFilterAndSortAddresses (peerId: PeerId, filter: AddressFilter, addresses: Array<Address | AddressPB | undefined>): Promise<AddressPB[]> {\n  const addressMap = new Map<string, Address>()\n\n  for (const addr of addresses) {\n    if (addr == null) {\n      continue\n    }\n\n    if (addr.multiaddr instanceof Uint8Array) {\n      addr.multiaddr = multiaddr(addr.multiaddr)\n    }\n\n    if (!isMultiaddr(addr.multiaddr)) {\n      throw new InvalidParametersError('Multiaddr was invalid')\n    }\n\n    if (!(await filter(peerId, addr.multiaddr))) {\n      continue\n    }\n\n    const isCertified = addr.isCertified ?? false\n    const maStr = addr.multiaddr.toString()\n    const existingAddr = addressMap.get(maStr)\n\n    if (existingAddr != null) {\n      addr.isCertified = existingAddr.isCertified || isCertified\n    } else {\n      addressMap.set(maStr, {\n        multiaddr: addr.multiaddr,\n        isCertified\n      })\n    }\n  }\n\n  return [...addressMap.values()]\n    .sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n    })\n    .map(({ isCertified, multiaddr }) => ({\n      isCertified,\n      multiaddr: multiaddr.bytes\n    }))\n}\n", "import { publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidParametersError } from '@libp2p/interface'\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Tag, Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Address, Peer, PeerData, TagOptions } from '@libp2p/interface'\n\nexport interface ToPBPeerOptions {\n  addressFilter?: AddressFilter\n  existingPeer?: Peer\n}\n\nexport async function toPeerPB (peerId: PeerId, data: Partial<PeerData>, strategy: 'merge' | 'patch', options: ToPBPeerOptions): Promise<PeerPB> {\n  if (data == null) {\n    throw new InvalidParametersError('Invalid PeerData')\n  }\n\n  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {\n    throw new InvalidParametersError('publicKey bytes do not match peer id publicKey bytes')\n  }\n\n  const existingPeer = options.existingPeer\n\n  if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n    throw new InvalidParametersError('peer id did not match existing peer id')\n  }\n\n  let addresses: Address[] = existingPeer?.addresses ?? []\n  let protocols = new Set<string>(existingPeer?.protocols ?? [])\n  let metadata: Map<string, Uint8Array> = existingPeer?.metadata ?? new Map()\n  let tags: Map<string, Tag> = existingPeer?.tags ?? new Map()\n  let peerRecordEnvelope: Uint8Array | undefined = existingPeer?.peerRecordEnvelope\n\n  // when patching, we replace the original fields with passed values\n  if (strategy === 'patch') {\n    if (data.multiaddrs != null || data.addresses != null) {\n      addresses = []\n\n      if (data.multiaddrs != null) {\n        addresses.push(...data.multiaddrs.map(multiaddr => ({\n          isCertified: false,\n          multiaddr\n        })))\n      }\n\n      if (data.addresses != null) {\n        addresses.push(...data.addresses)\n      }\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set(data.protocols)\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      metadata = createSortedMap(metadataEntries, {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n\n      tags = createSortedMap(tagsEntries, {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  // when merging, we join the original fields with passed values\n  if (strategy === 'merge') {\n    if (data.multiaddrs != null) {\n      addresses.push(...data.multiaddrs.map(multiaddr => ({\n        isCertified: false,\n        multiaddr\n      })))\n    }\n\n    if (data.addresses != null) {\n      addresses.push(...data.addresses)\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set([...protocols, ...data.protocols])\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      for (const [key, value] of metadataEntries) {\n        if (value == null) {\n          metadata.delete(key)\n        } else {\n          metadata.set(key, value)\n        }\n      }\n\n      metadata = createSortedMap([...metadata.entries()], {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n      const mergedTags = new Map<string, Tag | TagOptions>(tags)\n\n      for (const [key, value] of tagsEntries) {\n        if (value == null) {\n          mergedTags.delete(key)\n        } else {\n          mergedTags.set(key, value)\n        }\n      }\n\n      tags = createSortedMap([...mergedTags.entries()], {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  let publicKey: Uint8Array | undefined\n\n  if (existingPeer?.id.publicKey != null) {\n    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey)\n  } else if (data.publicKey != null) {\n    publicKey = publicKeyToProtobuf(data.publicKey)\n  } else if (peerId.publicKey != null) {\n    publicKey = publicKeyToProtobuf(peerId.publicKey)\n  }\n\n  const output: PeerPB = {\n    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),\n    protocols: [...protocols.values()].sort((a, b) => {\n      return a.localeCompare(b)\n    }),\n    metadata,\n    tags,\n    publicKey,\n    peerRecordEnvelope\n  }\n\n  // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n  if (peerId.type !== 'RSA') {\n    delete output.publicKey\n  }\n\n  return output\n}\n\ninterface CreateSortedMapOptions <V, R = V> {\n  validate(key: string, value: V): void\n  map?(key: string, value: V): R\n}\n\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap <V, R = V> (entries: Array<[string, V | undefined]>, options: CreateSortedMapOptions<V, R>): Map<string, R> {\n  const output = new Map()\n\n  for (const [key, value] of entries) {\n    if (value == null) {\n      continue\n    }\n\n    options.validate(key, value)\n  }\n\n  for (const [key, value] of entries.sort(([a], [b]) => {\n    return a.localeCompare(b)\n  })) {\n    if (value != null) {\n      output.set(key, options.map?.(key, value) ?? value)\n    }\n  }\n\n  return output\n}\n\nfunction validateMetadata (key: string, value: Uint8Array): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Metadata key must be a string')\n  }\n\n  if (!(value instanceof Uint8Array)) {\n    throw new InvalidParametersError('Metadata value must be a Uint8Array')\n  }\n}\n\nfunction validateTag (key: string, tag: TagOptions): void {\n  if (typeof key !== 'string') {\n    throw new InvalidParametersError('Tag name must be a string')\n  }\n\n  if (tag.value != null) {\n    if (parseInt(`${tag.value}`, 10) !== tag.value) {\n      throw new InvalidParametersError('Tag value must be an integer')\n    }\n\n    if (tag.value < 0 || tag.value > 100) {\n      throw new InvalidParametersError('Tag value must be between 0-100')\n    }\n  }\n\n  if (tag.ttl != null) {\n    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n      throw new InvalidParametersError('Tag ttl must be an integer')\n    }\n\n    if (tag.ttl < 0) {\n      throw new InvalidParametersError('Tag ttl must be between greater than 0')\n    }\n  }\n}\n\nfunction mapTag (key: string, tag: any): Tag {\n  let expiry: bigint | undefined\n\n  if (tag.expiry != null) {\n    expiry = tag.expiry\n  }\n\n  if (tag.ttl != null) {\n    expiry = BigInt(Date.now() + Number(tag.ttl))\n  }\n\n  return {\n    value: tag.value ?? 0,\n    expiry\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport mortice, { type Mortice } from 'mortice'\nimport { base32 } from 'multiformats/bases/base32'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { Peer as PeerPB } from './pb/peer.js'\nimport { bytesToPeer } from './utils/bytes-to-peer.js'\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js'\nimport { toPeerPB } from './utils/to-peer-pb.js'\nimport type { AddressFilter, PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js'\nimport type { PeerUpdate as PeerUpdateExternal, PeerId, Peer, PeerData, PeerQuery, Logger } from '@libp2p/interface'\nimport type { Datastore, Key, Query } from 'interface-datastore'\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate extends PeerUpdateExternal {\n  updated: boolean\n}\n\nfunction decodePeer (key: Key, value: Uint8Array): Peer {\n  // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n  const base32Str = key.toString().split('/')[2]\n  const buf = CID.parse(base32Str, base32)\n  const peerId = peerIdFromCID(buf)\n\n  return bytesToPeer(peerId, value)\n}\n\nfunction mapQuery (query: PeerQuery): Query {\n  if (query == null) {\n    return {}\n  }\n\n  return {\n    prefix: NAMESPACE_COMMON,\n    filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n      return fn(decodePeer(key, value))\n    }),\n    orders: (query.orders ?? []).map(fn => (a, b) => {\n      return fn(decodePeer(a.key, a.value), decodePeer(b.key, b.value))\n    })\n  }\n}\n\nexport class PersistentStore {\n  private readonly peerId: PeerId\n  private readonly datastore: Datastore\n  public readonly lock: Mortice\n  private readonly addressFilter?: AddressFilter\n  private readonly log: Logger\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.peerId = components.peerId\n    this.datastore = components.datastore\n    this.addressFilter = init.addressFilter\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    })\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    return this.datastore.has(peerIdToDatastoreKey(peerId))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      throw new InvalidParametersError('Cannot delete self peer')\n    }\n\n    await this.datastore.delete(peerIdToDatastoreKey(peerId))\n  }\n\n  async load (peerId: PeerId): Promise<Peer> {\n    const buf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n\n    return bytesToPeer(peerId, buf)\n  }\n\n  async save (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async patch (peerId: PeerId, data: Partial<PeerData>): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async merge (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'merge', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async * all (query?: PeerQuery): AsyncGenerator<Peer, void, unknown> {\n    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}))) {\n      const peer = decodePeer(key, value)\n\n      if (peer.id.equals(this.peerId)) {\n        // Skip self peer if present\n        continue\n      }\n\n      yield peer\n    }\n  }\n\n  async #findExistingPeer (peerId: PeerId): Promise<{ existingBuf?: Uint8Array, existingPeer?: Peer }> {\n    try {\n      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n      const existingPeer = bytesToPeer(peerId, existingBuf)\n\n      return {\n        existingBuf,\n        existingPeer\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        this.log.error('invalid peer data found in peer store - %e', err)\n      }\n    }\n\n    return {}\n  }\n\n  async #saveIfDifferent (peerId: PeerId, peer: PeerPB, existingBuf?: Uint8Array, existingPeer?: Peer): Promise<PeerUpdate> {\n    const buf = PeerPB.encode(peer)\n\n    if (existingBuf != null && uint8ArrayEquals(buf, existingBuf)) {\n      return {\n        peer: bytesToPeer(peerId, buf),\n        previous: existingPeer,\n        updated: false\n      }\n    }\n\n    await this.datastore.put(peerIdToDatastoreKey(peerId), buf)\n\n    return {\n      peer: bytesToPeer(peerId, buf),\n      previous: existingPeer,\n      updated: true\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The peer store is where libp2p stores data about the peers it has encountered on the network.\n */\n\nimport { peerIdFromCID } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport all from 'it-all'\nimport { PersistentStore, type PeerUpdate } from './store.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore, Peer, PeerData, PeerQuery } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Return true to allow storing the passed multiaddr for the passed peer\n */\nexport interface AddressFilter {\n  (peerId: PeerId, multiaddr: Multiaddr): Promise<boolean> | boolean\n}\n\nexport interface PersistentPeerStoreInit {\n  addressFilter?: AddressFilter\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nclass PersistentPeerStore implements PeerStore {\n  private readonly store: PersistentStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly peerId: PeerId\n  private readonly log: Logger\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.events = components.events\n    this.peerId = components.peerId\n    this.store = new PersistentStore(components, init)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-store'\n\n  async forEach (fn: (peer: Peer,) => void, query?: PeerQuery): Promise<void> {\n    this.log.trace('forEach await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('forEach got read lock')\n\n    try {\n      for await (const peer of this.store.all(query)) {\n        fn(peer)\n      }\n    } finally {\n      this.log.trace('forEach release read lock')\n      release()\n    }\n  }\n\n  async all (query?: PeerQuery): Promise<Peer[]> {\n    this.log.trace('all await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('all got read lock')\n\n    try {\n      return await all(this.store.all(query))\n    } finally {\n      this.log.trace('all release read lock')\n      release()\n    }\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    this.log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('delete got write lock')\n\n    try {\n      await this.store.delete(peerId)\n    } finally {\n      this.log.trace('delete release write lock')\n      release()\n    }\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    this.log.trace('has await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('has got read lock')\n\n    try {\n      return await this.store.has(peerId)\n    } finally {\n      this.log.trace('has release read lock')\n      release()\n    }\n  }\n\n  async get (peerId: PeerId): Promise<Peer> {\n    this.log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('get got read lock')\n\n    try {\n      return await this.store.load(peerId)\n    } finally {\n      this.log.trace('get release read lock')\n      release()\n    }\n  }\n\n  async save (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('save await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('save got write lock')\n\n    try {\n      const result = await this.store.save(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('save release write lock')\n      release()\n    }\n  }\n\n  async patch (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('patch await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('patch got write lock')\n\n    try {\n      const result = await this.store.patch(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('patch release write lock')\n      release()\n    }\n  }\n\n  async merge (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('merge await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('merge got write lock')\n\n    try {\n      const result = await this.store.merge(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('merge release write lock')\n      release()\n    }\n  }\n\n  async consumePeerRecord (buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean> {\n    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN)\n    const peerId = peerIdFromCID(envelope.publicKey.toCID())\n\n    if (expectedPeer?.equals(peerId) === false) {\n      this.log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, peerId)\n      return false\n    }\n\n    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.get(peerId)\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    // ensure seq is greater than, or equal to, the last received\n    if (peer?.peerRecordEnvelope != null) {\n      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n      if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n        this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n        return false\n      }\n    }\n\n    await this.patch(peerRecord.peerId, {\n      peerRecordEnvelope: buf,\n      addresses: peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n    })\n\n    return true\n  }\n\n  #emitIfUpdated (id: PeerId, result: PeerUpdate): void {\n    if (!result.updated) {\n      return\n    }\n\n    if (this.peerId.equals(id)) {\n      this.events.safeDispatchEvent('self:peer:update', { detail: result })\n    } else {\n      this.events.safeDispatchEvent('peer:update', { detail: result })\n    }\n  }\n}\n\nexport function persistentPeerStore (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}): PeerStore {\n  return new PersistentPeerStore(components, init)\n}\n", "export class OpenFailedError extends Error {\n  static name = 'OpenFailedError'\n  static code = 'ERR_OPEN_FAILED'\n  name = OpenFailedError.name\n  code = OpenFailedError.code\n\n  constructor (message = 'Open failed') {\n    super(message)\n  }\n}\n\nexport class CloseFailedError extends Error {\n  static name = 'CloseFailedError'\n  static code = 'ERR_CLOSE_FAILED'\n  name = CloseFailedError.name\n  code = CloseFailedError.code\n\n  constructor (message = 'Close failed') {\n    super(message)\n  }\n}\n\nexport class PutFailedError extends Error {\n  static name = 'PutFailedError'\n  static code = 'ERR_PUT_FAILED'\n  name = PutFailedError.name\n  code = PutFailedError.code\n\n  constructor (message = 'Put failed') {\n    super(message)\n  }\n}\n\nexport class GetFailedError extends Error {\n  static name = 'GetFailedError'\n  static code = 'ERR_GET_FAILED'\n  name = GetFailedError.name\n  code = GetFailedError.code\n\n  constructor (message = 'Get failed') {\n    super(message)\n  }\n}\n\nexport class DeleteFailedError extends Error {\n  static name = 'DeleteFailedError'\n  static code = 'ERR_DELETE_FAILED'\n  name = DeleteFailedError.name\n  code = DeleteFailedError.code\n\n  constructor (message = 'Delete failed') {\n    super(message)\n  }\n}\n\nexport class HasFailedError extends Error {\n  static name = 'HasFailedError'\n  static code = 'ERR_HAS_FAILED'\n  name = HasFailedError.name\n  code = HasFailedError.code\n\n  constructor (message = 'Has failed') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not Found') {\n    super(message)\n  }\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  static code = 'ERR_ABORTED'\n  name = AbortError.name\n  code = AbortError.code\n\n  constructor (message = 'Aborted') {\n    super(message)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything\n */\nfunction drain (source: Iterable<unknown>): void\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void>\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void> | void {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    })()\n  } else {\n    for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n  }\n}\n\nexport default drain\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import { Key } from 'interface-datastore/key'\nimport { NotFoundError } from 'interface-store'\nimport { BaseDatastore } from './base.js'\nimport type { Pair } from 'interface-datastore'\nimport type { Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array): Await<Key> { // eslint-disable-line require-await\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key): Await<Uint8Array> {\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw new NotFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key): Await<boolean> { // eslint-disable-line require-await\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key): Await<void> { // eslint-disable-line require-await\n    this.data.delete(key.toString())\n  }\n\n  * _all (): AwaitIterable<Pair> {\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n    }\n  }\n\n  * _allKeys (): AwaitIterable<Key> {\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n    }\n  }\n}\n", "import type { Startable } from '@libp2p/interface'\n\nexport interface DebouncedFunction extends Startable {\n  (): void\n}\n\n/**\n * Returns a function wrapper that will only call the passed function once\n *\n * Important - the passed function should not throw or reject\n */\nexport function debounce (func: () => void | Promise<void>, wait: number): DebouncedFunction {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  const output = function (): void {\n    const later = function (): void {\n      timeout = undefined\n      void func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n  output.start = () => {}\n  output.stop = () => {\n    clearTimeout(timeout)\n  }\n\n  return output\n}\n", "import { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { Netmask } from 'netmask'\n\nconst PRIVATE_IP_RANGES = [\n  '0.0.0.0/8',\n  '10.0.0.0/8',\n  '100.64.0.0/10',\n  '127.0.0.0/8',\n  '169.254.0.0/16',\n  '172.16.0.0/12',\n  '192.0.0.0/24',\n  '192.0.0.0/29',\n  '192.0.0.8/32',\n  '192.0.0.9/32',\n  '192.0.0.10/32',\n  '192.0.0.170/32',\n  '192.0.0.171/32',\n  '192.0.2.0/24',\n  '192.31.196.0/24',\n  '192.52.193.0/24',\n  '192.88.99.0/24',\n  '192.168.0.0/16',\n  '192.175.48.0/24',\n  '198.18.0.0/15',\n  '198.51.100.0/24',\n  '203.0.113.0/24',\n  '240.0.0.0/4',\n  '255.255.255.255/32'\n]\n\nconst NETMASK_RANGES = PRIVATE_IP_RANGES.map(ipRange => new Netmask(ipRange))\n\nfunction ipv4Check (ipAddr: string): boolean {\n  for (const r of NETMASK_RANGES) {\n    if (r.contains(ipAddr)) return true\n  }\n\n  return false\n}\n\nfunction isIpv4MappedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.5.5.2\n */\nfunction ipv4MappedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n\n  if (parts.length < 2) {\n    return false\n  }\n\n  const octet34 = parts[parts.length - 1].padStart(4, '0')\n  const octet12 = parts[parts.length - 2].padStart(4, '0')\n\n  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`\n\n  return ipv4Check(ip4)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc4291#section-2.2 example 3\n */\nfunction isIpv4EmbeddedIpv6 (ipAddr: string): boolean {\n  return /^::ffff:([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr)\n}\n\nfunction ipv4EmbeddedIpv6Check (ipAddr: string): boolean {\n  const parts = ipAddr.split(':')\n  const ip4 = parts[parts.length - 1]\n\n  return ipv4Check(ip4)\n}\n\nfunction ipv6Check (ipAddr: string): boolean {\n  return /^::$/.test(ipAddr) ||\n    /^::1$/.test(ipAddr) ||\n    /^64:ff9b::([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/.test(ipAddr) ||\n    /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) ||\n    /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) ||\n    /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) ||\n    /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr)\n}\n\nexport function isPrivateIp (ip: string): boolean | undefined {\n  if (isIPv4(ip)) return ipv4Check(ip)\n  else if (isIpv4MappedIpv6(ip)) return ipv4MappedIpv6Check(ip)\n  else if (isIpv4EmbeddedIpv6(ip)) return ipv4EmbeddedIpv6Check(ip)\n  else if (isIPv6(ip)) return ipv6Check(ip)\n  else return undefined\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nconst MAX_DATE = 8_640_000_000_000_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface DNSMapping {\n  domain: string\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nconst CODEC_TLS = 0x01c0\nconst CODEC_SNI = 0x01c1\nconst CODEC_DNS = 0x35\nconst CODEC_DNS4 = 0x36\nconst CODEC_DNS6 = 0x37\nconst CODEC_DNSADDR = 0x38\n\nexport class DNSMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, DNSMapping>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:dns-mappings')\n    this.mappings = new Map()\n  }\n\n  has (ma: Multiaddr): boolean {\n    const host = this.findHost(ma)\n\n    for (const mapping of this.mappings.values()) {\n      if (mapping.domain === host) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  add (domain: string, addresses: string[]): void {\n    addresses.forEach(ip => {\n      this.log('add DNS mapping %s to %s', ip, domain)\n      // we are only confident if this is an local domain mapping, otherwise\n      // we will require external validation\n      const verified = isPrivateIp(ip) === true\n\n      this.mappings.set(ip, {\n        domain,\n        verified,\n        expires: verified ? MAX_DATE - Date.now() : 0,\n        lastVerified: verified ? MAX_DATE - Date.now() : undefined\n      })\n    })\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const host = this.findHost(ma)\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('removing %s to %s DNS mapping %e', ip, mapping.domain, new Error('where'))\n        this.mappings.delete(ip)\n        wasConfident = wasConfident || mapping.verified\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const dnsMappedAddresses: NodeAddress[] = []\n\n    for (let i = 0; i < addresses.length; i++) {\n      const address = addresses[i]\n      const tuples = address.multiaddr.stringTuples()\n      const host = tuples[0][1]\n\n      if (host == null) {\n        continue\n      }\n\n      for (const [ip, mapping] of this.mappings.entries()) {\n        if (host !== ip) {\n          continue\n        }\n\n        // insert SNI tuple after TLS tuple, if one is present\n        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain)\n\n        if (mappedIp) {\n          // remove the address and replace it with the version that includes\n          // the SNI tuple\n          addresses.splice(i, 1)\n          i--\n\n          dnsMappedAddresses.push({\n            multiaddr: multiaddr(`/${\n              tuples.map(tuple => {\n                return [\n                  protocols(tuple[0]).name,\n                  tuple[1]\n                ].join('/')\n              }).join('/')\n            }`),\n            verified: mapping.verified,\n            type: 'dns-mapping',\n            expires: mapping.expires,\n            lastVerified: mapping.lastVerified\n          })\n        }\n      }\n    }\n\n    return dnsMappedAddresses\n  }\n\n  private maybeAddSNITuple (tuples: StringTuple[], domain: string): boolean {\n    for (let j = 0; j < tuples.length; j++) {\n      if (tuples[j][0] === CODEC_TLS && tuples[j + 1]?.[0] !== CODEC_SNI) {\n        tuples.splice(j + 1, 0, [CODEC_SNI, domain])\n        return true\n      }\n    }\n\n    return false\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const host = this.findHost(ma)\n    let startingConfidence = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('marking %s to %s DNS mapping as verified', ip, mapping.domain)\n        startingConfidence = mapping.verified\n        mapping.verified = true\n        mapping.expires = Date.now() + ttl\n        mapping.lastVerified = Date.now()\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const host = this.findHost(ma)\n    let wasConfident = false\n\n    for (const [ip, mapping] of this.mappings.entries()) {\n      if (mapping.domain === host) {\n        this.log('removing verification of %s to %s DNS mapping', ip, mapping.domain)\n        wasConfident = wasConfident || mapping.verified\n        mapping.verified = false\n        mapping.expires = Date.now() + ttl\n      }\n    }\n\n    return wasConfident\n  }\n\n  private findHost (ma: Multiaddr): string | undefined {\n    for (const tuple of ma.stringTuples()) {\n      if (tuple[0] === CODEC_SNI) {\n        return tuple[1]\n      }\n\n      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {\n        return tuple[1]\n      }\n    }\n  }\n}\n", "import { isIPv4 } from '@chainsafe/is-ip'\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface PublicAddressMapping {\n  internalIp: string\n  internalPort: number\n  externalIp: string\n  externalPort: number\n  externalFamily: 4 | 6\n  protocol: 'tcp' | 'udp'\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\nconst CODEC_TCP = 0x06\nconst CODEC_UDP = 0x0111\n\nexport class IPMappings {\n  private readonly log: Logger\n  private readonly mappings: Map<string, PublicAddressMapping[]>\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:ip-mappings')\n    this.mappings = new Map()\n  }\n\n  has (ma: Multiaddr): boolean {\n    const tuples = ma.stringTuples()\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        if (mapping.externalIp === tuples[0][1]) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  add (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    const key = `${internalIp}-${internalPort}-${protocol}`\n    const mappings = this.mappings.get(key) ?? []\n    const mapping: PublicAddressMapping = {\n      internalIp,\n      internalPort,\n      externalIp,\n      externalPort,\n      externalFamily: isIPv4(externalIp) ? 4 : 6,\n      protocol,\n      verified: false,\n      expires: 0\n    }\n    mappings.push(mapping)\n\n    this.mappings.set(key, mappings)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1] ?? ''\n    const protocol = tuples[1][0] === CODEC_TCP ? 'tcp' : 'udp'\n    const port = parseInt(tuples[1][1] ?? '0')\n    let wasConfident = false\n\n    for (const [key, mappings] of this.mappings.entries()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {\n          this.log('removing %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, host, port, protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mappings.splice(i, 1)\n          i--\n        }\n      }\n\n      if (mappings.length === 0) {\n        this.mappings.delete(key)\n      }\n    }\n\n    return wasConfident\n  }\n\n  getAll (addresses: NodeAddress[]): NodeAddress[] {\n    const ipMappedAddresses: NodeAddress[] = []\n\n    for (const { multiaddr: ma } of addresses) {\n      const tuples = ma.stringTuples()\n      let tuple: string | undefined\n\n      // see if the internal host/port/protocol tuple has been mapped externally\n      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {\n        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`\n      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {\n        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`\n      }\n\n      if (tuple == null) {\n        continue\n      }\n\n      const mappings = this.mappings.get(tuple)\n\n      if (mappings == null) {\n        continue\n      }\n\n      for (const mapping of mappings) {\n        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6\n        tuples[0][1] = mapping.externalIp\n        tuples[1][1] = `${mapping.externalPort}`\n\n        ipMappedAddresses.push({\n          multiaddr: multiaddr(`/${\n            tuples.map(tuple => {\n              return [\n                protocols(tuple[0]).name,\n                tuple[1]\n              ].join('/')\n            }).join('/')\n          }`),\n          verified: mapping.verified,\n          type: 'ip-mapping',\n          expires: mapping.expires,\n          lastVerified: mapping.lastVerified\n        })\n      }\n    }\n\n    return ipMappedAddresses\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1]\n    let startingConfidence = false\n\n    for (const mappings of this.mappings.values()) {\n      for (const mapping of mappings) {\n        // eslint-disable-next-line max-depth\n        if (mapping.externalIp === host) {\n          this.log('marking %s to %s IP mapping as verified', mapping.internalIp, mapping.externalIp)\n          startingConfidence = mapping.verified\n          mapping.verified = true\n          mapping.expires = Date.now() + ttl\n          mapping.lastVerified = Date.now()\n        }\n      }\n    }\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const tuples = ma.stringTuples()\n    const host = tuples[0][1] ?? ''\n    const protocol = tuples[1][0] === CODEC_TCP ? 'tcp' : 'udp'\n    const port = parseInt(tuples[1][1] ?? '0')\n    let wasConfident = false\n\n    for (const mappings of this.mappings.values()) {\n      for (let i = 0; i < mappings.length; i++) {\n        const mapping = mappings[i]\n\n        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {\n          this.log('removing verification of %s:%s to %s:%s %s IP mapping', mapping.externalIp, mapping.externalPort, host, port, protocol)\n\n          wasConfident = wasConfident || mapping.verified\n          mapping.verified = false\n          mapping.expires = Date.now() + ttl\n        }\n      }\n    }\n\n    return wasConfident\n  }\n}\n", "import type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Check if a given multiaddr is a link-local address\n */\nexport function isLinkLocal (ma: Multiaddr): boolean {\n  try {\n    const [[codec, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return false\n    }\n\n    if (codec === CODEC_IP4) {\n      return value.startsWith('169.254.')\n    }\n\n    if (codec === CODEC_IP6) {\n      return value.toLowerCase().startsWith('fe80')\n    }\n  } catch {\n\n  }\n\n  return false\n}\n", "import { isPrivateIp } from '../private-ip.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\nconst CODEC_DNS = 0x35\nconst CODEC_DNS4 = 0x36\nconst CODEC_DNS6 = 0x37\nconst CODEC_DNSADDR = 0x38\n\n/**\n * Check if a given multiaddr starts with a private address\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    const [[codec, value]] = ma.stringTuples()\n\n    if (value == null) {\n      return true\n    }\n\n    if (codec === CODEC_DNS || codec === CODEC_DNS4 || codec === CODEC_DNS6 || codec === CODEC_DNSADDR) {\n      return false\n    }\n\n    if (codec === CODEC_IP4 || codec === CODEC_IP6) {\n      return isPrivateIp(value) ?? false\n    }\n  } catch {\n\n  }\n\n  return true\n}\n", "import { isLinkLocal } from '@libp2p/utils/multiaddr/is-link-local'\nimport { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface ObservedAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class ObservedAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, ObservedAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = new Map()\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  has (ma: Multiaddr): boolean {\n    return this.addresses.has(ma.toString())\n  }\n\n  removePrefixed (prefix: string): void {\n    for (const key of this.addresses.keys()) {\n      if (key.toString().startsWith(prefix)) {\n        this.addresses.delete(key)\n      }\n    }\n  }\n\n  add (ma: Multiaddr): void {\n    if (this.addresses.size === this.maxObservedAddresses) {\n      return\n    }\n\n    if (isPrivate(ma) || isLinkLocal(ma)) {\n      return\n    }\n\n    this.log('adding observed address %a', ma)\n    this.addresses.set(ma.toString(), {\n      verified: false,\n      expires: 0\n    })\n  }\n\n  getAll (): NodeAddress[] {\n    return Array.from(this.addresses)\n      .map(([ma, metadata]) => ({\n        multiaddr: multiaddr(ma),\n        verified: metadata.verified,\n        type: 'observed',\n        expires: metadata.expires,\n        lastVerified: metadata.lastVerified\n      }))\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const startingConfidence = this.addresses.get(ma.toString())?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(ma.toString())\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const addrString = ma.toString()\n    const metadata = this.addresses.get(addrString) ?? {\n      verified: false,\n      expires: Date.now() + ttl,\n      lastVerified: Date.now()\n    }\n    const startingConfidence = metadata.verified\n    metadata.verified = true\n    metadata.lastVerified = Date.now()\n\n    this.log('marking observed address %a as verified', addrString)\n    this.addresses.set(addrString, metadata)\n\n    return startingConfidence\n  }\n}\n", "import { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport type { AddressManagerComponents, AddressManagerInit } from './index.js'\nimport type { Logger } from '@libp2p/interface'\nimport type { NodeAddress } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const defaultValues = {\n  maxObservedAddresses: 10\n}\n\ninterface TransportAddressMetadata {\n  verified: boolean\n  expires: number\n  lastVerified?: number\n}\n\nexport class TransportAddresses {\n  private readonly log: Logger\n  private readonly addresses: Map<string, TransportAddressMetadata>\n  private readonly maxObservedAddresses: number\n\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:address-manager:observed-addresses')\n    this.addresses = new Map()\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n  }\n\n  get (multiaddr: Multiaddr, ttl: number): NodeAddress {\n    if (isPrivate(multiaddr)) {\n      return {\n        multiaddr,\n        verified: true,\n        type: 'transport',\n        expires: Date.now() + ttl,\n        lastVerified: Date.now()\n      }\n    }\n\n    const key = this.toKey(multiaddr)\n    let metadata = this.addresses.get(key)\n\n    if (metadata == null) {\n      metadata = {\n        verified: false,\n        expires: 0\n      }\n\n      this.addresses.set(key, metadata)\n    }\n\n    return {\n      multiaddr,\n      verified: metadata.verified,\n      type: 'transport',\n      expires: metadata.expires,\n      lastVerified: metadata.lastVerified\n    }\n  }\n\n  has (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    return this.addresses.has(key)\n  }\n\n  remove (ma: Multiaddr): boolean {\n    const key = this.toKey(ma)\n    const startingConfidence = this.addresses.get(key)?.verified ?? false\n\n    this.log('removing observed address %a', ma)\n    this.addresses.delete(key)\n\n    return startingConfidence\n  }\n\n  confirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0,\n      lastVerified: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = true\n    metadata.expires = Date.now() + ttl\n    metadata.lastVerified = Date.now()\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  unconfirm (ma: Multiaddr, ttl: number): boolean {\n    const key = this.toKey(ma)\n    const metadata = this.addresses.get(key) ?? {\n      verified: false,\n      expires: 0\n    }\n\n    const startingConfidence = metadata.verified\n\n    metadata.verified = false\n    metadata.expires = Date.now() + ttl\n\n    this.addresses.set(key, metadata)\n\n    return startingConfidence\n  }\n\n  private toKey (ma: Multiaddr): string {\n    const options = ma.toOptions()\n\n    return `${options.host}-${options.port}-${options.transport}`\n  }\n}\n", "/* eslint-disable complexity */\nimport { isIPv4 } from '@chainsafe/is-ip'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { debounce } from '@libp2p/utils/debounce'\nimport { createScalableCuckooFilter } from '@libp2p/utils/filters'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { DNSMappings } from './dns-mappings.js'\nimport { IPMappings } from './ip-mappings.js'\nimport { ObservedAddresses } from './observed-addresses.js'\nimport { TransportAddresses } from './transport-addresses.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore } from '@libp2p/interface'\nimport type { AddressManager as AddressManagerInterface, TransportManager, NodeAddress, ConfirmAddressOptions } from '@libp2p/interface-internal'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst ONE_MINUTE = 60_000\n\nexport const defaultValues = {\n  maxObservedAddresses: 10,\n  addressVerificationTTL: ONE_MINUTE * 10,\n  addressVerificationRetry: ONE_MINUTE * 5\n}\n\nexport interface AddressManagerInit {\n  /**\n   * Pass an function in this field to override the list of addresses\n   * that are announced to the network\n   */\n  announceFilter?: AddressFilter\n\n  /**\n   * A list of string multiaddrs to listen on\n   */\n  listen?: string[]\n\n  /**\n   * A list of string multiaddrs to use instead of those reported by transports\n   */\n  announce?: string[]\n\n  /**\n   * A list of string multiaddrs string to never announce\n   */\n  noAnnounce?: string[]\n\n  /**\n   * A list of string multiaddrs to add to the list of announced addresses\n   */\n  appendAnnounce?: string[]\n\n  /**\n   * Limits the number of observed addresses we will store\n   */\n  maxObservedAddresses?: number\n\n  /**\n   * How long before each public address should be reverified in ms.\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 600_000\n   */\n  addressVerificationTTL?: number\n\n  /**\n   * After a transport or mapped address has failed to verify, how long to wait\n   * before retrying it in ms\n   *\n   * Requires `@libp2p/autonat` or some other verification method to be\n   * configured.\n   *\n   * @default 300_000\n   */\n  addressVerificationRetry?: number\n}\n\nexport interface AddressManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * A function that takes a list of multiaddrs and returns a list\n * to announce\n */\nexport interface AddressFilter {\n  (addrs: Multiaddr[]): Multiaddr[]\n}\n\nconst defaultAddressFilter = (addrs: Multiaddr[]): Multiaddr[] => addrs\n\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId (ma: Multiaddr, peerId: PeerId): Multiaddr {\n  const observedPeerIdStr = ma.getPeerId()\n\n  // strip our peer id if it has been passed\n  if (observedPeerIdStr != null) {\n    const observedPeerId = peerIdFromString(observedPeerIdStr)\n\n    // use same encoding for comparison\n    if (observedPeerId.equals(peerId)) {\n      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`))\n    }\n  }\n\n  return ma\n}\n\nexport class AddressManager implements AddressManagerInterface {\n  private readonly log: Logger\n  private readonly components: AddressManagerComponents\n  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n  private readonly listen: string[]\n  private readonly announce: Set<string>\n  private readonly appendAnnounce: Set<string>\n  private readonly announceFilter: AddressFilter\n  private readonly observed: ObservedAddresses\n  private readonly dnsMappings: DNSMappings\n  private readonly ipMappings: IPMappings\n  private readonly transportAddresses: TransportAddresses\n  private readonly observedAddressFilter: Filter\n  private readonly addressVerificationTTL: number\n  private readonly addressVerificationRetry: number\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   */\n  constructor (components: AddressManagerComponents, init: AddressManagerInit = {}) {\n    const { listen = [], announce = [], appendAnnounce = [] } = init\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:address-manager')\n    this.listen = listen.map(ma => ma.toString())\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.appendAnnounce = new Set(appendAnnounce.map(ma => ma.toString()))\n    this.observed = new ObservedAddresses(components, init)\n    this.dnsMappings = new DNSMappings(components, init)\n    this.ipMappings = new IPMappings(components, init)\n    this.transportAddresses = new TransportAddresses(components, init)\n    this.announceFilter = init.announceFilter ?? defaultAddressFilter\n    this.observedAddressFilter = createScalableCuckooFilter(1024)\n    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues.addressVerificationTTL\n    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues.addressVerificationRetry\n\n    // this method gets called repeatedly on startup when transports start listening so\n    // debounce it so we don't cause multiple self:peer:update events to be emitted\n    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000)\n\n    // update our stored addresses when new transports listen\n    components.events.addEventListener('transport:listening', () => {\n      this._updatePeerStoreAddresses()\n    })\n    // update our stored addresses when existing transports stop listening\n    components.events.addEventListener('transport:close', () => {\n      this._updatePeerStoreAddresses()\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/address-manager'\n\n  _updatePeerStoreAddresses (): void {\n    // if announce addresses have been configured, ensure they make it into our peer\n    // record for things like identify\n    const addrs = this.getAddresses()\n      .map(ma => {\n        // strip our peer id if it is present\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`)\n        }\n\n        return ma\n      })\n\n    this.components.peerStore.patch(this.components.peerId, {\n      multiaddrs: addrs\n    })\n      .catch(err => {\n        this.log.error('error updating addresses', err)\n      })\n  }\n\n  /**\n   * Get peer listen multiaddrs\n   */\n  getListenAddrs (): Multiaddr[] {\n    return Array.from(this.listen).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.announce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAppendAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.appendAnnounce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs\n   */\n  getObservedAddrs (): Multiaddr[] {\n    return this.observed.getAll().map(addr => addr.multiaddr)\n  }\n\n  /**\n   * Add peer observed addresses\n   */\n  addObservedAddr (addr: Multiaddr): void {\n    const tuples = addr.stringTuples()\n    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`\n\n    // ignore if this address if it's been observed before\n    if (this.observedAddressFilter.has(socketAddress)) {\n      return\n    }\n\n    this.observedAddressFilter.add(socketAddress)\n\n    addr = stripPeerId(addr, this.components.peerId)\n\n    // ignore observed address if it is an IP mapping\n    if (this.ipMappings.has(addr)) {\n      return\n    }\n\n    // ignore observed address if it is a DNS mapping\n    if (this.dnsMappings.has(addr)) {\n      return\n    }\n\n    this.observed.add(addr)\n  }\n\n  confirmObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    let startingConfidence = true\n\n    if (options?.type === 'observed' || this.observed.has(addr)) {\n      startingConfidence = this.observed.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n    }\n\n    if (options?.type === 'transport' || this.transportAddresses.has(addr)) {\n      startingConfidence = this.transportAddresses.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n    }\n\n    if (options?.type === 'dns-mapping' || this.dnsMappings.has(addr)) {\n      startingConfidence = this.dnsMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n    }\n\n    if (options?.type === 'ip-mapping' || this.ipMappings.has(addr)) {\n      startingConfidence = this.ipMappings.confirm(addr, options?.ttl ?? this.addressVerificationTTL)\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (!startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  removeObservedAddr (addr: Multiaddr, options?: ConfirmAddressOptions): void {\n    addr = stripPeerId(addr, this.components.peerId)\n\n    let startingConfidence = false\n\n    if (this.observed.has(addr)) {\n      startingConfidence = this.observed.remove(addr)\n    }\n\n    if (this.transportAddresses.has(addr)) {\n      startingConfidence = this.transportAddresses.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n    }\n\n    if (this.dnsMappings.has(addr)) {\n      startingConfidence = this.dnsMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n    }\n\n    if (this.ipMappings.has(addr)) {\n      startingConfidence = this.ipMappings.unconfirm(addr, options?.ttl ?? this.addressVerificationRetry)\n    }\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  getAddresses (): Multiaddr[] {\n    const addresses = new Set<string>()\n\n    const multiaddrs = this.getAddressesWithMetadata()\n      .filter(addr => {\n        if (!addr.verified) {\n          return false\n        }\n\n        const maStr = addr.multiaddr.toString()\n\n        if (addresses.has(maStr)) {\n          return false\n        }\n\n        addresses.add(maStr)\n\n        return true\n      })\n      .map(address => address.multiaddr)\n\n    // filter addressees before returning\n    return this.announceFilter(\n      multiaddrs.map(str => {\n        const ma = multiaddr(str)\n\n        // do not append our peer id to a path multiaddr as it will become invalid\n        if (ma.protos().pop()?.path === true) {\n          return ma\n        }\n\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`)\n      })\n    )\n  }\n\n  getAddressesWithMetadata (): NodeAddress[] {\n    const announceMultiaddrs = this.getAnnounceAddrs()\n\n    if (announceMultiaddrs.length > 0) {\n      return announceMultiaddrs.map(multiaddr => ({\n        multiaddr,\n        verified: true,\n        type: 'announce',\n        expires: Date.now() + this.addressVerificationTTL,\n        lastVerified: Date.now()\n      }))\n    }\n\n    let addresses: NodeAddress[] = []\n\n    // add transport addresses\n    addresses = addresses.concat(\n      this.components.transportManager.getAddrs()\n        .map(multiaddr => this.transportAddresses.get(multiaddr, this.addressVerificationTTL))\n    )\n\n    // add append announce addresses\n    addresses = addresses.concat(\n      this.getAppendAnnounceAddrs().map(multiaddr => ({\n        multiaddr,\n        verified: true,\n        type: 'announce',\n        expires: Date.now() + this.addressVerificationTTL,\n        lastVerified: Date.now()\n      }))\n    )\n\n    // add observed addresses\n    addresses = addresses.concat(\n      this.observed.getAll()\n    )\n\n    // add ip mapped addresses\n    addresses = addresses.concat(\n      this.ipMappings.getAll(addresses)\n    )\n\n    // add ip->domain mappings, must be done after IP mappings\n    addresses = addresses.concat(\n      this.dnsMappings.getAll(addresses)\n    )\n\n    return addresses\n  }\n\n  addDNSMapping (domain: string, addresses: string[]): void {\n    this.dnsMappings.add(domain, addresses)\n  }\n\n  removeDNSMapping (domain: string): void {\n    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  addPublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol)\n\n    // remove duplicate observed addresses\n    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`)\n  }\n\n  removePublicAddressMapping (internalIp: string, internalPort: number, externalIp: string, externalPort: number = internalPort, protocol: 'tcp' | 'udp' = 'tcp'): void {\n    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n}\n", "export enum messages {\n  NOT_STARTED_YET = 'The libp2p node is not started yet',\n  NOT_FOUND = 'Not found'\n}\n\nexport class MissingServiceError extends Error {\n  constructor (message = 'Missing service') {\n    super(message)\n    this.name = 'MissingServiceError'\n  }\n}\n\nexport class UnmetServiceDependenciesError extends Error {\n  constructor (message = 'Unmet service dependencies') {\n    super(message)\n    this.name = 'UnmetServiceDependenciesError'\n  }\n}\n\nexport class NoContentRoutersError extends Error {\n  constructor (message = 'No content routers available') {\n    super(message)\n    this.name = 'NoContentRoutersError'\n  }\n}\n\nexport class NoPeerRoutersError extends Error {\n  constructor (message = 'No peer routers available') {\n    super(message)\n    this.name = 'NoPeerRoutersError'\n  }\n}\n\nexport class QueriedForSelfError extends Error {\n  constructor (message = 'Should not try to find self') {\n    super(message)\n    this.name = 'QueriedForSelfError'\n  }\n}\n\nexport class UnhandledProtocolError extends Error {\n  constructor (message = 'Unhandled protocol error') {\n    super(message)\n    this.name = 'UnhandledProtocolError'\n  }\n}\n\nexport class DuplicateProtocolHandlerError extends Error {\n  constructor (message = 'Duplicate protocol handler error') {\n    super(message)\n    this.name = 'DuplicateProtocolHandlerError'\n  }\n}\n\nexport class DialDeniedError extends Error {\n  constructor (message = 'Dial denied error') {\n    super(message)\n    this.name = 'DialDeniedError'\n  }\n}\n\nexport class NoValidAddressesError extends Error {\n  constructor (message = 'No valid addresses') {\n    super(message)\n    this.name = 'NoValidAddressesError'\n  }\n}\n\nexport class ConnectionInterceptedError extends Error {\n  constructor (message = 'Connection intercepted') {\n    super(message)\n    this.name = 'ConnectionInterceptedError'\n  }\n}\n\nexport class ConnectionDeniedError extends Error {\n  constructor (message = 'Connection denied') {\n    super(message)\n    this.name = 'ConnectionDeniedError'\n  }\n}\n\nexport class MuxerUnavailableError extends Error {\n  constructor (message = 'Stream is not multiplexed') {\n    super(message)\n    this.name = 'MuxerUnavailableError'\n  }\n}\n\nexport class EncryptionFailedError extends Error {\n  constructor (message = 'Encryption failed') {\n    super(message)\n    this.name = 'EncryptionFailedError'\n  }\n}\n\nexport class TransportUnavailableError extends Error {\n  constructor (message = 'Transport unavailable') {\n    super(message)\n    this.name = 'TransportUnavailableError'\n  }\n}\n", "import { serviceCapabilities, serviceDependencies } from '@libp2p/interface'\nimport { isStartable, type Startable, type Libp2pEvents, type ComponentLogger, type NodeInfo, type ConnectionProtector, type ConnectionGater, type ContentRouting, type TypedEventTarget, type Metrics, type PeerId, type PeerRouting, type PeerStore, type PrivateKey, type Upgrader } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { MissingServiceError, UnmetServiceDependenciesError } from './errors.js'\nimport type { AddressManager, ConnectionManager, RandomWalk, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface Components extends Record<string, any>, Startable {\n  peerId: PeerId\n  privateKey: PrivateKey\n  nodeInfo: NodeInfo\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  addressManager: AddressManager\n  peerStore: PeerStore\n  upgrader: Upgrader\n  randomWalk: RandomWalk\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  contentRouting: ContentRouting\n  peerRouting: PeerRouting\n  datastore: Datastore\n  connectionProtector?: ConnectionProtector\n  metrics?: Metrics\n  dns?: DNS\n}\n\nexport interface ComponentsInit {\n  peerId?: PeerId\n  privateKey?: PrivateKey\n  nodeInfo?: NodeInfo\n  logger?: ComponentLogger\n  events?: TypedEventTarget<Libp2pEvents>\n  addressManager?: AddressManager\n  peerStore?: PeerStore\n  upgrader?: Upgrader\n  randomWalk?: RandomWalk\n  metrics?: Metrics\n  registrar?: Registrar\n  connectionManager?: ConnectionManager\n  transportManager?: TransportManager\n  connectionGater?: ConnectionGater\n  contentRouting?: ContentRouting\n  peerRouting?: PeerRouting\n  datastore?: Datastore\n  connectionProtector?: ConnectionProtector\n  dns?: DNS\n}\n\nclass DefaultComponents implements Startable {\n  public components: Record<string, any> = {}\n  private _started = false\n\n  constructor (init: ComponentsInit = {}) {\n    this.components = {}\n\n    for (const [key, value] of Object.entries(init)) {\n      this.components[key] = value\n    }\n\n    if (this.components.logger == null) {\n      this.components.logger = defaultLogger()\n    }\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  private async _invokeStartableMethod (methodName: 'beforeStart' | 'start' | 'afterStart' | 'beforeStop' | 'stop' | 'afterStop'): Promise<void> {\n    await Promise.all(\n      Object.values(this.components)\n        .filter(obj => isStartable(obj))\n        .map(async (startable: Startable) => {\n          await startable[methodName]?.()\n        })\n    )\n  }\n\n  async beforeStart (): Promise<void> {\n    await this._invokeStartableMethod('beforeStart')\n  }\n\n  async start (): Promise<void> {\n    await this._invokeStartableMethod('start')\n    this._started = true\n  }\n\n  async afterStart (): Promise<void> {\n    await this._invokeStartableMethod('afterStart')\n  }\n\n  async beforeStop (): Promise<void> {\n    await this._invokeStartableMethod('beforeStop')\n  }\n\n  async stop (): Promise<void> {\n    await this._invokeStartableMethod('stop')\n    this._started = false\n  }\n\n  async afterStop (): Promise<void> {\n    await this._invokeStartableMethod('afterStop')\n  }\n}\n\nconst OPTIONAL_SERVICES = [\n  'metrics',\n  'connectionProtector',\n  'dns'\n]\n\nconst NON_SERVICE_PROPERTIES = [\n  'components',\n  'isStarted',\n  'beforeStart',\n  'start',\n  'afterStart',\n  'beforeStop',\n  'stop',\n  'afterStop',\n  'then',\n  '_invokeStartableMethod'\n]\n\nexport function defaultComponents (init: ComponentsInit = {}): Components {\n  const components = new DefaultComponents(init)\n\n  const proxy = new Proxy(components, {\n    get (target, prop, receiver) {\n      if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n        const service = components.components[prop]\n\n        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n          throw new MissingServiceError(`${prop} not set`)\n        }\n\n        return service\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n\n    set (target, prop, value) {\n      if (typeof prop === 'string') {\n        components.components[prop] = value\n      } else {\n        Reflect.set(target, prop, value)\n      }\n\n      return true\n    }\n  })\n\n  // @ts-expect-error component keys are proxied\n  return proxy\n}\n\nexport function checkServiceDependencies (components: Components): void {\n  const serviceCapabilities: Record<string, ConstrainBoolean> = {}\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceCapabilities(service)) {\n      serviceCapabilities[capability] = true\n    }\n  }\n\n  for (const service of Object.values(components.components)) {\n    for (const capability of getServiceDependencies(service)) {\n      if (serviceCapabilities[capability] !== true) {\n        throw new UnmetServiceDependenciesError(`Service \"${getServiceName(service)}\" required capability \"${capability}\" but it was not provided by any component, you may need to add additional configuration when creating your node.`)\n      }\n    }\n  }\n}\n\nfunction getServiceCapabilities (service: any): string[] {\n  if (Array.isArray(service?.[serviceCapabilities])) {\n    return service[serviceCapabilities]\n  }\n\n  return []\n}\n\nfunction getServiceDependencies (service: any): string[] {\n  if (Array.isArray(service?.[serviceDependencies])) {\n    return service[serviceDependencies]\n  }\n\n  return []\n}\n\nfunction getServiceName (service: any): string {\n  return service?.[Symbol.toStringTag] ?? service?.toString() ?? 'unknown'\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { WebSockets } from '@multiformats/multiaddr-matcher'\nimport type { ConnectionGater } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CODEC_IP4 = 0x04\nconst CODEC_IP6 = 0x29\n\n/**\n * Returns a connection gater that disallows dialling private addresses or\n * insecure websockets by default.\n *\n * Browsers are severely limited in their resource usage so don't waste time\n * trying to dial undiallable addresses, and they also print verbose error\n * messages when making connections over insecure transports which causes\n * confusion.\n */\nexport function connectionGater (gater: ConnectionGater = {}): ConnectionGater {\n  return {\n    denyDialPeer: async () => false,\n    denyDialMultiaddr: async (multiaddr: Multiaddr) => {\n      // do not connect to insecure websockets by default\n      if (WebSockets.matches(multiaddr)) {\n        return false\n      }\n\n      const tuples = multiaddr.stringTuples()\n\n      // do not connect to private addresses by default\n      if (tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) {\n        return Boolean(isPrivateIp(`${tuples[0][1]}`))\n      }\n\n      return false\n    },\n    denyInboundConnection: async () => false,\n    denyOutboundConnection: async () => false,\n    denyInboundEncryptedConnection: async () => false,\n    denyOutboundEncryptedConnection: async () => false,\n    denyInboundUpgradedConnection: async () => false,\n    denyOutboundUpgradedConnection: async () => false,\n    filterMultiaddrForPeer: async () => true,\n    ...gater\n  }\n}\n", "// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst clearMethods = new WeakMap();\n\nexport function createDelay({clearTimeout: defaultClear, setTimeout: defaultSet} = {}) {\n\t// We cannot use `async` here as we need the promise identity.\n\treturn (milliseconds, {value, signal} = {}) => {\n\t\t// TODO: Use `signal?.throwIfAborted()` when targeting Node.js 18.\n\t\tif (signal?.aborted) {\n\t\t\treturn Promise.reject(createAbortError());\n\t\t}\n\n\t\tlet timeoutId;\n\t\tlet settle;\n\t\tlet rejectFunction;\n\t\tconst clear = defaultClear ?? clearTimeout;\n\n\t\tconst signalListener = () => {\n\t\t\tclear(timeoutId);\n\t\t\trejectFunction(createAbortError());\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t\t}\n\t\t};\n\n\t\tconst delayPromise = new Promise((resolve, reject) => {\n\t\t\tsettle = () => {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(value);\n\t\t\t};\n\n\t\t\trejectFunction = reject;\n\t\t\ttimeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);\n\t\t});\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tclearMethods.set(delayPromise, () => {\n\t\t\tclear(timeoutId);\n\t\t\ttimeoutId = null;\n\t\t\tsettle();\n\t\t});\n\n\t\treturn delayPromise;\n\t};\n}\n\nconst delay = createDelay();\n\nexport default delay;\n\nexport async function rangeDelay(minimum, maximum, options = {}) {\n\treturn delay(randomInteger(minimum, maximum), options);\n}\n\nexport function clearDelay(promise) {\n\tclearMethods.get(promise)?.();\n}\n", "import type { RateLimiterResult } from './rate-limiter.js'\n\n/**\n * A rate limit was hit\n */\nexport class RateLimitError extends Error {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n\n  constructor (message = 'Rate limit exceeded', props: RateLimiterResult) {\n    super(message)\n    this.name = 'RateLimitError'\n    this.remainingPoints = props.remainingPoints\n    this.msBeforeNext = props.msBeforeNext\n    this.consumedPoints = props.consumedPoints\n    this.isFirstInDuration = props.isFirstInDuration\n  }\n}\n\nexport class QueueFullError extends Error {\n  static name = 'QueueFullError'\n\n  constructor (message: string = 'The queue was full') {\n    super(message)\n    this.name = 'QueueFullError'\n  }\n}\n", "import delay from 'delay'\nimport { RateLimitError } from './errors.js'\n\nexport interface RateLimiterInit {\n  /**\n   * Number of points\n   *\n   * @default 4\n   */\n  points?: number\n\n  /**\n   * Per seconds\n   *\n   * @default 1\n   */\n  duration?: number\n\n  /**\n   * Block if consumed more than points in current duration for blockDuration seconds\n   *\n   * @default 0\n   */\n  blockDuration?: number\n\n  /**\n   * Execute allowed actions evenly over duration\n   *\n   * @default false\n   */\n  execEvenly?: boolean\n\n  /**\n   * ms, works with execEvenly=true option\n   *\n   * @default duration * 1000 / points\n   */\n  execEvenlyMinDelayMs?: number\n\n  /**\n   * @default rlflx\n   */\n  keyPrefix?: string\n}\n\nexport interface GetKeySecDurationOptions {\n  customDuration?: number\n}\n\nexport interface RateLimiterResult {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n}\n\nexport interface RateRecord {\n  value: number\n  expiresAt?: Date\n  timeoutId?: ReturnType<typeof setTimeout>\n}\n\nexport class RateLimiter {\n  public readonly memoryStorage: MemoryStorage\n  protected points: number\n  protected duration: number\n  protected blockDuration: number\n  protected execEvenly: boolean\n  protected execEvenlyMinDelayMs: number\n  protected keyPrefix: string\n\n  constructor (opts: RateLimiterInit = {}) {\n    this.points = opts.points ?? 4\n    this.duration = opts.duration ?? 1\n    this.blockDuration = opts.blockDuration ?? 0\n    this.execEvenly = opts.execEvenly ?? false\n    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? (this.duration * 1000 / this.points)\n    this.keyPrefix = opts.keyPrefix ?? 'rlflx'\n    this.memoryStorage = new MemoryStorage()\n  }\n\n  async consume (key: string, pointsToConsume: number = 1, options: GetKeySecDurationOptions = {}): Promise<RateLimiterResult> {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    if (res.consumedPoints > this.points) {\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n        // Block key\n        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration)\n      }\n\n      throw new RateLimitError('Rate limit exceeded', res)\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      // Execute evenly\n      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2))\n      if (delayMs < this.execEvenlyMinDelayMs) {\n        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs\n      }\n\n      await delay(delayMs)\n    }\n\n    return res\n  }\n\n  penalty (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  reward (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, -points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block (key: string, secDuration: number): RateLimiterResult {\n    const msDuration = secDuration * 1000\n    const initPoints = this.points + 1\n\n    this.memoryStorage.set(this.getKey(key), initPoints, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: initPoints,\n      isFirstInDuration: false\n    }\n  }\n\n  set (key: string, points: number, secDuration: number = 0): RateLimiterResult {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000\n\n    this.memoryStorage.set(this.getKey(key), points, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: points,\n      isFirstInDuration: false\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const res = this.memoryStorage.get(this.getKey(key))\n\n    if (res != null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n    }\n\n    return res\n  }\n\n  delete (key: string): void {\n    this.memoryStorage.delete(this.getKey(key))\n  }\n\n  private _getKeySecDuration (options?: GetKeySecDurationOptions): number {\n    if (options?.customDuration != null && options.customDuration >= 0) {\n      return options.customDuration\n    }\n\n    return this.duration\n  }\n\n  getKey (key: string): string {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key\n  }\n\n  parseKey (rlKey: string): string {\n    return rlKey.substring(this.keyPrefix.length)\n  }\n}\n\nexport class MemoryStorage {\n  public readonly storage: Map<string, RateRecord>\n\n  constructor () {\n    this.storage = new Map()\n  }\n\n  incrby (key: string, value: number, durationSec: number): RateLimiterResult {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n\n      if (existing.expiresAt == null || msBeforeExpires > 0) {\n        // Change value\n        existing.value += value\n\n        return {\n          remainingPoints: 0,\n          msBeforeNext: msBeforeExpires,\n          consumedPoints: existing.value,\n          isFirstInDuration: false\n        }\n      }\n\n      return this.set(key, value, durationSec)\n    }\n\n    return this.set(key, value, durationSec)\n  }\n\n  set (key: string, value: number, durationSec: number): RateLimiterResult {\n    const durationMs = durationSec * 1000\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      clearTimeout(existing.timeoutId)\n    }\n\n    const record: RateRecord = {\n      value,\n      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined\n    }\n\n    this.storage.set(key, record)\n\n    if (durationMs > 0) {\n      record.timeoutId = setTimeout(() => {\n        this.storage.delete(key)\n      }, durationMs)\n\n      if (record.timeoutId.unref != null) {\n        record.timeoutId.unref()\n      }\n    }\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: durationMs === 0 ? -1 : durationMs,\n      consumedPoints: record.value,\n      isFirstInDuration: true\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n      return {\n        remainingPoints: 0,\n        msBeforeNext: msBeforeExpires,\n        consumedPoints: existing.value,\n        isFirstInDuration: false\n      }\n    }\n  }\n\n  delete (key: string): boolean {\n    const record = this.storage.get(key)\n\n    if (record != null) {\n      if (record.timeoutId != null) {\n        clearTimeout(record.timeoutId)\n      }\n\n      this.storage.delete(key)\n\n      return true\n    }\n    return false\n  }\n}\n", "import { InvalidMultiaddrError, InvalidParametersError, isPeerId } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface PeerAddress {\n  peerId?: PeerId\n  multiaddrs: Multiaddr[]\n}\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress (peer: PeerId | Multiaddr | Multiaddr[]): PeerAddress {\n  if (isPeerId(peer)) {\n    return { peerId: peer, multiaddrs: [] }\n  }\n\n  if (!Array.isArray(peer)) {\n    peer = [peer]\n  }\n\n  let peerId: PeerId | undefined\n\n  if (peer.length > 0) {\n    const peerIdStr = peer[0].getPeerId()\n    peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr)\n\n    // ensure PeerId is either not set or is consistent\n    peer.forEach(ma => {\n      if (!isMultiaddr(ma)) {\n        throw new InvalidMultiaddrError('Invalid multiaddr')\n      }\n\n      const maPeerIdStr = ma.getPeerId()\n\n      if (maPeerIdStr == null) {\n        if (peerId != null) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      } else {\n        const maPeerId = peerIdFromString(maPeerIdStr)\n\n        if (peerId?.equals(maPeerId) !== true) {\n          throw new InvalidParametersError('Multiaddrs must all have the same peer id or have no peer id')\n        }\n      }\n    })\n  }\n\n  return {\n    peerId,\n    multiaddrs: peer\n  }\n}\n", "import type { Connection, Stream, AbortOptions } from '@libp2p/interface'\n\n/**\n * Close the passed stream, falling back to aborting the stream if closing\n * cleanly fails.\n */\nexport async function safelyCloseStream (stream?: Stream, options?: AbortOptions): Promise<void> {\n  try {\n    await stream?.close(options)\n  } catch (err: any) {\n    stream?.abort(err)\n  }\n}\n\n/**\n * These are speculative protocols that are run automatically on connection open\n * so are usually not the reason the connection was opened.\n *\n * Consequently when requested it should be safe to close connections that only\n * have these protocol streams open.\n */\nconst DEFAULT_CLOSABLE_PROTOCOLS = [\n  // identify\n  '/ipfs/id/1.0.0',\n\n  // identify-push\n  '/ipfs/id/push/1.0.0',\n\n  // autonat\n  '/libp2p/autonat/1.0.0',\n\n  // dcutr\n  '/libp2p/dcutr'\n]\n\nexport interface SafelyCloseConnectionOptions extends AbortOptions {\n  /**\n   * Only close the stream if it either has no protocol streams open or only\n   * ones in this list.\n   *\n   * @default ['/ipfs/id/1.0.0']\n   */\n  closableProtocols?: string[]\n}\n\n/**\n * Close the passed connection if it has no streams, or only closable protocol\n * streams, falling back to aborting the connection if closing it cleanly fails.\n */\nexport async function safelyCloseConnectionIfUnused (connection?: Connection, options?: SafelyCloseConnectionOptions): Promise<void> {\n  const streamProtocols = connection?.streams?.map(stream => stream.protocol) ?? []\n  const closableProtocols = options?.closableProtocols ?? DEFAULT_CLOSABLE_PROTOCOLS\n\n  // if the connection has protocols not in the closable protocols list, do not\n  // close the connection\n  if (streamProtocols.filter(proto => proto != null && !closableProtocols.includes(proto)).length > 0) {\n    return\n  }\n\n  try {\n    await connection?.close(options)\n  } catch (err: any) {\n    connection?.abort(err)\n  }\n}\n", "/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 5e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#upgradeTimeout\n */\nexport const UPGRADE_TIMEOUT = 3e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#protocolNegotiationTimeout\n */\nexport const PROTOCOL_NEGOTIATION_TIMEOUT = 2e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelReconnects\n */\nexport const MAX_PARALLEL_RECONNECTS = 5\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt failed with the timestamp\n * stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure'\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempt succeeded with the\n * timestamp stored as a string.\n */\nexport const LAST_DIAL_SUCCESS_KEY = 'last-dial-success'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */\nexport const MAX_DIAL_QUEUE_LENGTH = 500\n", "export * from './constants.defaults.js'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50\n", "import { multiaddr, resolvers, type Multiaddr, type ResolveOptions } from '@multiformats/multiaddr'\nimport { convertToIpNet } from '@multiformats/multiaddr/convert'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { LoggerOptions } from '@libp2p/interface'\n\n/**\n * Recursively resolve DNSADDR multiaddrs\n */\nexport async function resolveMultiaddrs (ma: Multiaddr, options: ResolveOptions & LoggerOptions): Promise<Multiaddr[]> {\n  // check multiaddr resolvers\n  let resolvable = false\n\n  for (const key of resolvers.keys()) {\n    resolvable = ma.protoNames().includes(key)\n\n    if (resolvable) {\n      break\n    }\n  }\n\n  // return multiaddr if it is not resolvable\n  if (!resolvable) {\n    return [ma]\n  }\n\n  const output = await ma.resolve(options)\n\n  options.log('resolved %s to', ma, output.map(ma => ma.toString()))\n\n  return output\n}\n\n/**\n * Converts a multiaddr string or object to an IpNet object.\n * If the multiaddr doesn't include /ipcidr, it will encapsulate with the appropriate CIDR:\n * - /ipcidr/32 for IPv4\n * - /ipcidr/128 for IPv6\n *\n * @param {string | Multiaddr} ma - The multiaddr string or object to convert.\n * @returns {IpNet} The converted IpNet object.\n * @throws {Error} Throws an error if the multiaddr is not valid.\n */\nexport function multiaddrToIpNet (ma: string | Multiaddr): IpNet {\n  try {\n    let parsedMa: Multiaddr\n    if (typeof ma === 'string') {\n      parsedMa = multiaddr(ma)\n    } else {\n      parsedMa = ma\n    }\n\n    // Check if /ipcidr is already present\n    if (!parsedMa.protoNames().includes('ipcidr')) {\n      const isIPv6 = parsedMa.protoNames().includes('ip6')\n      const cidr = isIPv6 ? '/ipcidr/128' : '/ipcidr/32'\n      parsedMa = parsedMa.encapsulate(cidr)\n    }\n\n    return convertToIpNet(parsedMa)\n  } catch (error) {\n    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`)\n  }\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { safelyCloseConnectionIfUnused } from '@libp2p/utils/close'\nimport { MAX_CONNECTIONS } from './constants.js'\nimport { multiaddrToIpNet } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { Libp2pEvents, Logger, ComponentLogger, TypedEventTarget, PeerStore, Connection } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\ninterface ConnectionPrunerInit {\n  maxConnections?: number\n  allow?: Multiaddr[]\n}\n\ninterface ConnectionPrunerComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  allow: []\n}\n\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n  private readonly maxConnections: number\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly allow: IpNet[]\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n\n  constructor (components: ConnectionPrunerComponents, init: ConnectionPrunerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    this.allow = (init.allow ?? []).map(ma => multiaddrToIpNet(ma))\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager:connection-pruner')\n    this.maybePruneConnections = this.maybePruneConnections.bind(this)\n  }\n\n  start (): void {\n    this.events.addEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  stop (): void {\n    this.events.removeEventListener('connection:open', this.maybePruneConnections)\n  }\n\n  maybePruneConnections (): void {\n    this._maybePruneConnections()\n      .catch(err => {\n        this.log.error('error while pruning connections %e', err)\n      })\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  private async _maybePruneConnections (): Promise<void> {\n    const connections = this.connectionManager.getConnections()\n    const numConnections = connections.length\n\n    this.log('checking max connections limit %d/%d', numConnections, this.maxConnections)\n\n    if (numConnections <= this.maxConnections) {\n      return\n    }\n\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      peerValues.set(remotePeer, 0)\n\n      try {\n        const peer = await this.peerStore.get(remotePeer)\n\n        // sum all tag values\n        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n          return acc + curr.value\n        }, 0))\n      } catch (err: any) {\n        if (err.name !== 'NotFoundError') {\n          this.log.error('error loading peer tags', err)\n        }\n      }\n    }\n\n    const sortedConnections = this.sortConnections(connections, peerValues)\n\n    // close some connections\n    const toPrune = Math.max(numConnections - this.maxConnections, 0)\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      this.log('too many connections open - closing a connection to %p', connection.remotePeer)\n      // check allow list\n      const connectionInAllowList = this.allow.some((ipNet) => {\n        return ipNet.contains(connection.remoteAddr.nodeAddress().address)\n      })\n\n      // Connections in the allow list should be excluded from pruning\n      if (!connectionInAllowList) {\n        toClose.push(connection)\n      }\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        await safelyCloseConnectionIfUnused(connection, {\n          signal: AbortSignal.timeout(1000)\n        })\n      })\n    )\n\n    // despatch prune event\n    this.events.safeDispatchEvent('connection:prune', { detail: toClose })\n  }\n\n  sortConnections (connections: Connection[], peerValues: PeerMap<number>): Connection[] {\n    return connections\n      // sort by connection age, newest to oldest\n      .sort((a, b) => {\n        const connectionALifespan = a.timeline.open\n        const connectionBLifespan = b.timeline.open\n\n        if (connectionALifespan < connectionBLifespan) {\n          return 1\n        }\n\n        if (connectionALifespan > connectionBLifespan) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by direction, incoming first then outgoing\n      .sort((a, b) => {\n        if (a.direction === 'outbound' && b.direction === 'inbound') {\n          return 1\n        }\n\n        if (a.direction === 'inbound' && b.direction === 'outbound') {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by number of streams, lowest to highest\n      .sort((a, b) => {\n        if (a.streams.length > b.streams.length) {\n          return 1\n        }\n\n        if (a.streams.length < b.streams.length) {\n          return -1\n        }\n\n        return 0\n      })\n      // sort by tag value, lowest to highest\n      .sort((a, b) => {\n        const peerAValue = peerValues.get(a.remotePeer) ?? 0\n        const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n        if (peerAValue > peerBValue) {\n          return 1\n        }\n\n        if (peerAValue < peerBValue) {\n          return -1\n        }\n\n        return 0\n      })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Race an event against an AbortSignal, taking care to remove any event\n * listeners that were added.\n *\n * @example Getting started\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * setTimeout(() => {\n *   // too late\n *   emitter.dispatchEvent(new CustomEvent('event'))\n * }, 1000)\n *\n * // throws an AbortError\n * const resolve = await raceEvent(emitter, 'event', controller.signal)\n * ```\n *\n * @example Aborting the promise with an error event\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   emitter.dispatchEvent(new CustomEvent('failure', {\n *     detail: new Error('Oh no!')\n *   }))\n * }, 1000)\n *\n * // throws 'Oh no!' error\n * const resolve = await raceEvent(emitter, 'success', AbortSignal.timeout(5000), {\n *   errorEvent: 'failure'\n * })\n * ```\n *\n * @example Customising the thrown AbortError\n *\n * The error message and `.code` property of the thrown `AbortError` can be\n * specified by passing options:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * setTimeout(() => {\n *   controller.abort()\n * }, 500)\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   errorMessage: 'Oh no!',\n *   errorCode: 'ERR_OH_NO'\n * })\n * ```\n *\n * @example Only resolving on specific events\n *\n * Where multiple events with the same type are emitted, a `filter` function can\n * be passed to only resolve on one of them:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws a Error: Oh no!\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt: Event) => {\n *     return evt.detail.foo === 'bar'\n *   }\n * })\n * ```\n *\n * @example Terminating early by throwing from the filter\n *\n * You can cause listening for the event to cease and all event listeners to be\n * removed by throwing from the filter:\n *\n * ```TypeScript\n * import { raceEvent } from 'race-event'\n *\n * const controller = new AbortController()\n * const emitter = new EventTarget()\n *\n * // throws Error: Cannot continue\n * const resolve = await raceEvent(emitter, 'event', controller.signal, {\n *   filter: (evt) => {\n *     if (...reasons) {\n *       throw new Error('Cannot continue')\n *     }\n *\n *     return true\n *   }\n * })\n * ```\n */\n\n/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceEventOptions<T> {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name of an event emitted on the emitter that should cause the returned\n   * promise to reject. The rejection reason will be the `.detail` field of the\n   * event.\n   */\n  errorEvent?: string\n\n  /**\n   * When multiple events with the same name may be emitted, pass a filter\n   * function here to allow ignoring ones that should not cause the returned\n   * promise to resolve.\n   */\n  filter?(evt: T): boolean\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceEvent <T> (emitter: EventTarget, eventName: string, signal?: AbortSignal, opts?: RaceEventOptions<T>): Promise<T> {\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode)\n\n  if (signal?.aborted === true) {\n    return Promise.reject(error)\n  }\n\n  return new Promise((resolve, reject) => {\n    function removeListeners (): void {\n      signal?.removeEventListener('abort', abortListener)\n      emitter.removeEventListener(eventName, eventListener)\n\n      if (opts?.errorEvent != null) {\n        emitter.removeEventListener(opts.errorEvent, errorEventListener)\n      }\n    }\n\n    const eventListener = (evt: any): void => {\n      try {\n        if (opts?.filter?.(evt) === false) {\n          return\n        }\n      } catch (err: any) {\n        removeListeners()\n        reject(err)\n        return\n      }\n\n      removeListeners()\n      resolve(evt)\n    }\n\n    const errorEventListener = (evt: any): void => {\n      removeListeners()\n      reject(evt.detail)\n    }\n\n    const abortListener = (): void => {\n      removeListeners()\n      reject(error)\n    }\n\n    signal?.addEventListener('abort', abortListener)\n    emitter.addEventListener(eventName, eventListener)\n\n    if (opts?.errorEvent != null) {\n      emitter.addEventListener(opts.errorEvent, errorEventListener)\n    }\n  })\n}\n", "import { AbortError } from '@libp2p/interface'\nimport pDefer from 'p-defer'\nimport type { DeferredPromise } from 'p-defer'\n\nexport class JobRecipient<JobReturnType> {\n  public deferred: DeferredPromise<JobReturnType>\n  public signal?: AbortSignal\n\n  constructor (signal?: AbortSignal) {\n    this.signal = signal\n    this.deferred = pDefer()\n\n    this.onAbort = this.onAbort.bind(this)\n    this.signal?.addEventListener('abort', this.onAbort)\n  }\n\n  onAbort (): void {\n    this.deferred.reject(this.signal?.reason ?? new AbortError())\n  }\n\n  cleanup (): void {\n    this.signal?.removeEventListener('abort', this.onAbort)\n  }\n}\n", "import { AbortError, setMaxListeners } from '@libp2p/interface'\nimport { raceSignal } from 'race-signal'\nimport { JobRecipient } from './recipient.js'\nimport type { JobStatus } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Returns a random string\n */\nfunction randomId (): string {\n  return `${(parseInt(String(Math.random() * 1e9), 10)).toString()}${Date.now()}`\n}\n\nexport interface JobTimeline {\n  created: number\n  started?: number\n  finished?: number\n}\n\nexport class Job <JobOptions extends AbortOptions = AbortOptions, JobReturnType = unknown> {\n  public id: string\n  public fn: (options: JobOptions) => Promise<JobReturnType>\n  public options: JobOptions\n  public recipients: Array<JobRecipient<JobReturnType>>\n  public status: JobStatus\n  public readonly timeline: JobTimeline\n  private readonly controller: AbortController\n\n  constructor (fn: (options: JobOptions) => Promise<JobReturnType>, options: any) {\n    this.id = randomId()\n    this.status = 'queued'\n    this.fn = fn\n    this.options = options\n    this.recipients = []\n    this.timeline = {\n      created: Date.now()\n    }\n\n    this.controller = new AbortController()\n    setMaxListeners(Infinity, this.controller.signal)\n\n    this.onAbort = this.onAbort.bind(this)\n  }\n\n  abort (err: Error): void {\n    this.controller.abort(err)\n  }\n\n  onAbort (): void {\n    const allAborted = this.recipients.reduce((acc, curr) => {\n      return acc && (curr.signal?.aborted === true)\n    }, true)\n\n    // if all recipients have aborted the job, actually abort the job\n    if (allAborted) {\n      this.controller.abort(new AbortError())\n      this.cleanup()\n    }\n  }\n\n  async join (options: AbortOptions = {}): Promise<JobReturnType> {\n    const recipient = new JobRecipient<JobReturnType>(options.signal)\n    this.recipients.push(recipient)\n\n    options.signal?.addEventListener('abort', this.onAbort)\n\n    return recipient.deferred.promise\n  }\n\n  async run (): Promise<void> {\n    this.status = 'running'\n    this.timeline.started = Date.now()\n\n    try {\n      this.controller.signal.throwIfAborted()\n\n      const result = await raceSignal(this.fn({\n        ...(this.options ?? {}),\n        signal: this.controller.signal\n      }), this.controller.signal)\n\n      this.recipients.forEach(recipient => {\n        recipient.deferred.resolve(result)\n      })\n\n      this.status = 'complete'\n    } catch (err) {\n      this.recipients.forEach(recipient => {\n        recipient.deferred.reject(err)\n      })\n\n      this.status = 'errored'\n    } finally {\n      this.timeline.finished = Date.now()\n      this.cleanup()\n    }\n  }\n\n  cleanup (): void {\n    this.recipients.forEach(recipient => {\n      recipient.cleanup()\n      recipient.signal?.removeEventListener('abort', this.onAbort)\n    })\n  }\n}\n", "import { AbortError, TypedEventEmitter } from '@libp2p/interface'\nimport { pushable } from 'it-pushable'\nimport { raceEvent } from 'race-event'\nimport { QueueFullError } from '../errors.js'\nimport { Job } from './job.js'\nimport type { AbortOptions, Metrics } from '@libp2p/interface'\n\nexport type { Job, JobTimeline } from './job.js'\nexport type { JobRecipient } from './recipient.js'\n\nexport interface Comparator<T> {\n  (a: T, b: T): -1 | 0 | 1\n}\n\nexport interface QueueInit<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * Concurrency limit.\n   *\n   * Minimum: `1`.\n   *\n   * @default Infinity\n   */\n  concurrency?: number\n\n  /**\n   * If the queue size grows to larger than this number the promise returned\n   * from the add function will reject\n   *\n   * @default Infinity\n   */\n  maxSize?: number\n\n  /**\n   * The name of the metric for the queue length\n   */\n  metricName?: string\n\n  /**\n   * An implementation of the libp2p Metrics interface\n   */\n  metrics?: Metrics\n\n  /**\n   * An optional function that will sort the queue after a job has been added\n   */\n  sort?: Comparator<Job<JobOptions, JobReturnType>>\n}\n\nexport type JobStatus = 'queued' | 'running' | 'errored' | 'complete'\n\nexport interface RunFunction<Options extends AbortOptions = AbortOptions, ReturnType = void> {\n  (options: Options): Promise<ReturnType>\n}\n\nexport interface JobMatcher<JobOptions extends AbortOptions = AbortOptions> {\n  (options?: Partial<JobOptions>): boolean\n}\n\nexport interface QueueJobSuccess<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  result: JobReturnType\n}\n\nexport interface QueueJobFailure<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  job: Job<JobOptions, JobReturnType>\n  error: Error\n}\n\nexport interface QueueEvents<JobReturnType, JobOptions extends AbortOptions = AbortOptions> {\n  /**\n   * A job is about to start running\n   */\n  'active': CustomEvent\n\n  /**\n   * All jobs have finished and the queue is empty\n   */\n  'idle': CustomEvent\n\n  /**\n   * The queue is empty, jobs may be running\n   */\n  'empty': CustomEvent\n\n  /**\n   * A job was added to the queue\n   */\n  'add': CustomEvent\n\n  /**\n   * A job has finished or failed\n   */\n  'next': CustomEvent\n\n  /**\n   * A job has finished successfully\n   */\n  'completed': CustomEvent<JobReturnType>\n\n  /**\n   * A job has failed\n   */\n  'error': CustomEvent<Error>\n\n  /**\n   * Emitted just after `\"completed\", a job has finished successfully - this\n   * event gives access to the job and it's result\n   */\n  'success': CustomEvent<QueueJobSuccess<JobReturnType, JobOptions>>\n\n  /**\n   * Emitted just after `\"error\", a job has failed - this event gives access to\n   * the job and the thrown error\n   */\n  'failure': CustomEvent<QueueJobFailure<JobReturnType, JobOptions>>\n}\n\n/**\n * Heavily influence by `p-queue` with the following differences:\n *\n * 1. Items remain at the head of the queue while they are running so `queue.size` includes `queue.pending` items - this is so interested parties can join the results of a queue item while it is running\n * 2. The options for a job are stored separately to the job in order for them to be modified while they are still in the queue\n */\nexport class Queue<JobReturnType = unknown, JobOptions extends AbortOptions = AbortOptions> extends TypedEventEmitter<QueueEvents<JobReturnType, JobOptions>> {\n  public concurrency: number\n  public maxSize: number\n  public queue: Array<Job<JobOptions, JobReturnType>>\n  private pending: number\n  private readonly sort?: Comparator<Job<JobOptions, JobReturnType>>\n\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super()\n\n    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY\n    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY\n    this.pending = 0\n\n    if (init.metricName != null) {\n      init.metrics?.registerMetricGroup(init.metricName, {\n        calculate: () => {\n          return {\n            size: this.queue.length,\n            running: this.pending,\n            queued: this.queue.length - this.pending\n          }\n        }\n      })\n    }\n\n    this.sort = init.sort\n    this.queue = []\n  }\n\n  private tryToStartAnother (): boolean {\n    if (this.size === 0) {\n      // do this in the microtask queue so all job recipients receive the\n      // result before the \"empty\" event fires\n      queueMicrotask(() => {\n        this.safeDispatchEvent('empty')\n      })\n\n      if (this.running === 0) {\n        // do this in the microtask queue so all job recipients receive the\n        // result before the \"idle\" event fires\n        queueMicrotask(() => {\n          this.safeDispatchEvent('idle')\n        })\n      }\n\n      return false\n    }\n\n    if (this.pending < this.concurrency) {\n      let job: Job<JobOptions, JobReturnType> | undefined\n\n      for (const j of this.queue) {\n        if (j.status === 'queued') {\n          job = j\n          break\n        }\n      }\n\n      if (job == null) {\n        return false\n      }\n\n      this.safeDispatchEvent('active')\n\n      this.pending++\n\n      void job.run()\n        .finally(() => {\n          // remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n\n          this.pending--\n          this.tryToStartAnother()\n          this.safeDispatchEvent('next')\n        })\n\n      return true\n    }\n\n    return false\n  }\n\n  private enqueue (job: Job<JobOptions, JobReturnType>): void {\n    this.queue.push(job)\n\n    if (this.sort != null) {\n      this.queue.sort(this.sort)\n    }\n  }\n\n  /**\n   * Adds a sync or async task to the queue. Always returns a promise.\n   */\n  async add (fn: RunFunction<JobOptions, JobReturnType>, options?: JobOptions): Promise<JobReturnType> {\n    options?.signal?.throwIfAborted()\n\n    if (this.size === this.maxSize) {\n      throw new QueueFullError()\n    }\n\n    const job = new Job<JobOptions, JobReturnType>(fn, options)\n    this.enqueue(job)\n    this.safeDispatchEvent('add')\n    this.tryToStartAnother()\n\n    return job.join(options)\n      .then(result => {\n        this.safeDispatchEvent('completed', { detail: result })\n        this.safeDispatchEvent('success', { detail: { job, result } })\n\n        return result\n      })\n      .catch(err => {\n        if (job.status === 'queued') {\n          // job was aborted before it started - remove the job from the queue\n          for (let i = 0; i < this.queue.length; i++) {\n            if (this.queue[i] === job) {\n              this.queue.splice(i, 1)\n              break\n            }\n          }\n        }\n\n        this.safeDispatchEvent('error', { detail: err })\n        this.safeDispatchEvent('failure', { detail: { job, error: err } })\n\n        throw err\n      })\n  }\n\n  /**\n   * Clear the queue\n   */\n  clear (): void {\n    this.queue.splice(0, this.queue.length)\n  }\n\n  /**\n   * Abort all jobs in the queue and clear it\n   */\n  abort (): void {\n    this.queue.forEach(job => {\n      job.abort(new AbortError())\n    })\n\n    this.clear()\n  }\n\n  /**\n   * Can be called multiple times. Useful if you for example add additional items at a later time.\n   *\n   * @returns A promise that settles when the queue becomes empty.\n   */\n  async onEmpty (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty\n    if (this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'empty', options?.signal)\n  }\n\n  /**\n   * @returns A promise that settles when the queue size is less than the given\n   * limit: `queue.size < limit`.\n   *\n   * If you want to avoid having the queue grow beyond a certain size you can\n   * `await queue.onSizeLessThan()` before adding a new item.\n   *\n   * Note that this only limits the number of items waiting to start. There\n   * could still be up to `concurrency` jobs already running that this call does\n   * not include in its calculation.\n   */\n  async onSizeLessThan (limit: number, options?: AbortOptions): Promise<void> {\n    // Instantly resolve if the queue is empty.\n    if (this.size < limit) {\n      return\n    }\n\n    await raceEvent(this, 'next', options?.signal, {\n      filter: () => this.size < limit\n    })\n  }\n\n  /**\n   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work\n   * from the queue has finished. `.onEmpty` merely signals that the queue is\n   * empty, but it could mean that some promises haven't completed yet.\n   *\n   * @returns A promise that settles when the queue becomes empty, and all\n   * promises have completed; `queue.size === 0 && queue.pending === 0`.\n   */\n  async onIdle (options?: AbortOptions): Promise<void> {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this.pending === 0 && this.size === 0) {\n      return\n    }\n\n    await raceEvent(this, 'idle', options?.signal)\n  }\n\n  /**\n   * Size of the queue including running items\n   */\n  get size (): number {\n    return this.queue.length\n  }\n\n  /**\n   * The number of queued items waiting to run.\n   */\n  get queued (): number {\n    return this.queue.length - this.pending\n  }\n\n  /**\n   * The number of items currently running.\n   */\n  get running (): number {\n    return this.pending\n  }\n\n  /**\n   * Returns an async generator that makes it easy to iterate over the results\n   * of jobs added to the queue.\n   *\n   * The generator will end when the queue becomes idle, that is there are no\n   * jobs running and no jobs that have yet to run.\n   *\n   * If you need to keep the queue open indefinitely, consider using it-pushable\n   * instead.\n   */\n  async * toGenerator (options?: AbortOptions): AsyncGenerator<JobReturnType, void, unknown> {\n    options?.signal?.throwIfAborted()\n\n    const stream = pushable<JobReturnType>({\n      objectMode: true\n    })\n\n    const cleanup = (err?: Error): void => {\n      if (err != null) {\n        this.abort()\n      } else {\n        this.clear()\n      }\n\n      stream.end(err)\n    }\n\n    const onQueueJobComplete = (evt: CustomEvent<JobReturnType>): void => {\n      if (evt.detail != null) {\n        stream.push(evt.detail)\n      }\n    }\n\n    const onQueueError = (evt: CustomEvent<Error>): void => {\n      cleanup(evt.detail)\n    }\n\n    const onQueueIdle = (): void => {\n      cleanup()\n    }\n\n    // clear the queue and throw if the query is aborted\n    const onSignalAbort = (): void => {\n      cleanup(new AbortError('Queue aborted'))\n    }\n\n    // add listeners\n    this.addEventListener('completed', onQueueJobComplete)\n    this.addEventListener('error', onQueueError)\n    this.addEventListener('idle', onQueueIdle)\n    options?.signal?.addEventListener('abort', onSignalAbort)\n\n    try {\n      yield * stream\n    } finally {\n      // remove listeners\n      this.removeEventListener('completed', onQueueJobComplete)\n      this.removeEventListener('error', onQueueError)\n      this.removeEventListener('idle', onQueueIdle)\n      options?.signal?.removeEventListener('abort', onSignalAbort)\n\n      // empty the queue for when the user has broken out of a loop early\n      cleanup()\n    }\n  }\n}\n", "import { Queue } from './queue/index.js'\nimport type { QueueInit } from './queue/index.js'\nimport type { AbortOptions } from '@libp2p/interface'\n\nexport interface PriorityQueueJobOptions extends AbortOptions {\n  priority: number\n}\n\nexport class PriorityQueue <JobReturnType = void, JobOptions extends PriorityQueueJobOptions = PriorityQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  constructor (init: QueueInit<JobReturnType, JobOptions> = {}) {\n    super({\n      ...init,\n      sort: (a, b) => {\n        if (a.options.priority > b.options.priority) {\n          return -1\n        }\n\n        if (a.options.priority < b.options.priority) {\n          return 1\n        }\n\n        return 0\n      }\n    })\n  }\n}\n", "\nexport interface ClearableSignal extends AbortSignal {\n  clear: () => void\n}\n\n/**\n * Takes an array of AbortSignals and returns a single signal.\n * If any signals are aborted, the returned signal will be aborted.\n */\nexport function anySignal (signals: Array<AbortSignal | undefined | null>): ClearableSignal {\n  const controller = new globalThis.AbortController()\n\n  function onAbort (): void {\n    controller.abort()\n\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  for (const signal of signals) {\n    if (signal?.aborted === true) {\n      onAbort()\n      break\n    }\n\n    if (signal?.addEventListener != null) {\n      signal.addEventListener('abort', onAbort)\n    }\n  }\n\n  function clear (): void {\n    for (const signal of signals) {\n      if (signal?.removeEventListener != null) {\n        signal.removeEventListener('abort', onAbort)\n      }\n    }\n  }\n\n  const signal = controller.signal as ClearableSignal\n  signal.clear = clear\n\n  return signal\n}\n", "import { isPrivate } from '@libp2p/utils/multiaddr/is-private'\nimport { Circuit, WebSockets, WebSocketsSecure, WebRTC, WebRTCDirect, WebTransport, TCP } from '@multiformats/multiaddr-matcher'\nimport type { Address } from '@libp2p/interface'\n\n/**\n * Sorts addresses by order of reliability, where they have presented the fewest\n * problems:\n *\n * TCP -> WebSockets/Secure -> WebRTC -> WebRTCDirect -> WebTransport\n */\n// eslint-disable-next-line complexity\nexport function reliableTransportsFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isATCP = TCP.exactMatch(a.multiaddr)\n  const isBTCP = TCP.exactMatch(b.multiaddr)\n\n  if (isATCP && !isBTCP) {\n    return -1\n  }\n\n  if (!isATCP && isBTCP) {\n    return 1\n  }\n\n  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr)\n  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr)\n\n  if (isAWebSocketSecure && !isBWebSocketSecure) {\n    return -1\n  }\n\n  if (!isAWebSocketSecure && isBWebSocketSecure) {\n    return 1\n  }\n\n  const isAWebSocket = WebSockets.exactMatch(a.multiaddr)\n  const isBWebSocket = WebSockets.exactMatch(b.multiaddr)\n\n  if (isAWebSocket && !isBWebSocket) {\n    return -1\n  }\n\n  if (!isAWebSocket && isBWebSocket) {\n    return 1\n  }\n\n  const isAWebRTC = WebRTC.exactMatch(a.multiaddr)\n  const isBWebRTC = WebRTC.exactMatch(b.multiaddr)\n\n  if (isAWebRTC && !isBWebRTC) {\n    return -1\n  }\n\n  if (!isAWebRTC && isBWebRTC) {\n    return 1\n  }\n\n  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr)\n  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr)\n\n  if (isAWebRTCDirect && !isBWebRTCDirect) {\n    return -1\n  }\n\n  if (!isAWebRTCDirect && isBWebRTCDirect) {\n    return 1\n  }\n\n  const isAWebTransport = WebTransport.exactMatch(a.multiaddr)\n  const isBWebTransport = WebTransport.exactMatch(b.multiaddr)\n\n  if (isAWebTransport && !isBWebTransport) {\n    return -1\n  }\n\n  if (!isAWebTransport && isBWebTransport) {\n    return 1\n  }\n\n  // ... everything else\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isAPrivate = isPrivate(a.multiaddr)\n  const isBPrivate = isPrivate(b.multiaddr)\n\n  if (isAPrivate && !isBPrivate) {\n    return 1\n  } else if (!isAPrivate && isBPrivate) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  if (a.isCertified && !b.isCertified) {\n    return -1\n  } else if (!a.isCertified && b.isCertified) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * end of the array.\n */\nexport function circuitRelayAddressesLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isACircuit = Circuit.exactMatch(a.multiaddr)\n  const isBCircuit = Circuit.exactMatch(b.multiaddr)\n\n  if (isACircuit && !isBCircuit) {\n    return 1\n  } else if (!isACircuit && isBCircuit) {\n    return -1\n  }\n\n  return 0\n}\n\nexport function defaultAddressSorter (addresses: Address[]): Address[] {\n  return addresses\n    .sort(reliableTransportsFirst)\n    .sort(certifiedAddressesFirst)\n    .sort(circuitRelayAddressesLast)\n    .sort(publicAddressesFirst)\n}\n", "/* eslint-disable max-depth */\nimport { TimeoutError, DialError, setMaxListeners, AbortError } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { PriorityQueue } from '@libp2p/utils/priority-queue'\nimport { resolvers, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { anySignal } from 'any-signal'\nimport { CustomProgressEvent } from 'progress-events'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { DialDeniedError, NoValidAddressesError } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport { defaultAddressSorter } from './address-sorter.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PEER_ADDRS_TO_DIAL,\n  LAST_DIAL_FAILURE_KEY,\n  MAX_DIAL_QUEUE_LENGTH,\n  LAST_DIAL_SUCCESS_KEY\n} from './constants.js'\nimport { resolveMultiaddrs } from './utils.js'\nimport { DEFAULT_DIAL_PRIORITY } from './index.js'\nimport type { AddressSorter, ComponentLogger, Logger, Connection, ConnectionGater, Metrics, PeerId, Address, PeerStore, PeerRouting, IsDialableOptions, OpenConnectionProgressEvents } from '@libp2p/interface'\nimport type { OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { PriorityQueueJobOptions } from '@libp2p/utils/priority-queue'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr, Resolver } from '@multiformats/multiaddr'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PendingDialTarget {\n  resolve(value: any): void\n  reject(err: Error): void\n}\n\ninterface DialQueueJobOptions extends PriorityQueueJobOptions, ProgressOptions<OpenConnectionProgressEvents> {\n  peerId?: PeerId\n  multiaddrs: Set<string>\n}\n\ninterface DialerInit {\n  addressSorter?: AddressSorter\n  maxParallelDials?: number\n  maxDialQueueLength?: number\n  maxPeerAddrsToDial?: number\n  dialTimeout?: number\n  resolvers?: Record<string, Resolver>\n  connections?: PeerMap<Connection[]>\n}\n\nconst defaultOptions = {\n  maxParallelDials: MAX_PARALLEL_DIALS,\n  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,\n  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n  dialTimeout: DIAL_TIMEOUT,\n  resolvers: {\n    dnsaddr: dnsaddrResolver\n  }\n}\n\ninterface DialQueueComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n  dns?: DNS\n}\n\nexport class DialQueue {\n  public queue: PriorityQueue<Connection, DialQueueJobOptions>\n  private readonly components: DialQueueComponents\n  private readonly addressSorter?: AddressSorter\n  private readonly maxPeerAddrsToDial: number\n  private readonly maxDialQueueLength: number\n  private readonly dialTimeout: number\n  private shutDownController: AbortController\n  private readonly connections: PeerMap<Connection[]>\n  private readonly log: Logger\n\n  constructor (components: DialQueueComponents, init: DialerInit = {}) {\n    this.addressSorter = init.addressSorter\n    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial\n    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength\n    this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout\n    this.connections = init.connections ?? new PeerMap()\n    this.log = components.logger.forComponent('libp2p:connection-manager:dial-queue')\n    this.components = components\n\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n\n    // controls dial concurrency\n    this.queue = new PriorityQueue({\n      concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n      metricName: 'libp2p_dial_queue',\n      metrics: components.metrics\n    })\n    // a started job errored\n    this.queue.addEventListener('error', (event) => {\n      if (event.detail.name !== AbortError.name) {\n        this.log.error('error in dial queue - %e', event.detail)\n      }\n    })\n  }\n\n  start (): void {\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  stop (): void {\n    this.shutDownController.abort()\n    this.queue.abort()\n  }\n\n  /**\n   * Connects to a given peer, multiaddr or list of multiaddrs.\n   *\n   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n   * multiaddrs are passed only those will be dialled.\n   *\n   * Where a list of multiaddrs is passed, if any contain a peer id then all\n   * multiaddrs in the list must contain the same peer id.\n   *\n   * The dial to the first address that is successfully able to upgrade a\n   * connection will be used, all other dials will be aborted when that happens.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n    // make sure we don't have an existing connection to any of the addresses we\n    // are about to dial\n    const existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n      if (options.force === true) {\n        return false\n      }\n\n      if (conn.remotePeer.equals(peerId)) {\n        return true\n      }\n\n      return multiaddrs.find(addr => {\n        return addr.equals(conn.remoteAddr)\n      })\n    })\n\n    if (existingConnection?.status === 'open') {\n      this.log('already connected to %a', existingConnection.remoteAddr)\n      options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n      return existingConnection\n    }\n\n    // ready to dial, all async work finished - make sure we don't have any\n    // pending dials in progress for this peer or set of multiaddrs\n    const existingDial = this.queue.queue.find(job => {\n      if (peerId?.equals(job.options.peerId) === true) {\n        return true\n      }\n\n      // does the dial contain any of the target multiaddrs?\n      const addresses = job.options.multiaddrs\n\n      if (addresses == null) {\n        return false\n      }\n\n      for (const multiaddr of multiaddrs) {\n        if (addresses.has(multiaddr.toString())) {\n          return true\n        }\n      }\n\n      return false\n    })\n\n    if (existingDial != null) {\n      this.log('joining existing dial target for %p', peerId)\n\n      // add all multiaddrs to the dial target\n      for (const multiaddr of multiaddrs) {\n        existingDial.options.multiaddrs.add(multiaddr.toString())\n      }\n\n      options.onProgress?.(new CustomProgressEvent('dial-queue:already-in-dial-queue'))\n      return existingDial.join(options)\n    }\n\n    if (this.queue.size >= this.maxDialQueueLength) {\n      throw new DialError('Dial queue is full')\n    }\n\n    this.log('creating dial target for %p', peerId, multiaddrs.map(ma => ma.toString()))\n\n    options.onProgress?.(new CustomProgressEvent('dial-queue:add-to-dial-queue'))\n    return this.queue.add(async (options) => {\n      options?.onProgress?.(new CustomProgressEvent('dial-queue:start-dial'))\n      // create abort conditions - need to do this before `calculateMultiaddrs` as\n      // we may be about to resolve a dns addr which can time out\n      const signal = anySignal([\n        this.shutDownController.signal,\n        options.signal\n      ])\n      setMaxListeners(Infinity, signal)\n\n      let addrsToDial: Address[]\n\n      try {\n        // load addresses from address book, resolve and dnsaddrs, filter\n        // undiallables, add peer IDs, etc\n        addrsToDial = await this.calculateMultiaddrs(peerId, options?.multiaddrs, {\n          ...options,\n          signal\n        })\n\n        options?.onProgress?.(new CustomProgressEvent<Address[]>('dial-queue:calculated-addresses', addrsToDial))\n\n        addrsToDial.map(({ multiaddr }) => multiaddr.toString()).forEach(addr => {\n          options?.multiaddrs.add(addr)\n        })\n      } catch (err) {\n        signal.clear()\n        throw err\n      }\n\n      try {\n        let dialed = 0\n        const errors: Error[] = []\n\n        for (const address of addrsToDial) {\n          if (dialed === this.maxPeerAddrsToDial) {\n            this.log('dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others', dialed, peerId)\n\n            throw new DialError('Peer had more than maxPeerAddrsToDial')\n          }\n\n          dialed++\n\n          try {\n            const conn = await this.components.transportManager.dial(address.multiaddr, {\n              ...options,\n              signal\n            })\n\n            this.log('dial to %a succeeded', address.multiaddr)\n\n            // record the successful dial and the address\n            try {\n              await this.components.peerStore.merge(conn.remotePeer, {\n                multiaddrs: [\n                  conn.remoteAddr\n                ],\n                metadata: {\n                  [LAST_DIAL_SUCCESS_KEY]: uint8ArrayFromString(Date.now().toString())\n                }\n              })\n            } catch (err: any) {\n              this.log.error('could not update last dial failure key for %p', peerId, err)\n            }\n\n            return conn\n          } catch (err: any) {\n            this.log.error('dial failed to %a', address.multiaddr, err)\n\n            if (peerId != null) {\n              // record the failed dial\n              try {\n                await this.components.peerStore.merge(peerId, {\n                  metadata: {\n                    [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                  }\n                })\n              } catch (err: any) {\n                this.log.error('could not update last dial failure key for %p', peerId, err)\n              }\n            }\n\n            // the user/dial timeout/shutdown controller signal aborted\n            if (signal.aborted) {\n              throw new TimeoutError(err.message)\n            }\n\n            errors.push(err)\n          }\n        }\n\n        if (errors.length === 1) {\n          throw errors[0]\n        }\n\n        throw new AggregateError(errors, 'All multiaddr dials failed')\n      } finally {\n        // clean up abort signals/controllers\n        signal.clear()\n      }\n    }, {\n      peerId,\n      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,\n      multiaddrs: new Set(multiaddrs.map(ma => ma.toString())),\n      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),\n      onProgress: options.onProgress\n    })\n  }\n\n  // eslint-disable-next-line complexity\n  private async calculateMultiaddrs (peerId?: PeerId, multiaddrs: Set<string> = new Set<string>(), options: OpenConnectionOptions = {}): Promise<Address[]> {\n    const addrs: Address[] = [...multiaddrs].map(ma => ({\n      multiaddr: multiaddr(ma),\n      isCertified: false\n    }))\n\n    // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw new DialError('Tried to dial self')\n      }\n\n      if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {\n        throw new DialDeniedError('The dial request is blocked by gater.allowDialPeer')\n      }\n\n      // if just a peer id was passed, load available multiaddrs for this peer\n      // from the peer store\n      if (addrs.length === 0) {\n        this.log('loading multiaddrs for %p', peerId)\n        try {\n          const peer = await this.components.peerStore.get(peerId)\n          addrs.push(...peer.addresses)\n          this.log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n        } catch (err: any) {\n          if (err.name !== 'NotFoundError') {\n            throw err\n          }\n        }\n      }\n\n      // if we still don't have any addresses for this peer, try a lookup\n      // using the peer routing\n      if (addrs.length === 0) {\n        this.log('looking up multiaddrs for %p in the peer routing', peerId)\n\n        try {\n          const peerInfo = await this.components.peerRouting.findPeer(peerId, options)\n\n          this.log('found multiaddrs for %p in the peer routing', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n\n          addrs.push(...peerInfo.multiaddrs.map(multiaddr => ({\n            multiaddr,\n            isCertified: false\n          })))\n        } catch (err: any) {\n          if (err.name !== 'NoPeerRoutersError') {\n            this.log.error('looking up multiaddrs for %p in the peer routing failed', peerId, err)\n          }\n        }\n      }\n    }\n\n    // resolve addresses - this can result in a one-to-many translation when\n    // dnsaddrs are resolved\n    let resolvedAddresses = (await Promise.all(\n      addrs.map(async addr => {\n        const result = await resolveMultiaddrs(addr.multiaddr, {\n          dns: this.components.dns,\n          ...options,\n          log: this.log\n        })\n\n        if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n          return addr\n        }\n\n        return result.map(multiaddr => ({\n          multiaddr,\n          isCertified: false\n        }))\n      })\n    ))\n      .flat()\n\n    // ensure the peer id is appended to the multiaddr\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      resolvedAddresses = resolvedAddresses.map(addr => {\n        const lastProto = addr.multiaddr.protos().pop()\n\n        // do not append peer id to path multiaddrs\n        if (lastProto?.path === true) {\n          return addr\n        }\n\n        // append peer id to multiaddr if it is not already present\n        if (addr.multiaddr.getPeerId() == null) {\n          return {\n            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n            isCertified: addr.isCertified\n          }\n        }\n\n        return addr\n      })\n    }\n\n    const filteredAddrs = resolvedAddresses.filter(addr => {\n      // filter out any multiaddrs that we do not have transports for\n      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {\n        return false\n      }\n\n      // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n      // - this can happen with addresses like bootstrap.libp2p.io that resolve\n      // to multiple different peers\n      const addrPeerId = addr.multiaddr.getPeerId()\n      if (peerId != null && addrPeerId != null) {\n        return peerId.equals(addrPeerId)\n      }\n\n      return true\n    })\n\n    // deduplicate addresses\n    const dedupedAddrs = new Map<string, Address>()\n\n    for (const addr of filteredAddrs) {\n      const maStr = addr.multiaddr.toString()\n      const existing = dedupedAddrs.get(maStr)\n\n      if (existing != null) {\n        existing.isCertified = existing.isCertified || addr.isCertified || false\n        continue\n      }\n\n      dedupedAddrs.set(maStr, addr)\n    }\n\n    const dedupedMultiaddrs = [...dedupedAddrs.values()]\n\n    // make sure we actually have some addresses to dial\n    if (dedupedMultiaddrs.length === 0) {\n      throw new NoValidAddressesError('The dial request has no valid addresses')\n    }\n\n    const gatedAdrs: Address[] = []\n\n    for (const addr of dedupedMultiaddrs) {\n      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n        continue\n      }\n\n      gatedAdrs.push(addr)\n    }\n\n    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAdrs) : gatedAdrs.sort(this.addressSorter)\n\n    // make sure we actually have some addresses to dial\n    if (sortedGatedAddrs.length === 0) {\n      throw new DialDeniedError('The connection gater denied all addresses in the dial request')\n    }\n\n    this.log.trace('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()))\n    this.log.trace('addresses for %p after filtering', peerId ?? 'unknown peer', sortedGatedAddrs.map(({ multiaddr }) => multiaddr.toString()))\n\n    return sortedGatedAddrs\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    if (!Array.isArray(multiaddr)) {\n      multiaddr = [multiaddr]\n    }\n\n    try {\n      const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map(ma => ma.toString())), options)\n\n      if (options.runOnLimitedConnection === false) {\n        // return true if any resolved multiaddrs are not relay addresses\n        return addresses.find(addr => {\n          return !Circuit.matches(addr.multiaddr)\n        }) != null\n      }\n\n      return true\n    } catch (err) {\n      this.log.trace('error calculating if multiaddr(s) were dialable', err)\n    }\n\n    return false\n  }\n}\n", "import { Queue } from './queue/index.js'\nimport type { Job } from './queue/job.js'\nimport type { AbortOptions, PeerId } from '@libp2p/interface'\n\nexport interface PeerQueueJobOptions extends AbortOptions {\n  peerId: PeerId\n}\n\n/**\n * Extends Queue to add support for querying queued jobs by peer id\n */\nexport class PeerQueue<JobReturnType = void, JobOptions extends PeerQueueJobOptions = PeerQueueJobOptions> extends Queue<JobReturnType, JobOptions> {\n  has (peerId: PeerId): boolean {\n    return this.find(peerId) != null\n  }\n\n  find (peerId: PeerId): Job<JobOptions, JobReturnType> | undefined {\n    return this.queue.find(job => {\n      return peerId.equals(job.options.peerId)\n    })\n  }\n}\n", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n", "import { KEEP_ALIVE } from '@libp2p/interface'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport pRetry from 'p-retry'\nimport { MAX_PARALLEL_RECONNECTS } from './constants.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, Metrics, Peer, PeerId, PeerStore, Startable, TypedEventTarget } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\nexport interface ReconnectQueueComponents {\n  connectionManager: ConnectionManager\n  events: TypedEventTarget<Libp2pEvents>\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface ReconnectQueueInit {\n  retries?: number\n  retryInterval?: number\n  backoffFactor?: number\n  maxParallelReconnects?: number\n}\n\n/**\n * When peers tagged with `KEEP_ALIVE` disconnect, this component attempts to\n * redial them\n */\nexport class ReconnectQueue implements Startable {\n  private readonly log: Logger\n  private readonly queue: PeerQueue\n  private started: boolean\n  private readonly peerStore: PeerStore\n  private readonly retries: number\n  private readonly retryInterval?: number\n  private readonly backoffFactor?: number\n  private readonly connectionManager: ConnectionManager\n  private readonly events: TypedEventTarget<Libp2pEvents>\n\n  constructor (components: ReconnectQueueComponents, init: ReconnectQueueInit = {}) {\n    this.log = components.logger.forComponent('libp2p:reconnect-queue')\n    this.peerStore = components.peerStore\n    this.connectionManager = components.connectionManager\n    this.queue = new PeerQueue({\n      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,\n      metricName: 'libp2p_reconnect_queue',\n      metrics: components.metrics\n    })\n    this.started = false\n    this.retries = init.retries ?? 5\n    this.backoffFactor = init.backoffFactor\n    this.retryInterval = init.retryInterval\n    this.events = components.events\n\n    components.events.addEventListener('peer:disconnect', (evt) => {\n      this.maybeReconnect(evt.detail)\n        .catch(err => {\n          this.log.error('failed to maybe reconnect to %p - %e', evt.detail, err)\n        })\n    })\n  }\n\n  private async maybeReconnect (peerId: PeerId): Promise<void> {\n    if (!this.started) {\n      return\n    }\n\n    const peer = await this.peerStore.get(peerId)\n\n    if (!hasKeepAliveTag(peer)) {\n      return\n    }\n\n    if (this.queue.has(peerId)) {\n      return\n    }\n\n    this.queue.add(async (options) => {\n      await pRetry(async (attempt) => {\n        if (!this.started) {\n          return\n        }\n\n        try {\n          await this.connectionManager.openConnection(peerId, {\n            signal: options?.signal\n          })\n        } catch (err) {\n          this.log('reconnecting to %p attempt %d of %d failed - %e', peerId, attempt, this.retries, err)\n          throw err\n        }\n      }, {\n        signal: options?.signal,\n        retries: this.retries,\n        factor: this.backoffFactor,\n        minTimeout: this.retryInterval\n      })\n    }, {\n      peerId\n    })\n      .catch(async err => {\n        this.log.error('failed to reconnect to %p - %e', peerId, err)\n\n        const tags: Record<string, undefined> = {}\n\n        ;[...peer.tags.keys()].forEach(key => {\n          if (key.startsWith(KEEP_ALIVE)) {\n            tags[key] = undefined\n          }\n        })\n\n        await this.peerStore.merge(peerId, {\n          tags\n        })\n\n        this.events.safeDispatchEvent('peer:reconnect-failure', {\n          detail: peerId\n        })\n      })\n      .catch(async err => {\n        this.log.error('failed to remove keep-alive tag from %p - %e', peerId, err)\n      })\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: Peer[] = await this.peerStore.all({\n          filters: [\n            (peer) => hasKeepAliveTag(peer)\n          ]\n        })\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.connectionManager.openConnection(peer.id)\n              .catch(err => {\n                this.log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        this.log.error(err)\n      })\n  }\n\n  stop (): void {\n    this.started = false\n    this.queue.abort()\n  }\n}\n\nfunction hasKeepAliveTag (peer: Peer): boolean {\n  for (const tag of peer.tags.keys()) {\n    if (tag.startsWith(KEEP_ALIVE)) {\n      return true\n    }\n  }\n\n  return false\n}\n", "import { ConnectionClosedError, InvalidMultiaddrError, InvalidParametersError, InvalidPeerIdError, NotStartedError, start, stop } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { RateLimiter } from '@libp2p/utils/rate-limiter'\nimport { type Multiaddr, type Resolver, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { CustomProgressEvent } from 'progress-events'\nimport { getPeerAddress } from '../get-peer.js'\nimport { ConnectionPruner } from './connection-pruner.js'\nimport { DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_DIAL_QUEUE_LENGTH, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL } from './constants.js'\nimport { DialQueue } from './dial-queue.js'\nimport { ReconnectQueue } from './reconnect-queue.js'\nimport { multiaddrToIpNet } from './utils.js'\nimport type { IpNet } from '@chainsafe/netmask'\nimport type { PendingDial, AddressSorter, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, MultiaddrConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, PeerStore, Startable, PendingDialStatus, PeerRouting, IsDialableOptions } from '@libp2p/interface'\nimport type { ConnectionManager, OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { JobStatus } from '@libp2p/utils/queue'\n\nexport const DEFAULT_DIAL_PRIORITY = 50\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections libp2p is willing to have before it\n   * starts pruning connections to reduce resource usage.\n   *\n   * @default 300/100\n   */\n  maxConnections?: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial, By default public\n   * addresses will be dialled before private (e.g. loopback or LAN) addresses.\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * The maximum number of dials across all peers to execute in parallel.\n   *\n   * @default 100/50\n   */\n  maxParallelDials?: number\n\n  /**\n   * The maximum size the dial queue is allowed to grow to. Promises returned\n   * when dialing peers after this limit is reached will not resolve until the\n   * queue size falls beneath this size.\n   *\n   * @default 500\n   */\n  maxDialQueueLength?: number\n\n  /**\n   * Maximum number of addresses allowed for a given peer before giving up\n   *\n   * @default 25\n   */\n  maxPeerAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   *\n   * @default 5000\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new incoming connection is opened, the upgrade process (e.g.\n   * protect, encrypt, multiplex etc) must complete within this number of ms.\n   *\n   * @default 3000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * When a new outbound connection is opened, the upgrade process (e.g.\n   * protect, encrypt, multiplex etc) must complete within this number of ms.\n   *\n   * @default 3000\n   */\n  outboundUpgradeTimeout?: number\n\n  /**\n   * Protocol negotiation must complete within this number of ms\n   *\n   * @default 2000\n   */\n  protocolNegotiationTimeout?: number\n\n  /**\n   * Multiaddr resolvers to use when dialling\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached\n   * maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections.\n   *\n   * @default 5\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet\n   * to complete the connection upgrade - e.g. choosing connection encryption,\n   * muxer, etc.\n   *\n   * @default 10\n   */\n  maxIncomingPendingConnections?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, attempt to redial them\n   * this many times.\n   *\n   * @default 5\n   */\n  reconnectRetries?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, wait this long between\n   * each retry. Note this will be multiplied by `reconnectFactor` to create an\n   * increasing retry backoff.\n   *\n   * @default 1000\n   */\n  reconnectRetryInterval?: number\n\n  /**\n   * When a peer tagged with `KEEP_ALIVE` disconnects, apply this multiplication\n   * factor to the time interval between each retry.\n   *\n   * @default 2\n   */\n  reconnectBackoffFactor?: number\n\n  /**\n   * When a peers tagged with `KEEP_ALIVE` disconnect, reconnect to this many at\n   * once.\n   *\n   * @default 5\n   */\n  maxParallelReconnects?: number\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS\n}\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager implements ConnectionManager, Startable {\n  private started: boolean\n  private readonly connections: PeerMap<Connection[]>\n  private readonly allow: IpNet[]\n  private readonly deny: IpNet[]\n  private readonly maxIncomingPendingConnections: number\n  private incomingPendingConnections: number\n  private outboundPendingConnections: number\n  private readonly maxConnections: number\n\n  public readonly dialQueue: DialQueue\n  public readonly reconnectQueue: ReconnectQueue\n  public readonly connectionPruner: ConnectionPruner\n  private readonly inboundConnectionRateLimiter: RateLimiter\n  private readonly peerStore: PeerStore\n  private readonly metrics?: Metrics\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n  private readonly peerId: PeerId\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n\n    if (this.maxConnections < 1) {\n      throw new InvalidParametersError('Connection Manager maxConnections must be greater than 0')\n    }\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new PeerMap()\n\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.metrics = components.metrics\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager')\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n\n    // allow/deny lists\n    this.allow = (init.allow ?? []).map(str => multiaddrToIpNet(str))\n    this.deny = (init.deny ?? []).map(str => multiaddrToIpNet(str))\n\n    this.incomingPendingConnections = 0\n    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections\n    this.outboundPendingConnections = 0\n\n    // controls individual peers trying to dial us too quickly\n    this.inboundConnectionRateLimiter = new RateLimiter({\n      points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    // controls what happens when we have too many connections\n    this.connectionPruner = new ConnectionPruner({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      maxConnections: this.maxConnections,\n      allow: init.allow?.map(a => multiaddr(a))\n    })\n\n    this.dialQueue = new DialQueue(components, {\n      addressSorter: init.addressSorter,\n      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,\n      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n      resolvers: init.resolvers ?? {\n        dnsaddr: dnsaddrResolver\n      },\n      connections: this.connections\n    })\n\n    this.reconnectQueue = new ReconnectQueue({\n      events: components.events,\n      peerStore: components.peerStore,\n      logger: components.logger,\n      connectionManager: this\n    }, {\n      retries: init.reconnectRetries,\n      retryInterval: init.reconnectRetryInterval,\n      backoffFactor: init.reconnectBackoffFactor,\n      maxParallelReconnects: init.maxParallelReconnects\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-manager'\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start (): Promise<void> {\n    // track inbound/outbound connections\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          'inbound pending': this.incomingPendingConnections,\n          outbound: 0,\n          'outbound pending': this.outboundPendingConnections\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            metric[conn.direction]++\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    this.events.addEventListener('connection:open', this.onConnect)\n    this.events.addEventListener('connection:close', this.onDisconnect)\n\n    await start(\n      this.dialQueue,\n      this.reconnectQueue,\n      this.connectionPruner\n    )\n\n    this.started = true\n    this.log('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop (): Promise<void> {\n    this.events.removeEventListener('connection:open', this.onConnect)\n    this.events.removeEventListener('connection:close', this.onDisconnect)\n\n    await stop(\n      this.reconnectQueue,\n      this.dialQueue,\n      this.connectionPruner\n    )\n\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            this.log.error(err)\n          }\n        })())\n      }\n    }\n\n    this.log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n\n    this.log('stopped')\n  }\n\n  getMaxConnections (): number {\n    return this.maxConnections\n  }\n\n  onConnect (evt: CustomEvent<Connection>): void {\n    void this._onConnect(evt).catch(err => {\n      this.log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>): Promise<void> {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    if (connection.status !== 'open') {\n      // this can happen when the remote closes the connection immediately after\n      // opening\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const isNewPeer = !this.connections.has(peerId)\n    const storedConns = this.connections.get(peerId) ?? []\n    storedConns.push(connection)\n\n    this.connections.set(peerId, storedConns)\n\n    // only need to store RSA public keys, all other types are embedded in the peer id\n    if (peerId.publicKey != null && peerId.type === 'RSA') {\n      await this.peerStore.patch(peerId, {\n        publicKey: peerId.publicKey\n      })\n    }\n\n    if (isNewPeer) {\n      this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer })\n    }\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>): void {\n    const { detail: connection } = evt\n    const peerId = connection.remotePeer\n    const peerConns = this.connections.get(peerId) ?? []\n\n    // remove closed connection\n    const filteredPeerConns = peerConns.filter(conn => conn.id !== connection.id)\n\n    // update peer connections\n    this.connections.set(peerId, filteredPeerConns)\n\n    if (filteredPeerConns.length === 0) {\n      // trigger disconnect event if no connections remain\n      this.log('onDisconnect remove all connections for peer %p', peerId)\n      this.connections.delete(peerId)\n\n      // broadcast disconnect event\n      this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer })\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  getConnectionsMap (): PeerMap<Connection[]> {\n    return this.connections\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    if (!this.started) {\n      throw new NotStartedError('Not started')\n    }\n\n    this.outboundPendingConnections++\n\n    try {\n      options.signal?.throwIfAborted()\n\n      const { peerId } = getPeerAddress(peerIdOrMultiaddr)\n\n      if (this.peerId.equals(peerId)) {\n        throw new InvalidPeerIdError('Can not dial self')\n      }\n\n      if (peerId != null && options.force !== true) {\n        this.log('dial %p', peerId)\n        const existingConnection = this.getConnections(peerId)\n          .find(conn => conn.limits == null)\n\n        if (existingConnection != null) {\n          this.log('had an existing non-limited connection to %p', peerId)\n\n          options.onProgress?.(new CustomProgressEvent('dial-queue:already-connected'))\n          return existingConnection\n        }\n      }\n\n      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n        ...options,\n        priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n      })\n\n      if (connection.status !== 'open') {\n        throw new ConnectionClosedError('Remote closed connection during opening')\n      }\n\n      let peerConnections = this.connections.get(connection.remotePeer)\n\n      if (peerConnections == null) {\n        peerConnections = []\n        this.connections.set(connection.remotePeer, peerConnections)\n      }\n\n      // we get notified of connections via the Upgrader emitting \"connection\"\n      // events, double check we aren't already tracking this connection before\n      // storing it\n      let trackedConnection = false\n\n      for (const conn of peerConnections) {\n        if (conn.id === connection.id) {\n          trackedConnection = true\n        }\n\n        // make sure we don't already have a connection to this multiaddr\n        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {\n          connection.abort(new InvalidMultiaddrError('Duplicate multiaddr connection'))\n\n          // return the existing connection\n          return conn\n        }\n      }\n\n      if (!trackedConnection) {\n        peerConnections.push(connection)\n      }\n\n      return connection\n    } finally {\n      this.outboundPendingConnections--\n    }\n  }\n\n  async closeConnections (peerId: PeerId, options: AbortOptions = {}): Promise<void> {\n    const connections = this.connections.get(peerId) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        try {\n          await connection.close(options)\n        } catch (err: any) {\n          connection.abort(err)\n        }\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return ma.contains(maConn.remoteAddr.nodeAddress().address)\n    })\n\n    if (denyConnection) {\n      this.log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ipNet => {\n      return ipNet.contains(maConn.remoteAddr.nodeAddress().address)\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n      this.log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr)\n      return false\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1)\n      } catch {\n        this.log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    this.log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound (): void {\n    this.incomingPendingConnections--\n  }\n\n  getDialQueue (): PendingDial[] {\n    const statusMap: Record<JobStatus, PendingDialStatus> = {\n      queued: 'queued',\n      running: 'active',\n      errored: 'error',\n      complete: 'success'\n    }\n\n    return this.dialQueue.queue.queue.map(job => {\n      return {\n        id: job.id,\n        status: statusMap[job.status],\n        peerId: job.options.peerId,\n        multiaddrs: [...job.options.multiaddrs].map(ma => multiaddr(ma))\n      }\n    })\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    return this.dialQueue.isDialable(multiaddr, options)\n  }\n}\n", "/**\n * Implements exponential moving average. Ported from `moving-average`.\n *\n * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n * @see https://www.npmjs.com/package/moving-average\n */\nexport class MovingAverage {\n  public movingAverage: number\n  public variance: number\n  public deviation: number\n  public forecast: number\n  private readonly timespan: number\n  private previousTime?: number\n\n  constructor (timespan: number) {\n    this.timespan = timespan\n    this.movingAverage = 0\n    this.variance = 0\n    this.deviation = 0\n    this.forecast = 0\n  }\n\n  alpha (t: number, pt: number): number {\n    return 1 - (Math.exp(-(t - pt) / this.timespan))\n  }\n\n  push (value: number, time: number = Date.now()): void {\n    if (this.previousTime != null) {\n      // calculate moving average\n      const a = this.alpha(time, this.previousTime)\n      const diff = value - this.movingAverage\n      const incr = a * diff\n      this.movingAverage = a * value + (1 - a) * this.movingAverage\n      // calculate variance & deviation\n      this.variance = (1 - a) * (this.variance + diff * incr)\n      this.deviation = Math.sqrt(this.variance)\n      // calculate forecast\n      this.forecast = this.movingAverage + a * diff\n    } else {\n      this.movingAverage = value\n    }\n\n    this.previousTime = time\n  }\n}\n", "import { setMaxListeners } from '@libp2p/interface'\nimport { anySignal, type ClearableSignal } from 'any-signal'\nimport { MovingAverage } from './moving-average.js'\nimport type { MetricGroup, Metrics } from '@libp2p/interface'\n\nexport const DEFAULT_TIMEOUT_MULTIPLIER = 1.2\nexport const DEFAULT_FAILURE_MULTIPLIER = 2\nexport const DEFAULT_MIN_TIMEOUT = 2000\n\nexport interface AdaptiveTimeoutSignal extends ClearableSignal {\n  start: number\n  timeout: number\n}\n\nexport interface AdaptiveTimeoutInit {\n  metricName?: string\n  metrics?: Metrics\n  interval?: number\n  initialValue?: number\n  timeoutMultiplier?: number\n  failureMultiplier?: number\n  minTimeout?: number\n}\n\nexport interface GetTimeoutSignalOptions {\n  timeoutFactor?: number\n  signal?: AbortSignal\n}\n\nexport class AdaptiveTimeout {\n  private readonly success: MovingAverage\n  private readonly failure: MovingAverage\n  private readonly next: MovingAverage\n  private readonly metric?: MetricGroup\n  private readonly timeoutMultiplier: number\n  private readonly failureMultiplier: number\n  private readonly minTimeout: number\n\n  constructor (init: AdaptiveTimeoutInit = {}) {\n    this.success = new MovingAverage(init.interval ?? 5000)\n    this.failure = new MovingAverage(init.interval ?? 5000)\n    this.next = new MovingAverage(init.interval ?? 5000)\n    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER\n    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER\n    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT\n\n    if (init.metricName != null) {\n      this.metric = init.metrics?.registerMetricGroup(init.metricName)\n    }\n  }\n\n  getTimeoutSignal (options: GetTimeoutSignalOptions = {}): AdaptiveTimeoutSignal {\n    // calculate timeout for individual peers based on moving average of\n    // previous successful requests\n    const timeout = Math.max(\n      Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier)),\n      this.minTimeout\n    )\n    const sendTimeout = AbortSignal.timeout(timeout)\n    const timeoutSignal = anySignal([options.signal, sendTimeout]) as AdaptiveTimeoutSignal\n    setMaxListeners(Infinity, timeoutSignal, sendTimeout)\n\n    timeoutSignal.start = Date.now()\n    timeoutSignal.timeout = timeout\n\n    return timeoutSignal\n  }\n\n  cleanUp (signal: AdaptiveTimeoutSignal): void {\n    const time = Date.now() - signal.start\n\n    if (signal.aborted) {\n      this.failure.push(time)\n      this.next.push(time * this.failureMultiplier)\n      this.metric?.update({\n        failureMovingAverage: this.failure.movingAverage,\n        failureDeviation: this.failure.deviation,\n        failureForecast: this.failure.forecast,\n        failureVariance: this.failure.variance,\n        failure: time\n      })\n    } else {\n      this.success.push(time)\n      this.next.push(time)\n      this.metric?.update({\n        successMovingAverage: this.success.movingAverage,\n        successDeviation: this.success.deviation,\n        successForecast: this.success.forecast,\n        successVariance: this.success.variance,\n        success: time\n      })\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { AdaptiveTimeout } from '@libp2p/utils/adaptive-timeout'\nimport { byteStream } from 'it-byte-stream'\nimport type { ComponentLogger, Logger, Metrics, Startable } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { AdaptiveTimeoutInit } from '@libp2p/utils/adaptive-timeout'\n\nconst DEFAULT_PING_INTERVAL_MS = 10000\nconst PROTOCOL_VERSION = '1.0.0'\nconst PROTOCOL_NAME = 'ping'\nconst PROTOCOL_PREFIX = 'ipfs'\nconst PING_LENGTH = 32\nconst DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true\n\nexport interface ConnectionMonitorInit {\n  /**\n   * Whether the connection monitor is enabled\n   *\n   * @default true\n   */\n  enabled?: boolean\n\n  /**\n   * How often to ping remote peers in ms\n   *\n   * @default 10000\n   */\n  pingInterval?: number\n\n  /**\n   * Timeout settings for how long the ping is allowed to take before the\n   * connection will be judged inactive and aborted.\n   *\n   * The timeout is adaptive to cope with slower networks or nodes that\n   * have changing network characteristics, such as mobile.\n   */\n  pingTimeout?: Omit<AdaptiveTimeoutInit, 'metricsName' | 'metrics'>\n\n  /**\n   * If true, any connection that fails the ping will be aborted\n   *\n   * @default true\n   */\n  abortConnectionOnPingFailure?: boolean\n\n  /**\n   * Override the ping protocol prefix\n   *\n   * @default 'ipfs'\n   */\n  protocolPrefix?: string\n}\n\nexport interface ConnectionMonitorComponents {\n  logger: ComponentLogger\n  connectionManager: ConnectionManager\n  metrics?: Metrics\n}\n\nexport class ConnectionMonitor implements Startable {\n  private readonly protocol: string\n  private readonly components: ConnectionMonitorComponents\n  private readonly log: Logger\n  private heartbeatInterval?: ReturnType<typeof setInterval>\n  private readonly pingIntervalMs: number\n  private abortController?: AbortController\n  private readonly timeout: AdaptiveTimeout\n  private readonly abortConnectionOnPingFailure: boolean\n\n  constructor (components: ConnectionMonitorComponents, init: ConnectionMonitorInit = {}) {\n    this.components = components\n    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`\n\n    this.log = components.logger.forComponent('libp2p:connection-monitor')\n    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS\n    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE\n    this.timeout = new AdaptiveTimeout({\n      ...(init.pingTimeout ?? {}),\n      metrics: components.metrics,\n      metricName: 'libp2p_connection_monitor_ping_time_milliseconds'\n    })\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/connection-monitor'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/connection-monitor'\n  ]\n\n  start (): void {\n    this.abortController = new AbortController()\n    setMaxListeners(Infinity, this.abortController.signal)\n\n    this.heartbeatInterval = setInterval(() => {\n      this.components.connectionManager.getConnections().forEach(conn => {\n        Promise.resolve().then(async () => {\n          let start = Date.now()\n          try {\n            const signal = this.timeout.getTimeoutSignal({\n              signal: this.abortController?.signal\n            })\n            const stream = await conn.newStream(this.protocol, {\n              signal,\n              runOnLimitedConnection: true\n            })\n            const bs = byteStream(stream)\n            start = Date.now()\n\n            await Promise.all([\n              bs.write(randomBytes(PING_LENGTH), {\n                signal\n              }),\n              bs.read(PING_LENGTH, {\n                signal\n              })\n            ])\n\n            conn.rtt = Date.now() - start\n\n            await bs.unwrap().close({\n              signal\n            })\n          } catch (err: any) {\n            if (err.name !== 'UnsupportedProtocolError') {\n              throw err\n            }\n\n            // protocol was unsupported, but that's ok as it means the remote\n            // peer was still alive. We ran multistream-select which means two\n            // round trips (e.g. 1x for the mss header, then another for the\n            // protocol) so divide the time it took by two\n            conn.rtt = (Date.now() - start) / 2\n          }\n        })\n          .catch(err => {\n            this.log.error('error during heartbeat', err)\n\n            if (this.abortConnectionOnPingFailure) {\n              this.log.error('aborting connection due to ping failure')\n              conn.abort(err)\n            } else {\n              this.log('connection ping failed, but not aborting due to abortConnectionOnPingFailure flag')\n            }\n          })\n      })\n    }, this.pingIntervalMs)\n  }\n\n  stop (): void {\n    this.abortController?.abort()\n\n    if (this.heartbeatInterval != null) {\n      clearInterval(this.heartbeatInterval)\n    }\n  }\n}\n", "import { NotStartedError } from '@libp2p/interface'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport merge from 'it-merge'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoContentRoutersError } from './errors.js'\nimport type { AbortOptions, ComponentLogger, ContentRouting, Metrics, PeerInfo, PeerRouting, PeerStore, RoutingOptions, Startable } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nexport interface CompoundContentRoutingInit {\n  routers: ContentRouting[]\n}\n\nexport interface CompoundContentRoutingComponents {\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class CompoundContentRouting implements ContentRouting, Startable {\n  private readonly routers: ContentRouting[]\n  private started: boolean\n  private readonly components: CompoundContentRoutingComponents\n\n  constructor (components: CompoundContentRoutingComponents, init: CompoundContentRoutingInit) {\n    this.routers = init.routers ?? []\n    this.started = false\n    this.components = components\n\n    this.findProviders = components.metrics?.traceFunction('libp2p.contentRouting.findProviders', this.findProviders.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { providers?: string[] }) => {\n        return {\n          ...attrs,\n          providers: [...(Array.isArray(attrs.providers) ? attrs.providers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.findProviders\n    this.provide = components.metrics?.traceFunction('libp2p.contentRouting.provide', this.provide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.provide\n    this.cancelReprovide = components.metrics?.traceFunction('libp2p.contentRouting.cancelReprovide', this.cancelReprovide.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([cid], attrs) => {\n        return {\n          ...attrs,\n          cid: cid.toString()\n        }\n      }\n    }) ?? this.cancelReprovide\n    this.put = components.metrics?.traceFunction('libp2p.contentRouting.put', this.put.bind(this), {\n      optionsIndex: 2,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.put\n    this.get = components.metrics?.traceFunction('libp2p.contentRouting.get', this.get.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key]) => {\n        return {\n          key: uint8ArrayToString(key, 'base36')\n        }\n      }\n    }) ?? this.get\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/content-routing'\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.started = false\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key\n   */\n  async * findProviders (key: CID, options: RoutingOptions = {}): AsyncGenerator<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    const self = this\n    const seen = new PeerSet()\n\n    for await (const peer of merge(\n      ...self.routers.map(router => router.findProviders(key, options))\n    )) {\n      // the peer was yielded by a content router without multiaddrs and we\n      // failed to load them\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.components.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id)) {\n        continue\n      }\n\n      seen.add(peer.id)\n\n      yield peer\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key\n   */\n  async provide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.provide(key, options)\n    }))\n  }\n\n  async cancelReprovide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new NoContentRoutersError('No content routers available')\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.cancelReprovide(key, options)\n    }))\n  }\n\n  /**\n   * Store the given key/value pair in the available content routings\n   */\n  async put (key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.put(key, value, options)\n    }))\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   */\n  async get (key: Uint8Array, options?: AbortOptions): Promise<Uint8Array> {\n    if (!this.isStarted()) {\n      throw new NotStartedError()\n    }\n\n    return Promise.any(this.routers.map(async (router) => {\n      return router.get(key, options)\n    }))\n  }\n}\n", "import { NotFoundError } from '@libp2p/interface'\nimport { createScalableCuckooFilter } from '@libp2p/utils/filters'\nimport merge from 'it-merge'\nimport parallel from 'it-parallel'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { NoPeerRoutersError, QueriedForSelfError } from './errors.js'\nimport type { Logger, Metrics, PeerId, PeerInfo, PeerRouting, PeerStore, RoutingOptions } from '@libp2p/interface'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport class DefaultPeerRouting implements PeerRouting {\n  private readonly log: Logger\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly routers: PeerRouting[]\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-routing')\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.routers = init.routers ?? []\n\n    this.findPeer = components.metrics?.traceFunction('libp2p.peerRouting.findPeer', this.findPeer.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([peer], attrs) => {\n        return {\n          ...attrs,\n          peer: peer.toString()\n        }\n      }\n    }) ?? this.findPeer\n    this.getClosestPeers = components.metrics?.traceFunction('libp2p.peerRouting.getClosestPeers', this.getClosestPeers.bind(this), {\n      optionsIndex: 1,\n      getAttributesFromArgs: ([key], attrs) => {\n        return {\n          ...attrs,\n          key: uint8ArrayToString(key, 'base36')\n        }\n      },\n      getAttributesFromYieldedValue: (value, attrs: { peers?: string[] }) => {\n        return {\n          ...attrs,\n          peers: [...(Array.isArray(attrs.peers) ? attrs.peers : []), value.id.toString()]\n        }\n      }\n    }) ?? this.getClosestPeers\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/peer-routing'\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: RoutingOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    if (id.toString() === this.peerId.toString()) {\n      throw new QueriedForSelfError('Should not try to find self')\n    }\n\n    const self = this\n    const source = merge(\n      ...this.routers.map(router => (async function * () {\n        try {\n          yield await router.findPeer(id, options)\n        } catch (err) {\n          self.log.error(err)\n        }\n      })())\n    )\n\n    for await (const peer of source) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      return peer\n    }\n\n    throw new NotFoundError()\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options: RoutingOptions = {}): AsyncGenerator<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new NoPeerRoutersError('No peer routers available')\n    }\n\n    const self = this\n    const seen = createScalableCuckooFilter(1024)\n\n    for await (const peer of parallel(\n      async function * () {\n        const source = merge(\n          ...self.routers.map(router => router.getClosestPeers(key, options))\n        )\n\n        for await (let peer of source) {\n          yield async () => {\n            // find multiaddrs if they are missing\n            if (peer.multiaddrs.length === 0) {\n              try {\n                peer = await self.findPeer(peer.id, {\n                  ...options,\n                  useCache: false\n                })\n              } catch (err) {\n                self.log.error('could not find peer multiaddrs', err)\n                return\n              }\n            }\n\n            return peer\n          }\n        }\n      }()\n    )) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id.toMultihash().bytes)) {\n        continue\n      }\n\n      seen.add(peer.id.toMultihash().bytes)\n\n      yield peer\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { anySignal } from 'any-signal'\nimport pDefer, { type DeferredPromise } from 'p-defer'\nimport { raceEvent } from 'race-event'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions, ComponentLogger, Logger, PeerInfo, PeerRouting, Startable } from '@libp2p/interface'\nimport type { RandomWalk as RandomWalkInterface } from '@libp2p/interface-internal'\n\nexport interface RandomWalkComponents {\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n}\n\ninterface RandomWalkEvents {\n  'walk:peer': CustomEvent<PeerInfo>\n  'walk:error': CustomEvent<Error>\n}\n\nexport class RandomWalk extends TypedEventEmitter<RandomWalkEvents> implements RandomWalkInterface, Startable {\n  private readonly peerRouting: PeerRouting\n  private readonly log: Logger\n  private walking: boolean\n  private walkers: number\n  private shutdownController: AbortController\n  private walkController?: AbortController\n  private needNext?: DeferredPromise<void>\n\n  constructor (components: RandomWalkComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:random-walk')\n    this.peerRouting = components.peerRouting\n    this.walkers = 0\n    this.walking = false\n\n    // stops any in-progress walks when the node is shut down\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/random-walk'\n\n  start (): void {\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  stop (): void {\n    this.shutdownController.abort()\n  }\n\n  async * walk (options?: AbortOptions): AsyncGenerator<PeerInfo> {\n    if (!this.walking) {\n      // start the query that causes walk:peer events to be emitted\n      this.startWalk()\n    }\n\n    this.walkers++\n    const signal = anySignal([this.shutdownController.signal, options?.signal])\n    setMaxListeners(Infinity, signal)\n\n    try {\n      while (true) {\n        // if another consumer has paused the query, start it again\n        this.needNext?.resolve()\n        this.needNext = pDefer()\n\n        // wait for a walk:peer or walk:error event\n        const event = await raceEvent<CustomEvent<PeerInfo>>(this, 'walk:peer', signal, {\n          errorEvent: 'walk:error'\n        })\n\n        yield event.detail\n      }\n    } finally {\n      signal.clear()\n      this.walkers--\n\n      // stop the walk if no more consumers are interested\n      if (this.walkers === 0) {\n        this.walkController?.abort()\n        this.walkController = undefined\n      }\n    }\n  }\n\n  private startWalk (): void {\n    this.walking = true\n\n    // the signal for this controller will be aborted if no more random peers\n    // are required\n    this.walkController = new AbortController()\n    setMaxListeners(Infinity, this.walkController.signal)\n\n    const signal = anySignal([this.walkController.signal, this.shutdownController.signal])\n    setMaxListeners(Infinity, signal)\n\n    const start = Date.now()\n    let found = 0\n\n    Promise.resolve().then(async () => {\n      this.log('start walk')\n\n      // find peers until no more consumers are interested\n      while (this.walkers > 0) {\n        try {\n          const data = randomBytes(32)\n          let s = Date.now()\n\n          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {\n            if (signal.aborted) {\n              this.log('aborting walk')\n            }\n\n            signal.throwIfAborted()\n\n            this.log('found peer %p after %dms for %d walkers', peer.id, Date.now() - s, this.walkers)\n            found++\n            this.safeDispatchEvent('walk:peer', {\n              detail: peer\n            })\n\n            // if we only have one consumer, pause the query until they request\n            // another random peer or they signal they are no longer interested\n            if (this.walkers === 1 && this.needNext != null) {\n              this.log('wait for need next')\n              await raceSignal(this.needNext.promise, signal)\n            }\n\n            s = Date.now()\n          }\n\n          this.log('walk iteration for %b and %d walkers finished, found %d peers', data, this.walkers, found)\n        } catch (err) {\n          this.log.error('randomwalk errored', err)\n\n          this.safeDispatchEvent('walk:error', {\n            detail: err\n          })\n        }\n      }\n\n      this.log('no walkers left, ended walk')\n    })\n      .catch(err => {\n        this.log.error('randomwalk errored', err)\n      })\n      .finally(() => {\n        this.log('finished walk, found %d peers after %dms', found, Date.now() - start)\n        this.walking = false\n      })\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport merge from 'merge-options'\nimport * as errorsJs from './errors.js'\nimport type { IdentifyResult, Libp2pEvents, Logger, PeerUpdate, TypedEventTarget, PeerId, PeerStore, Topology } from '@libp2p/interface'\nimport type { StreamHandlerOptions, StreamHandlerRecord, Registrar, StreamHandler } from '@libp2p/interface-internal'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar implements Registrar {\n  private readonly log: Logger\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n\n  constructor (components: RegistrarComponents) {\n    this.log = components.logger.forComponent('libp2p:registrar')\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onPeerUpdate = this._onPeerUpdate.bind(this)\n    this._onPeerIdentify = this._onPeerIdentify.bind(this)\n\n    this.components.events.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.events.addEventListener('peer:update', this._onPeerUpdate)\n    this.components.events.addEventListener('peer:identify', this._onPeerIdentify)\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/registrar'\n\n  getProtocols (): string[] {\n    return Array.from(new Set<string>([\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string): StreamHandlerRecord {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw new errorsJs.UnhandledProtocolError(`No handler registered for protocol ${protocol}`)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string): Topology[] {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol)) {\n      throw new errorsJs.DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocol to self protocols in the peer store\n    await this.components.peerStore.merge(this.components.peerId, {\n      protocols: [protocol]\n    })\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]): Promise<void> {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Update self protocols in the peer store\n    await this.components.peerStore.patch(this.components.peerId, {\n      protocols: this.getProtocols()\n    })\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (topology == null) {\n      throw new InvalidParametersError('invalid topology')\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string): void {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<PeerId>): void {\n    const remotePeer = evt.detail\n\n    void this.components.peerStore.get(remotePeer)\n      .then(peer => {\n        for (const protocol of peer.protocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            if (topology.filter?.has(remotePeer) === false) {\n              continue\n            }\n\n            topology.filter?.remove(remotePeer)\n            topology.onDisconnect?.(remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        if (err.name === 'NotFoundError') {\n          // peer has not completed identify so they are not in the peer store\n          return\n        }\n\n        this.log.error('could not inform topologies of disconnecting peer %p', remotePeer, err)\n      })\n  }\n\n  /**\n   * When a peer is updated, if they have removed supported protocols notify any\n   * topologies interested in the removed protocols.\n   */\n  _onPeerUpdate (evt: CustomEvent<PeerUpdate>): void {\n    const { peer, previous } = evt.detail\n    const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (topology.filter?.has(peer.id) === false) {\n          continue\n        }\n\n        topology.filter?.remove(peer.id)\n        topology.onDisconnect?.(peer.id)\n      }\n    }\n  }\n\n  /**\n   * After identify has completed and we have received the list of supported\n   * protocols, notify any topologies interested in those protocols.\n   */\n  _onPeerIdentify (evt: CustomEvent<IdentifyResult>): void {\n    const protocols = evt.detail.protocols\n    const connection = evt.detail.connection\n    const peerId = evt.detail.peerId\n\n    for (const protocol of protocols) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {\n          continue\n        }\n\n        if (topology.filter?.has(peerId) === true) {\n          continue\n        }\n\n        topology.filter?.add(peerId)\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n}\n", "import type { Metric, Metrics } from '@libp2p/interface'\n\nexport interface TrackedMapInit {\n  name: string\n  metrics: Metrics\n}\n\nclass TrackedMap<K, V> extends Map<K, V> {\n  private readonly metric: Metric\n\n  constructor (init: TrackedMapInit) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: K, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: K): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\nexport interface CreateTrackedMapInit {\n  /**\n   * The metric name to use\n   */\n  name: string\n\n  /**\n   * A metrics implementation\n   */\n  metrics?: Metrics\n}\n\nexport function trackedMap <K, V> (config: CreateTrackedMapInit): Map<K, V> {\n  const { name, metrics } = config\n  let map: Map<K, V>\n\n  if (metrics != null) {\n    map = new TrackedMap<K, V>({ name, metrics })\n  } else {\n    map = new Map<K, V>()\n  }\n\n  return map\n}\n", "import { FaultTolerance, InvalidParametersError, NotStartedError } from '@libp2p/interface'\nimport { trackedMap } from '@libp2p/utils/tracked-map'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NoValidAddressesError, TransportUnavailableError } from './errors.js'\nimport type { Libp2pEvents, ComponentLogger, Logger, Connection, TypedEventTarget, Metrics, Startable, Listener, Transport, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, TransportManager, TransportManagerDialOptions } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nexport class DefaultTransportManager implements TransportManager, Startable {\n  private readonly log: Logger\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:transports')\n    this.components = components\n    this.started = false\n    this.transports = new Map<string, Transport>()\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/transport-manager'\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport): void {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw new InvalidParametersError('Transport must have a valid tag')\n    }\n\n    if (this.transports.has(tag)) {\n      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`)\n    }\n\n    this.log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop (): Promise<void> {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      this.log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: TransportManagerDialOptions): Promise<Connection> {\n    const transport = this.dialTransportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`)\n    }\n\n    options?.onProgress?.(new CustomProgressEvent<string>('transport-manager:selected-transport', transport[Symbol.toStringTag]))\n\n    // @ts-expect-error the transport has a typed onProgress option but we\n    // can't predict what transport implementation we selected so all we can\n    // do is pass the onProgress handler in and hope for the best\n    return transport.dial(ma, {\n      ...options,\n      upgrader: this.components.upgrader\n    })\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports (): Transport[] {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Returns all the listener instances\n   */\n  getListeners (): Listener[] {\n    return Array.of(...this.listeners.values()).flat()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  dialTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.dialFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  listenTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.listenFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]): Promise<void> {\n    if (!this.isStarted()) {\n      throw new NotStartedError('Not started')\n    }\n\n    if (addrs == null || addrs.length === 0) {\n      this.log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    const couldNotListen = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.listenFilter(addrs)\n      const tasks = []\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        this.log('creating listener for %s on %a', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners: Listener[] = this.listeners.get(key) ?? []\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.components.events.safeDispatchEvent('transport:listening', {\n            detail: listener\n          })\n        })\n        listener.addEventListener('close', () => {\n          const index = listeners.findIndex(l => l === listener)\n\n          // remove the listener\n          listeners.splice(index, 1)\n\n          this.components.events.safeDispatchEvent('transport:close', {\n            detail: listener\n          })\n        })\n\n        // We need to attempt to listen on everything\n        tasks.push(listener.listen(addr))\n      }\n\n      // Keep track of transports we had no addresses for\n      if (tasks.length === 0) {\n        couldNotListen.push(key)\n        continue\n      }\n\n      const results = await Promise.allSettled(tasks)\n      // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n      const isListening = results.find(r => r.status === 'fulfilled')\n      if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n        throw new NoValidAddressesError(`Transport (${key}) could not listen on any available address`)\n      }\n    }\n\n    // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n    if (couldNotListen.length === this.transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`\n      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n        throw new NoValidAddressesError(message)\n      }\n      this.log(`libp2p in dial mode only: ${message}`)\n    }\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string): Promise<void> {\n    const listeners = this.listeners.get(key) ?? []\n    this.log.trace('removing transport %s', key)\n\n    // Close any running listeners\n    const tasks = []\n    this.log.trace('closing listeners for %s', key)\n    while (listeners.length > 0) {\n      const listener = listeners.pop()\n\n      if (listener == null) {\n        continue\n      }\n\n      tasks.push(listener.close())\n    }\n    await Promise.all(tasks)\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll (): Promise<void> {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n", "export const PROTOCOL_ID = '/multistream/1.0.0'\n\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024\n", "import { InvalidMessageError } from '@libp2p/interface'\nimport { type Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { AbortOptions, LoggerOptions } from '@libp2p/interface'\nimport type { LengthPrefixedStream } from 'it-length-prefixed-stream'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst NewLine = uint8ArrayFromString('\\n')\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport async function write (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffer: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void> {\n  await writer.write(buffer, options)\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport async function writeAll (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffers: Uint8Array[], options?: AbortOptions): Promise<void> {\n  await writer.writeV(buffers, options)\n}\n\n/**\n * Read a length-prefixed buffer from the passed stream, stripping the final newline character\n */\nexport async function read (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<Uint8ArrayList> {\n  const buf = await reader.read(options)\n\n  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    options.log.error('Invalid mss message - missing newline', buf)\n    throw new InvalidMessageError('Missing newline')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\n/**\n * Read a length-prefixed string from the passed stream, stripping the final newline character\n */\nexport async function readString (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<string> {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n", "import { UnsupportedProtocolError } from '@libp2p/interface'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport pDefer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport * as multistream from './multistream.js'\nimport { PROTOCOL_ID } from './index.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface SelectStream extends Duplex<any, any, any> {\n  readStatus?: string\n  closeWrite?(options?: AbortOptions): Promise<void>\n  closeRead?(options?: AbortOptions): Promise<void>\n  close?(options?: AbortOptions): Promise<void>\n}\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select <Stream extends SelectStream> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n\n  if (protocols.length === 1 && options.negotiateFully === false) {\n    return optimisticSelect(stream, protocols[0], options)\n  }\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  options.log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(`${PROTOCOL_ID}\\n`)\n  const p2 = uint8ArrayFromString(`${protocol}\\n`)\n  await multistream.writeAll(lp, [p1, p2], options)\n\n  options.log.trace('select: reading multistream-select header')\n  let response = await multistream.readString(lp, options)\n  options.log.trace('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    options.log.trace('select: reading protocol response')\n    response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    return { stream: lp.unwrap(), protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    options.log.trace('select: write \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n    options.log.trace('select: reading protocol response')\n    const response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      return { stream: lp.unwrap(), protocol }\n    }\n  }\n\n  throw new UnsupportedProtocolError('protocol selection failed')\n}\n\n/**\n * Optimistically negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nfunction optimisticSelect <Stream extends SelectStream> (stream: Stream, protocol: string, options: MultistreamSelectInit): ProtocolStream<Stream> {\n  const originalSink = stream.sink.bind(stream)\n  const originalSource = stream.source\n\n  let negotiated = false\n  let negotiating = false\n  const doneNegotiating = pDefer()\n\n  let sentProtocol = false\n  let sendingProtocol = false\n  const doneSendingProtocol = pDefer()\n\n  let readProtocol = false\n  let readingProtocol = false\n  const doneReadingProtocol = pDefer()\n\n  const lp = lpStream({\n    sink: originalSink,\n    source: originalSource\n  }, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n\n  stream.sink = async source => {\n    const { sink } = lp.unwrap()\n\n    await sink(async function * () {\n      let sentData = false\n\n      for await (const buf of source) {\n        // started reading before the source yielded, wait for protocol send\n        if (sendingProtocol) {\n          await doneSendingProtocol.promise\n        }\n\n        // writing before reading, send the protocol and the first chunk of data\n        if (!sentProtocol) {\n          sendingProtocol = true\n\n          options.log.trace('optimistic: write [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          const protocolString = `${protocol}\\n`\n\n          // send protocols in first chunk of data written to transport\n          yield new Uint8ArrayList(\n            Uint8Array.from([19]), // length of PROTOCOL_ID plus newline\n            uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n            varint.encode(protocolString.length),\n            uint8ArrayFromString(protocolString),\n            buf\n          ).subarray()\n\n          options.log.trace('optimistic: wrote [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          sentProtocol = true\n          sendingProtocol = false\n          doneSendingProtocol.resolve()\n\n          // read the negotiation response but don't block more sending\n          negotiate()\n            .catch(err => {\n              options.log.error('could not finish optimistic protocol negotiation of %s', protocol, err)\n            })\n        } else {\n          yield buf\n        }\n\n        sentData = true\n      }\n\n      // special case - the source passed to the sink has ended but we didn't\n      // negotiated the protocol yet so do it now\n      if (!sentData) {\n        await negotiate()\n      }\n    }())\n  }\n\n  async function negotiate (): Promise<void> {\n    if (negotiating) {\n      options.log.trace('optimistic: already negotiating %s stream', protocol)\n      await doneNegotiating.promise\n      return\n    }\n\n    negotiating = true\n\n    try {\n      // we haven't sent the protocol yet, send it now\n      if (!sentProtocol) {\n        options.log.trace('optimistic: doing send protocol for %s stream', protocol)\n        await doSendProtocol()\n      }\n\n      // if we haven't read the protocol response yet, do it now\n      if (!readProtocol) {\n        options.log.trace('optimistic: doing read protocol for %s stream', protocol)\n        await doReadProtocol()\n      }\n    } finally {\n      negotiating = false\n      negotiated = true\n      doneNegotiating.resolve()\n    }\n  }\n\n  async function doSendProtocol (): Promise<void> {\n    if (sendingProtocol) {\n      await doneSendingProtocol.promise\n      return\n    }\n\n    sendingProtocol = true\n\n    try {\n      options.log.trace('optimistic: write [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n      await lp.writeV([\n        uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n        uint8ArrayFromString(`${protocol}\\n`)\n      ])\n      options.log.trace('optimistic: wrote [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n    } finally {\n      sentProtocol = true\n      sendingProtocol = false\n      doneSendingProtocol.resolve()\n    }\n  }\n\n  async function doReadProtocol (): Promise<void> {\n    if (readingProtocol) {\n      await doneReadingProtocol.promise\n      return\n    }\n\n    readingProtocol = true\n\n    try {\n      options.log.trace('optimistic: reading multistream select header')\n      let response = await multistream.readString(lp, options)\n      options.log.trace('optimistic: read multistream select header \"%s\"', response)\n\n      if (response === PROTOCOL_ID) {\n        response = await multistream.readString(lp, options)\n      }\n\n      options.log.trace('optimistic: read protocol \"%s\", expecting \"%s\"', response, protocol)\n\n      if (response !== protocol) {\n        throw new UnsupportedProtocolError('protocol selection failed')\n      }\n    } finally {\n      readProtocol = true\n      readingProtocol = false\n      doneReadingProtocol.resolve()\n    }\n  }\n\n  stream.source = (async function * () {\n    // make sure we've done protocol negotiation before we read stream data\n    await negotiate()\n\n    options.log.trace('optimistic: reading data from \"%s\" stream', protocol)\n    yield * lp.unwrap().source\n  })()\n\n  if (stream.closeRead != null) {\n    const originalCloseRead = stream.closeRead.bind(stream)\n\n    stream.closeRead = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the readable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close read', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the readable end\n      await originalCloseRead(opts)\n    }\n  }\n\n  if (stream.closeWrite != null) {\n    const originalCloseWrite = stream.closeWrite.bind(stream)\n\n    stream.closeWrite = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the writable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close write', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalCloseWrite(opts)\n    }\n  }\n\n  if (stream.close != null) {\n    const originalClose = stream.close.bind(stream)\n\n    stream.close = async (opts) => {\n      // if we are in the process of negotiation, let it finish before closing\n      // because we may have unsent early data\n      const tasks = []\n\n      if (sendingProtocol) {\n        tasks.push(doneSendingProtocol.promise)\n      }\n\n      if (readingProtocol) {\n        tasks.push(doneReadingProtocol.promise)\n      }\n\n      if (tasks.length > 0) {\n        // let the in-flight protocol negotiation finish gracefully\n        await raceSignal(\n          Promise.all(tasks),\n          opts?.signal\n        )\n      } else {\n        // no protocol negotiation attempt has occurred so don't start one\n        negotiated = true\n        negotiating = false\n        doneNegotiating.resolve()\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalClose(opts)\n    }\n  }\n\n  return {\n    stream,\n    protocol\n  }\n}\n", "import { encode } from 'it-length-prefixed'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH, PROTOCOL_ID } from './constants.js'\nimport * as multistream from './multistream.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { Duplex } from 'it-stream-types'\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle <Stream extends Duplex<any, any, any>> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  options.log.trace('handle: available protocols %s', protocols)\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH,\n    maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH\n  })\n\n  while (true) {\n    options.log.trace('handle: reading incoming string')\n    const protocol = await multistream.readString(lp, options)\n    options.log.trace('handle: read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${PROTOCOL_ID}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', protocol, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', protocol, protocol)\n\n      return { stream: lp.unwrap(), protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      const protos = new Uint8ArrayList(\n        ...protocols.map(p => encode.single(uint8ArrayFromString(`${p}\\n`))),\n        uint8ArrayFromString('\\n')\n      )\n\n      options.log.trace('handle: respond with \"%s\" for %s', protocols, protocol)\n      await multistream.write(lp, protos, options)\n      options.log.trace('handle: responded with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    options.log.trace('handle: respond with \"na\" for \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString('na\\n'), options)\n    options.log('handle: responded with \"na\" for \"%s\"', protocol)\n  }\n}\n", "import { connectionSymbol, setMaxListeners, LimitedConnectionError, ConnectionClosedError, ConnectionClosingError } from '@libp2p/interface'\nimport type { AbortOptions, Logger, ComponentLogger, Direction, Connection, Stream, ConnectionTimeline, ConnectionStatus, NewStreamOptions, PeerId, ConnectionLimits } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CLOSE_TIMEOUT = 500\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream(protocols: string[], options?: AbortOptions): Promise<Stream>\n  close(options?: AbortOptions): Promise<void>\n  abort(err: Error): void\n  getStreams(): Stream[]\n  status: ConnectionStatus\n  direction: Direction\n  timeline: ConnectionTimeline\n  multiplexer?: string\n  encryption?: string\n  limits?: ConnectionLimits\n  logger: ComponentLogger\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  public direction: Direction\n  public timeline: ConnectionTimeline\n  public multiplexer?: string\n  public encryption?: string\n  public status: ConnectionStatus\n  public limits?: ConnectionLimits\n  public readonly log: Logger\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: NewStreamOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: (options?: AbortOptions) => Promise<void>\n\n  private readonly _abort: (err: Error) => void\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.direction = init.direction\n    this.status = 'open'\n    this.timeline = init.timeline\n    this.multiplexer = init.multiplexer\n    this.encryption = init.encryption\n    this.limits = init.limits\n    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`)\n\n    if (this.remoteAddr.getPeerId() == null) {\n      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)\n    }\n\n    this._newStream = newStream\n    this._close = close\n    this._abort = abort\n    this._getStreams = getStreams\n    this.tags = []\n  }\n\n  readonly [Symbol.toStringTag] = 'Connection'\n\n  readonly [connectionSymbol] = true\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams (): Stream[] {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: NewStreamOptions): Promise<Stream> {\n    if (this.status === 'closing') {\n      throw new ConnectionClosingError('the connection is being closed')\n    }\n\n    if (this.status === 'closed') {\n      throw new ConnectionClosedError('the connection is closed')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    if (this.limits != null && options?.runOnLimitedConnection !== true) {\n      throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Close the connection\n   */\n  async close (options: AbortOptions = {}): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.log('closing connection to %a', this.remoteAddr)\n\n    this.status = 'closing'\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      this.log.trace('closing underlying transport')\n\n      // close raw connection\n      await this._close(options)\n\n      this.log.trace('updating timeline with close time')\n\n      this.status = 'closed'\n      this.timeline.close = Date.now()\n    } catch (err: any) {\n      this.log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err)\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error): void {\n    if (this.status === 'closed') {\n      return\n    }\n\n    this.log.error('aborting connection to %a due to error', this.remoteAddr, err)\n\n    this.status = 'closing'\n\n    // Abort raw connection\n    this._abort(err)\n\n    this.status = 'closed'\n    this.timeline.close = Date.now()\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n", "import { InvalidMultiaddrError, TooManyInboundProtocolStreamsError, TooManyOutboundProtocolStreamsError, LimitedConnectionError, setMaxListeners, InvalidPeerIdError } from '@libp2p/interface'\nimport * as mss from '@libp2p/multistream-select'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { anySignal } from 'any-signal'\nimport { CustomProgressEvent } from 'progress-events'\nimport { createConnection } from './connection/index.js'\nimport { PROTOCOL_NEGOTIATION_TIMEOUT, UPGRADE_TIMEOUT } from './connection-manager/constants.js'\nimport { ConnectionDeniedError, ConnectionInterceptedError, EncryptionFailedError, MuxerUnavailableError } from './errors.js'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, MultiaddrConnection, Connection, Stream, ConnectionProtector, NewStreamOptions, ConnectionEncrypter, SecuredConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, PeerStore, StreamMuxer, StreamMuxerFactory, Upgrader, UpgraderOptions, ConnectionLimits, SecureConnectionOptions, CounterGroup } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\ninterface CreateConnectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: MultiaddrConnection\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n  limits?: ConnectionLimits\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection<MultiaddrConnection> {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncrypters: ConnectionEncrypter[]\n  streamMuxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade must complete\n   *\n   * @default 3000\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * An amount of ms by which an outbound connection upgrade must complete\n   *\n   * @default 3000\n   */\n  outboundUpgradeTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  inboundStreamProtocolNegotiationTimeout?: number\n\n  /**\n   * When a new incoming stream is opened on a multiplexed connection, protocol\n   * negotiation on that stream must complete within this many ms\n   *\n   * @default 2000\n   */\n  outboundStreamProtocolNegotiationTimeout?: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar): number | undefined {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar, options: NewStreamOptions = {}): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxOutboundStreams != null) {\n      return options.maxOutboundStreams\n    }\n  } catch (err: any) {\n    if (err.name !== 'UnhandledProtocolError') {\n      throw err\n    }\n  }\n\n  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection): number {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.direction === direction && stream.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport interface DefaultUpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ntype ConnectionDeniedType = keyof Pick<ConnectionGater, 'denyOutboundConnection' | 'denyInboundEncryptedConnection' | 'denyOutboundEncryptedConnection' | 'denyInboundUpgradedConnection' | 'denyOutboundUpgradedConnection'>\n\nexport class DefaultUpgrader implements Upgrader {\n  private readonly components: DefaultUpgraderComponents\n  private readonly connectionEncrypters: Map<string, ConnectionEncrypter>\n  private readonly streamMuxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n  private readonly outboundUpgradeTimeout: number\n  private readonly inboundStreamProtocolNegotiationTimeout: number\n  private readonly outboundStreamProtocolNegotiationTimeout: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly metrics: {\n    dials?: CounterGroup<'inbound' | 'outbound'>\n    errors?: CounterGroup<'inbound' | 'outbound'>\n  }\n\n  constructor (components: DefaultUpgraderComponents, init: UpgraderInit) {\n    this.components = components\n    this.connectionEncrypters = new Map()\n\n    init.connectionEncrypters.forEach(encrypter => {\n      this.connectionEncrypters.set(encrypter.protocol, encrypter)\n    })\n\n    this.streamMuxers = new Map()\n\n    init.streamMuxers.forEach(muxer => {\n      this.streamMuxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? UPGRADE_TIMEOUT\n    this.outboundUpgradeTimeout = init.outboundUpgradeTimeout ?? UPGRADE_TIMEOUT\n    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT\n    this.events = components.events\n    this.metrics = {\n      dials: components.metrics?.registerCounterGroup('libp2p_connection_manager_dials_total'),\n      errors: components.metrics?.registerCounterGroup('libp2p_connection_manager_dial_errors_total')\n    }\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/upgrader'\n\n  async shouldBlockConnection (connectionType: 'denyInboundConnection', maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (connectionType: ConnectionDeniedType, remotePeer: PeerId, maConn: MultiaddrConnection): Promise<void>\n  async shouldBlockConnection (method: ConnectionDeniedType | 'denyInboundConnection', ...args: any[]): Promise<void> {\n    const denyOperation: any = this.components.connectionGater[method]\n\n    if (denyOperation == null) {\n      return\n    }\n\n    const result = await denyOperation.apply(this.components.connectionGater, args)\n\n    if (result === true) {\n      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`)\n    }\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts: UpgraderOptions = {}): Promise<void> {\n    let accepted = false\n\n    try {\n      this.metrics.dials?.increment({\n        inbound: true\n      })\n\n      accepted = await this.components.connectionManager.acceptIncomingConnection(maConn)\n\n      if (!accepted) {\n        throw new ConnectionDeniedError('Connection denied')\n      }\n\n      await this.shouldBlockConnection('denyInboundConnection', maConn)\n\n      await this._performUpgrade(maConn, 'inbound', opts)\n    } catch (err) {\n      this.metrics.errors?.increment({\n        inbound: true\n      })\n\n      throw err\n    } finally {\n      if (accepted) {\n        this.components.connectionManager.afterUpgradeInbound()\n      }\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts: UpgraderOptions = {}): Promise<Connection> {\n    try {\n      this.metrics.dials?.increment({\n        outbound: true\n      })\n\n      const idStr = maConn.remoteAddr.getPeerId()\n      let remotePeerId: PeerId | undefined\n\n      if (idStr != null) {\n        remotePeerId = peerIdFromString(idStr)\n        await this.shouldBlockConnection('denyOutboundConnection', remotePeerId, maConn)\n      }\n\n      return await this._performUpgrade(maConn, 'outbound', opts)\n    } catch (err) {\n      this.metrics.errors?.increment({\n        outbound: true\n      })\n\n      throw err\n    }\n  }\n\n  private async _performUpgrade (maConn: MultiaddrConnection, direction: 'inbound' | 'outbound', opts: UpgraderOptions): Promise<Connection> {\n    let encryptedConn: MultiaddrConnection\n    let remotePeer: PeerId\n    let upgradedConn: MultiaddrConnection\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n\n    const upgradeTimeoutSignal = AbortSignal.timeout(direction === 'inbound' ? this.inboundUpgradeTimeout : this.outboundUpgradeTimeout)\n    const signal = anySignal([upgradeTimeoutSignal, opts.signal])\n    setMaxListeners(Infinity, upgradeTimeoutSignal, signal)\n    opts.signal = signal\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    maConn.log.trace('starting the %s connection upgrade', direction)\n\n    // Protect\n    let protectedConn = maConn\n\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        maConn.log('protecting the %s connection', direction)\n        protectedConn = await protector.protect(maConn, opts)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn\n      if (opts?.skipEncryption !== true) {\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));\n\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await (direction === 'inbound'\n          ? this._encryptInbound(protectedConn, {\n            ...opts,\n            signal\n          })\n          : this._encryptOutbound(protectedConn, {\n            ...opts,\n            signal\n          })\n        ))\n\n        const maConn: MultiaddrConnection = {\n          ...protectedConn,\n          ...encryptedConn\n        }\n\n        await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundEncryptedConnection' : 'denyOutboundEncryptedConnection', remotePeer, maConn)\n      } else {\n        const idStr = maConn.remoteAddr.getPeerId()\n\n        if (idStr == null) {\n          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`)\n        }\n\n        const remotePeerId = peerIdFromString(idStr)\n\n        cryptoProtocol = 'native'\n        remotePeer = remotePeerId\n      }\n\n      // this can happen if we dial a multiaddr without a peer id, we only find\n      // out the identity of the remote after the connection is encrypted\n      if (remotePeer.equals(this.components.peerId)) {\n        const err = new InvalidPeerIdError('Can not dial self')\n        maConn.abort(err)\n        throw err\n      }\n\n      upgradedConn = encryptedConn\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (this.streamMuxers.size > 0) {\n        opts?.onProgress?.(new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`))\n\n        // Multiplex the connection\n        const multiplexed = await (direction === 'inbound'\n          ? this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.streamMuxers, opts)\n          : this._multiplexOutbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.streamMuxers, opts))\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      }\n    } catch (err: any) {\n      maConn.log.error('failed to upgrade inbound connection %s %a - %e', direction === 'inbound' ? 'from' : 'to', maConn.remoteAddr, err)\n      throw err\n    } finally {\n      signal.clear()\n    }\n\n    await this.shouldBlockConnection(direction === 'inbound' ? 'denyInboundUpgradedConnection' : 'denyOutboundUpgradedConnection', remotePeer, maConn)\n\n    maConn.log('successfully upgraded %s connection', direction)\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer,\n      limits: opts?.limits\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConnectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory,\n      limits\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.registrar.getProtocols()\n              const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout)\n              setMaxListeners(Infinity, signal)\n\n              const { stream, protocol } = await mss.handle(muxedStream, protocols, {\n                signal,\n                log: muxedStream.log,\n                yieldBytes: false\n              })\n\n              if (connection == null) {\n                return\n              }\n\n              connection.log('incoming stream opened on %s', protocol)\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar)\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`)\n                muxedStream.abort(err)\n\n                throw err\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the souce/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.protocol = protocol\n\n              // allow closing the write end of a not-yet-negotiated stream\n              if (stream.closeWrite != null) {\n                muxedStream.closeWrite = stream.closeWrite\n              }\n\n              // allow closing the read end of a not-yet-negotiated stream\n              if (stream.closeRead != null) {\n                muxedStream.closeRead = stream.closeRead\n              }\n\n              // make sure we don't try to negotiate a stream we are closing\n              if (stream.close != null) {\n                muxedStream.close = stream.close\n              }\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peerstore should ensure that the peer is registered with that protocol\n              await this.components.peerStore.merge(remotePeer, {\n                protocols: [protocol]\n              })\n\n              this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(async err => {\n              connection.log.error('error handling incoming stream id %s - %e', muxedStream.id, err)\n\n              if (muxedStream.timeline.close == null) {\n                await muxedStream.close()\n              }\n            })\n        }\n      })\n\n      newStream = async (protocols: string[], options: NewStreamOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw new MuxerUnavailableError('Connection is not multiplexed')\n        }\n\n        connection.log.trace('starting new stream for protocols %s', protocols)\n        const muxedStream = await muxer.newStream()\n        connection.log.trace('started new stream %s for protocols %s', muxedStream.id, protocols)\n\n        try {\n          if (options.signal == null) {\n            muxedStream.log('no abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout)\n            setMaxListeners(Infinity, signal)\n\n            options = {\n              ...options,\n              signal\n            }\n          }\n\n          muxedStream.log.trace('selecting protocol from protocols %s', protocols)\n\n          const {\n            stream,\n            protocol\n          } = await mss.select(muxedStream, protocols, {\n            ...options,\n            log: muxedStream.log,\n            yieldBytes: true\n          })\n\n          muxedStream.log.trace('selected protocol %s', protocol)\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options)\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount >= outgoingLimit) {\n            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol \"${protocol}\" - ${streamCount}/${outgoingLimit}`)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          await this.components.peerStore.merge(remotePeer, {\n            protocols: [protocol]\n          })\n\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.protocol = protocol\n\n          // allow closing the write end of a not-yet-negotiated stream\n          if (stream.closeWrite != null) {\n            muxedStream.closeWrite = stream.closeWrite\n          }\n\n          // allow closing the read end of a not-yet-negotiated stream\n          if (stream.closeRead != null) {\n            muxedStream.closeRead = stream.closeRead\n          }\n\n          // make sure we don't try to negotiate a stream we are closing\n          if (stream.close != null) {\n            muxedStream.close = stream.close\n          }\n\n          this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n          return muxedStream\n        } catch (err: any) {\n          connection.log.error('could not create new outbound stream on connection %s %a for protocols %s - %e', direction === 'inbound' ? 'from' : 'to', opts.maConn.remoteAddr, protocols, err)\n\n          if (muxedStream.timeline.close == null) {\n            muxedStream.abort(err)\n          }\n\n          throw err\n        }\n      }\n\n      // Pipe all data through the muxer\n      void Promise.all([\n        muxer.sink(upgradedConn.source),\n        upgradedConn.sink(muxer.source)\n      ]).catch(err => {\n        connection.log.error('error piping data through muxer - %e', err)\n      })\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.status === 'open') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              connection.log.error('error closing connection after timeline close %e', err)\n            } finally {\n              this.events.safeDispatchEvent('connection:close', {\n                detail: connection\n              })\n            }\n          })().catch(err => {\n            connection.log.error('error thrown while dispatching connection:close event %e', err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = (): any => {\n      throw new MuxerUnavailableError('Connection is not multiplexed')\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer,\n      status: 'open',\n      direction,\n      timeline: maConn.timeline,\n      multiplexer: muxer?.protocol,\n      encryption: cryptoProtocol,\n      limits,\n      logger: this.components.logger,\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => {\n        return muxer?.streams ?? []\n      },\n      close: async (options?: AbortOptions) => {\n        // ensure remaining streams are closed gracefully\n        await muxer?.close(options)\n\n        // close the underlying transport\n        await maConn.close(options)\n      },\n      abort: (err) => {\n        maConn.abort(err)\n\n        // ensure remaining streams are aborted\n        muxer?.abort(err)\n      }\n    })\n\n    this.events.safeDispatchEvent('connection:open', {\n      detail: connection\n    })\n\n    // @ts-expect-error nah\n    connection.__maConnTimeline = _timeline\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler, options } = this.components.registrar.getHandler(protocol)\n\n    if (connection.limits != null && options.runOnLimitedConnection !== true) {\n      throw new LimitedConnectionError('Cannot open protocol stream on limited connection')\n    }\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: MultiaddrConnection, options?: AbortOptions): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        ...options,\n        log: connection.log\n      })\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting inbound connection to %a using %s', connection.remoteAddr, protocol)\n\n      return {\n        ...await encrypter.secureInbound(stream, options),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting inbound connection from %a failed', connection.remoteAddr, err)\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, options: SecureConnectionOptions): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncrypters.keys())\n\n    try {\n      connection.log.trace('selecting encrypter from %s', protocols)\n\n      const { stream, protocol } = await mss.select(connection, protocols, {\n        ...options,\n        log: connection.log,\n        yieldBytes: true\n      })\n      const encrypter = this.connectionEncrypters.get(protocol)\n\n      if (encrypter == null) {\n        throw new EncryptionFailedError(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting outbound connection to %a using %s', connection.remoteAddr, protocol)\n\n      return {\n        ...await encrypter.secureOutbound(stream, options),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting outbound connection to %a failed', connection.remoteAddr, err)\n      throw new EncryptionFailedError(err.message)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('outbound selecting muxer %s', protocols)\n    try {\n      connection.log.trace('selecting stream muxer from %s', protocols)\n\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        ...options,\n        log: connection.log,\n        yieldBytes: true\n      })\n\n      connection.log('selected %s as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing outbound connection', err)\n      throw new MuxerUnavailableError(String(err))\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>, options: AbortOptions): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        ...options,\n        log: connection.log\n      })\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing inbound connection', err)\n      throw new MuxerUnavailableError(String(err))\n    }\n  }\n}\n", "export const version = '2.5.0'\nexport const name = 'js-libp2p'\n", "import { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { contentRoutingSymbol, TypedEventEmitter, setMaxListeners, peerDiscoverySymbol, peerRoutingSymbol, InvalidParametersError } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { persistentPeerStore } from '@libp2p/peer-store'\nimport { isMultiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AddressManager } from './address-manager/index.js'\nimport { checkServiceDependencies, defaultComponents } from './components.js'\nimport { connectionGater } from './config/connection-gater.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { ConnectionMonitor } from './connection-monitor.js'\nimport { CompoundContentRouting } from './content-routing.js'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { RandomWalk } from './random-walk.js'\nimport { DefaultRegistrar } from './registrar.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { DefaultUpgrader } from './upgrader.js'\nimport * as pkg from './version.js'\nimport type { Components } from './components.js'\nimport type { Libp2p as Libp2pInterface, Libp2pInit } from './index.js'\nimport type { PeerRouting, ContentRouting, Libp2pEvents, PendingDial, ServiceMap, AbortOptions, ComponentLogger, Logger, Connection, NewStreamOptions, Stream, Metrics, PeerId, PeerInfo, PeerStore, Topology, Libp2pStatus, IsDialableOptions, DialOptions, PublicKey, Ed25519PeerId, Secp256k1PeerId, RSAPublicKey, RSAPeerId, URLPeerId, Ed25519PublicKey, Secp256k1PublicKey } from '@libp2p/interface'\nimport type { StreamHandler, StreamHandlerOptions } from '@libp2p/interface-internal'\n\nexport class Libp2p<T extends ServiceMap = ServiceMap> extends TypedEventEmitter<Libp2pEvents> implements Libp2pInterface<T> {\n  public peerId: PeerId\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public metrics?: Metrics\n  public services: T\n  public logger: ComponentLogger\n  public status: Libp2pStatus\n\n  public components: Components & T\n  private readonly log: Logger\n\n  constructor (init: Libp2pInit<T> & { peerId: PeerId }) {\n    super()\n\n    this.status = 'stopped'\n\n    // event bus - components can listen to this emitter to be notified of system events\n    // and also cause them to be emitted\n    const events = new TypedEventEmitter<Libp2pEvents>()\n    const originalDispatch = events.dispatchEvent.bind(events)\n    events.dispatchEvent = (evt: any) => {\n      const internalResult = originalDispatch(evt)\n      const externalResult = this.dispatchEvent(\n        new CustomEvent(evt.type, { detail: evt.detail })\n      )\n\n      return internalResult || externalResult\n    }\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, events)\n\n    this.peerId = init.peerId\n    this.logger = init.logger ?? defaultLogger()\n    this.log = this.logger.forComponent('libp2p')\n    // @ts-expect-error {} may not be of type T\n    this.services = {}\n    // @ts-expect-error defaultComponents is missing component types added later\n    const components = this.components = defaultComponents({\n      peerId: init.peerId,\n      privateKey: init.privateKey,\n      nodeInfo: init.nodeInfo ?? {\n        name: pkg.name,\n        version: pkg.version\n      },\n      logger: this.logger,\n      events,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: connectionGater(init.connectionGater),\n      dns: init.dns\n    })\n\n    this.peerStore = this.configureComponent('peerStore', persistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    }))\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.configureComponent('metrics', init.metrics(this.components))\n    }\n\n    components.events.addEventListener('peer:update', evt => {\n      // if there was no peer previously in the peer store this is a new peer\n      if (evt.detail.previous == null) {\n        const peerInfo: PeerInfo = {\n          id: evt.detail.peer.id,\n          multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr)\n        }\n\n        components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo })\n      }\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.configureComponent('connectionProtector', init.connectionProtector(components))\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new DefaultUpgrader(this.components, {\n      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager?.inboundUpgradeTimeout,\n      outboundUpgradeTimeout: init.connectionManager?.outboundUpgradeTimeout\n    })\n\n    // Setup the transport manager\n    this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager))\n\n    // Create the Connection Manager\n    this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager))\n\n    if (init.connectionMonitor?.enabled !== false) {\n      // Create the Connection Monitor if not disabled\n      this.configureComponent('connectionMonitor', new ConnectionMonitor(this.components, init.connectionMonitor))\n    }\n\n    // Create the Registrar\n    this.configureComponent('registrar', new DefaultRegistrar(this.components))\n\n    // Addresses {listen, announce, noAnnounce}\n    this.configureComponent('addressManager', new AddressManager(this.components, init.addresses))\n\n    // Peer routers\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)))\n    this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n      routers: peerRouters\n    }))\n\n    // Content routers\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)))\n    this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    // Random walk\n    this.configureComponent('randomWalk', new RandomWalk(this.components))\n\n    // Discovery modules\n    ;(init.peerDiscovery ?? []).forEach((fn, index) => {\n      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.#onDiscoveryPeer(evt)\n      })\n    })\n\n    // Transport modules\n    init.transports?.forEach((fn, index) => {\n      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)))\n    })\n\n    // User defined modules\n    if (init.services != null) {\n      for (const name of Object.keys(init.services)) {\n        const createService = init.services[name]\n        const service: any = createService(this.components)\n\n        if (service == null) {\n          this.log.error('service factory %s returned null or undefined instance', name)\n          continue\n        }\n\n        this.services[name as keyof T] = service\n        this.configureComponent(name, service)\n\n        if (service[contentRoutingSymbol] != null) {\n          this.log('registering service %s for content routing', name)\n          contentRouters.push(service[contentRoutingSymbol])\n        }\n\n        if (service[peerRoutingSymbol] != null) {\n          this.log('registering service %s for peer routing', name)\n          peerRouters.push(service[peerRoutingSymbol])\n        }\n\n        if (service[peerDiscoverySymbol] != null) {\n          this.log('registering service %s for peer discovery', name)\n          service[peerDiscoverySymbol].addEventListener?.('peer', (evt: CustomEvent<PeerInfo>) => {\n            this.#onDiscoveryPeer(evt)\n          })\n        }\n      }\n    }\n\n    // Ensure all services have their required dependencies\n    checkServiceDependencies(components)\n  }\n\n  private configureComponent <T> (name: string, component: T): T {\n    if (component == null) {\n      this.log.error('component %s was null or undefined', name)\n    }\n\n    // @ts-expect-error cannot assign props\n    this.components[name] = component\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start (): Promise<void> {\n    if (this.status !== 'stopped') {\n      return\n    }\n\n    this.status = 'starting'\n\n    this.log('libp2p is starting')\n\n    try {\n      await this.components.beforeStart?.()\n      await this.components.start()\n      await this.components.afterStart?.()\n\n      this.status = 'started'\n      this.safeDispatchEvent('start', { detail: this })\n      this.log('libp2p has started')\n    } catch (err: any) {\n      this.log.error('An error occurred starting libp2p', err)\n      // set status to 'started' so this.stop() will stop any running components\n      this.status = 'started'\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop (): Promise<void> {\n    if (this.status !== 'started') {\n      return\n    }\n\n    this.log('libp2p is stopping')\n\n    this.status = 'stopping'\n\n    await this.components.beforeStop?.()\n    await this.components.stop()\n    await this.components.afterStop?.()\n\n    this.status = 'stopped'\n    this.safeDispatchEvent('stop', { detail: this })\n    this.log('libp2p has stopped')\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.components.connectionManager.getDialQueue()\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr | Multiaddr[], options: DialOptions = {}): Promise<Connection> {\n    return this.components.connectionManager.openConnection(peer, {\n      // ensure any userland dials take top priority in the queue\n      priority: 75,\n      ...options\n    })\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options: NewStreamOptions = {}): Promise<Stream> {\n    if (protocols == null) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw new InvalidParametersError('no protocols were provided to open a stream')\n    }\n\n    const connection = await this.dial(peer, options)\n\n    return connection.newStream(protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  async getPublicKey (peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  async getPublicKey (peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  async getPublicKey (peer: URLPeerId, options?: AbortOptions): Promise<never>\n  async getPublicKey (peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<PublicKey> {\n    this.log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    try {\n      const peerInfo = await this.peerStore.get(peer)\n\n      if (peerInfo.id.publicKey != null) {\n        return peerInfo.id.publicKey\n      }\n    } catch (err: any) {\n      if (err.name !== 'NotFoundError') {\n        throw err\n      }\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.toMultihash().bytes\n    ])\n\n    // search any available content routing methods\n    const bytes = await this.contentRouting.get(peerKey, options)\n\n    // ensure the returned key is valid\n    const publicKey = publicKeyFromProtobuf(bytes)\n\n    await this.peerStore.patch(peer, {\n      publicKey\n    })\n\n    return publicKey\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology): Promise<string> {\n    return this.components.registrar.register(protocol, topology)\n  }\n\n  unregister (id: string): void {\n    this.components.registrar.unregister(id)\n  }\n\n  async isDialable (multiaddr: Multiaddr, options: IsDialableOptions = {}): Promise<boolean> {\n    return this.components.connectionManager.isDialable(multiaddr, options)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events and adds peers\n   * to the peer store.\n   */\n  #onDiscoveryPeer (evt: CustomEvent<PeerInfo>): void {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      this.log.error('peer discovery mechanism discovered self')\n      return\n    }\n\n    void this.components.peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs\n    })\n      .catch(err => { this.log.error(err) })\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { generateKeyPair } from '@libp2p/crypto/keys'\nimport { peerIdFromPrivateKey } from '@libp2p/peer-id'\nimport { validateConfig } from './config.js'\nimport { Libp2p as Libp2pClass } from './libp2p.js'\nimport type { AddressManagerInit, AddressFilter } from './address-manager/index.js'\nimport type { Components } from './components.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { ConnectionMonitorInit } from './connection-monitor.js'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { Libp2p, ServiceMap, ComponentLogger, NodeInfo, ConnectionProtector, ConnectionEncrypter, ConnectionGater, ContentRouting, Metrics, PeerDiscovery, PeerRouting, StreamMuxerFactory, Transport, PrivateKey } from '@libp2p/interface'\nimport type { PersistentPeerStoreInit } from '@libp2p/peer-store'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport type ServiceFactoryMap<T extends ServiceMap = ServiceMap> = {\n  [Property in keyof T]: (components: Components & T) => T[Property]\n}\n\nexport type { AddressManagerInit, AddressFilter }\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](https://github.com/libp2p/js-libp2p/tree/main/doc/CONFIGURATION.md).\n */\nexport interface Libp2pInit<T extends ServiceMap = ServiceMap> {\n  /**\n   * The private key is used in cryptographic operations and the Peer ID derived\n   * from it's corresponding public key is used to identify the node to other\n   * peers on the network.\n   *\n   * If this is not passed a new Ed25519 private key will be generated.\n   */\n  privateKey?: PrivateKey\n\n  /**\n   * Metadata about the node - implementation name, version number, etc\n   */\n  nodeInfo?: NodeInfo\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses?: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager?: ConnectionManagerInit\n\n  /**\n   * libp2p Connection Monitor configuration\n   */\n  connectionMonitor?: ConnectionMonitorInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater?: ConnectionGater\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager?: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore?: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore?: PersistentPeerStoreInit\n\n  /**\n   * Transports are low-level communication channels\n   */\n  transports?: Array<(components: Components) => Transport>\n\n  /**\n   * Stream muxers allow the creation of many data streams over a single\n   * connection.\n   */\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n\n  /**\n   * Connection encrypters ensure that data sent over connections cannot be\n   * eavesdropped on, and that the remote peer posesses the private key that\n   * corresponds to the public key that it's Peer ID is derived from.\n   */\n  connectionEncrypters?: Array<(components: Components) => ConnectionEncrypter>\n\n  /**\n   * Peer discovery mechanisms allow finding peers on the network\n   */\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n\n  /**\n   * Peer routers provide implementations for peer routing queries\n   */\n  peerRouters?: Array<(components: Components) => PeerRouting>\n\n  /**\n   * Content routers provide implementations for content routing queries\n   */\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?(components: Components): Metrics\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?(components: Components): ConnectionProtector\n\n  /**\n   * Arbitrary libp2p modules\n   */\n  services?: ServiceFactoryMap<T>\n\n  /**\n   * An optional logging implementation that can be used to write runtime logs.\n   *\n   * Set the `DEBUG` env var or the `debug` key on LocalStorage to see logs.\n   *\n   * @example\n   *\n   * Node.js:\n   *\n   * ```console\n   * $ DEBUG=\"*libp2p:*\" node myscript.js\n   * ```\n   *\n   * Browsers:\n   *\n   * ```TypeScript\n   * localStorage.setItem('debug', '*libp2p:*')\n   * ```\n   */\n  logger?: ComponentLogger\n\n  /**\n   * An optional DNS resolver configuration. If omitted the default DNS resolver\n   * for the platform will be used which means `node:dns` on Node.js and\n   * DNS-JSON-over-HTTPS for browsers using Google and Cloudflare servers.\n   */\n  dns?: DNS\n}\n\nexport type { Libp2p, ConnectionManagerInit, ConnectionMonitorInit, TransportManagerInit }\n\nexport type Libp2pOptions<T extends ServiceMap = ServiceMap> = Libp2pInit<T> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncrypters: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p <T extends ServiceMap = ServiceMap> (options: Libp2pOptions<T> = {}): Promise<Libp2p<T>> {\n  options.privateKey ??= await generateKeyPair('Ed25519')\n\n  const node = new Libp2pClass({\n    ...await validateConfig(options),\n    peerId: peerIdFromPrivateKey(options.privateKey)\n  })\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU,SAAU,KAAK;AAE9B,UAAI,CAAC;AAAK,cAAM,MAAM,+DAA+D;AAErF,UAAI,OAAO,GAAGA,SAAQ,uBAAO,OAAO,IAAI,GAAG,SAAS,uBAAO,OAAO,IAAI;AAEtE,eAAS,OAAQ,KAAK,OAAO;AAC3B,QAAAA,OAAM,GAAG,IAAI;AACb;AACA,YAAG,QAAQ,KAAK;AACd,iBAAO;AACP,mBAASA;AACT,UAAAA,SAAQ,uBAAO,OAAO,IAAI;AAAA,QAC5B;AAAA,MACF;AAEA,aAAO;AAAA,QACL,KAAK,SAAU,KAAK;AAClB,iBAAOA,OAAM,GAAG,MAAM,UAAa,OAAO,GAAG,MAAM;AAAA,QACrD;AAAA,QACA,QAAQ,SAAU,KAAK;AACrB,cAAGA,OAAM,GAAG,MAAM;AAChB,YAAAA,OAAM,GAAG,IAAI;AACf,cAAG,OAAO,GAAG,MAAM;AACjB,mBAAO,GAAG,IAAI;AAAA,QAClB;AAAA,QACA,KAAK,SAAU,KAAK;AAClB,cAAI,IAAIA,OAAM,GAAG;AACjB,cAAG,MAAM;AAAW,mBAAO;AAC3B,eAAI,IAAI,OAAO,GAAG,OAAO,QAAW;AAClC,mBAAO,KAAK,CAAC;AACb,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,QACA,KAAK,SAAU,KAAK,OAAO;AACzB,cAAGA,OAAM,GAAG,MAAM;AAAW,YAAAA,OAAM,GAAG,IAAI;AAAA;AACrC,mBAAO,KAAK,KAAK;AAAA,QACxB;AAAA,QACA,OAAO,WAAY;AACjB,UAAAA,SAAQ,uBAAO,OAAO,IAAI;AAC1B,mBAAS,uBAAO,OAAO,IAAI;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA;AAAA;;;AC3CA;AAAA;AACA,KAAC,WAAW;AACV,UAAIC,UAAS,MAAM,KAAK,MAAM,MAAM,MAAM,SAAS;AAEnD,gBAAU,SAAS,MAAM;AACvB,YAAI,GAAG,GAAG,GAAG;AACb,aAAK,OAAQ,OAAQ,QAAS;AAC9B,aAAK,OAAQ,OAAQ,QAAS;AAC9B,aAAK,OAAQ,OAAQ,OAAQ;AAC7B,YAAI,OAAO;AACX,eAAO,CAAC,GAAG,GAAG,GAAG,CAAC,EAAE,KAAK,GAAG;AAAA,MAC9B;AAEA,gBAAU,SAAS,IAAI;AACrB,YAAI,GAAG,GAAG,GAAG,GAAG,GAAG;AACnB,YAAI,CAAC;AACL,aAAK,IAAI,IAAI,GAAG,KAAK,GAAG,IAAI,EAAE,GAAG;AAC/B,cAAI,GAAG,WAAW,GAAG;AACnB;AAAA,UACF;AACA,cAAI,IAAI,GAAG;AACT,gBAAI,GAAG,CAAC,MAAM,KAAK;AACjB,oBAAM,IAAI,MAAM,YAAY;AAAA,YAC9B;AACA,iBAAK,GAAG,UAAU,CAAC;AAAA,UACrB;AACA,gBAAM,KAAK,EAAE,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC;AACrC,eAAK,GAAG,UAAU,CAAC;AACnB,YAAE,KAAK,CAAC;AAAA,QACV;AACA,YAAI,GAAG,WAAW,GAAG;AACnB,gBAAM,IAAI,MAAM,YAAY;AAAA,QAC9B;AACA,gBAAQ,EAAE,QAAQ;AAAA,UAChB,KAAK;AACH,gBAAI,EAAE,CAAC,IAAI,YAAY;AACrB,oBAAM,IAAI,MAAM,YAAY;AAAA,YAC9B;AACA,mBAAO,EAAE,CAAC,MAAM;AAAA,UAClB,KAAK;AACH,gBAAI,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,UAAU;AAClC,oBAAM,IAAI,MAAM,YAAY;AAAA,YAC9B;AACA,oBAAQ,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,OAAO;AAAA,UACjC,KAAK;AACH,gBAAI,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,OAAQ;AAC/C,oBAAM,IAAI,MAAM,YAAY;AAAA,YAC9B;AACA,oBAAQ,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,OAAO;AAAA,UAC9C,KAAK;AACH,gBAAI,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,OAAQ,EAAE,CAAC,IAAI,KAAM;AAC5D,oBAAM,IAAI,MAAM,YAAY;AAAA,YAC9B;AACA,oBAAQ,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,KAAK,KAAK,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,OAAO;AAAA,UAC1D;AACE,kBAAM,IAAI,MAAM,YAAY;AAAA,QAChC;AAAA,MACF;AAEA,YAAM,SAAS,GAAG;AAChB,eAAO,EAAE,WAAW,CAAC;AAAA,MACvB;AAEA,aAAO,IAAI,GAAG;AAEd,aAAO,IAAI,GAAG;AAEd,aAAO,IAAI,GAAG;AAEd,aAAO,SAAS,GAAG;AACjB,YAAI,MAAM,MAAM,GAAG,GAAGC;AACtB,YAAI;AACJ,eAAO;AACP,eAAO;AACP,YAAI;AACJ,YAAI,EAAE,SAAS,KAAK,EAAE,CAAC,MAAM,KAAK;AAChC,cAAI,EAAE,IAAI,CAAC,MAAM,OAAO,EAAE,IAAI,CAAC,MAAM,KAAK;AACxC,iBAAK;AACL,mBAAO;AAAA,UACT,WAAW,OAAO,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,KAAK;AAC7C;AACA,mBAAO;AACP,mBAAO;AAAA,UACT;AAAA,QACF;AACA,QAAAA,SAAQ;AACR,eAAO,IAAI,EAAE,QAAQ;AACnB,cAAI,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,MAAM;AAC/B,gBAAK,IAAI,QAAQ,IAAI,EAAE,CAAC,CAAC,IAAI,UAAW;AAAA,UAC1C,WAAW,SAAS,IAAI;AACtB,gBAAI,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,KAAK;AAC9B,kBAAK,IAAI,QAAQ,KAAK,IAAI,EAAE,CAAC,CAAC,IAAI,UAAW;AAAA,YAC/C,WAAW,OAAO,EAAE,CAAC,KAAK,EAAE,CAAC,KAAK,KAAK;AACrC,kBAAK,IAAI,QAAQ,KAAK,IAAI,EAAE,CAAC,CAAC,IAAI,UAAW;AAAA,YAC/C,OAAO;AACL;AAAA,YACF;AAAA,UACF,OAAO;AACL;AAAA,UACF;AACA,cAAI,IAAI,YAAY;AAClB,kBAAM,IAAI,MAAM,WAAW;AAAA,UAC7B;AACA;AAAA,QACF;AACA,YAAI,MAAMA,QAAO;AACf,gBAAM,IAAI,MAAM,aAAa;AAAA,QAC/B;AACA,eAAO,CAAC,GAAG,CAAC;AAAA,MACd;AAEA,MAAAD,WAAW,WAAW;AACpB,iBAASA,SAAQ,KAAK,MAAM;AAC1B,cAAI,OAAO,GAAG,GAAG;AACjB,cAAI,OAAO,QAAQ,UAAU;AAC3B,kBAAM,IAAI,MAAM,yBAAyB;AAAA,UAC3C;AACA,cAAI,CAAC,MAAM;AACT,kBAAM,IAAI,MAAM,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,OAAO,IAAI,CAAC;AAAA,UACrD;AACA,cAAI,CAAC,MAAM;AACT,mBAAO;AAAA,UACT;AACA,cAAI,OAAO,SAAS,YAAY,KAAK,QAAQ,GAAG,IAAI,IAAI;AACtD,gBAAI;AACF,mBAAK,WAAW,QAAQ,IAAI;AAAA,YAC9B,SAAS,QAAQ;AACf,sBAAQ;AACR,oBAAM,IAAI,MAAM,mBAAmB,IAAI;AAAA,YACzC;AACA,iBAAK,IAAI,IAAI,IAAI,KAAK,GAAG,IAAI,EAAE,GAAG;AAChC,kBAAI,KAAK,aAAc,cAAe,KAAK,MAAQ,GAAG;AACpD,qBAAK,UAAU;AACf;AAAA,cACF;AAAA,YACF;AAAA,UACF,WAAW,QAAQ,SAAS,GAAG;AAC7B,iBAAK,UAAU,SAAS,MAAM,EAAE;AAChC,iBAAK,WAAW;AAChB,gBAAI,KAAK,UAAU,GAAG;AACpB,mBAAK,WAAY,cAAe,KAAK,KAAK,YAAc;AAAA,YAC1D;AAAA,UACF,OAAO;AACL,kBAAM,IAAI,MAAM,qBAAqB;AAAA,UACvC;AACA,cAAI;AACF,iBAAK,WAAW,QAAQ,GAAG,IAAI,KAAK,cAAc;AAAA,UACpD,SAAS,QAAQ;AACf,oBAAQ;AACR,kBAAM,IAAI,MAAM,0BAA0B,GAAG;AAAA,UAC/C;AACA,cAAI,EAAE,KAAK,WAAW,KAAK;AACzB,kBAAM,IAAI,MAAM,2BAA2B,IAAI;AAAA,UACjD;AACA,eAAK,OAAO,KAAK,IAAI,GAAG,KAAK,KAAK,OAAO;AACzC,eAAK,OAAO,QAAQ,KAAK,OAAO;AAChC,eAAK,OAAO,QAAQ,KAAK,QAAQ;AACjC,eAAK,WAAW,QAAQ,CAAC,KAAK,QAAQ;AACtC,eAAK,QAAQ,KAAK,WAAW,KAAK,QAAQ,KAAK,UAAU,CAAC,IAAI,KAAK;AACnE,eAAK,OAAO,KAAK,WAAW,KAAK,QAAQ,KAAK,UAAU,KAAK,OAAO,CAAC,IAAI,QAAQ,KAAK,UAAU,KAAK,OAAO,CAAC;AAC7G,eAAK,YAAY,KAAK,WAAW,KAAK,QAAQ,KAAK,UAAU,KAAK,OAAO,CAAC,IAAI;AAAA,QAChF;AAEA,QAAAA,SAAQ,UAAU,WAAW,SAAS,IAAI;AACxC,cAAI,OAAO,OAAO,aAAa,GAAG,QAAQ,GAAG,IAAI,KAAK,GAAG,MAAM,GAAG,EAAE,WAAW,IAAI;AACjF,iBAAK,IAAIA,SAAQ,EAAE;AAAA,UACrB;AACA,cAAI,cAAcA,UAAS;AACzB,mBAAO,KAAK,SAAS,GAAG,IAAI,KAAK,KAAK,SAAS,GAAG,aAAa,GAAG,IAAI;AAAA,UACxE,OAAO;AACL,oBAAQ,QAAQ,EAAE,IAAI,KAAK,cAAc,OAAO,KAAK,UAAU,KAAK,cAAc;AAAA,UACpF;AAAA,QACF;AAEA,QAAAA,SAAQ,UAAU,OAAO,SAAS,OAAO;AACvC,cAAI,SAAS,MAAM;AACjB,oBAAQ;AAAA,UACV;AACA,iBAAO,IAAIA,SAAQ,QAAQ,KAAK,UAAW,KAAK,OAAO,KAAM,GAAG,KAAK,IAAI;AAAA,QAC3E;AAEA,QAAAA,SAAQ,UAAU,UAAU,SAAS,IAAI;AACvC,cAAI,OAAO,UAAU;AACrB,iBAAO,QAAQ,KAAK,KAAK;AACzB,qBAAW,QAAQ,KAAK,IAAI;AAC5B,kBAAQ;AACR,iBAAO,QAAQ,UAAU;AACvB,eAAG,QAAQ,IAAI,GAAG,MAAM,KAAK;AAC7B;AACA;AAAA,UACF;AAAA,QACF;AAEA,QAAAA,SAAQ,UAAU,WAAW,WAAW;AACtC,iBAAO,KAAK,OAAO,MAAM,KAAK;AAAA,QAChC;AAEA,eAAOA;AAAA,MAET,EAAG;AAEH,cAAQ,UAAU;AAElB,cAAQ,UAAU;AAElB,cAAQ,UAAUA;AAAA,IAEpB,GAAG,KAAK,OAAI;AAAA;AAAA;;;AC/MZ;AAAA;AAAA,aAAS,eAAe,UAAU,SAAS;AAEzC,UAAI,OAAO,YAAY,WAAW;AAChC,kBAAU,EAAE,SAAS,QAAQ;AAAA,MAC/B;AAEA,WAAK,oBAAoB,KAAK,MAAM,KAAK,UAAU,QAAQ,CAAC;AAC5D,WAAK,YAAY;AACjB,WAAK,WAAW,WAAW,CAAC;AAC5B,WAAK,gBAAgB,WAAW,QAAQ,gBAAgB;AACxD,WAAK,MAAM;AACX,WAAK,UAAU,CAAC;AAChB,WAAK,YAAY;AACjB,WAAK,oBAAoB;AACzB,WAAK,sBAAsB;AAC3B,WAAK,WAAW;AAChB,WAAK,kBAAkB;AACvB,WAAK,SAAS;AAEd,UAAI,KAAK,SAAS,SAAS;AACzB,aAAK,kBAAkB,KAAK,UAAU,MAAM,CAAC;AAAA,MAC/C;AAAA,IACF;AACA,WAAO,UAAU;AAEjB,mBAAe,UAAU,QAAQ,WAAW;AAC1C,WAAK,YAAY;AACjB,WAAK,YAAY,KAAK,kBAAkB,MAAM,CAAC;AAAA,IACjD;AAEA,mBAAe,UAAU,OAAO,WAAW;AACzC,UAAI,KAAK,UAAU;AACjB,qBAAa,KAAK,QAAQ;AAAA,MAC5B;AACA,UAAI,KAAK,QAAQ;AACf,qBAAa,KAAK,MAAM;AAAA,MAC1B;AAEA,WAAK,YAAkB,CAAC;AACxB,WAAK,kBAAkB;AAAA,IACzB;AAEA,mBAAe,UAAU,QAAQ,SAAS,KAAK;AAC7C,UAAI,KAAK,UAAU;AACjB,qBAAa,KAAK,QAAQ;AAAA,MAC5B;AAEA,UAAI,CAAC,KAAK;AACR,eAAO;AAAA,MACT;AACA,UAAI,eAAc,oBAAI,KAAK,GAAE,QAAQ;AACrC,UAAI,OAAO,cAAc,KAAK,mBAAmB,KAAK,eAAe;AACnE,aAAK,QAAQ,KAAK,GAAG;AACrB,aAAK,QAAQ,QAAQ,IAAI,MAAM,iCAAiC,CAAC;AACjE,eAAO;AAAA,MACT;AAEA,WAAK,QAAQ,KAAK,GAAG;AAErB,UAAI,UAAU,KAAK,UAAU,MAAM;AACnC,UAAI,YAAY,QAAW;AACzB,YAAI,KAAK,iBAAiB;AAExB,eAAK,QAAQ,OAAO,GAAG,KAAK,QAAQ,SAAS,CAAC;AAC9C,oBAAU,KAAK,gBAAgB,MAAM,EAAE;AAAA,QACzC,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAEA,UAAI,OAAO;AACX,WAAK,SAAS,WAAW,WAAW;AAClC,aAAK;AAEL,YAAI,KAAK,qBAAqB;AAC5B,eAAK,WAAW,WAAW,WAAW;AACpC,iBAAK,oBAAoB,KAAK,SAAS;AAAA,UACzC,GAAG,KAAK,iBAAiB;AAEzB,cAAI,KAAK,SAAS,OAAO;AACrB,iBAAK,SAAS,MAAM;AAAA,UACxB;AAAA,QACF;AAEA,aAAK,IAAI,KAAK,SAAS;AAAA,MACzB,GAAG,OAAO;AAEV,UAAI,KAAK,SAAS,OAAO;AACrB,aAAK,OAAO,MAAM;AAAA,MACtB;AAEA,aAAO;AAAA,IACT;AAEA,mBAAe,UAAU,UAAU,SAAS,IAAI,YAAY;AAC1D,WAAK,MAAM;AAEX,UAAI,YAAY;AACd,YAAI,WAAW,SAAS;AACtB,eAAK,oBAAoB,WAAW;AAAA,QACtC;AACA,YAAI,WAAW,IAAI;AACjB,eAAK,sBAAsB,WAAW;AAAA,QACxC;AAAA,MACF;AAEA,UAAI,OAAO;AACX,UAAI,KAAK,qBAAqB;AAC5B,aAAK,WAAW,WAAW,WAAW;AACpC,eAAK,oBAAoB;AAAA,QAC3B,GAAG,KAAK,iBAAiB;AAAA,MAC3B;AAEA,WAAK,mBAAkB,oBAAI,KAAK,GAAE,QAAQ;AAE1C,WAAK,IAAI,KAAK,SAAS;AAAA,IACzB;AAEA,mBAAe,UAAU,MAAM,SAAS,IAAI;AAC1C,cAAQ,IAAI,0CAA0C;AACtD,WAAK,QAAQ,EAAE;AAAA,IACjB;AAEA,mBAAe,UAAU,QAAQ,SAAS,IAAI;AAC5C,cAAQ,IAAI,4CAA4C;AACxD,WAAK,QAAQ,EAAE;AAAA,IACjB;AAEA,mBAAe,UAAU,QAAQ,eAAe,UAAU;AAE1D,mBAAe,UAAU,SAAS,WAAW;AAC3C,aAAO,KAAK;AAAA,IACd;AAEA,mBAAe,UAAU,WAAW,WAAW;AAC7C,aAAO,KAAK;AAAA,IACd;AAEA,mBAAe,UAAU,YAAY,WAAW;AAC9C,UAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,eAAO;AAAA,MACT;AAEA,UAAI,SAAS,CAAC;AACd,UAAI,YAAY;AAChB,UAAI,iBAAiB;AAErB,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,QAAQ,KAAK;AAC5C,YAAI,QAAQ,KAAK,QAAQ,CAAC;AAC1B,YAAIE,WAAU,MAAM;AACpB,YAAI,SAAS,OAAOA,QAAO,KAAK,KAAK;AAErC,eAAOA,QAAO,IAAI;AAElB,YAAI,SAAS,gBAAgB;AAC3B,sBAAY;AACZ,2BAAiB;AAAA,QACnB;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA;AAAA;;;ACjKA;AAAA;AAAA,QAAI,iBAAiB;AAErB,YAAQ,YAAY,SAAS,SAAS;AACpC,UAAI,WAAW,QAAQ,SAAS,OAAO;AACvC,aAAO,IAAI,eAAe,UAAU;AAAA,QAChC,SAAS,YAAY,QAAQ,WAAW,QAAQ,YAAY;AAAA,QAC5D,OAAO,WAAW,QAAQ;AAAA,QAC1B,cAAc,WAAW,QAAQ;AAAA,MACrC,CAAC;AAAA,IACH;AAEA,YAAQ,WAAW,SAAS,SAAS;AACnC,UAAI,mBAAmB,OAAO;AAC5B,eAAO,CAAC,EAAE,OAAO,OAAO;AAAA,MAC1B;AAEA,UAAI,OAAO;AAAA,QACT,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,YAAY,IAAI;AAAA,QAChB,YAAY;AAAA,QACZ,WAAW;AAAA,MACb;AACA,eAAS,OAAO,SAAS;AACvB,aAAK,GAAG,IAAI,QAAQ,GAAG;AAAA,MACzB;AAEA,UAAI,KAAK,aAAa,KAAK,YAAY;AACrC,cAAM,IAAI,MAAM,uCAAuC;AAAA,MACzD;AAEA,UAAI,WAAW,CAAC;AAChB,eAAS,IAAI,GAAG,IAAI,KAAK,SAAS,KAAK;AACrC,iBAAS,KAAK,KAAK,cAAc,GAAG,IAAI,CAAC;AAAA,MAC3C;AAEA,UAAI,WAAW,QAAQ,WAAW,CAAC,SAAS,QAAQ;AAClD,iBAAS,KAAK,KAAK,cAAc,GAAG,IAAI,CAAC;AAAA,MAC3C;AAGA,eAAS,KAAK,SAAS,GAAE,GAAG;AAC1B,eAAO,IAAI;AAAA,MACb,CAAC;AAED,aAAO;AAAA,IACT;AAEA,YAAQ,gBAAgB,SAAS,SAAS,MAAM;AAC9C,UAAI,SAAU,KAAK,YACd,KAAK,OAAO,IAAI,IACjB;AAEJ,UAAI,UAAU,KAAK,MAAM,SAAS,KAAK,IAAI,KAAK,YAAY,CAAC,IAAI,KAAK,IAAI,KAAK,QAAQ,OAAO,CAAC;AAC/F,gBAAU,KAAK,IAAI,SAAS,KAAK,UAAU;AAE3C,aAAO;AAAA,IACT;AAEA,YAAQ,OAAO,SAAS,KAAK,SAAS,SAAS;AAC7C,UAAI,mBAAmB,OAAO;AAC5B,kBAAU;AACV,kBAAU;AAAA,MACZ;AAEA,UAAI,CAAC,SAAS;AACZ,kBAAU,CAAC;AACX,iBAAS,OAAO,KAAK;AACnB,cAAI,OAAO,IAAI,GAAG,MAAM,YAAY;AAClC,oBAAQ,KAAK,GAAG;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAEA,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAI,SAAW,QAAQ,CAAC;AACxB,YAAI,WAAW,IAAI,MAAM;AAEzB,YAAI,MAAM,KAAI,SAAS,aAAaC,WAAU;AAC5C,cAAI,KAAW,QAAQ,UAAU,OAAO;AACxC,cAAI,OAAW,MAAM,UAAU,MAAM,KAAK,WAAW,CAAC;AACtD,cAAI,WAAW,KAAK,IAAI;AAExB,eAAK,KAAK,SAAS,KAAK;AACtB,gBAAI,GAAG,MAAM,GAAG,GAAG;AACjB;AAAA,YACF;AACA,gBAAI,KAAK;AACP,wBAAU,CAAC,IAAI,GAAG,UAAU;AAAA,YAC9B;AACA,qBAAS,MAAM,MAAM,SAAS;AAAA,UAChC,CAAC;AAED,aAAG,QAAQ,WAAW;AACpB,YAAAA,UAAS,MAAM,KAAK,IAAI;AAAA,UAC1B,CAAC;AAAA,QACH,GAAE,KAAK,KAAK,QAAQ;AACpB,YAAI,MAAM,EAAE,UAAU;AAAA,MACxB;AAAA,IACF;AAAA;AAAA;;;ACnGA,IAAAC,iBAAA;AAAA;AAAA,WAAO,UAAU;AAAA;AAAA;;;ACEX,SAAU,SAAU,OAAiC;AACzD,QAAM,gBAAgB;IACpB,WAAW;;AAGb,MAAI,SAAS,MAAM;AACjB,WAAO;EACT;AAEA,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,QAAI,MAAM,WAAW,GAAG;AACtB,aAAO;IACT;AAEA,WAAO;EACT;AAEA,SAAO;IACL;;AAEJ;;;AChBO,IAAM,cAAc;AAErB,SAAU,cAAe,KAAQ;AACrC,SAAO;IACL,QAAQ,IAAI,UAAU;IACtB,IAAI,IAAI,MAAM,IAAI,WAAW;IAC7B,IAAI,IAAI,MAAM,IAAI,WAAW;IAC7B,IAAI,IAAI,MAAM,IAAI,WAAW;IAC7B,IAAI,IAAI,MAAM,IAAI,WAAW;IAC7B,IAAI,IAAI,MAAM,IAAI,WAAW;IAC7B,WAAW,IAAI,YAAY,IAAI,aAAa,CAAA,GAAI,IAAI,CAAC,aAAiB;AACpE,aAAO;QACL,MAAM,SAAS;QACf,MAAM,WAAW,SAAS,IAAI;;IAElC,CAAC;IACD,SAAS,IAAI,UAAU,IAAI,WAAW,CAAA,GAAI,IAAI,CAAC,WAAe;AAC5D,aAAO;QACL,MAAM,OAAO;QACb,MAAM,WAAW,OAAO,IAAI;QAC5B,KAAM,OAAO,OAAO,OAAO,OAAO;QAClC,MAAM,OAAO,gBAAgB,aAAa,SAAmB,OAAO,IAAI,IAAI,OAAO;;IAEvF,CAAC;;AAEL;;;ACjBO,IAAM,4BAA4B;AAqBnC,SAAU,iBAAkB,KAAa,OAAgC,CAAA,GAAE;AAC/E,QAAM,YAAY,IAAI,OAAO;IAC3B,aAAa,KAAK,oBAAoB;GACvC;AAED,SAAO,OAAO,MAAM,UAAU,CAAA,MAAM;AAxCtC,QAAAC;AAyCI,UAAM,eAAe,IAAI,gBAAe;AACxC,iBAAa,IAAI,QAAQ,IAAI;AAE7B,aAAS,QAAQ,KAAK,EAAE,QAAQ,UAAO;AAErC,mBAAa,OAAO,QAAQ,WAAW,IAAI,CAAC;IAC9C,CAAC;AAED,KAAAA,OAAA,QAAQ,eAAR,gBAAAA,KAAA,cAAqB,IAAI,oBAA4B,aAAa,EAAE,QAAQ,KAAI,CAAE;AAGlF,UAAM,WAAW,MAAM,UAAU,IAAI,YAAW;AApDpD,UAAAA;AAqDM,YAAM,MAAM,MAAM,MAAM,GAAG,GAAG,IAAI,YAAY,IAAI;QAChD,SAAS;UACP,QAAQ;;QAEV,QAAQ,mCAAS;OAClB;AAED,UAAI,IAAI,WAAW,KAAK;AACtB,cAAM,IAAI,MAAM,2BAA2B,IAAI,MAAM,MAAM,IAAI,UAAU,EAAE;MAC7E;AAEA,YAAMC,YAAW,cAAc,MAAM,IAAI,KAAI,CAAE;AAE/C,OAAAD,OAAA,QAAQ,eAAR,gBAAAA,KAAA,cAAqB,IAAI,oBAAiC,gBAAgB,EAAE,QAAQC,UAAQ,CAAE;AAE9F,aAAOA;IACT,GAAG;MACD,QAAQ,QAAQ;KACjB;AAED,QAAI,YAAY,MAAM;AACpB,YAAM,IAAI,MAAM,0BAA0B;IAC5C;AAEA,WAAO;EACT;AACF;;;AC5EM,SAAU,kBAAe;AAC7B,SAAO;IACL,iBAAiB,sCAAsC;IACvD,iBAAiB,4BAA4B;;AAEjD;;;ACRA,qBAAoB;AAsBpB,IAAM,gBAAN,MAAmB;EAGjB,YAAa,SAAe;AAFX;AAGf,SAAK,UAAM,eAAAC,SAAQ,OAAO;EAC5B;EAEA,IAAK,MAAc,OAAmB;AACpC,QAAI,kBAAkB;AACtB,UAAM,UAAoB,CAAA;AAE1B,eAAW,QAAQ,OAAO;AACxB,YAAM,SAAS,KAAK,WAAW,MAAM,IAAI;AAEzC,UAAI,OAAO,WAAW,GAAG;AACvB,0BAAkB;AAClB;MACF;AAEA,cAAQ,KAAK,GAAG,MAAM;IACxB;AAEA,QAAI,iBAAiB;AACnB,aAAO,cAAc,EAAE,QAAO,CAAE;IAClC;EACF;EAEQ,WAAY,QAAgB,MAAgB;AAClD,UAAM,MAAM,GAAG,OAAO,YAAW,CAAE,IAAI,IAAI;AAC3C,UAAM,UAA0B,KAAK,IAAI,IAAI,GAAG;AAEhD,QAAI,WAAW,MAAM;AACnB,YAAM,gBAAgB,QACnB,OAAO,CAAC,UAAS;AAChB,eAAO,MAAM,UAAU,KAAK,IAAG;MACjC,CAAC,EACA,IAAI,CAAC,EAAE,SAAS,MAAK,OAAQ;QAC5B,GAAG;QACH,KAAK,KAAK,OAAO,UAAU,KAAK,IAAG,KAAM,GAAI;QAC7C,MAAM,WAAW,MAAM,IAAI;QAC3B;AAEJ,UAAI,cAAc,WAAW,GAAG;AAC9B,aAAK,IAAI,OAAO,GAAG;MACrB;AAIA,aAAO;IACT;AAEA,WAAO,CAAA;EACT;EAEA,IAAK,QAAgB,QAAc;AACjC,UAAM,MAAM,GAAG,OAAO,YAAW,CAAE,IAAI,OAAO,IAAI;AAElD,UAAM,UAA0B,KAAK,IAAI,IAAI,GAAG,KAAK,CAAA;AACrD,YAAQ,KAAK;MACX,SAAS,KAAK,IAAG,KAAO,OAAO,OAAO,eAAe;MACrD,OAAO;KACR;AAED,SAAK,IAAI,IAAI,KAAK,OAAO;EAC3B;EAEA,OAAQ,QAAgB,MAAkB;AACxC,UAAM,MAAM,GAAG,OAAO,YAAW,CAAE,IAAI,IAAI;AAE3C,SAAK,IAAI,OAAO,GAAG;EACrB;EAEA,QAAK;AACH,SAAK,IAAI,MAAK;EAChB;;AAMI,SAAU,MAAO,MAAY;AACjC,SAAO,IAAI,cAAc,IAAI;AAC/B;;;AChGA,IAAM,4BAA4B;AAE5B,IAAO,MAAP,MAAU;EAId,YAAa,MAAa;AAHT;AACA;AAGf,SAAK,YAAY,CAAA;AACjB,SAAK,QAAQ,MAAM,KAAK,aAAa,yBAAyB;AAE9D,WAAO,QAAQ,KAAK,aAAa,CAAA,CAAE,EAAE,QAAQ,CAAC,CAAC,KAAK,QAAQ,MAAK;AAC/D,UAAI,CAAC,MAAM,QAAQ,QAAQ,GAAG;AAC5B,mBAAW,CAAC,QAAQ;MACtB;AAGA,UAAI,CAAC,IAAI,SAAS,GAAG,GAAG;AACtB,cAAM,GAAG,GAAG;MACd;AAEA,WAAK,UAAU,GAAG,IAAI;IACxB,CAAC;AAGD,QAAI,KAAK,UAAU,GAAG,KAAK,MAAM;AAC/B,WAAK,UAAU,GAAG,IAAI,gBAAe;IACvC;EACF;;;;;;;;;EAUA,MAAM,MAAO,QAAgB,UAAwB,CAAA,GAAE;AA7CzD,QAAAC,MAAAC,KAAA;AA8CI,UAAM,QAAQ,SAAS,QAAQ,KAAK;AACpC,UAAM,SAAS,QAAQ,WAAW,QAAQ,KAAK,MAAM,IAAI,QAAQ,KAAK,IAAI;AAE1E,QAAI,UAAU,MAAM;AAClB,OAAAD,OAAA,QAAQ,eAAR,gBAAAA,KAAA,cAAqB,IAAI,oBAA4B,aAAa,EAAE,QAAQ,OAAM,CAAE;AAEpF,aAAO;IACT;AAEA,UAAM,MAAM,GAAG,OAAO,MAAM,GAAG,EAAE,IAAG,CAAE;AACtC,UAAME,cAAa,KAAK,UAAU,GAAG,KAAK,KAAK,UAAU,GAAG,GAAG,KAAK,MAAK;AACvE,aAAQ,KAAK,OAAM,IAAK,MAAO,KAAK;IACtC,CAAC;AAED,UAAM,SAAkB,CAAA;AAExB,eAAW,YAAYA,YAAW;AAEhC,YAAID,MAAA,QAAQ,WAAR,gBAAAA,IAAgB,aAAY,MAAM;AACpC;MACF;AAEA,UAAI;AACF,cAAM,SAAS,MAAM,SAAS,QAAQ;UACpC,GAAG;UACH;SACD;AAED,mBAAW,UAAU,OAAO,QAAQ;AAClC,eAAK,MAAM,IAAI,QAAQ,MAAM;QAC/B;AAEA,eAAO;MACT,SAAS,KAAU;AACjB,eAAO,KAAK,GAAG;AACf,sBAAQ,eAAR,iCAAqB,IAAI,oBAA2B,aAAa,EAAE,QAAQ,IAAG,CAAE;MAClF;IACF;AAEA,QAAI,OAAO,WAAW,GAAG;AACvB,YAAM,OAAO,CAAC;IAChB;AAEA,UAAM,IAAI,eAAe,QAAQ,iBAAiB,MAAM,IAAI,KAAK,SAAS;EAC5E;;;;ACCF,IAAY;CAAZ,SAAYE,aAAU;AACpB,EAAAA,YAAAA,YAAA,GAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,OAAA,IAAA,CAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,KAAA,IAAA,EAAA,IAAA;AACA,EAAAA,YAAAA,YAAA,MAAA,IAAA,EAAA,IAAA;AACF,GALY,eAAA,aAAU,CAAA,EAAA;AAwKhB,SAAU,IAAK,OAAgB,CAAA,GAAE;AACrC,SAAO,IAAI,IAAS,IAAI;AAC1B;;;AC9PA,IAAM,sBAAsB;AAC5B,IAAM,EAAE,MAAM,YAAW,IAAK,YAAY,SAAS;AAEnD,IAAM,sBAAN,cAAkC,MAAK;EACrC,YAAaC,WAAU,+BAA6B;AAClD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAkBK,IAAM,kBAA4C,eAAeC,iBAAiB,IAAe,UAA0B,CAAA,GAAE;AAClI,QAAM,iBAAiB,QAAQ,qBAAqB;AAEpD,MAAI,mBAAmB,GAAG;AACxB,UAAM,IAAI,oBAAoB,6BAA6B;EAC7D;AAEA,QAAM,CAAC,EAAE,QAAQ,IAAI,GAAG,aAAY,EAAG,KAAK,CAAC,CAAC,KAAK,MAAM,UAAU,WAAW,KAAK,CAAA;AAEnF,QAAM,YAAW,mCAAS,QAAO,IAAG;AACpC,QAAM,SAAS,MAAM,SAAS,MAAM,YAAY,QAAQ,IAAI;IAC1D,QAAQ,mCAAS;IACjB,OAAO;MACL,WAAW;;GAEd;AAED,QAAM,SAAS,GAAG,UAAS;AAC3B,QAAM,SAAmB,CAAA;AAEzB,aAAW,UAAU,OAAO,QAAQ;AAClC,UAAM,OAAO,OAAO,KACjB,QAAQ,SAAS,EAAE,EACnB,KAAI,EACJ,MAAM,GAAG,EAAE,CAAC;AAEf,QAAI,QAAQ,MAAM;AAChB;IACF;AAEA,QAAI,UAAU,QAAQ,CAAC,KAAK,SAAS,MAAM,GAAG;AAC5C;IACF;AAEA,UAAMC,MAAK,UAAU,IAAI;AAEzB,QAAI,KAAK,WAAW,UAAU,GAAG;AAC/B,YAAM,WAAW,MAAMA,IAAG,QAAQ;QAChC,GAAG;QACH,mBAAmB,iBAAiB;OACrC;AAED,aAAO,KAAK,GAAG,SAAS,IAAI,CAAAA,QAAMA,IAAG,SAAQ,CAAE,CAAC;IAClD,OAAO;AACL,aAAO,KAAKA,IAAG,SAAQ,CAAE;IAC3B;EACF;AAEA,SAAO;AACT;;;AC1EA,IAAM,gBAA4B;EAChC,WAAW;IACT,QAAQ,CAAA;IACR,UAAU,CAAA;IACV,YAAY,CAAA;IACZ,gBAAgB,CAAC,eAA4B;;EAE/C,mBAAmB;IACjB,WAAW;MACT,SAAS;;;EAGb,kBAAkB;IAChB,gBAAgB,eAAe;;;AAInC,eAAsB,eAAiE,MAAmB;AAxB1G,MAAAC,MAAAC;AAyBE,QAAM,mBAAkC,sBAAa,eAAe,IAAI;AAExE,MAAI,iBAAiB,wBAAwB,UAAQA,OAAAD,OAAA,WAAW,YAAX,gBAAAA,KAAoB,QAApB,gBAAAC,IAAyB,sBAAqB,MAAM;AACvG,UAAM,IAAI,uBAAuB,4DAA4D;EAC/F;AAEA,SAAO;AACT;;;ACxBM,SAAU,YAAoB,MAA2B,KAAkB;AAC/E,QAAM,WAAgC;IACpC,CAAC,OAAO,QAAQ,GAAG,MAAK;AACtB,aAAO;IACT;IACA,MAAM,MAAK;AACT,YAAM,OAAO,KAAK,KAAI;AACtB,YAAM,MAAM,KAAK;AAEjB,UAAI,KAAK,SAAS,QAAQ,OAAO,MAAM;AACrC,cAAM,SAAoC;UACxC,MAAM;UACN,OAAO;;AAGT,eAAO;MACT;AAEA,aAAO;QACL,MAAM;QACN,OAAO,IAAI,GAAG;;IAElB;;AAGF,SAAO;AACT;AAEM,SAAUC,kBAAkB,KAAW;AAC3C,QAAM,YAAmB,OAAO,UAAU,OAAO,IAAI,GAAG,EAAE,CAAC;AAC3D,SAAO,oBAAoB,SAAS;AACtC;;;ACnBM,IAAO,UAAP,MAAc;EAGlB,YAAa,KAAgB;AAFZ;AAGf,SAAK,MAAM,oBAAI,IAAG;AAElB,QAAI,OAAO,MAAM;AACf,iBAAW,CAAC,KAAK,KAAK,KAAK,IAAI,QAAO,GAAI;AACxC,aAAK,IAAI,IAAI,IAAI,SAAQ,GAAI,EAAE,KAAK,MAAK,CAAE;MAC7C;IACF;EACF;EAEA,CAAC,OAAO,QAAQ,IAAC;AACf,WAAO,KAAK,QAAO;EACrB;EAEA,QAAK;AACH,SAAK,IAAI,MAAK;EAChB;EAEA,OAAQ,MAAY;AAClB,WAAO,KAAK,IAAI,OAAO,KAAK,SAAQ,CAAE;EACxC;EAEA,UAAO;AACL,WAAO,YACL,KAAK,IAAI,QAAO,GAChB,CAAC,QAAO;AACN,aAAO,CAAC,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,KAAK;IAClC,CAAC;EAEL;EAEA,QAAS,IAAoD;AAC3D,SAAK,IAAI,QAAQ,CAAC,OAAO,QAAO;AAC9B,SAAG,MAAM,OAAO,MAAM,KAAK,IAAI;IACjC,CAAC;EACH;EAEA,IAAK,MAAY;AA5DnB,QAAAC;AA6DI,YAAOA,OAAA,KAAK,IAAI,IAAI,KAAK,SAAQ,CAAE,MAA5B,gBAAAA,KAA+B;EACxC;EAEA,IAAK,MAAY;AACf,WAAO,KAAK,IAAI,IAAI,KAAK,SAAQ,CAAE;EACrC;EAEA,IAAK,MAAc,OAAQ;AACzB,SAAK,IAAI,IAAI,KAAK,SAAQ,GAAI,EAAE,KAAK,MAAM,MAAK,CAAE;EACpD;EAEA,OAAI;AACF,WAAO,YACL,KAAK,IAAI,OAAM,GACf,CAAC,QAAO;AACN,aAAO,IAAI;IACb,CAAC;EAEL;EAEA,SAAM;AACJ,WAAO,YAAY,KAAK,IAAI,OAAM,GAAI,CAAC,QAAQ,IAAI,KAAK;EAC1D;EAEA,IAAI,OAAI;AACN,WAAO,KAAK,IAAI;EAClB;;;;ACnEI,IAAO,UAAP,MAAO,SAAO;EAGlB,YAAa,KAAgC;AAF5B;AAGf,SAAK,MAAM,oBAAI,IAAG;AAElB,QAAI,OAAO,MAAM;AACf,iBAAW,OAAO,KAAK;AACrB,aAAK,IAAI,IAAI,IAAI,SAAQ,CAAE;MAC7B;IACF;EACF;EAEA,IAAI,OAAI;AACN,WAAO,KAAK,IAAI;EAClB;EAEA,CAAC,OAAO,QAAQ,IAAC;AACf,WAAO,KAAK,OAAM;EACpB;EAEA,IAAK,MAAY;AACf,SAAK,IAAI,IAAI,KAAK,SAAQ,CAAE;EAC9B;EAEA,QAAK;AACH,SAAK,IAAI,MAAK;EAChB;EAEA,OAAQ,MAAY;AAClB,SAAK,IAAI,OAAO,KAAK,SAAQ,CAAE;EACjC;EAEA,UAAO;AACL,WAAO,YACL,KAAK,IAAI,QAAO,GAChB,CAAC,QAAO;AACN,YAAM,SAASC,kBAAiB,IAAI,CAAC,CAAC;AAEtC,aAAO,CAAC,QAAQ,MAAM;IACxB,CAAC;EAEL;EAEA,QAAS,WAAgE;AACvE,SAAK,IAAI,QAAQ,CAAC,QAAO;AACvB,YAAM,SAASA,kBAAiB,GAAG;AAEnC,gBAAU,QAAQ,QAAQ,IAAI;IAChC,CAAC;EACH;EAEA,IAAK,MAAY;AACf,WAAO,KAAK,IAAI,IAAI,KAAK,SAAQ,CAAE;EACrC;EAEA,SAAM;AACJ,WAAO,YACL,KAAK,IAAI,OAAM,GACf,CAAC,QAAO;AACN,aAAOA,kBAAiB,GAAG;IAC7B,CAAC;EAEL;EAEA,aAAc,OAAc;AAC1B,UAAM,SAAS,IAAI,SAAO;AAE1B,eAAW,UAAU,OAAO;AAC1B,UAAI,KAAK,IAAI,MAAM,GAAG;AACpB,eAAO,IAAI,MAAM;MACnB;IACF;AAEA,WAAO;EACT;EAEA,WAAY,OAAc;AACxB,UAAM,SAAS,IAAI,SAAO;AAE1B,eAAW,UAAU,MAAM;AACzB,UAAI,CAAC,MAAM,IAAI,MAAM,GAAG;AACtB,eAAO,IAAI,MAAM;MACnB;IACF;AAEA,WAAO;EACT;EAEA,MAAO,OAAc;AACnB,UAAM,SAAS,IAAI,SAAO;AAE1B,eAAW,UAAU,OAAO;AAC1B,aAAO,IAAI,MAAM;IACnB;AAEA,eAAW,UAAU,MAAM;AACzB,aAAO,IAAI,MAAM;IACnB;AAEA,WAAO;EACT;;AAGI,SAAU,UAAO;AACrB,SAAO,IAAI,QAAO;AACpB;;;AC1GM,IAAO,WAAP,MAAO,UAAQ;EAGnB,YAAa,MAAkC;AAFvC;AAGN,SAAK,OAAO,CAAA;AAEZ,QAAI,QAAQ,MAAM;AAChB,iBAAW,SAAS,MAAM;AACxB,aAAK,KAAK,KAAK,KAAK;MACtB;IACF;EACF;EAEA,CAAC,OAAO,QAAQ,IAAC;AACf,WAAO,YACL,KAAK,KAAK,QAAO,GACjB,CAAC,QAAO;AACN,aAAO,IAAI,CAAC;IACd,CAAC;EAEL;EAEA,OAAQ,MAAc;AACpB,UAAM,SAAS,IAAI,UAAS,IAAI;AAEhC,eAAW,SAAS,MAAM;AACxB,aAAO,KAAK,KAAK;IACnB;AAEA,WAAO;EACT;EAEA,UAAO;AACL,WAAO,YACL,KAAK,KAAK,QAAO,GACjB,CAAC,QAAO;AACN,aAAO,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;IACxB,CAAC;EAEL;EAEA,MAAO,WAAoE;AACzE,WAAO,KAAK,KAAK,MAAM,CAAC,QAAQ,UAAS;AACvC,aAAO,UAAU,QAAQ,OAAO,IAAI;IACtC,CAAC;EACH;EAEA,OAAQ,WAAoE;AAC1E,UAAM,SAAS,IAAI,UAAQ;AAE3B,SAAK,KAAK,QAAQ,CAAC,QAAQ,UAAS;AAClC,UAAI,UAAU,QAAQ,OAAO,IAAI,GAAG;AAClC,eAAO,KAAK,MAAM;MACpB;IACF,CAAC;AAED,WAAO;EACT;EAEA,KAAM,WAAoE;AACxE,UAAM,SAAS,KAAK,KAAK,KAAK,CAACC,SAAQ,UAAS;AAC9C,aAAO,UAAUA,SAAQ,OAAO,IAAI;IACtC,CAAC;AAED,QAAI,UAAU,MAAM;AAClB,aAAO;IACT;AAEA,WAAO;EACT;EAEA,UAAW,WAAoE;AAC7E,WAAO,KAAK,KAAK,UAAU,CAAC,QAAQ,UAAS;AAC3C,aAAO,UAAU,QAAQ,OAAO,IAAI;IACtC,CAAC;EACH;EAEA,QAAS,WAAiE;AACxE,SAAK,KAAK,QAAQ,CAAC,QAAQ,UAAS;AAClC,gBAAU,QAAQ,OAAO,IAAI;IAC/B,CAAC;EACH;EAEA,SAAU,QAAc;AACtB,WAAO,KAAK,SAAS,MAAM;EAC7B;EAEA,QAAS,QAAc;AACrB,WAAO,KAAK,KAAK,UAAU,QAAM,GAAG,OAAO,MAAM,CAAC;EACpD;EAEA,MAAG;AACD,UAAM,SAAS,KAAK,KAAK,IAAG;AAE5B,QAAI,UAAU,MAAM;AAClB,aAAO;IACT;AAEA,WAAO;EACT;EAEA,QAAS,SAAiB;AACxB,eAAW,UAAU,SAAS;AAC5B,WAAK,KAAK,KAAK,MAAM;IACvB;EACF;EAEA,QAAK;AACH,UAAM,SAAS,KAAK,KAAK,MAAK;AAE9B,QAAI,UAAU,MAAM;AAClB,aAAO;IACT;AAEA,WAAO;EACT;EAEA,WAAY,SAAiB;AAC3B,QAAI,MAAM,KAAK,KAAK;AAEpB,aAAS,IAAI,QAAQ,SAAS,GAAG,IAAI,IAAI,KAAK;AAC5C,YAAM,KAAK,KAAK,QAAQ,QAAQ,CAAC,CAAC;IACpC;AAEA,WAAO;EACT;EAEA,QAAK;AACH,SAAK,OAAO,CAAA;EACd;EAEA,IAAI,SAAM;AACR,WAAO,KAAK,KAAK;EACnB;;;;ACnIF,SAAS,WAAW,MAAa,WAAkB,OAAc,OAAgB;AAC/E,QAAM,IAAI;AACV,QAAM,OAAO,UAAU,EAAE,OAAO,IAAI,WAAW,GAAE,GAAI,KAAK;AAC1D,QAAM,EAAE,GAAG,OAAO,UAAS,IAAK;AAChC,UAAQ,CAAC;AACT,UAAQ,KAAK;AACb,UAAQ,SAAS;AACjB,MAAI,IAAI;AAAG,UAAM,IAAI,MAAM,uCAAuC;AAClE,QAAM,WAAW,QAAQ,SAAS;AAClC,QAAM,OAAO,QAAQ,KAAK;AAE1B,QAAM,KAAK,IAAI,WAAW,KAAK;AAE/B,QAAM,MAAM,KAAK,OAAO,MAAM,QAAQ;AACtC,QAAM,UAAU,IAAI,WAAU,EAAG,OAAO,IAAI;AAC5C,SAAO,EAAE,GAAG,OAAO,WAAW,IAAI,KAAK,QAAO;AAChD;AAEA,SAAS,aACP,KACA,SACA,IACA,MACA,GAAa;AAEb,MAAI,QAAO;AACX,UAAQ,QAAO;AACf,MAAI;AAAM,SAAK,QAAO;AACtB,IAAE,KAAK,CAAC;AACR,SAAO;AACT;AAWM,SAAU,OAAO,MAAa,UAAiB,MAAa,MAAe;AAC/E,QAAM,EAAE,GAAG,OAAO,IAAI,KAAK,QAAO,IAAK,WAAW,MAAM,UAAU,MAAM,IAAI;AAC5E,MAAI;AACJ,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,QAAM,OAAO,WAAW,GAAG;AAC3B,QAAM,IAAI,IAAI,WAAW,IAAI,SAAS;AAEtC,WAAS,KAAK,GAAG,MAAM,GAAG,MAAM,OAAO,MAAM,OAAO,IAAI,WAAW;AAEjE,UAAM,KAAK,GAAG,SAAS,KAAK,MAAM,IAAI,SAAS;AAC/C,SAAK,SAAS,GAAG,IAAI,KAAK;AAG1B,KAAC,OAAO,QAAQ,WAAW,IAAI,GAAG,OAAO,GAAG,EAAE,WAAW,CAAC;AAC1D,OAAG,IAAI,EAAE,SAAS,GAAG,GAAG,MAAM,CAAC;AAC/B,aAAS,KAAK,GAAG,KAAK,GAAG,MAAM;AAE7B,UAAI,WAAW,IAAI,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC;AAC3C,eAAS,IAAI,GAAG,IAAI,GAAG,QAAQ;AAAK,WAAG,CAAC,KAAK,EAAE,CAAC;IAClD;EACF;AACA,SAAO,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC;AAC/C;AAOA,eAAsB,YACpB,MACA,UACA,MACA,MAAe;AAEf,QAAM,EAAE,GAAG,OAAO,WAAW,IAAI,KAAK,QAAO,IAAK,WAAW,MAAM,UAAU,MAAM,IAAI;AACvF,MAAI;AACJ,QAAM,MAAM,IAAI,WAAW,CAAC;AAC5B,QAAM,OAAO,WAAW,GAAG;AAC3B,QAAM,IAAI,IAAI,WAAW,IAAI,SAAS;AAEtC,WAAS,KAAK,GAAG,MAAM,GAAG,MAAM,OAAO,MAAM,OAAO,IAAI,WAAW;AAEjE,UAAM,KAAK,GAAG,SAAS,KAAK,MAAM,IAAI,SAAS;AAC/C,SAAK,SAAS,GAAG,IAAI,KAAK;AAG1B,KAAC,OAAO,QAAQ,WAAW,IAAI,GAAG,OAAO,GAAG,EAAE,WAAW,CAAC;AAC1D,OAAG,IAAI,EAAE,SAAS,GAAG,GAAG,MAAM,CAAC;AAC/B,UAAM,UAAU,IAAI,GAAG,WAAW,MAAK;AAErC,UAAI,WAAW,IAAI,EAAE,OAAO,CAAC,EAAE,WAAW,CAAC;AAC3C,eAAS,IAAI,GAAG,IAAI,GAAG,QAAQ;AAAK,WAAG,CAAC,KAAK,EAAE,CAAC;IAClD,CAAC;EACH;AACA,SAAO,aAAa,KAAK,SAAS,IAAI,MAAM,CAAC;AAC/C;;;AC/GA,IAAM,UAA0B,IAAI,YAAY;EAC9C;EAAY;EAAY;EAAY;EAAY;CACjD;AAID,IAAM,SAAyB,IAAI,YAAY,EAAE;AAC3C,IAAO,OAAP,cAAoB,OAAY;EAOpC,cAAA;AACE,UAAM,IAAI,IAAI,GAAG,KAAK;AAPhB,SAAA,IAAI,QAAQ,CAAC,IAAI;AACjB,SAAA,IAAI,QAAQ,CAAC,IAAI;AACjB,SAAA,IAAI,QAAQ,CAAC,IAAI;AACjB,SAAA,IAAI,QAAQ,CAAC,IAAI;AACjB,SAAA,IAAI,QAAQ,CAAC,IAAI;EAIzB;EACU,MAAG;AACX,UAAM,EAAE,GAAG,GAAG,GAAG,GAAG,EAAC,IAAK;AAC1B,WAAO,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC;EACvB;EACU,IAAI,GAAW,GAAW,GAAW,GAAW,GAAS;AACjE,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;EACf;EACU,QAAQ,MAAgB,QAAc;AAC9C,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,UAAU;AAAG,aAAO,CAAC,IAAI,KAAK,UAAU,QAAQ,KAAK;AAClF,aAAS,IAAI,IAAI,IAAI,IAAI;AACvB,aAAO,CAAC,IAAI,KAAK,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,EAAE,IAAI,OAAO,IAAI,EAAE,GAAG,CAAC;AAErF,QAAI,EAAE,GAAG,GAAG,GAAG,GAAG,EAAC,IAAK;AACxB,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,UAAI,GAAG;AACP,UAAI,IAAI,IAAI;AACV,YAAI,IAAI,GAAG,GAAG,CAAC;AACf,YAAI;MACN,WAAW,IAAI,IAAI;AACjB,YAAI,IAAI,IAAI;AACZ,YAAI;MACN,WAAW,IAAI,IAAI;AACjB,YAAI,IAAI,GAAG,GAAG,CAAC;AACf,YAAI;MACN,OAAO;AACL,YAAI,IAAI,IAAI;AACZ,YAAI;MACN;AACA,YAAM,IAAK,KAAK,GAAG,CAAC,IAAI,IAAI,IAAI,IAAI,OAAO,CAAC,IAAK;AACjD,UAAI;AACJ,UAAI;AACJ,UAAI,KAAK,GAAG,EAAE;AACd,UAAI;AACJ,UAAI;IACN;AAEA,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;EACxB;EACU,aAAU;AAClB,WAAO,KAAK,CAAC;EACf;EACA,UAAO;AACL,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AACtB,SAAK,OAAO,KAAK,CAAC;EACpB;;AAIK,IAAM,OAA8B,gBAAgB,MAAM,IAAI,KAAI,CAAE;;;ACpE3E,IAAM,WAAW;EACf;EACA,YAAY;EACZ,YAAY;;AAMA,SAAPC,QAAyB,UAAkB,MAA2B,YAAoB,SAAiB,MAAY;AAC5H,MAAI,SAAS,UAAU,SAAS,cAAc,SAAS,YAAY;AACjE,UAAM,QAAQ,OAAO,KAAK,QAAQ,EAAE,KAAK,KAAK;AAC9C,UAAM,IAAI,uBAAuB,SAAS,IAAI,0CAA0C,KAAK,EAAE;EACjG;AAEA,QAAM,SAAS,SAAS,IAAI;AAC5B,QAAM,MAAM,OACV,QACA,UACA,MAAM;IACJ,GAAG;IACH,OAAO;GACR;AAGH,SAAO,OAAO,OAAO,GAAG,EAAE,UAAU,CAAC;AACvC;;;ACtCA,qCAAgB;AAMhB,IAAM,cAAc,KAAK,MAAM,KAAK;;;ACJ7B,IAAM,uBAAuB;AAE9B,IAAO,cAAP,MAAkB;EAKtB,YAAa,KAAiB,MAAY,MAAc,kBAA0B,GAAC;AAJlE;AACA;AACA;AAGf,QAAI,kBAAkB,sBAAsB;AAC1C,YAAM,IAAI,UAAU,0BAA0B;IAChD;AAEA,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI;AAChC,UAAM,KAAK,MAAgB,eAAe;AAE1C,aAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK;AAClC,SAAG,CAAC,IAAI,IAAI,CAAC;IACf;AAEA,QAAI,GAAG,WAAW,GAAG;AACnB,SAAG,CAAC,IAAI;IACV;AAEA,SAAK,KAAK;AACV,SAAK,IAAI;AACT,SAAK,OAAO;EACd;EAEA,OAAI;AACF,WAAO,KAAK,EAAE,KAAK,KAAK,IAAI,KAAK,IAAI;EACvC;EAEA,OAAQ,OAAW;AACjB,QAAI,GAAE,+BAAO,eAAc,aAAa;AACtC,aAAO;IACT;AAEA,WAAO,OAAiB,KAAK,IAAI,MAAM,EAAE;EAC3C;;;;AC1CI,SAAU,aAAc,KAAa,KAAW;AACpD,SAAO,KAAK,MAAM,KAAK,OAAM,KAAM,MAAM,IAAI,IAAI;AACnD;;;ACCM,IAAO,SAAP,MAAa;EAGjB,YAAa,MAAY;AAFR;AAGf,SAAK,WAAW,IAAI,MAAM,IAAI,EAAE,KAAK,IAAI;EAC3C;EAEA,IAAK,aAAwB;AAC3B,QAAI,EAAE,uBAAuB,cAAc;AACzC,YAAM,IAAI,UAAU,qBAAqB;IAC3C;AAEA,WAAO,KAAK,SAAS,KAAK,CAAC,OAAM;AAC/B,aAAO,YAAY,OAAO,EAAE;IAC9B,CAAC;EACH;EAEA,IAAK,aAAwB;AAC3B,QAAI,EAAE,uBAAuB,cAAc;AACzC,YAAM,IAAI,UAAU,qBAAqB;IAC3C;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AAC7C,UAAI,KAAK,SAAS,CAAC,KAAK,MAAM;AAC5B,aAAK,SAAS,CAAC,IAAI;AACnB,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,KAAM,aAAwB;AAC5B,QAAI,EAAE,uBAAuB,cAAc;AACzC,YAAM,IAAI,UAAU,qBAAqB;IAC3C;AAEA,UAAM,IAAI,aAAa,GAAG,KAAK,SAAS,SAAS,CAAC;AAClD,UAAM,UAAU,KAAK,SAAS,CAAC;AAC/B,SAAK,SAAS,CAAC,IAAI;AAEnB,WAAO;EACT;EAEA,OAAQ,aAAwB;AAC9B,QAAI,EAAE,uBAAuB,cAAc;AACzC,YAAM,IAAI,UAAU,qBAAqB;IAC3C;AAEA,UAAM,QAAQ,KAAK,SAAS,UAAU,CAAC,OAAM;AAC3C,aAAO,YAAY,OAAO,EAAE;IAC9B,CAAC;AAED,QAAI,QAAQ,IAAI;AACd,WAAK,SAAS,KAAK,IAAI;AACvB,aAAO;IACT,OAAO;AACL,aAAO;IACT;EACF;;;;AC3DF,IAAM,aAAa;AAAA,EAClB,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AACP;AAEA,IAAM,cAAc;AAAA,EACnB,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AACP;AAEA,IAAM,gBAAgB,IAAI,WAAW,YAAY;AAEjD,SAAS,gBAAgB,YAAY,MAAM;AAC1C,QAAM,WAAW,WAAW,IAAI;AAChC,MAAI,OAAO,YAAY,IAAI;AAG3B,WAAS,QAAQ,GAAG,QAAQ,WAAW,QAAQ,SAAS;AACvD,YAAQ,OAAO,WAAW,KAAK,CAAC;AAChC,WAAO,OAAO,QAAQ,MAAM,OAAO,QAAQ;AAAA,EAC5C;AAEA,SAAO;AACR;AAEA,SAAS,gBAAgB,QAAQ,MAAM,YAAY;AAClD,MAAI,WAAW,WAAW,GAAG;AAC5B,UAAM,IAAI,MAAM,8DAA8D;AAAA,EAC/E;AAEA,QAAM,WAAW,WAAW,IAAI;AAChC,MAAI,OAAO,YAAY,IAAI;AAC3B,MAAI,YAAY;AAEhB,SAAO,UAAU,SAAS,GAAG;AAC5B,UAAM,SAAS,cAAc,WAAW,WAAW,UAAU;AAC7D,gBAAY,UAAU,MAAM,OAAO,IAAI;AACvC,aAAS,QAAQ,GAAG,QAAQ,OAAO,SAAS,SAAS;AACpD,cAAQ,OAAO,WAAW,KAAK,CAAC;AAChC,aAAO,OAAO,QAAQ,MAAM,OAAO,QAAQ;AAAA,IAC5C;AAAA,EACD;AAEA,SAAO;AACR;AAEe,SAAR,MAAuB,OAAO,EAAC,OAAO,IAAI,WAAU,IAAI,CAAC,GAAG;AAClE,MAAI,CAAC,WAAW,IAAI,GAAG;AACtB,UAAM,IAAI,MAAM,iEAAiE;AAAA,EAClF;AAEA,MAAI,OAAO,UAAU,UAAU;AAC9B,QAAI,YAAY;AACf,aAAO,gBAAgB,OAAO,MAAM,UAAU;AAAA,IAC/C;AAEA,YAAQ,cAAc,OAAO,KAAK;AAAA,EACnC;AAEA,SAAO,gBAAgB,OAAO,IAAI;AACnC;;;ACtEA,IAAAC,kCAAgB;AAiBT,IAAMC,SAAc;EACzB,MAAM,CAAC,UAAS;AACd,WAAO,OAAO,MAAU,OAAO;MAC7B,MAAM;KACP,CAAC;EACJ;EACA,OAAO,CAAC,OAAO,SAAQ;AACrB,WAAO,eAAeA,OAAM,KAAK,OAAO,IAAI,CAAC;EAC/C;;AAGI,SAAU,eAAgB,KAAoB;AAClD,MAAI,MAAM,IAAI,SAAS,EAAE;AAEzB,MAAI,IAAI,SAAS,MAAM,GAAG;AACxB,UAAM,IAAI,GAAG;EACf;AAEA,SAAO,WAAqB,KAAK,QAAQ;AAC3C;;;AC9BA,IAAM,iBAAiB;AA6BjB,IAAO,eAAP,MAAmB;EASvB,YAAa,MAAsB;AARlB;AACA;AACA;AACA;AACV;AACU;AACA;AAGf,SAAK,aAAa,KAAK;AACvB,SAAK,aAAa,KAAK,cAAc;AACrC,SAAK,kBAAkB,KAAK,mBAAmB;AAC/C,SAAK,QAAQ;AACb,SAAK,UAAU,CAAA;AACf,SAAK,OAAO,KAAK,QAAQC;AACzB,SAAK,OAAO,KAAK,QAAQ,aAAa,GAAG,KAAK,IAAI,GAAG,EAAE,CAAC;EAC1D;EAEA,IAAK,MAAyB;AAC5B,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,UAAM,cAAc,IAAI,YAAY,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,eAAe;AACpF,UAAM,IAAI,KAAK,KAAK,KAAK,MAAM,KAAK,IAAI,IAAI,KAAK;AACjD,UAAM,KAAK,IAAI,YAAY,KAAI,KAAM,KAAK;AAE1C,QAAI,KAAK,QAAQ,CAAC,KAAK,MAAM;AAC3B,WAAK,QAAQ,CAAC,IAAI,IAAI,OAAO,KAAK,UAAU;IAC9C;AAEA,QAAI,KAAK,QAAQ,CAAC,KAAK,MAAM;AAC3B,WAAK,QAAQ,CAAC,IAAI,IAAI,OAAO,KAAK,UAAU;IAC9C;AAEA,QAAI,KAAK,QAAQ,CAAC,EAAE,IAAI,WAAW,KAAK,KAAK,QAAQ,CAAC,EAAE,IAAI,WAAW,GAAG;AACxE,WAAK;AACL,aAAO;IACT;AAEA,UAAM,OAAO,CAAC,GAAG,CAAC;AAClB,QAAI,IAAI,KAAK,aAAa,GAAG,KAAK,SAAS,CAAC,CAAC;AAE7C,QAAI,KAAK,QAAQ,CAAC,KAAK,MAAM;AAC3B,WAAK,QAAQ,CAAC,IAAI,IAAI,OAAO,KAAK,UAAU;IAC9C;AAEA,aAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK;AACvC,YAAM,UAAU,KAAK,QAAQ,CAAC,EAAE,KAAK,WAAW;AAEhD,UAAI,WAAW,MAAM;AACnB;MACF;AAEA,WAAK,IAAI,QAAQ,KAAI,KAAM,KAAK;AAEhC,UAAI,KAAK,QAAQ,CAAC,KAAK,MAAM;AAC3B,aAAK,QAAQ,CAAC,IAAI,IAAI,OAAO,KAAK,UAAU;MAC9C;AAEA,UAAI,KAAK,QAAQ,CAAC,EAAE,IAAI,OAAO,GAAG;AAChC,aAAK;AAEL,eAAO;MACT,OAAO;AACL;MACF;IACF;AAEA,WAAO;EACT;EAEA,IAAK,MAAyB;AA7GhC,QAAAC,MAAAC;AA8GI,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,UAAM,cAAc,IAAI,YAAY,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,eAAe;AACpF,UAAM,IAAI,KAAK,KAAK,KAAK,MAAM,KAAK,IAAI,IAAI,KAAK;AACjD,UAAM,QAAMD,OAAA,KAAK,QAAQ,CAAC,MAAd,gBAAAA,KAAiB,IAAI,iBAAgB;AAEjD,QAAI,KAAK;AACP,aAAO;IACT;AAEA,UAAM,KAAK,IAAI,YAAY,KAAI,KAAM,KAAK;AAE1C,aAAOC,MAAA,KAAK,QAAQ,CAAC,MAAd,gBAAAA,IAAiB,IAAI,iBAAgB;EAC9C;EAEA,OAAQ,MAAyB;AA/HnC,QAAAD,MAAAC;AAgII,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,UAAM,cAAc,IAAI,YAAY,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,eAAe;AACpF,UAAM,IAAI,KAAK,KAAK,KAAK,MAAM,KAAK,IAAI,IAAI,KAAK;AACjD,UAAM,QAAMD,OAAA,KAAK,QAAQ,CAAC,MAAd,gBAAAA,KAAiB,OAAO,iBAAgB;AAEpD,QAAI,KAAK;AACP,WAAK;AACL,aAAO;IACT;AAEA,UAAM,KAAK,IAAI,YAAY,KAAI,KAAM,KAAK;AAC1C,UAAM,QAAMC,MAAA,KAAK,QAAQ,CAAC,MAAd,gBAAAA,IAAiB,OAAO,iBAAgB;AAEpD,QAAI,KAAK;AACP,WAAK;IACP;AAEA,WAAO;EACT;EAEA,IAAI,WAAQ;AACV,WAAO,KAAK,MAAM,OAAO,KAAK,QAAQ,KAAK,WAAW,KAAK;EAC7D;;AAIF,IAAM,WAAW;EACf,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;;AAGL,SAAS,oBAAqB,YAAoB,MAAK;AACrD,MAAI,YAAY,MAAO;AACrB,WAAO;EACT;AAEA,MAAI,YAAY,MAAS;AACvB,WAAO;EACT;AAEA,SAAO;AACT;AAEM,SAAU,SAAU,UAAkB,YAAoB,MAAK;AAGnE,QAAM,aAAa,oBAAoB,SAAS;AAChD,QAAM,OAAO,SAAS,UAAU;AAGhC,QAAM,aAAa,KAAK,MAAM,WAAW,IAAI;AAC7C,QAAM,kBAAkB,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,IAAI,SAAS,IAAI,KAAK,KAAK,IAAI,UAAU,CAAC,GAAG,oBAAoB;AAEtH,SAAO;IACL;IACA;IACA;;AAEJ;;;AClLM,IAAO,uBAAP,MAA2B;EAS/B,YAAa,MAA8B;AAR1B;AACA;AACA;AACA;AACA;AACA;AACA;AAGf,SAAK,aAAa,KAAK,cAAc;AACrC,SAAK,aAAa,KAAK,eAAe,KAAK,MAAM,KAAK;AACtD,SAAK,kBAAkB,KAAK,mBAAmB;AAC/C,SAAK,QAAQ,KAAK,SAAS;AAC3B,SAAK,OAAO,KAAK,QAAQC;AACzB,SAAK,OAAO,KAAK,QAAQ,aAAa,GAAG,KAAK,IAAI,GAAG,EAAE,CAAC;AACxD,SAAK,eAAe;MAClB,IAAI,aAAa;QACf,YAAY,KAAK;QACjB,YAAY,KAAK;QACjB,iBAAiB,KAAK;QACtB,MAAM,KAAK;QACX,MAAM,KAAK;OACZ;;EAEL;EAEA,IAAK,MAAyB;AAC5B,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,QAAI,KAAK,IAAI,IAAI,GAAG;AAClB,aAAO;IACT;AAEA,QAAI,UAAU,KAAK,aAAa,KAAK,CAAC,WAAU;AAC9C,aAAO,OAAO;IAChB,CAAC;AAED,QAAI,WAAW,MAAM;AACnB,YAAM,UAAU,KAAK,aAAa,KAAK,IAAI,KAAK,OAAO,KAAK,aAAa,MAAM;AAE/E,gBAAU,IAAI,aAAa;QACzB,YAAY;QACZ,YAAY,KAAK;QACjB,iBAAiB,KAAK;QACtB,MAAM,KAAK;QACX,MAAM,KAAK;OACZ;AAED,WAAK,aAAa,KAAK,OAAO;IAChC;AAEA,WAAO,QAAQ,IAAI,IAAI;EACzB;EAEA,IAAK,MAAyB;AAC5B,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAAK;AACjD,UAAI,KAAK,aAAa,CAAC,EAAE,IAAI,IAAI,GAAG;AAClC,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,OAAQ,MAAyB;AAC/B,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,WAAqB,IAAI;IAClC;AAEA,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAAK;AACjD,UAAI,KAAK,aAAa,CAAC,EAAE,OAAO,IAAI,GAAG;AACrC,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,IAAI,QAAK;AACP,WAAO,KAAK,aAAa,OAAO,CAAC,KAAK,SAAQ;AAC5C,aAAO,MAAM,KAAK;IACpB,GAAG,CAAC;EACN;;AAGI,SAAU,2BAA4B,UAAkB,YAAoB,MAAO,SAAmE;AAC1J,SAAO,IAAI,qBAAqB;IAC9B,GAAG,SAAS,UAAU,SAAS;IAC/B,GAAI,WAAW,CAAA;GAChB;AACH;;;ACtGM,IAAO,aAAP,MAAiB;EAGrB,YAAa,MAAc,WAAkB;AAF5B;AAGf,SAAK,SAAS,2BAA2B,MAAM,SAAS;EAC1D;EAEA,IAAK,QAAc;AACjB,WAAO,KAAK,OAAO,IAAI,OAAO,YAAW,EAAG,KAAK;EACnD;EAEA,IAAK,QAAc;AACjB,SAAK,OAAO,IAAI,OAAO,YAAW,EAAG,KAAK;EAC5C;EAEA,OAAQ,QAAc;AAvBxB,QAAAC,MAAAC;AAwBI,KAAAA,OAAAD,OAAA,KAAK,QAAO,WAAZ,gBAAAC,IAAA,KAAAD,MAAqB,OAAO,YAAW,EAAG;EAC5C;;AASI,SAAU,WAAY,MAAc,YAAoB,MAAK;AACjE,SAAO,IAAI,WAAW,MAAM,SAAS;AACvC;;;AC5BA,IAAM,iBAAN,cAAgC,QAAU;EAGxC,YAAa,MAAkC;AAC7C,UAAK;AAHU;AAKf,UAAM,EAAE,MAAAE,OAAM,QAAO,IAAK;AAE1B,SAAK,SAAS,QAAQ,eAAeA,KAAI;AACzC,SAAK,sBAAqB;EAC5B;EAEA,IAAK,KAAa,OAAQ;AACxB,UAAM,IAAI,KAAK,KAAK;AACpB,SAAK,sBAAqB;AAC1B,WAAO;EACT;EAEA,OAAQ,KAAW;AACjB,UAAM,UAAU,MAAM,OAAO,GAAG;AAChC,SAAK,sBAAqB;AAC1B,WAAO;EACT;EAEA,QAAK;AACH,UAAM,MAAK;AACX,SAAK,sBAAqB;EAC5B;EAEQ,wBAAqB;AAC3B,SAAK,OAAO,OAAO,KAAK,IAAI;EAC9B;;AAkBI,SAAU,eAAoB,QAA0B;AAC5D,QAAM,EAAE,MAAAA,OAAM,QAAO,IAAK;AAC1B,MAAI;AAEJ,MAAI,WAAW,MAAM;AACnB,UAAM,IAAI,eAAkB,EAAE,MAAAA,OAAM,QAAO,CAAE;EAC/C,OAAO;AACL,UAAM,IAAI,QAAO;EACnB;AAEA,SAAO;AACT;;;ACnDM,IAAW;CAAjB,SAAiBC,WAAQ;AACvB,MAAI;AAES,EAAAA,UAAA,QAAQ,MAAsB;AACzC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAkB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC/C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAK,IAAI,eAAe,QAAQ,IAAI,YAAY,aAAa,GAAI;AAC/D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,WAAW;QACzB;AAEA,YAAK,IAAI,WAAW,QAAQ,IAAI,QAAQ,aAAa,GAAI;AACvD,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,OAAO;QACrB;AAEA,YAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,cAAM,MAAW;UACf,WAAW,MAAgB,CAAC;UAC5B,aAAa,MAAgB,CAAC;UAC9B,SAAS,MAAgB,CAAC;UAC1B,WAAW,MAAgB,CAAC;;AAG9B,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,cAAc,OAAO,MAAK;AAC9B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,UAAU,OAAO,MAAK;AAC1B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAA,UAAA,SAAS,CAAC,QAAsC;AAC3D,WAAO,cAAc,KAAKA,UAAS,MAAK,CAAE;EAC5C;AAEa,EAAAA,UAAA,SAAS,CAAC,KAAkC,SAA4C;AACnG,WAAO,cAAc,KAAKA,UAAS,MAAK,GAAI,IAAI;EAClD;AACF,GApFiB,aAAA,WAAQ,CAAA,EAAA;;;ACdnB,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaC,WAAU,qBAAmB;AACxC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;;;ACSI,IAAO,kBAAP,MAAO,gBAAc;;;;;EAgEzB,YAAa,MAAwB;AAV9B;AACA;AACA;AACA;AACA;AAOL,UAAM,EAAE,WAAW,aAAa,SAAS,UAAS,IAAK;AAEvD,SAAK,YAAY;AACjB,SAAK,cAAc;AACnB,SAAK,UAAU;AACf,SAAK,YAAY;EACnB;;;;EAKA,UAAO;AACL,QAAI,KAAK,aAAa,MAAM;AAC1B,WAAK,YAAY,SAAS,OAAO;QAC/B,WAAW,oBAAoB,KAAK,SAAS;QAC7C,aAAa,KAAK;QAClB,SAAS,KAAK,QAAQ,SAAQ;QAC9B,WAAW,KAAK;OACjB;IACH;AAEA,WAAO,KAAK;EACd;;;;EAKA,OAAQ,OAAe;AACrB,WAAO,OAAiB,KAAK,QAAO,GAAI,MAAM,QAAO,CAAE;EACzD;;;;EAKA,MAAM,SAAU,QAAc;AAC5B,UAAM,WAAW,uBAAuB,QAAQ,KAAK,aAAa,KAAK,OAAO;AAE9E,WAAO,KAAK,UAAU,OAAO,SAAS,SAAQ,GAAI,KAAK,SAAS;EAClE;;;;;AAnGA,cAJW,iBAIJ,sBAAqB,OAAO,SAA8D;AAC/F,QAAM,eAAe,SAAS,OAAO,IAAI;AACzC,QAAM,YAAY,sBAAsB,aAAa,SAAS;AAE9D,SAAO,IAAI,gBAAe;IACxB;IACA,aAAa,aAAa;IAC1B,SAAS,aAAa;IACtB,WAAW,aAAa;GACzB;AACH;;;;;AAMA,cApBW,iBAoBJ,QAAO,OAAO,QAAgB,eAAmD;AACtF,MAAI,cAAc,MAAM;AACtB,UAAM,IAAI,MAAM,qBAAqB;EACvC;AAEA,QAAM,SAAS,OAAO;AACtB,QAAM,cAAc,OAAO;AAC3B,QAAM,UAAU,OAAO,QAAO;AAC9B,QAAM,WAAW,uBAAuB,QAAQ,aAAa,OAAO;AACpE,QAAM,YAAY,MAAM,WAAW,KAAK,SAAS,SAAQ,CAAE;AAE3D,SAAO,IAAI,gBAAe;IACxB,WAAW,WAAW;IACtB;IACA;IACA;GACD;AACH;;;;;AAMA,cA3CW,iBA2CJ,kBAAiB,OAAO,MAAmC,WAA2C;AAC3G,QAAM,WAAW,MAAM,gBAAe,mBAAmB,IAAI;AAC7D,QAAM,QAAQ,MAAM,SAAS,SAAS,MAAM;AAE5C,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,sBAAsB,sDAAsD;EACxF;AAEA,SAAO;AACT;AApDI,IAAO,iBAAP;AA6GN,IAAM,yBAAyB,CAAC,QAAgB,aAAyB,YAAwD;AAS/H,QAAM,mBAAmB,WAAsB,MAAM;AACrD,QAAM,eAAsB,OAAO,iBAAiB,UAAU;AAC9D,QAAM,oBAA2B,OAAO,YAAY,MAAM;AAC1D,QAAM,gBAAuB,OAAO,QAAQ,MAAM;AAElD,SAAO,IAAI,eACT,cACA,kBACA,mBACA,aACA,eACA,OAAO;AAEX;;;AC5HM,SAAU,YAAa,GAAU,GAAQ;AAC7C,QAAMC,QAAO,CAACC,IAAQC,OAAmBD,GAAE,SAAQ,EAAG,cAAcC,GAAE,SAAQ,CAAE;AAEhF,MAAI,EAAE,WAAW,EAAE,QAAQ;AACzB,WAAO;EACT;AAEA,IAAE,KAAKF,KAAI;AAEX,SAAO,EAAE,KAAKA,KAAI,EAAE,MAAM,CAAC,MAAM,UAAU,EAAE,KAAK,EAAE,OAAO,IAAI,CAAC;AAClE;;;AChCO,IAAM,8BAA8B;AAKpC,IAAM,oCAAoC,WAAW,KAAK,CAAC,GAAG,CAAC,CAAC;;;ACUjE,IAAW;CAAjB,SAAiBG,aAAU;AAKzB,MAAiB;AAAjB,GAAA,SAAiBC,cAAW;AAC1B,QAAIC;AAES,IAAAD,aAAA,QAAQ,MAAyB;AAC5C,UAAIC,WAAU,MAAM;AAClB,QAAAA,UAAS,QAAqB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAClD,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,KAAI;UACR;AAEA,cAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,cAAE,OAAO,EAAE;AACX,cAAE,MAAM,IAAI,SAAS;UACvB;AAEA,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,OAAM;UACV;QACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,gBAAM,MAAW;YACf,WAAW,MAAgB,CAAC;;AAG9B,gBAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,iBAAO,OAAO,MAAM,KAAK;AACvB,kBAAM,MAAM,OAAO,OAAM;AAEzB,oBAAQ,QAAQ,GAAG;cACjB,KAAK,GAAG;AACN,oBAAI,YAAY,OAAO,MAAK;AAC5B;cACF;cACA,SAAS;AACP,uBAAO,SAAS,MAAM,CAAC;AACvB;cACF;YACF;UACF;AAEA,iBAAO;QACT,CAAC;MACH;AAEA,aAAOA;IACT;AAEa,IAAAD,aAAA,SAAS,CAAC,QAAyC;AAC9D,aAAO,cAAc,KAAKA,aAAY,MAAK,CAAE;IAC/C;AAEa,IAAAA,aAAA,SAAS,CAAC,KAAkC,SAAkD;AACzG,aAAO,cAAc,KAAKA,aAAY,MAAK,GAAI,IAAI;IACrD;EACF,GAtDiB,cAAAD,YAAA,gBAAAA,YAAA,cAAW,CAAA,EAAA;AAwD5B,MAAI;AAES,EAAAA,YAAA,QAAQ,MAAwB;AAC3C,QAAI,UAAU,MAAM;AAClB,eAAS,QAAoB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AACjD,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,UAAU,QAAQ,IAAI,OAAO,aAAa,GAAI;AACrD,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,MAAM;QACpB;AAEA,YAAK,IAAI,OAAO,QAAQ,IAAI,QAAQ,IAAK;AACvC,YAAE,OAAO,EAAE;AACX,YAAE,OAAO,IAAI,GAAG;QAClB;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,qBAAW,SAAS,IAAI,WAAW;AACjC,cAAE,OAAO,EAAE;AACX,YAAAA,YAAW,YAAY,MAAK,EAAG,OAAO,OAAO,CAAC;UAChD;QACF;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AA1GvC,YAAAG,MAAAC;AA2GQ,cAAM,MAAW;UACf,QAAQ,MAAgB,CAAC;UACzB,KAAK;UACL,WAAW,CAAA;;AAGb,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,SAAS,OAAO,MAAK;AACzB;YACF;YACA,KAAK,GAAG;AACN,kBAAI,MAAM,OAAO,OAAM;AACvB;YACF;YACA,KAAK,GAAG;AACN,oBAAID,OAAA,KAAK,WAAL,gBAAAA,KAAa,cAAa,QAAQ,IAAI,UAAU,WAAW,KAAK,OAAO,WAAW;AACpF,sBAAM,IAAI,eAAe,4DAA4D;cACvF;AAEA,kBAAI,UAAU,KAAKH,YAAW,YAAY,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,GAAI;gBAChF,SAAQI,MAAA,KAAK,WAAL,gBAAAA,IAAa;eACtB,CAAC;AACF;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAJ,YAAA,SAAS,CAAC,QAAwC;AAC7D,WAAO,cAAc,KAAKA,YAAW,MAAK,CAAE;EAC9C;AAEa,EAAAA,YAAA,SAAS,CAAC,KAAkC,SAAgD;AACvG,WAAO,cAAc,KAAKA,YAAW,MAAK,GAAI,IAAI;EACpD;AACF,GA9IiB,eAAA,aAAU,CAAA,EAAA;;;ACerB,IAAO,cAAP,MAAO,YAAU;EAuBrB,YAAa,MAAoB;AAP1B;AACA;AACA;AACA,kCAAS,YAAW;AACpB,iCAAQ,YAAW;AAClB;AAGN,UAAM,EAAE,QAAQ,YAAY,UAAS,IAAK;AAE1C,SAAK,SAAS;AACd,SAAK,aAAa,cAAc,CAAA;AAChC,SAAK,YAAY,aAAa,OAAO,KAAK,IAAG,CAAE;EACjD;;;;EAKA,UAAO;AACL,QAAI,KAAK,aAAa,MAAM;AAC1B,WAAK,YAAY,WAAS,OAAO;QAC/B,QAAQ,KAAK,OAAO,YAAW,EAAG;QAClC,KAAK,OAAO,KAAK,SAAS;QAC1B,WAAW,KAAK,WAAW,IAAI,CAAC,OAAO;UACrC,WAAW,EAAE;UACb;OACH;IACH;AAEA,WAAO,KAAK;EACd;;;;EAKA,OAAQ,OAAc;AACpB,QAAI,EAAE,iBAAiB,cAAa;AAClC,aAAO;IACT;AAGA,QAAI,CAAC,KAAK,OAAO,OAAO,MAAM,MAAM,GAAG;AACrC,aAAO;IACT;AAGA,QAAI,KAAK,cAAc,MAAM,WAAW;AACtC,aAAO;IACT;AAGA,QAAI,CAAC,YAAY,KAAK,YAAY,MAAM,UAAU,GAAG;AACnD,aAAO;IACT;AAEA,WAAO;EACT;;;;;AApEA,cAJW,aAIJ,sBAAqB,CAAC,QAAgD;AAC3E,QAAM,aAAa,WAAS,OAAO,GAAG;AACtC,QAAM,SAAS,oBAA2B,OAAO,WAAW,MAAM,CAAC;AACnE,QAAM,cAAc,WAAW,aAAa,CAAA,GAAI,IAAI,CAAC,MAAM,UAAU,EAAE,SAAS,CAAC;AACjF,QAAM,YAAY,WAAW;AAE7B,SAAO,IAAI,YAAW,EAAE,QAAQ,YAAY,UAAS,CAAE;AACzD;AAEA,cAbW,aAaJ,UAAS;AAChB,cAdW,aAcJ,SAAQ;AAdX,IAAOK,cAAP;;;AC3BN,IAAM,SAAmD,CAAA;AAEzD,IAAM,aAAa,CAAC,WAAmC;AACrD,SAAO,iBAAiB,WAAW,CAAC,UAAS;AAC3C,eAAW,cAAc,WAAW,QAAQ,KAAK;EACnD,CAAC;AAED,MAAI,OAAO,QAAQ,MAAM;AACvB,WAAO,KAAK,iBAAiB,WAAW,CAAC,UAAc;AACrD,iBAAW,cAAc,WAAW,QAAQ,KAAK;IACnD,CAAC;;AAEL;AAEA,WAAW,mBAAmB,CAAC,MAAc,OAA8B;AACzE,MAAI,OAAO,IAAI,KAAK,MAAM;AACxB,WAAO,IAAI,IAAI,CAAA;;AAGjB,SAAO,IAAI,EAAE,KAAK,EAAE;AACtB;AAEA,WAAW,sBAAsB,CAAC,MAAc,OAA8B;AAC5E,MAAI,OAAO,IAAI,KAAK,MAAM;AACxB;;AAGF,SAAO,IAAI,IAAI,OAAO,IAAI,EACvB,OAAO,cAAY,aAAa,EAAE;AACvC;AAEA,WAAW,gBAAgB,SAAU,MAAc,QAAgB,OAAwB;AACzF,MAAI,OAAO,IAAI,KAAK,MAAM;AACxB;;AAGF,SAAO,IAAI,EAAE,QAAQ,QAAM,GAAG,QAAQ,KAAK,CAAC;AAC9C;AAEA,IAAAC,eAAe;;;AC3CR,IAAM,2BAA2B;AACjC,IAAM,2BAA2B;AACjC,IAAM,yBAAyB;AAE/B,IAAM,4BAA4B;AAClC,IAAM,4BAA4B;AAClC,IAAM,0BAA0B;;;ACNhC,IAAM,SAAS,CAAC,OAAe,OAAc;AAClD,SAAO,KAAK,OAAM,EAAG,SAAQ,EAAG,UAAU,CAAC;AAC7C;;;ACUA,IAAM,0BAA0B,CAAC,SAAsB,aAAqB,aAAqB,aAAqB,cAAqB;AACzI,SAAO,CAAC,QAAgB,UAAuB;AAC7C,QAAI,MAAM,KAAK,SAAS,aAAa;AACnC;IACF;AAEA,UAAM,eAAe;MACnB,MAAM,MAAM,KAAK;MACjB,MAAM,MAAM,KAAK;MACjB,YAAY,MAAM,KAAK;;AAGzB,YAAQ,cAAc,IAAI,aAAa,aAAa;MAClD,MAAM;QACJ,MAAM,aAAa;QACnB,SAAS,YAA0B;AAEjC,iBAAO,YAAY;YACjB,MAAM;YACN,MAAM,aAAa;YACnB,YAAY,aAAa;WAC1B;AAGD,gBAAM,IAAI,QAAc,CAAC,YAAW;AAClC,kBAAM,uBAAuB,CAACC,WAA6B;AACzD,mBAAIA,UAAA,gBAAAA,OAAO,SAAQ,MAAM;AACvB;cACF;AAEA,oBAAM,eAAe;gBACnB,MAAMA,OAAM,KAAK;gBACjB,MAAMA,OAAM,KAAK;gBACjB,YAAYA,OAAM,KAAK;;AAGzB,kBAAI,aAAa,SAAS,eAAe,aAAa,eAAe,aAAa,YAAY;AAC5F,uBAAO,oBAAoB,WAAW,oBAAoB;AAC1D,wBAAO;cACT;YACF;AAEA,mBAAO,iBAAiB,WAAW,oBAAoB;UACzD,CAAC;QACH;;KAEH,CAAC;EACJ;AACF;AAEA,IAAM,wBAAwB,CAACC,OAAc,aAAqB,WAAmB,gBAAuB;AAC1G,SAAO,YAAW;AAChB,UAAM,KAAK,OAAM;AAEjB,eAAW,YAAY;MACrB,MAAM;MACN,YAAY;MACZ,MAAAA;KACD;AAED,WAAO,IAAI,QAAiB,CAAC,YAAW;AACtC,YAAM,WAAW,CAAC,UAA6B;AAC7C,aAAI,+BAAO,SAAQ,MAAM;AACvB;QACF;AAEA,cAAM,gBAAgB;UACpB,MAAM,MAAM,KAAK;UACjB,YAAY,MAAM,KAAK;;AAGzB,YAAI,cAAc,SAAS,aAAa,cAAc,eAAe,IAAI;AACvE,qBAAW,oBAAoB,WAAW,QAAQ;AAGlD,kBAAQ,MAAK;AAEX,uBAAW,YAAY;cACrB,MAAM;cACN,YAAY;cACZ,MAAAA;aACD;UACH,CAAC;QACH;MACF;AAEA,iBAAW,iBAAiB,WAAW,QAAQ;IACjD,CAAC;EACH;AACF;AAEA,IAAM,iBAAiB;EACrB,eAAe;;AAGjB,IAAA,kBAAe,CAAC,YAA0E;AACxF,YAAU,OAAO,OAAO,CAAA,GAAI,gBAAgB,OAAO;AACnD,QAAM,YAAY,QAAQ,WAAW,QAAQ,KAAK,QAAQ;AAE1D,MAAI,WAAW;AACb,UAAM,UAAU,IAAI,YAAW;AAE/B,IAAAC,aAAS,iBAAiB,WAAW,wBAAwB,SAAS,mBAAmB,0BAA0B,0BAA0B,sBAAsB,CAAC;AACpK,IAAAA,aAAS,iBAAiB,WAAW,wBAAwB,SAAS,oBAAoB,2BAA2B,2BAA2B,uBAAuB,CAAC;AAExK,WAAO;EACT;AAEA,SAAO;IACL,UAAU;IACV,UAAU,CAACD,UAAS,sBAAsBA,OAAM,0BAA0B,wBAAwB,wBAAwB;IAC1H,WAAW,CAACA,UAAS,sBAAsBA,OAAM,2BAA2B,yBAAyB,yBAAyB;;AAElI;;;ACYA,IAAM,UAAmC,CAAA;AACzC,IAAI;AAEJ,eAAe,kBAAmB,OAAe,SAAiC;AAChF,MAAI;AAEJ,QAAM,IAAI,IAAI,QAAiB,CAAC,YAAW;AACzC,UAAM;EACR,CAAC;AAED,OAAK,MAAM,IAAI,YAAY,UAAU,YAAW;AAC9C,UAAM,IAAI,QAAc,CAAC,YAAW;AAClC,UAAI,MAAK;AACP,gBAAO;MACT,CAAC;IACH,CAAC;EACH,GAAE,GAAI;IACJ,cAAc,QAAQ;GACvB,CAAC;AAEF,SAAO;AACT;AAEA,IAAM,cAAc,CAACE,OAAc,YAA8C;AAC/E,MAAI,eAAe,aAAa,MAAM;AACpC,WAAO;MACL,UAAU,eAAe,SAASA,OAAM,OAAO;MAC/C,WAAW,eAAe,UAAUA,OAAM,OAAO;;EAErD;AAEA,QAAM,cAAc,IAAI,OAAO,EAAE,aAAa,EAAC,CAAE;AACjD,MAAI;AAEJ,SAAO;IACL,MAAM,WAAQ;AAEZ,UAAI,aAAa,MAAM;AACrB,eAAO,kBAAkB,WAAW,OAAO;MAC7C;AAGA,kBAAY,IAAI,OAAO;QACrB,aAAa,QAAQ;QACrB,WAAW;OACZ;AACD,YAAM,iBAAiB;AAGvB,YAAM,cAAc,kBAAkB,WAAW,OAAO;AAExD,WAAK,YAAY,IAAI,YAAW;AAG9B,uBAAe,MAAK;AAKpB,cAAM,eAAe,OAAM,EACxB,KAAK,MAAK;AACT,cAAI,cAAc,gBAAgB;AAChC,wBAAY;UACd;QACF,CAAC;MACL,CAAC;AAED,aAAO;IACT;IACA,MAAM,YAAS;AAIb,kBAAY;AAEZ,aAAO,kBAAkB,aAAa,OAAO;IAC/C;;AAEJ;AAEA,IAAMC,kBAAiB;EACrB,MAAM;EACN,aAAa;EACb,SAAS;EACT,eAAe;;AAQH,SAAP,cAAgC,SAAwB;AAC7D,QAAM,OAAiC,OAAO,OAAO,CAAA,GAAIA,iBAAgB,OAAO;AAEhF,MAAI,kBAAkB,MAAM;AAC1B,qBAAiB,gBAAK,IAAI;AAE1B,QAAI,eAAe,aAAa,MAAM;AAEpC,qBAAe,iBAAiB,mBAAmB,CAAC,UAAkC;AACpF,YAAI,QAAQ,MAAM,KAAK,IAAI,KAAK,MAAM;AACpC;QACF;AAEA,aAAK,QAAQ,MAAM,KAAK,IAAI,EAAE,SAAQ,EACnC,KAAK,OAAM,YAAW,MAAM,KAAK,QAAO,EAAG,QAAQ,MAAK;AAAG,kBAAO;QAAG,CAAC,CAAC;MAC5E,CAAC;AAED,qBAAe,iBAAiB,oBAAoB,OAAO,UAAkC;AAC3F,YAAI,QAAQ,MAAM,KAAK,IAAI,KAAK,MAAM;AACpC;QACF;AAEA,aAAK,QAAQ,MAAM,KAAK,IAAI,EAAE,UAAS,EACpC,KAAK,OAAM,YAAW,MAAM,KAAK,QAAO,EAAG,QAAQ,MAAK;AAAG,kBAAO;QAAG,CAAC,CAAC;MAC5E,CAAC;IACH;EACF;AAEA,MAAI,QAAQ,KAAK,IAAI,KAAK,MAAM;AAC9B,YAAQ,KAAK,IAAI,IAAI,YAAY,KAAK,MAAM,IAAI;EAClD;AAEA,SAAO,QAAQ,KAAK,IAAI;AAC1B;;;ACnPM,IAAW;CAAjB,SAAiBC,OAAI;AAMnB,MAAiB;AAAjB,GAAA,SAAiBC,qBAAkB;AACjC,QAAIC;AAES,IAAAD,oBAAA,QAAQ,MAAgC;AACnD,UAAIC,WAAU,MAAM;AAClB,QAAAA,UAAS,QAA4B,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AACzD,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,KAAI;UACR;AAEA,cAAK,IAAI,OAAO,QAAQ,IAAI,QAAQ,IAAK;AACvC,cAAE,OAAO,EAAE;AACX,cAAE,OAAO,IAAI,GAAG;UAClB;AAEA,cAAK,IAAI,SAAS,QAAQ,IAAI,MAAM,aAAa,GAAI;AACnD,cAAE,OAAO,EAAE;AACX,cAAE,MAAM,IAAI,KAAK;UACnB;AAEA,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,OAAM;UACV;QACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,gBAAM,MAAW;YACf,KAAK;YACL,OAAO,MAAgB,CAAC;;AAG1B,gBAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,iBAAO,OAAO,MAAM,KAAK;AACvB,kBAAM,MAAM,OAAO,OAAM;AAEzB,oBAAQ,QAAQ,GAAG;cACjB,KAAK,GAAG;AACN,oBAAI,MAAM,OAAO,OAAM;AACvB;cACF;cACA,KAAK,GAAG;AACN,oBAAI,QAAQ,OAAO,MAAK;AACxB;cACF;cACA,SAAS;AACP,uBAAO,SAAS,MAAM,CAAC;AACvB;cACF;YACF;UACF;AAEA,iBAAO;QACT,CAAC;MACH;AAEA,aAAOA;IACT;AAEa,IAAAD,oBAAA,SAAS,CAAC,QAAgD;AACrE,aAAO,cAAc,KAAKA,oBAAmB,MAAK,CAAE;IACtD;AAEa,IAAAA,oBAAA,SAAS,CAAC,KAAkC,SAAgE;AACvH,aAAO,cAAc,KAAKA,oBAAmB,MAAK,GAAI,IAAI;IAC5D;EACF,GAhEiB,qBAAAD,MAAA,uBAAAA,MAAA,qBAAkB,CAAA,EAAA;AAuEnC,MAAiB;AAAjB,GAAA,SAAiBG,iBAAc;AAC7B,QAAID;AAES,IAAAC,gBAAA,QAAQ,MAA4B;AAC/C,UAAID,WAAU,MAAM;AAClB,QAAAA,UAAS,QAAwB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AACrD,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,KAAI;UACR;AAEA,cAAK,IAAI,OAAO,QAAQ,IAAI,QAAQ,IAAK;AACvC,cAAE,OAAO,EAAE;AACX,cAAE,OAAO,IAAI,GAAG;UAClB;AAEA,cAAI,IAAI,SAAS,MAAM;AACrB,cAAE,OAAO,EAAE;AACX,gBAAI,MAAK,EAAG,OAAO,IAAI,OAAO,CAAC;UACjC;AAEA,cAAI,KAAK,oBAAoB,OAAO;AAClC,cAAE,OAAM;UACV;QACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAvHzC,cAAAE;AAwHU,gBAAM,MAAW;YACf,KAAK;;AAGP,gBAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,iBAAO,OAAO,MAAM,KAAK;AACvB,kBAAM,MAAM,OAAO,OAAM;AAEzB,oBAAQ,QAAQ,GAAG;cACjB,KAAK,GAAG;AACN,oBAAI,MAAM,OAAO,OAAM;AACvB;cACF;cACA,KAAK,GAAG;AACN,oBAAI,QAAQ,IAAI,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,GAAI;kBACtD,SAAQA,OAAA,KAAK,WAAL,gBAAAA,KAAa;iBACtB;AACD;cACF;cACA,SAAS;AACP,uBAAO,SAAS,MAAM,CAAC;AACvB;cACF;YACF;UACF;AAEA,iBAAO;QACT,CAAC;MACH;AAEA,aAAOF;IACT;AAEa,IAAAC,gBAAA,SAAS,CAAC,QAA4C;AACjE,aAAO,cAAc,KAAKA,gBAAe,MAAK,CAAE;IAClD;AAEa,IAAAA,gBAAA,SAAS,CAAC,KAAkC,SAAwD;AAC/G,aAAO,cAAc,KAAKA,gBAAe,MAAK,GAAI,IAAI;IACxD;EACF,GAjEiB,iBAAAH,MAAA,mBAAAA,MAAA,iBAAc,CAAA,EAAA;AAmE/B,MAAI;AAES,EAAAA,MAAA,QAAQ,MAAkB;AACrC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAc,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC3C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,qBAAW,SAAS,IAAI,WAAW;AACjC,cAAE,OAAO,EAAE;AACX,oBAAQ,MAAK,EAAG,OAAO,OAAO,CAAC;UACjC;QACF;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,qBAAW,SAAS,IAAI,WAAW;AACjC,cAAE,OAAO,EAAE;AACX,cAAE,OAAO,KAAK;UAChB;QACF;AAEA,YAAI,IAAI,aAAa,MAAM;AACzB,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAI,IAAI,sBAAsB,MAAM;AAClC,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,kBAAkB;QAChC;AAEA,YAAI,IAAI,YAAY,QAAQ,IAAI,SAAS,SAAS,GAAG;AACnD,qBAAW,CAAC,KAAK,KAAK,KAAK,IAAI,SAAS,QAAO,GAAI;AACjD,cAAE,OAAO,EAAE;AACX,YAAAA,MAAK,mBAAmB,MAAK,EAAG,OAAO,EAAE,KAAK,MAAK,GAAI,CAAC;UAC1D;QACF;AAEA,YAAI,IAAI,QAAQ,QAAQ,IAAI,KAAK,SAAS,GAAG;AAC3C,qBAAW,CAAC,KAAK,KAAK,KAAK,IAAI,KAAK,QAAO,GAAI;AAC7C,cAAE,OAAO,EAAE;AACX,YAAAA,MAAK,eAAe,MAAK,EAAG,OAAO,EAAE,KAAK,MAAK,GAAI,CAAC;UACtD;QACF;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AArNvC,YAAAI,MAAAC,KAAA;AAsNQ,cAAM,MAAW;UACf,WAAW,CAAA;UACX,WAAW,CAAA;UACX,UAAU,oBAAI,IAAG;UACjB,MAAM,oBAAI,IAAG;;AAGf,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,oBAAID,OAAA,KAAK,WAAL,gBAAAA,KAAa,cAAa,QAAQ,IAAI,UAAU,WAAW,KAAK,OAAO,WAAW;AACpF,sBAAM,IAAI,eAAe,4DAA4D;cACvF;AAEA,kBAAI,UAAU,KAAK,QAAQ,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,GAAI;gBACjE,SAAQC,MAAA,KAAK,WAAL,gBAAAA,IAAa;eACtB,CAAC;AACF;YACF;YACA,KAAK,GAAG;AACN,oBAAI,UAAK,WAAL,mBAAa,cAAa,QAAQ,IAAI,UAAU,WAAW,KAAK,OAAO,WAAW;AACpF,sBAAM,IAAI,eAAe,4DAA4D;cACvF;AAEA,kBAAI,UAAU,KAAK,OAAO,OAAM,CAAE;AAClC;YACF;YACA,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,qBAAqB,OAAO,MAAK;AACrC;YACF;YACA,KAAK,GAAG;AACN,oBAAI,UAAK,WAAL,mBAAa,aAAY,QAAQ,IAAI,SAAS,SAAS,KAAK,OAAO,UAAU;AAC/E,sBAAM,IAAI,aAAa,2DAA2D;cACpF;AAEA,oBAAM,QAAQL,MAAK,mBAAmB,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,CAAE;AAC5E,kBAAI,SAAS,IAAI,MAAM,KAAK,MAAM,KAAK;AACvC;YACF;YACA,KAAK,GAAG;AACN,oBAAI,UAAK,WAAL,mBAAa,SAAQ,QAAQ,IAAI,KAAK,SAAS,KAAK,OAAO,MAAM;AACnE,sBAAM,IAAI,aAAa,uDAAuD;cAChF;AAEA,oBAAM,QAAQA,MAAK,eAAe,MAAK,EAAG,OAAO,QAAQ,OAAO,OAAM,GAAI;gBACxE,QAAQ;kBACN,QAAO,UAAK,WAAL,mBAAa;;eAEvB;AACD,kBAAI,KAAK,IAAI,MAAM,KAAK,MAAM,KAAK;AACnC;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAA,MAAA,SAAS,CAAC,QAAkC;AACvD,WAAO,cAAc,KAAKA,MAAK,MAAK,CAAE;EACxC;AAEa,EAAAA,MAAA,SAAS,CAAC,KAAkC,SAAoC;AAC3F,WAAO,cAAc,KAAKA,MAAK,MAAK,GAAI,IAAI;EAC9C;AACF,GArRiB,SAAA,OAAI,CAAA,EAAA;AA4Rf,IAAW;CAAjB,SAAiBM,UAAO;AACtB,MAAI;AAES,EAAAA,SAAA,QAAQ,MAAqB;AACxC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAiB,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC9C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,aAAa,QAAQ,IAAI,UAAU,aAAa,GAAI;AAC3D,YAAE,OAAO,EAAE;AACX,YAAE,MAAM,IAAI,SAAS;QACvB;AAEA,YAAI,IAAI,eAAe,MAAM;AAC3B,YAAE,OAAO,EAAE;AACX,YAAE,KAAK,IAAI,WAAW;QACxB;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,cAAM,MAAW;UACf,WAAW,MAAgB,CAAC;;AAG9B,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,YAAY,OAAO,MAAK;AAC5B;YACF;YACA,KAAK,GAAG;AACN,kBAAI,cAAc,OAAO,KAAI;AAC7B;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAA,SAAA,SAAS,CAAC,QAAqC;AAC1D,WAAO,cAAc,KAAKA,SAAQ,MAAK,CAAE;EAC3C;AAEa,EAAAA,SAAA,SAAS,CAAC,KAAkC,SAA0C;AACjG,WAAO,cAAc,KAAKA,SAAQ,MAAK,GAAI,IAAI;EACjD;AACF,GA/DiB,YAAA,UAAO,CAAA,EAAA;AAsElB,IAAW;CAAjB,SAAiBC,MAAG;AAClB,MAAI;AAES,EAAAA,KAAA,QAAQ,MAAiB;AACpC,QAAI,UAAU,MAAM;AAClB,eAAS,QAAa,CAAC,KAAK,GAAG,OAAO,CAAA,MAAM;AAC1C,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,KAAI;QACR;AAEA,YAAK,IAAI,SAAS,QAAQ,IAAI,UAAU,GAAI;AAC1C,YAAE,OAAO,CAAC;AACV,YAAE,OAAO,IAAI,KAAK;QACpB;AAEA,YAAI,IAAI,UAAU,MAAM;AACtB,YAAE,OAAO,EAAE;AACX,YAAE,OAAO,IAAI,MAAM;QACrB;AAEA,YAAI,KAAK,oBAAoB,OAAO;AAClC,YAAE,OAAM;QACV;MACF,GAAG,CAAC,QAAQ,QAAQ,OAAO,CAAA,MAAM;AAC/B,cAAM,MAAW;UACf,OAAO;;AAGT,cAAM,MAAM,UAAU,OAAO,OAAO,MAAM,OAAO,MAAM;AAEvD,eAAO,OAAO,MAAM,KAAK;AACvB,gBAAM,MAAM,OAAO,OAAM;AAEzB,kBAAQ,QAAQ,GAAG;YACjB,KAAK,GAAG;AACN,kBAAI,QAAQ,OAAO,OAAM;AACzB;YACF;YACA,KAAK,GAAG;AACN,kBAAI,SAAS,OAAO,OAAM;AAC1B;YACF;YACA,SAAS;AACP,qBAAO,SAAS,MAAM,CAAC;AACvB;YACF;UACF;QACF;AAEA,eAAO;MACT,CAAC;IACH;AAEA,WAAO;EACT;AAEa,EAAAA,KAAA,SAAS,CAAC,QAAiC;AACtD,WAAO,cAAc,KAAKA,KAAI,MAAK,CAAE;EACvC;AAEa,EAAAA,KAAA,SAAS,CAAC,KAAkC,SAAkC;AACzF,WAAO,cAAc,KAAKA,KAAI,MAAK,GAAI,IAAI;EAC7C;AACF,GA/DiB,QAAA,MAAG,CAAA,EAAA;;;AC/Wd,SAAU,YAAa,QAAgB,KAAe;AAC1D,QAAM,OAAO,KAAO,OAAO,GAAG;AAE9B,MAAI,KAAK,aAAa,QAAQ,OAAO,aAAa,MAAM;AACtD,UAAM,YAAY,sBAAsB,KAAK,SAAS;AACtD,aAAS,oBAAoB,SAAS;EACxC;AAEA,QAAM,OAAO,oBAAI,IAAG;AAGpB,QAAM,MAAM,OAAO,KAAK,IAAG,CAAE;AAE7B,aAAW,CAAC,KAAK,GAAG,KAAK,KAAK,KAAK,QAAO,GAAI;AAC5C,QAAI,IAAI,UAAU,QAAQ,IAAI,SAAS,KAAK;AAC1C;IACF;AAEA,SAAK,IAAI,KAAK,GAAG;EACnB;AAEA,SAAO;IACL,GAAG;IACH,IAAI;IACJ,WAAW,KAAK,UAAU,IAAI,CAAC,EAAE,WAAW,IAAI,YAAW,MAAM;AAC/D,aAAO;QACL,WAAW,UAAU,EAAE;QACvB,aAAa,eAAe;;IAEhC,CAAC;IACD,UAAU,KAAK;IACf,oBAAoB,KAAK,sBAAsB;IAC/C;;AAEJ;;;ACrCA,IAAM,WAAW;AACjB,IAAM,WAAW,IAAI,YAAW,EAAG,OAAO,QAAQ;AAClD,IAAM,UAAU,SAAS,CAAC;AAkBpB,IAAO,MAAP,MAAO,KAAG;;;;;EAOd,YAAa,GAAwB,OAAe;AAN5C;AAON,QAAI,OAAO,MAAM,UAAU;AACzB,WAAK,OAAO,WAAqB,CAAC;IACpC,WAAW,aAAa,YAAY;AAClC,WAAK,OAAO;IACd,OAAO;AACL,YAAM,IAAI,MAAM,6CAA6C;IAC/D;AAEA,QAAI,SAAS,MAAM;AACjB,cAAQ;IACV;AAEA,QAAI,OAAO;AACT,WAAK,MAAK;IACZ;AAEA,QAAI,KAAK,KAAK,eAAe,KAAK,KAAK,KAAK,CAAC,MAAM,SAAS;AAC1D,YAAM,IAAI,MAAM,aAAa;IAC/B;EACF;;;;;;;EAQA,SAAU,WAA+B,QAAM;AAC7C,WAAO,SAAmB,KAAK,MAAM,QAAQ;EAC/C;;;;;;EAOA,aAAU;AACR,WAAO,KAAK;EACd;;;;;;EAOA,KAAK,OAAO,WAAW,IAAC;AACtB,WAAO,OAAO,KAAK,SAAQ,CAAE;EAC/B;;;;;;;;;;;;;EAcA,OAAO,eAAgB,MAAc;AACnC,WAAO,IAAI,KAAI,KAAK,KAAK,QAAQ,CAAC;EACpC;;;;;;;;;;;;EAaA,OAAO,SAAM;AACX,WAAO,IAAI,KAAI,KAAK,OAAM,EAAG,SAAQ,EAAG,UAAU,CAAC,CAAC;EACtD;;;;EAKA,OAAO,MAAO,OAAU;AACtB,QAAI,iBAAiB,cAAc,OAAO,UAAU,UAAU;AAE5D,aAAO,IAAI,KAAI,KAAK;IACtB;AAEA,QAAI,OAAO,MAAM,eAAe,YAAY;AAE1C,aAAO,IAAI,KAAI,MAAM,WAAU,CAAE;IACnC;AAEA,WAAO;EACT;;;;;;EAOA,QAAK;AACH,QAAI,KAAK,QAAQ,QAAQ,KAAK,KAAK,eAAe,GAAG;AACnD,WAAK,OAAO;IACd;AAEA,QAAI,KAAK,KAAK,CAAC,MAAM,SAAS;AAC5B,YAAM,QAAQ,IAAI,WAAW,KAAK,KAAK,aAAa,CAAC;AACrD,YAAM,KAAK,SAAS,GAAG,CAAC;AACxB,YAAM,IAAI,KAAK,MAAM,CAAC;AACtB,WAAK,OAAO;IACd;AAGA,WAAO,KAAK,KAAK,aAAa,KAAK,KAAK,KAAK,KAAK,KAAK,aAAa,CAAC,MAAM,SAAS;AAClF,WAAK,OAAO,KAAK,KAAK,SAAS,GAAG,EAAE;IACtC;EACF;;;;;;;EAQA,KAAM,KAAQ;AACZ,UAAM,QAAQ,KAAK,KAAI;AACvB,UAAM,QAAQ,IAAI,KAAI;AAEtB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAI,MAAM,SAAS,IAAI,GAAG;AACxB,eAAO;MACT;AAEA,YAAM,KAAK,MAAM,CAAC;AAClB,YAAM,KAAK,MAAM,CAAC;AAElB,UAAI,KAAK,IAAI;AACX,eAAO;MACT,WAAW,KAAK,IAAI;AAClB,eAAO;MACT;IACF;AAEA,WAAO,MAAM,SAAS,MAAM;EAC9B;;;;;;;;;;;;EAaA,UAAO;AACL,WAAO,KAAI,eAAe,KAAK,KAAI,EAAG,MAAK,EAAG,QAAO,CAAE;EACzD;;;;;;EAOA,aAAU;AACR,WAAO,KAAK,KAAI;EAClB;;;;;;;;;;;EAYA,gBAAa;AACX,UAAM,KAAK,KAAK,WAAU;AAC1B,WAAO,GAAG,GAAG,SAAS,CAAC;EACzB;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,KAAK,SAAQ,EAAG,MAAM,QAAQ,EAAE,MAAM,CAAC;EAChD;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,cAAc,KAAK,cAAa,CAAE;EAC3C;;;;;;;;;;;;EAaA,OAAI;AACF,WAAO,eAAe,KAAK,cAAa,CAAE;EAC5C;;;;;;;;;;;;;EAcA,SAAU,GAAS;AACjB,WAAO,IAAI,KAAI,KAAK,SAAQ,IAAK,MAAM,CAAC;EAC1C;;;;;;;;;;;;EAaA,OAAI;AACF,QAAI,IAAI,KAAK,OAAM,EAAG,SAAQ;AAC9B,QAAI,CAAC,EAAE,SAAS,QAAQ,GAAG;AACzB,WAAK;IACP;AACA,SAAK,KAAK,KAAI;AACd,WAAO,IAAI,KAAI,CAAC;EAClB;;;;;;;;;;;;EAaA,SAAM;AACJ,UAAM,OAAO,KAAK,KAAI;AACtB,QAAI,KAAK,WAAW,GAAG;AACrB,aAAO,IAAI,KAAI,QAAQ;IACzB;AAEA,WAAO,IAAI,KAAI,KAAK,MAAM,GAAG,EAAE,EAAE,KAAK,QAAQ,CAAC;EACjD;;;;;;;;;;;;;EAcA,MAAO,KAAQ;AACb,QAAI,KAAK,SAAQ,MAAO,UAAU;AAChC,aAAO;IACT,WAAW,IAAI,SAAQ,MAAO,UAAU;AACtC,aAAO;IACT;AAEA,WAAO,IAAI,KAAI,KAAK,SAAQ,IAAK,IAAI,SAAQ,GAAI,KAAK;EACxD;;;;;;;;;;;;;EAcA,aAAc,OAAU;AACtB,QAAI,MAAM,SAAQ,MAAO,KAAK,SAAQ,GAAI;AACxC,aAAO;IACT;AAEA,WAAO,MAAM,SAAQ,EAAG,WAAW,KAAK,SAAQ,CAAE;EACpD;;;;;;;;;;;;;EAcA,cAAe,OAAU;AACvB,QAAI,MAAM,SAAQ,MAAO,KAAK,SAAQ,GAAI;AACxC,aAAO;IACT;AAEA,WAAO,KAAK,SAAQ,EAAG,WAAW,MAAM,SAAQ,CAAE;EACpD;;;;;;EAOA,aAAU;AACR,WAAO,KAAK,KAAI,EAAG,WAAW;EAChC;;;;;;;EAQA,UAAW,MAAW;AACpB,WAAO,KAAI,eAAe,CAAC,GAAG,KAAK,WAAU,GAAI,GAAG,QAAQ,KAAK,IAAI,SAAO,IAAI,WAAU,CAAE,CAAC,CAAC,CAAC;EACjG;;AASF,SAAS,cAAe,IAAU;AAChC,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO;EACT;AACA,SAAO,MAAM,MAAM,GAAG,EAAE,EAAE,KAAK,GAAG;AACpC;AAQA,SAAS,eAAgB,IAAU;AACjC,QAAM,QAAQ,GAAG,MAAM,GAAG;AAC1B,SAAO,MAAM,MAAM,SAAS,CAAC;AAC/B;AASA,SAAS,QAAS,KAAU;AAC1B,SAAQ,CAAA,EAAI,OAAO,GAAG,GAAG;AAC3B;;;AC/aO,IAAM,mBAAmB;AAE1B,SAAU,qBAAsB,QAAc;AAClD,MAAI,CAAC,SAAS,MAAM,KAAK,OAAO,QAAQ,MAAM;AAC5C,UAAM,IAAI,uBAAuB,gBAAgB;EACnD;AAEA,QAAM,SAAS,OAAO,MAAK,EAAG,SAAQ;AACtC,SAAO,IAAI,IAAI,GAAG,gBAAgB,GAAG,MAAM,EAAE;AAC/C;;;ACPA,eAAsB,6BAA8B,QAAgB,QAAuB,WAAiD;AAC1I,QAAM,aAAa,oBAAI,IAAG;AAE1B,aAAW,QAAQ,WAAW;AAC5B,QAAI,QAAQ,MAAM;AAChB;IACF;AAEA,QAAI,KAAK,qBAAqB,YAAY;AACxC,WAAK,YAAY,UAAU,KAAK,SAAS;IAC3C;AAEA,QAAI,CAAC,YAAY,KAAK,SAAS,GAAG;AAChC,YAAM,IAAI,uBAAuB,uBAAuB;IAC1D;AAEA,QAAI,CAAE,MAAM,OAAO,QAAQ,KAAK,SAAS,GAAI;AAC3C;IACF;AAEA,UAAM,cAAc,KAAK,eAAe;AACxC,UAAM,QAAQ,KAAK,UAAU,SAAQ;AACrC,UAAM,eAAe,WAAW,IAAI,KAAK;AAEzC,QAAI,gBAAgB,MAAM;AACxB,WAAK,cAAc,aAAa,eAAe;IACjD,OAAO;AACL,iBAAW,IAAI,OAAO;QACpB,WAAW,KAAK;QAChB;OACD;IACH;EACF;AAEA,SAAO,CAAC,GAAG,WAAW,OAAM,CAAE,EAC3B,KAAK,CAAC,GAAG,MAAK;AACb,WAAO,EAAE,UAAU,SAAQ,EAAG,cAAc,EAAE,UAAU,SAAQ,CAAE;EACpE,CAAC,EACA,IAAI,CAAC,EAAE,aAAa,WAAAC,WAAS,OAAQ;IACpC;IACA,WAAWA,WAAU;IACrB;AACN;;;ACpCA,eAAsB,SAAU,QAAgB,MAAyB,UAA6B,SAAwB;AAC5H,MAAI,QAAQ,MAAM;AAChB,UAAM,IAAI,uBAAuB,kBAAkB;EACrD;AAEA,MAAI,KAAK,aAAa,QAAQ,OAAO,aAAa,QAAQ,CAAC,KAAK,UAAU,OAAO,OAAO,SAAS,GAAG;AAClG,UAAM,IAAI,uBAAuB,sDAAsD;EACzF;AAEA,QAAM,eAAe,QAAQ;AAE7B,MAAI,gBAAgB,QAAQ,CAAC,OAAO,OAAO,aAAa,EAAE,GAAG;AAC3D,UAAM,IAAI,uBAAuB,wCAAwC;EAC3E;AAEA,MAAI,aAAuB,6CAAc,cAAa,CAAA;AACtD,MAAI,YAAY,IAAI,KAAY,6CAAc,cAAa,CAAA,CAAE;AAC7D,MAAI,YAAoC,6CAAc,aAAY,oBAAI,IAAG;AACzE,MAAI,QAAyB,6CAAc,SAAQ,oBAAI,IAAG;AAC1D,MAAI,qBAA6C,6CAAc;AAG/D,MAAI,aAAa,SAAS;AACxB,QAAI,KAAK,cAAc,QAAQ,KAAK,aAAa,MAAM;AACrD,kBAAY,CAAA;AAEZ,UAAI,KAAK,cAAc,MAAM;AAC3B,kBAAU,KAAK,GAAG,KAAK,WAAW,IAAI,CAAAC,gBAAc;UAClD,aAAa;UACb,WAAAA;UACA,CAAC;MACL;AAEA,UAAI,KAAK,aAAa,MAAM;AAC1B,kBAAU,KAAK,GAAG,KAAK,SAAS;MAClC;IACF;AAEA,QAAI,KAAK,aAAa,MAAM;AAC1B,kBAAY,IAAI,IAAI,KAAK,SAAS;IACpC;AAEA,QAAI,KAAK,YAAY,MAAM;AACzB,YAAM,kBAAkB,KAAK,oBAAoB,MAAM,CAAC,GAAG,KAAK,SAAS,QAAO,CAAE,IAAI,OAAO,QAAQ,KAAK,QAAQ;AAElH,iBAAW,gBAAgB,iBAAiB;QAC1C,UAAU;OACX;IACH;AAEA,QAAI,KAAK,QAAQ,MAAM;AACrB,YAAM,cAAc,KAAK,gBAAgB,MAAM,CAAC,GAAG,KAAK,KAAK,QAAO,CAAE,IAAI,OAAO,QAAQ,KAAK,IAAI;AAElG,aAAO,gBAAgB,aAAa;QAClC,UAAU;QACV,KAAK;OACN;IACH;AAEA,QAAI,KAAK,sBAAsB,MAAM;AACnC,2BAAqB,KAAK;IAC5B;EACF;AAGA,MAAI,aAAa,SAAS;AACxB,QAAI,KAAK,cAAc,MAAM;AAC3B,gBAAU,KAAK,GAAG,KAAK,WAAW,IAAI,CAAAA,gBAAc;QAClD,aAAa;QACb,WAAAA;QACA,CAAC;IACL;AAEA,QAAI,KAAK,aAAa,MAAM;AAC1B,gBAAU,KAAK,GAAG,KAAK,SAAS;IAClC;AAEA,QAAI,KAAK,aAAa,MAAM;AAC1B,kBAAY,oBAAI,IAAI,CAAC,GAAG,WAAW,GAAG,KAAK,SAAS,CAAC;IACvD;AAEA,QAAI,KAAK,YAAY,MAAM;AACzB,YAAM,kBAAkB,KAAK,oBAAoB,MAAM,CAAC,GAAG,KAAK,SAAS,QAAO,CAAE,IAAI,OAAO,QAAQ,KAAK,QAAQ;AAElH,iBAAW,CAAC,KAAK,KAAK,KAAK,iBAAiB;AAC1C,YAAI,SAAS,MAAM;AACjB,mBAAS,OAAO,GAAG;QACrB,OAAO;AACL,mBAAS,IAAI,KAAK,KAAK;QACzB;MACF;AAEA,iBAAW,gBAAgB,CAAC,GAAG,SAAS,QAAO,CAAE,GAAG;QAClD,UAAU;OACX;IACH;AAEA,QAAI,KAAK,QAAQ,MAAM;AACrB,YAAM,cAAc,KAAK,gBAAgB,MAAM,CAAC,GAAG,KAAK,KAAK,QAAO,CAAE,IAAI,OAAO,QAAQ,KAAK,IAAI;AAClG,YAAM,aAAa,IAAI,IAA8B,IAAI;AAEzD,iBAAW,CAAC,KAAK,KAAK,KAAK,aAAa;AACtC,YAAI,SAAS,MAAM;AACjB,qBAAW,OAAO,GAAG;QACvB,OAAO;AACL,qBAAW,IAAI,KAAK,KAAK;QAC3B;MACF;AAEA,aAAO,gBAAgB,CAAC,GAAG,WAAW,QAAO,CAAE,GAAG;QAChD,UAAU;QACV,KAAK;OACN;IACH;AAEA,QAAI,KAAK,sBAAsB,MAAM;AACnC,2BAAqB,KAAK;IAC5B;EACF;AAEA,MAAI;AAEJ,OAAI,6CAAc,GAAG,cAAa,MAAM;AACtC,gBAAY,oBAAoB,aAAa,GAAG,SAAS;EAC3D,WAAW,KAAK,aAAa,MAAM;AACjC,gBAAY,oBAAoB,KAAK,SAAS;EAChD,WAAW,OAAO,aAAa,MAAM;AACnC,gBAAY,oBAAoB,OAAO,SAAS;EAClD;AAEA,QAAM,SAAiB;IACrB,WAAW,MAAM,6BAA6B,QAAQ,QAAQ,kBAAkB,YAAY,OAAO,SAAS;IAC5G,WAAW,CAAC,GAAG,UAAU,OAAM,CAAE,EAAE,KAAK,CAAC,GAAG,MAAK;AAC/C,aAAO,EAAE,cAAc,CAAC;IAC1B,CAAC;IACD;IACA;IACA;IACA;;AAIF,MAAI,OAAO,SAAS,OAAO;AACzB,WAAO,OAAO;EAChB;AAEA,SAAO;AACT;AAWA,SAAS,gBAA4B,SAAyC,SAAqC;AA1KnH,MAAAC;AA2KE,QAAM,SAAS,oBAAI,IAAG;AAEtB,aAAW,CAAC,KAAK,KAAK,KAAK,SAAS;AAClC,QAAI,SAAS,MAAM;AACjB;IACF;AAEA,YAAQ,SAAS,KAAK,KAAK;EAC7B;AAEA,aAAW,CAAC,KAAK,KAAK,KAAK,QAAQ,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,MAAK;AACnD,WAAO,EAAE,cAAc,CAAC;EAC1B,CAAC,GAAG;AACF,QAAI,SAAS,MAAM;AACjB,aAAO,IAAI,OAAKA,OAAA,QAAQ,QAAR,gBAAAA,KAAA,cAAc,KAAK,WAAU,KAAK;IACpD;EACF;AAEA,SAAO;AACT;AAEA,SAAS,iBAAkB,KAAa,OAAiB;AACvD,MAAI,OAAO,QAAQ,UAAU;AAC3B,UAAM,IAAI,uBAAuB,+BAA+B;EAClE;AAEA,MAAI,EAAE,iBAAiB,aAAa;AAClC,UAAM,IAAI,uBAAuB,qCAAqC;EACxE;AACF;AAEA,SAAS,YAAa,KAAa,KAAe;AAChD,MAAI,OAAO,QAAQ,UAAU;AAC3B,UAAM,IAAI,uBAAuB,2BAA2B;EAC9D;AAEA,MAAI,IAAI,SAAS,MAAM;AACrB,QAAI,SAAS,GAAG,IAAI,KAAK,IAAI,EAAE,MAAM,IAAI,OAAO;AAC9C,YAAM,IAAI,uBAAuB,8BAA8B;IACjE;AAEA,QAAI,IAAI,QAAQ,KAAK,IAAI,QAAQ,KAAK;AACpC,YAAM,IAAI,uBAAuB,iCAAiC;IACpE;EACF;AAEA,MAAI,IAAI,OAAO,MAAM;AACnB,QAAI,SAAS,GAAG,IAAI,GAAG,IAAI,EAAE,MAAM,IAAI,KAAK;AAC1C,YAAM,IAAI,uBAAuB,4BAA4B;IAC/D;AAEA,QAAI,IAAI,MAAM,GAAG;AACf,YAAM,IAAI,uBAAuB,wCAAwC;IAC3E;EACF;AACF;AAEA,SAAS,OAAQ,KAAa,KAAQ;AACpC,MAAI;AAEJ,MAAI,IAAI,UAAU,MAAM;AACtB,aAAS,IAAI;EACf;AAEA,MAAI,IAAI,OAAO,MAAM;AACnB,aAAS,OAAO,KAAK,IAAG,IAAK,OAAO,IAAI,GAAG,CAAC;EAC9C;AAEA,SAAO;IACL,OAAO,IAAI,SAAS;IACpB;;AAEJ;;;AC9NA,SAAS,WAAY,KAAU,OAAiB;AAE9C,QAAM,YAAY,IAAI,SAAQ,EAAG,MAAM,GAAG,EAAE,CAAC;AAC7C,QAAM,MAAM,IAAI,MAAM,WAAW,MAAM;AACvC,QAAM,SAAS,cAAc,GAAG;AAEhC,SAAO,YAAY,QAAQ,KAAK;AAClC;AAEA,SAAS,SAAU,OAAgB;AACjC,MAAI,SAAS,MAAM;AACjB,WAAO,CAAA;EACT;AAEA,SAAO;IACL,QAAQ;IACR,UAAU,MAAM,WAAW,CAAA,GAAI,IAAI,QAAM,CAAC,EAAE,KAAK,MAAK,MAAM;AAC1D,aAAO,GAAG,WAAW,KAAK,KAAK,CAAC;IAClC,CAAC;IACD,SAAS,MAAM,UAAU,CAAA,GAAI,IAAI,QAAM,CAAC,GAAG,MAAK;AAC9C,aAAO,GAAG,WAAW,EAAE,KAAK,EAAE,KAAK,GAAG,WAAW,EAAE,KAAK,EAAE,KAAK,CAAC;IAClE,CAAC;;AAEL;AA5CA;AA8CM,IAAO,kBAAP,MAAsB;EAO1B,YAAa,YAA2C,OAAgC,CAAA,GAAE;AAmF1F,uBAAM;AAkBN,uBAAM;AA3GW;AACA;AACD;AACC;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,mBAAmB;AAC7D,SAAK,SAAS,WAAW;AACzB,SAAK,YAAY,WAAW;AAC5B,SAAK,gBAAgB,KAAK;AAC1B,SAAK,OAAO,cAAQ;MAClB,MAAM;MACN,eAAe;KAChB;EACH;EAEA,MAAM,IAAK,QAAc;AACvB,WAAO,KAAK,UAAU,IAAI,qBAAqB,MAAM,CAAC;EACxD;EAEA,MAAM,OAAQ,QAAc;AAC1B,QAAI,KAAK,OAAO,OAAO,MAAM,GAAG;AAC9B,YAAM,IAAI,uBAAuB,yBAAyB;IAC5D;AAEA,UAAM,KAAK,UAAU,OAAO,qBAAqB,MAAM,CAAC;EAC1D;EAEA,MAAM,KAAM,QAAc;AACxB,UAAM,MAAM,MAAM,KAAK,UAAU,IAAI,qBAAqB,MAAM,CAAC;AAEjE,WAAO,YAAY,QAAQ,GAAG;EAChC;EAEA,MAAM,KAAM,QAAgB,MAAc;AACxC,UAAM,EACJ,aACA,aAAY,IACV,MAAM,sBAAK,wCAAL,WAAuB;AAEjC,UAAM,SAAiB,MAAM,SAAS,QAAQ,MAAM,SAAS;MAC3D,eAAe,KAAK;KACrB;AAED,WAAO,sBAAK,sCAAL,WAAsB,QAAQ,QAAQ,aAAa;EAC5D;EAEA,MAAM,MAAO,QAAgB,MAAuB;AAClD,UAAM,EACJ,aACA,aAAY,IACV,MAAM,sBAAK,wCAAL,WAAuB;AAEjC,UAAM,SAAiB,MAAM,SAAS,QAAQ,MAAM,SAAS;MAC3D,eAAe,KAAK;MACpB;KACD;AAED,WAAO,sBAAK,sCAAL,WAAsB,QAAQ,QAAQ,aAAa;EAC5D;EAEA,MAAM,MAAO,QAAgB,MAAc;AACzC,UAAM,EACJ,aACA,aAAY,IACV,MAAM,sBAAK,wCAAL,WAAuB;AAEjC,UAAM,SAAiB,MAAM,SAAS,QAAQ,MAAM,SAAS;MAC3D,eAAe,KAAK;MACpB;KACD;AAED,WAAO,sBAAK,sCAAL,WAAsB,QAAQ,QAAQ,aAAa;EAC5D;EAEA,OAAQ,IAAK,OAAiB;AAC5B,qBAAiB,EAAE,KAAK,MAAK,KAAM,KAAK,UAAU,MAAM,SAAS,SAAS,CAAA,CAAE,CAAC,GAAG;AAC9E,YAAM,OAAO,WAAW,KAAK,KAAK;AAElC,UAAI,KAAK,GAAG,OAAO,KAAK,MAAM,GAAG;AAE/B;MACF;AAEA,YAAM;IACR;EACF;;AAEM;sBAAiB,eAAE,QAAc;AACrC,MAAI;AACF,UAAM,cAAc,MAAM,KAAK,UAAU,IAAI,qBAAqB,MAAM,CAAC;AACzE,UAAM,eAAe,YAAY,QAAQ,WAAW;AAEpD,WAAO;MACL;MACA;;EAEJ,SAAS,KAAU;AACjB,QAAI,IAAI,SAAS,iBAAiB;AAChC,WAAK,IAAI,MAAM,8CAA8C,GAAG;IAClE;EACF;AAEA,SAAO,CAAA;AACT;AAEM;qBAAgB,eAAE,QAAgB,MAAc,aAA0B,cAAmB;AACjG,QAAM,MAAM,KAAO,OAAO,IAAI;AAE9B,MAAI,eAAe,QAAQ,OAAiB,KAAK,WAAW,GAAG;AAC7D,WAAO;MACL,MAAM,YAAY,QAAQ,GAAG;MAC7B,UAAU;MACV,SAAS;;EAEb;AAEA,QAAM,KAAK,UAAU,IAAI,qBAAqB,MAAM,GAAG,GAAG;AAE1D,SAAO;IACL,MAAM,YAAY,QAAQ,GAAG;IAC7B,UAAU;IACV,SAAS;;AAEb;;;AC5KF;AAmCA,IAAM,sBAAN,MAAyB;EAMvB,YAAa,YAA2C,OAAgC,CAAA,GAAE;AAyK1F;AA9KiB;AACA;AACA;AACA;AASR,wBAAC,IAAsB;AAN9B,SAAK,MAAM,WAAW,OAAO,aAAa,mBAAmB;AAC7D,SAAK,SAAS,WAAW;AACzB,SAAK,SAAS,WAAW;AACzB,SAAK,QAAQ,IAAI,gBAAgB,YAAY,IAAI;EACnD;EAIA,MAAM,QAAS,IAA2B,OAAiB;AACzD,SAAK,IAAI,MAAM,yBAAyB;AACxC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,SAAQ;AAC9C,SAAK,IAAI,MAAM,uBAAuB;AAEtC,QAAI;AACF,uBAAiB,QAAQ,KAAK,MAAM,IAAI,KAAK,GAAG;AAC9C,WAAG,IAAI;MACT;IACF;AACE,WAAK,IAAI,MAAM,2BAA2B;AAC1C,cAAO;IACT;EACF;EAEA,MAAM,IAAK,OAAiB;AAC1B,SAAK,IAAI,MAAM,qBAAqB;AACpC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,SAAQ;AAC9C,SAAK,IAAI,MAAM,mBAAmB;AAElC,QAAI;AACF,aAAO,MAAMC,aAAI,KAAK,MAAM,IAAI,KAAK,CAAC;IACxC;AACE,WAAK,IAAI,MAAM,uBAAuB;AACtC,cAAO;IACT;EACF;EAEA,MAAM,OAAQ,QAAc;AAC1B,SAAK,IAAI,MAAM,yBAAyB;AACxC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,UAAS;AAC/C,SAAK,IAAI,MAAM,uBAAuB;AAEtC,QAAI;AACF,YAAM,KAAK,MAAM,OAAO,MAAM;IAChC;AACE,WAAK,IAAI,MAAM,2BAA2B;AAC1C,cAAO;IACT;EACF;EAEA,MAAM,IAAK,QAAc;AACvB,SAAK,IAAI,MAAM,qBAAqB;AACpC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,SAAQ;AAC9C,SAAK,IAAI,MAAM,mBAAmB;AAElC,QAAI;AACF,aAAO,MAAM,KAAK,MAAM,IAAI,MAAM;IACpC;AACE,WAAK,IAAI,MAAM,uBAAuB;AACtC,cAAO;IACT;EACF;EAEA,MAAM,IAAK,QAAc;AACvB,SAAK,IAAI,MAAM,qBAAqB;AACpC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,SAAQ;AAC9C,SAAK,IAAI,MAAM,mBAAmB;AAElC,QAAI;AACF,aAAO,MAAM,KAAK,MAAM,KAAK,MAAM;IACrC;AACE,WAAK,IAAI,MAAM,uBAAuB;AACtC,cAAO;IACT;EACF;EAEA,MAAM,KAAM,IAAY,MAAc;AACpC,SAAK,IAAI,MAAM,uBAAuB;AACtC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,UAAS;AAC/C,SAAK,IAAI,MAAM,qBAAqB;AAEpC,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI;AAE7C,4BAAK,kCAAL,WAAoB,IAAI;AAExB,aAAO,OAAO;IAChB;AACE,WAAK,IAAI,MAAM,yBAAyB;AACxC,cAAO;IACT;EACF;EAEA,MAAM,MAAO,IAAY,MAAc;AACrC,SAAK,IAAI,MAAM,wBAAwB;AACvC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,UAAS;AAC/C,SAAK,IAAI,MAAM,sBAAsB;AAErC,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,MAAM,MAAM,IAAI,IAAI;AAE9C,4BAAK,kCAAL,WAAoB,IAAI;AAExB,aAAO,OAAO;IAChB;AACE,WAAK,IAAI,MAAM,0BAA0B;AACzC,cAAO;IACT;EACF;EAEA,MAAM,MAAO,IAAY,MAAc;AACrC,SAAK,IAAI,MAAM,wBAAwB;AACvC,UAAM,UAAU,MAAM,KAAK,MAAM,KAAK,UAAS;AAC/C,SAAK,IAAI,MAAM,sBAAsB;AAErC,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,MAAM,MAAM,IAAI,IAAI;AAE9C,4BAAK,kCAAL,WAAoB,IAAI;AAExB,aAAO,OAAO;IAChB;AACE,WAAK,IAAI,MAAM,0BAA0B;AACzC,cAAO;IACT;EACF;EAEA,MAAM,kBAAmB,KAAiB,cAAqB;AAC7D,UAAM,WAAW,MAAM,eAAe,eAAe,KAAKC,YAAW,MAAM;AAC3E,UAAM,SAAS,cAAc,SAAS,UAAU,MAAK,CAAE;AAEvD,SAAI,6CAAc,OAAO,aAAY,OAAO;AAC1C,WAAK,IAAI,6EAA6E,cAAc,MAAM;AAC1G,aAAO;IACT;AAEA,UAAM,aAAaA,YAAW,mBAAmB,SAAS,OAAO;AACjE,QAAI;AAEJ,QAAI;AACF,aAAO,MAAM,KAAK,IAAI,MAAM;IAC9B,SAAS,KAAU;AACjB,UAAI,IAAI,SAAS,iBAAiB;AAChC,cAAM;MACR;IACF;AAGA,SAAI,6BAAM,uBAAsB,MAAM;AACpC,YAAM,iBAAiB,MAAM,eAAe,mBAAmB,KAAK,kBAAkB;AACtF,YAAM,eAAeA,YAAW,mBAAmB,eAAe,OAAO;AAEzE,UAAI,aAAa,aAAa,WAAW,WAAW;AAClD,aAAK,IAAI,4FAA4F,aAAa,WAAW,WAAW,SAAS;AACjJ,eAAO;MACT;IACF;AAEA,UAAM,KAAK,MAAM,WAAW,QAAQ;MAClC,oBAAoB;MACpB,WAAW,WAAW,WAAW,IAAI,CAAAC,gBAAc;QACjD,aAAa;QACb,WAAAA;QACA;KACH;AAED,WAAO;EACT;;AAhKU,YAAO;AAkKjB;mBAAc,SAAE,IAAY,QAAkB;AAC5C,MAAI,CAAC,OAAO,SAAS;AACnB;EACF;AAEA,MAAI,KAAK,OAAO,OAAO,EAAE,GAAG;AAC1B,SAAK,OAAO,kBAAkB,oBAAoB,EAAE,QAAQ,OAAM,CAAE;EACtE,OAAO;AACL,SAAK,OAAO,kBAAkB,eAAe,EAAE,QAAQ,OAAM,CAAE;EACjE;AACF;AAGI,SAAU,oBAAqB,YAA2C,OAAgC,CAAA,GAAE;AAChH,SAAO,IAAI,oBAAoB,YAAY,IAAI;AACjD;;;AC/JM,IAAO,iBAAP,MAAO,uBAAsB,MAAK;EAMtC,YAAaC,WAAU,aAAW;AAChC,UAAMA,QAAO;AAJf,gCAAO,eAAc;AACrB,gCAAO,eAAc;EAIrB;;AAPA,cADW,gBACJ,QAAO;AACd,cAFW,gBAEJ,QAAO;AAFV,IAAOC,iBAAP;;;ACrCN,SAAS,gBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAQA,SAAS,MAAO,QAAkD;AAChE,MAAI,gBAAgB,MAAM,GAAG;AAC3B,YAAQ,YAAW;AACjB,uBAAiB,KAAK,QAAQ;MAAE;IAClC,GAAE;EACJ,OAAO;AACL,eAAW,KAAK,QAAQ;IAAE;EAC5B;AACF;AAEA,IAAAC,eAAe;;;ACJf,SAASC,iBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAYA,SAAS,KAAU,QAAwC,QAA0B;AACnF,MAAIA,iBAAgB,MAAM,GAAG;AAC3B,WAAQ,mBAAgB;AACtB,YAAM,MAAM,MAAMC,aAAI,MAAM;AAE5B,aAAQ,IAAI,KAAK,MAAM;IACzB,EAAE;EACJ;AAEA,SAAQ,aAAU;AAChB,UAAM,MAAMA,aAAI,MAAM;AAEtB,WAAQ,IAAI,KAAK,MAAM;EACzB,EAAE;AACJ;AAEA,IAAAA,eAAe;;;ACxCf,SAASC,iBAAqB,OAAU;AACtC,SAAO,MAAM,OAAO,aAAa,KAAK;AACxC;AAOA,SAAS,KAAU,QAAwC,OAAa;AACtE,MAAIA,iBAAgB,MAAM,GAAG;AAC3B,WAAQ,mBAAgB;AACtB,UAAI,QAAQ;AAEZ,UAAI,QAAQ,GAAG;AACb;MACF;AAEA,uBAAiB,SAAS,QAAQ;AAChC,cAAM;AAEN;AAEA,YAAI,UAAU,OAAO;AACnB;QACF;MACF;IACF,EAAE;EACJ;AAEA,SAAQ,aAAU;AAChB,QAAI,QAAQ;AAEZ,QAAI,QAAQ,GAAG;AACb;IACF;AAEA,eAAW,SAAS,QAAQ;AAC1B,YAAM;AAEN;AAEA,UAAI,UAAU,OAAO;AACnB;MACF;IACF;EACF,EAAE;AACJ;AAEA,IAAAC,eAAe;;;AC7ET,IAAO,gBAAP,MAAoB;EACxB,IAAK,KAAU,KAAiB,SAAsB;AACpD,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,IAAK,KAAU,SAAsB;AACnC,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,IAAK,KAAU,SAAsB;AACnC,WAAO,QAAQ,OAAO,IAAI,MAAM,yBAAyB,CAAC;EAC5D;EAEA,OAAQ,KAAU,SAAsB;AACtC,WAAO,QAAQ,OAAO,IAAI,MAAM,4BAA4B,CAAC;EAC/D;EAEA,OAAQ,QAAS,QAA6B,UAAwB,CAAA,GAAE;AACtE,qBAAiB,EAAE,KAAK,MAAK,KAAM,QAAQ;AACzC,YAAM,KAAK,IAAI,KAAK,OAAO,OAAO;AAClC,YAAM;IACR;EACF;EAEA,OAAQ,QAAS,QAA4B,UAAwB,CAAA,GAAE;AACrE,qBAAiB,OAAO,QAAQ;AAC9B,YAAM;QACJ;QACA,OAAO,MAAM,KAAK,IAAI,KAAK,OAAO;;IAEtC;EACF;EAEA,OAAQ,WAAY,QAA4B,UAAwB,CAAA,GAAE;AACxE,qBAAiB,OAAO,QAAQ;AAC9B,YAAM,KAAK,OAAO,KAAK,OAAO;AAC9B,YAAM;IACR;EACF;EAEA,QAAK;AACH,QAAI,OAAe,CAAA;AACnB,QAAI,OAAc,CAAA;AAElB,WAAO;MACL,IAAK,KAAK,OAAK;AACb,aAAK,KAAK,EAAE,KAAK,MAAK,CAAE;MAC1B;MAEA,OAAQ,KAAG;AACT,aAAK,KAAK,GAAG;MACf;MACA,QAAQ,OAAO,YAAW;AACxB,cAAMC,aAAM,KAAK,QAAQ,MAAM,OAAO,CAAC;AACvC,eAAO,CAAA;AACP,cAAMA,aAAM,KAAK,WAAW,MAAM,OAAO,CAAC;AAC1C,eAAO,CAAA;MACT;;EAEJ;;;;;EAMA,OAAQ,KAAM,GAAU,SAAsB;AAC5C,UAAM,IAAI,MAAM,0BAA0B;EAC5C;;;;;EAMA,OAAQ,SAAU,GAAa,SAAsB;AACnD,UAAM,IAAI,MAAM,8BAA8B;EAChD;EAEA,MAAO,GAAU,SAAsB;AACrC,QAAI,KAAK,KAAK,KAAK,GAAG,OAAO;AAE7B,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,CAAC,MAAM,EAAE,IAAI,SAAQ,EAAG,WAAW,MAAM,CAAC;IAC5D;AAEA,QAAI,MAAM,QAAQ,EAAE,OAAO,GAAG;AAC5B,WAAK,EAAE,QAAQ,OAAO,CAACC,KAAI,MAAMD,aAAOC,KAAI,CAAC,GAAG,EAAE;IACpD;AAEA,QAAI,MAAM,QAAQ,EAAE,MAAM,GAAG;AAC3B,WAAK,EAAE,OAAO,OAAO,CAACA,KAAI,MAAMD,aAAKC,KAAI,CAAC,GAAG,EAAE;IACjD;AAEA,QAAI,EAAE,UAAU,MAAM;AACpB,UAAI,IAAI;AACR,YAAM,SAAS,EAAE;AACjB,WAAKD,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AAEA,QAAI,EAAE,SAAS,MAAM;AACnB,WAAKA,aAAK,IAAI,EAAE,KAAK;IACvB;AAEA,WAAO;EACT;EAEA,UAAW,GAAa,SAAsB;AAC5C,QAAI,KAAK,KAAK,SAAS,GAAG,OAAO;AAEjC,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,WAAKA,aAAO,IAAI,CAAC,QACf,IAAI,SAAQ,EAAG,WAAW,MAAM,CAAC;IAErC;AAEA,QAAI,MAAM,QAAQ,EAAE,OAAO,GAAG;AAC5B,WAAK,EAAE,QAAQ,OAAO,CAACC,KAAI,MAAMD,aAAOC,KAAI,CAAC,GAAG,EAAE;IACpD;AAEA,QAAI,MAAM,QAAQ,EAAE,MAAM,GAAG;AAC3B,WAAK,EAAE,OAAO,OAAO,CAACA,KAAI,MAAMD,aAAKC,KAAI,CAAC,GAAG,EAAE;IACjD;AAEA,QAAI,EAAE,UAAU,MAAM;AACpB,YAAM,SAAS,EAAE;AACjB,UAAI,IAAI;AACR,WAAKD,aAAO,IAAI,MAAM,OAAO,MAAM;IACrC;AAEA,QAAI,EAAE,SAAS,MAAM;AACnB,WAAKA,aAAK,IAAI,EAAE,KAAK;IACvB;AAEA,WAAO;EACT;;;;ACxII,IAAO,kBAAP,cAA+B,cAAa;EAGhD,cAAA;AACE,UAAK;AAHU;AAKf,SAAK,OAAO,oBAAI,IAAG;EACrB;EAEA,IAAK,KAAU,KAAe;AAC5B,SAAK,KAAK,IAAI,IAAI,SAAQ,GAAI,GAAG;AAEjC,WAAO;EACT;EAEA,IAAK,KAAQ;AACX,UAAM,SAAS,KAAK,KAAK,IAAI,IAAI,SAAQ,CAAE;AAE3C,QAAI,UAAU,MAAM;AAClB,YAAM,IAAIE,eAAa;IACzB;AAEA,WAAO;EACT;EAEA,IAAK,KAAQ;AACX,WAAO,KAAK,KAAK,IAAI,IAAI,SAAQ,CAAE;EACrC;EAEA,OAAQ,KAAQ;AACd,SAAK,KAAK,OAAO,IAAI,SAAQ,CAAE;EACjC;EAEA,CAAE,OAAI;AACJ,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,QAAO,GAAI;AAC9C,YAAM,EAAE,KAAK,IAAI,IAAI,GAAG,GAAG,MAAK;IAClC;EACF;EAEA,CAAE,WAAQ;AACR,eAAW,OAAO,KAAK,KAAK,KAAI,GAAI;AAClC,YAAM,IAAI,IAAI,GAAG;IACnB;EACF;;;;ACtCI,SAAU,SAAU,MAAkC,MAAY;AACtE,MAAI;AAEJ,QAAM,SAAS,WAAA;AACb,UAAM,QAAQ,WAAA;AACZ,gBAAU;AACV,WAAK,KAAI;IACX;AAEA,iBAAa,OAAO;AACpB,cAAU,WAAW,OAAO,IAAI;EAClC;AACA,SAAO,QAAQ,MAAK;EAAE;AACtB,SAAO,OAAO,MAAK;AACjB,iBAAa,OAAO;EACtB;AAEA,SAAO;AACT;;;AC5BA,qBAAwB;AAExB,IAAM,oBAAoB;EACxB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGF,IAAM,iBAAiB,kBAAkB,IAAI,aAAW,IAAI,uBAAQ,OAAO,CAAC;AAE5E,SAAS,UAAW,QAAc;AAChC,aAAW,KAAK,gBAAgB;AAC9B,QAAI,EAAE,SAAS,MAAM;AAAG,aAAO;EACjC;AAEA,SAAO;AACT;AAEA,SAAS,iBAAkB,QAAc;AACvC,SAAO,iDAAiD,KAAK,MAAM;AACrE;AAKA,SAAS,oBAAqB,QAAc;AAC1C,QAAM,QAAQ,OAAO,MAAM,GAAG;AAE9B,MAAI,MAAM,SAAS,GAAG;AACpB,WAAO;EACT;AAEA,QAAM,UAAU,MAAM,MAAM,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG;AACvD,QAAM,UAAU,MAAM,MAAM,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG;AAEvD,QAAM,MAAM,GAAG,SAAS,QAAQ,UAAU,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,SAAS,QAAQ,UAAU,CAAC,GAAG,EAAE,CAAC;AAEzK,SAAO,UAAU,GAAG;AACtB;AAKA,SAAS,mBAAoB,QAAc;AACzC,SAAO,kEAAkE,KAAK,MAAM;AACtF;AAEA,SAAS,sBAAuB,QAAc;AAC5C,QAAM,QAAQ,OAAO,MAAM,GAAG;AAC9B,QAAM,MAAM,MAAM,MAAM,SAAS,CAAC;AAElC,SAAO,UAAU,GAAG;AACtB;AAEA,SAAS,UAAW,QAAc;AAChC,SAAO,OAAO,KAAK,MAAM,KACvB,QAAQ,KAAK,MAAM,KACnB,oEAAoE,KAAK,MAAM,KAC/E,wFAAwF,KAAK,MAAM,KACnG,iIAAiI,KAAK,MAAM,KAC5I,6IAA6I,KAAK,MAAM,KACxJ,oIAAoI,KAAK,MAAM,KAC/I,oJAAoJ,KAAK,MAAM,KAC/J,8BAA8B,KAAK,MAAM,KACzC,8BAA8B,KAAK,MAAM,KACzC,0BAA0B,KAAK,MAAM;AACzC;AAEM,SAAU,YAAa,IAAU;AACrC,MAAI,OAAO,EAAE;AAAG,WAAO,UAAU,EAAE;WAC1B,iBAAiB,EAAE;AAAG,WAAO,oBAAoB,EAAE;WACnD,mBAAmB,EAAE;AAAG,WAAO,sBAAsB,EAAE;WACvD,OAAO,EAAE;AAAG,WAAO,UAAU,EAAE;;AACnC,WAAO;AACd;;;ACzFA,IAAM,WAAW;AAajB,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,aAAa;AACnB,IAAM,aAAa;AACnB,IAAM,gBAAgB;AAEhB,IAAO,cAAP,MAAkB;EAItB,YAAa,YAAsC,OAA2B,CAAA,GAAE;AAH/D;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,qCAAqC;AAC/E,SAAK,WAAW,oBAAI,IAAG;EACzB;EAEA,IAAK,IAAa;AAChB,UAAM,OAAO,KAAK,SAAS,EAAE;AAE7B,eAAW,WAAW,KAAK,SAAS,OAAM,GAAI;AAC5C,UAAI,QAAQ,WAAW,MAAM;AAC3B,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,IAAK,QAAgB,WAAmB;AACtC,cAAU,QAAQ,QAAK;AACrB,WAAK,IAAI,4BAA4B,IAAI,MAAM;AAG/C,YAAM,WAAW,YAAY,EAAE,MAAM;AAErC,WAAK,SAAS,IAAI,IAAI;QACpB;QACA;QACA,SAAS,WAAW,WAAW,KAAK,IAAG,IAAK;QAC5C,cAAc,WAAW,WAAW,KAAK,IAAG,IAAK;OAClD;IACH,CAAC;EACH;EAEA,OAAQ,IAAa;AACnB,UAAM,OAAO,KAAK,SAAS,EAAE;AAC7B,QAAI,eAAe;AAEnB,eAAW,CAAC,IAAI,OAAO,KAAK,KAAK,SAAS,QAAO,GAAI;AACnD,UAAI,QAAQ,WAAW,MAAM;AAC3B,aAAK,IAAI,oCAAoC,IAAI,QAAQ,QAAQ,IAAI,MAAM,OAAO,CAAC;AACnF,aAAK,SAAS,OAAO,EAAE;AACvB,uBAAe,gBAAgB,QAAQ;MACzC;IACF;AAEA,WAAO;EACT;EAEA,OAAQ,WAAwB;AAC9B,UAAM,qBAAoC,CAAA;AAE1C,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,UAAU,UAAU,CAAC;AAC3B,YAAM,SAAS,QAAQ,UAAU,aAAY;AAC7C,YAAM,OAAO,OAAO,CAAC,EAAE,CAAC;AAExB,UAAI,QAAQ,MAAM;AAChB;MACF;AAEA,iBAAW,CAAC,IAAI,OAAO,KAAK,KAAK,SAAS,QAAO,GAAI;AACnD,YAAI,SAAS,IAAI;AACf;QACF;AAGA,cAAM,WAAW,KAAK,iBAAiB,QAAQ,QAAQ,MAAM;AAE7D,YAAI,UAAU;AAGZ,oBAAU,OAAO,GAAG,CAAC;AACrB;AAEA,6BAAmB,KAAK;YACtB,WAAW,UAAU,IACnB,OAAO,IAAI,WAAQ;AACjB,qBAAO;gBACL,YAAU,MAAM,CAAC,CAAC,EAAE;gBACpB,MAAM,CAAC;gBACP,KAAK,GAAG;YACZ,CAAC,EAAE,KAAK,GAAG,CACb,EAAE;YACF,UAAU,QAAQ;YAClB,MAAM;YACN,SAAS,QAAQ;YACjB,cAAc,QAAQ;WACvB;QACH;MACF;IACF;AAEA,WAAO;EACT;EAEQ,iBAAkB,QAAuB,QAAc;AA9HjE,QAAAC;AA+HI,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAI,OAAO,CAAC,EAAE,CAAC,MAAM,eAAaA,OAAA,OAAO,IAAI,CAAC,MAAZ,gBAAAA,KAAgB,QAAO,WAAW;AAClE,eAAO,OAAO,IAAI,GAAG,GAAG,CAAC,WAAW,MAAM,CAAC;AAC3C,eAAO;MACT;IACF;AAEA,WAAO;EACT;EAEA,QAAS,IAAe,KAAW;AACjC,UAAM,OAAO,KAAK,SAAS,EAAE;AAC7B,QAAI,qBAAqB;AAEzB,eAAW,CAAC,IAAI,OAAO,KAAK,KAAK,SAAS,QAAO,GAAI;AACnD,UAAI,QAAQ,WAAW,MAAM;AAC3B,aAAK,IAAI,4CAA4C,IAAI,QAAQ,MAAM;AACvE,6BAAqB,QAAQ;AAC7B,gBAAQ,WAAW;AACnB,gBAAQ,UAAU,KAAK,IAAG,IAAK;AAC/B,gBAAQ,eAAe,KAAK,IAAG;MACjC;IACF;AAEA,WAAO;EACT;EAEA,UAAW,IAAe,KAAW;AACnC,UAAM,OAAO,KAAK,SAAS,EAAE;AAC7B,QAAI,eAAe;AAEnB,eAAW,CAAC,IAAI,OAAO,KAAK,KAAK,SAAS,QAAO,GAAI;AACnD,UAAI,QAAQ,WAAW,MAAM;AAC3B,aAAK,IAAI,iDAAiD,IAAI,QAAQ,MAAM;AAC5E,uBAAe,gBAAgB,QAAQ;AACvC,gBAAQ,WAAW;AACnB,gBAAQ,UAAU,KAAK,IAAG,IAAK;MACjC;IACF;AAEA,WAAO;EACT;EAEQ,SAAU,IAAa;AAC7B,eAAW,SAAS,GAAG,aAAY,GAAI;AACrC,UAAI,MAAM,CAAC,MAAM,WAAW;AAC1B,eAAO,MAAM,CAAC;MAChB;AAEA,UAAI,MAAM,CAAC,MAAM,aAAa,MAAM,CAAC,MAAM,cAAc,MAAM,CAAC,MAAM,cAAc,MAAM,CAAC,MAAM,eAAe;AAC9G,eAAO,MAAM,CAAC;MAChB;IACF;EACF;;;;AC7JF,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,YAAY;AAClB,IAAM,YAAY;AAEZ,IAAO,aAAP,MAAiB;EAIrB,YAAa,YAAsC,OAA2B,CAAA,GAAE;AAH/D;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,oCAAoC;AAC9E,SAAK,WAAW,oBAAI,IAAG;EACzB;EAEA,IAAK,IAAa;AAChB,UAAM,SAAS,GAAG,aAAY;AAE9B,eAAW,YAAY,KAAK,SAAS,OAAM,GAAI;AAC7C,iBAAW,WAAW,UAAU;AAC9B,YAAI,QAAQ,eAAe,OAAO,CAAC,EAAE,CAAC,GAAG;AACvC,iBAAO;QACT;MACF;IACF;AAEA,WAAO;EACT;EAEA,IAAK,YAAoB,cAAsB,YAAoB,eAAuB,cAAc,WAA0B,OAAK;AACrI,UAAM,MAAM,GAAG,UAAU,IAAI,YAAY,IAAI,QAAQ;AACrD,UAAM,WAAW,KAAK,SAAS,IAAI,GAAG,KAAK,CAAA;AAC3C,UAAM,UAAgC;MACpC;MACA;MACA;MACA;MACA,gBAAgB,OAAO,UAAU,IAAI,IAAI;MACzC;MACA,UAAU;MACV,SAAS;;AAEX,aAAS,KAAK,OAAO;AAErB,SAAK,SAAS,IAAI,KAAK,QAAQ;EACjC;EAEA,OAAQ,IAAa;AACnB,UAAM,SAAS,GAAG,aAAY;AAC9B,UAAM,OAAO,OAAO,CAAC,EAAE,CAAC,KAAK;AAC7B,UAAM,WAAW,OAAO,CAAC,EAAE,CAAC,MAAM,YAAY,QAAQ;AACtD,UAAM,OAAO,SAAS,OAAO,CAAC,EAAE,CAAC,KAAK,GAAG;AACzC,QAAI,eAAe;AAEnB,eAAW,CAAC,KAAK,QAAQ,KAAK,KAAK,SAAS,QAAO,GAAI;AACrD,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,cAAM,UAAU,SAAS,CAAC;AAE1B,YAAI,QAAQ,eAAe,QAAQ,QAAQ,iBAAiB,QAAQ,QAAQ,aAAa,UAAU;AACjG,eAAK,IAAI,yCAAyC,QAAQ,YAAY,QAAQ,cAAc,MAAM,MAAM,QAAQ;AAEhH,yBAAe,gBAAgB,QAAQ;AACvC,mBAAS,OAAO,GAAG,CAAC;AACpB;QACF;MACF;AAEA,UAAI,SAAS,WAAW,GAAG;AACzB,aAAK,SAAS,OAAO,GAAG;MAC1B;IACF;AAEA,WAAO;EACT;EAEA,OAAQ,WAAwB;AAC9B,UAAM,oBAAmC,CAAA;AAEzC,eAAW,EAAE,WAAW,GAAE,KAAM,WAAW;AACzC,YAAM,SAAS,GAAG,aAAY;AAC9B,UAAI;AAGJ,WAAK,OAAO,CAAC,EAAE,CAAC,MAAM,aAAa,OAAO,CAAC,EAAE,CAAC,MAAM,cAAc,OAAO,CAAC,EAAE,CAAC,MAAM,WAAW;AAC5F,gBAAQ,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;MACzC,YAAY,OAAO,CAAC,EAAE,CAAC,MAAM,aAAa,OAAO,CAAC,EAAE,CAAC,MAAM,cAAc,OAAO,CAAC,EAAE,CAAC,MAAM,WAAW;AACnG,gBAAQ,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;MACzC;AAEA,UAAI,SAAS,MAAM;AACjB;MACF;AAEA,YAAM,WAAW,KAAK,SAAS,IAAI,KAAK;AAExC,UAAI,YAAY,MAAM;AACpB;MACF;AAEA,iBAAW,WAAW,UAAU;AAC9B,eAAO,CAAC,EAAE,CAAC,IAAI,QAAQ,mBAAmB,IAAI,YAAY;AAC1D,eAAO,CAAC,EAAE,CAAC,IAAI,QAAQ;AACvB,eAAO,CAAC,EAAE,CAAC,IAAI,GAAG,QAAQ,YAAY;AAEtC,0BAAkB,KAAK;UACrB,WAAW,UAAU,IACnB,OAAO,IAAI,CAAAC,WAAQ;AACjB,mBAAO;cACL,YAAUA,OAAM,CAAC,CAAC,EAAE;cACpBA,OAAM,CAAC;cACP,KAAK,GAAG;UACZ,CAAC,EAAE,KAAK,GAAG,CACb,EAAE;UACF,UAAU,QAAQ;UAClB,MAAM;UACN,SAAS,QAAQ;UACjB,cAAc,QAAQ;SACvB;MACH;IACF;AAEA,WAAO;EACT;EAEA,QAAS,IAAe,KAAW;AACjC,UAAM,SAAS,GAAG,aAAY;AAC9B,UAAM,OAAO,OAAO,CAAC,EAAE,CAAC;AACxB,QAAI,qBAAqB;AAEzB,eAAW,YAAY,KAAK,SAAS,OAAM,GAAI;AAC7C,iBAAW,WAAW,UAAU;AAE9B,YAAI,QAAQ,eAAe,MAAM;AAC/B,eAAK,IAAI,2CAA2C,QAAQ,YAAY,QAAQ,UAAU;AAC1F,+BAAqB,QAAQ;AAC7B,kBAAQ,WAAW;AACnB,kBAAQ,UAAU,KAAK,IAAG,IAAK;AAC/B,kBAAQ,eAAe,KAAK,IAAG;QACjC;MACF;IACF;AAEA,WAAO;EACT;EAEA,UAAW,IAAe,KAAW;AACnC,UAAM,SAAS,GAAG,aAAY;AAC9B,UAAM,OAAO,OAAO,CAAC,EAAE,CAAC,KAAK;AAC7B,UAAM,WAAW,OAAO,CAAC,EAAE,CAAC,MAAM,YAAY,QAAQ;AACtD,UAAM,OAAO,SAAS,OAAO,CAAC,EAAE,CAAC,KAAK,GAAG;AACzC,QAAI,eAAe;AAEnB,eAAW,YAAY,KAAK,SAAS,OAAM,GAAI;AAC7C,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,cAAM,UAAU,SAAS,CAAC;AAE1B,YAAI,QAAQ,eAAe,QAAQ,QAAQ,iBAAiB,QAAQ,QAAQ,aAAa,UAAU;AACjG,eAAK,IAAI,yDAAyD,QAAQ,YAAY,QAAQ,cAAc,MAAM,MAAM,QAAQ;AAEhI,yBAAe,gBAAgB,QAAQ;AACvC,kBAAQ,WAAW;AACnB,kBAAQ,UAAU,KAAK,IAAG,IAAK;QACjC;MACF;IACF;AAEA,WAAO;EACT;;;;AC3LF,IAAMC,aAAY;AAClB,IAAMC,aAAY;AAKZ,SAAU,YAAa,IAAa;AACxC,MAAI;AACF,UAAM,CAAC,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG,aAAY;AAExC,QAAI,SAAS,MAAM;AACjB,aAAO;IACT;AAEA,QAAI,UAAUD,YAAW;AACvB,aAAO,MAAM,WAAW,UAAU;IACpC;AAEA,QAAI,UAAUC,YAAW;AACvB,aAAO,MAAM,YAAW,EAAG,WAAW,MAAM;IAC9C;EACF,QAAQ;EAER;AAEA,SAAO;AACT;;;ACzBA,IAAMC,aAAY;AAClB,IAAMC,aAAY;AAClB,IAAMC,aAAY;AAClB,IAAMC,cAAa;AACnB,IAAMC,cAAa;AACnB,IAAMC,iBAAgB;AAKhB,SAAU,UAAW,IAAa;AACtC,MAAI;AACF,UAAM,CAAC,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG,aAAY;AAExC,QAAI,SAAS,MAAM;AACjB,aAAO;IACT;AAEA,QAAI,UAAUH,cAAa,UAAUC,eAAc,UAAUC,eAAc,UAAUC,gBAAe;AAClG,aAAO;IACT;AAEA,QAAI,UAAUL,cAAa,UAAUC,YAAW;AAC9C,aAAO,YAAY,KAAK,KAAK;IAC/B;EACF,QAAQ;EAER;AAEA,SAAO;AACT;;;ACzBO,IAAM,gBAAgB;EAC3B,sBAAsB;;AASlB,IAAO,oBAAP,MAAwB;EAK5B,YAAa,YAAsC,OAA2B,CAAA,GAAE;AAJ/D;AACA;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,2CAA2C;AACrF,SAAK,YAAY,oBAAI,IAAG;AACxB,SAAK,uBAAuB,KAAK,wBAAwB,cAAc;EACzE;EAEA,IAAK,IAAa;AAChB,WAAO,KAAK,UAAU,IAAI,GAAG,SAAQ,CAAE;EACzC;EAEA,eAAgB,QAAc;AAC5B,eAAW,OAAO,KAAK,UAAU,KAAI,GAAI;AACvC,UAAI,IAAI,SAAQ,EAAG,WAAW,MAAM,GAAG;AACrC,aAAK,UAAU,OAAO,GAAG;MAC3B;IACF;EACF;EAEA,IAAK,IAAa;AAChB,QAAI,KAAK,UAAU,SAAS,KAAK,sBAAsB;AACrD;IACF;AAEA,QAAI,UAAU,EAAE,KAAK,YAAY,EAAE,GAAG;AACpC;IACF;AAEA,SAAK,IAAI,8BAA8B,EAAE;AACzC,SAAK,UAAU,IAAI,GAAG,SAAQ,GAAI;MAChC,UAAU;MACV,SAAS;KACV;EACH;EAEA,SAAM;AACJ,WAAO,MAAM,KAAK,KAAK,SAAS,EAC7B,IAAI,CAAC,CAAC,IAAI,QAAQ,OAAO;MACxB,WAAW,UAAU,EAAE;MACvB,UAAU,SAAS;MACnB,MAAM;MACN,SAAS,SAAS;MAClB,cAAc,SAAS;MACvB;EACN;EAEA,OAAQ,IAAa;AApEvB,QAAAK;AAqEI,UAAM,uBAAqBA,OAAA,KAAK,UAAU,IAAI,GAAG,SAAQ,CAAE,MAAhC,gBAAAA,KAAmC,aAAY;AAE1E,SAAK,IAAI,gCAAgC,EAAE;AAC3C,SAAK,UAAU,OAAO,GAAG,SAAQ,CAAE;AAEnC,WAAO;EACT;EAEA,QAAS,IAAe,KAAW;AACjC,UAAM,aAAa,GAAG,SAAQ;AAC9B,UAAM,WAAW,KAAK,UAAU,IAAI,UAAU,KAAK;MACjD,UAAU;MACV,SAAS,KAAK,IAAG,IAAK;MACtB,cAAc,KAAK,IAAG;;AAExB,UAAM,qBAAqB,SAAS;AACpC,aAAS,WAAW;AACpB,aAAS,eAAe,KAAK,IAAG;AAEhC,SAAK,IAAI,2CAA2C,UAAU;AAC9D,SAAK,UAAU,IAAI,YAAY,QAAQ;AAEvC,WAAO;EACT;;;;ACtFK,IAAMC,iBAAgB;EAC3B,sBAAsB;;AASlB,IAAO,qBAAP,MAAyB;EAK7B,YAAa,YAAsC,OAA2B,CAAA,GAAE;AAJ/D;AACA;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,2CAA2C;AACrF,SAAK,YAAY,oBAAI,IAAG;AACxB,SAAK,uBAAuB,KAAK,wBAAwBA,eAAc;EACzE;EAEA,IAAKC,YAAsB,KAAW;AACpC,QAAI,UAAUA,UAAS,GAAG;AACxB,aAAO;QACL,WAAAA;QACA,UAAU;QACV,MAAM;QACN,SAAS,KAAK,IAAG,IAAK;QACtB,cAAc,KAAK,IAAG;;IAE1B;AAEA,UAAM,MAAM,KAAK,MAAMA,UAAS;AAChC,QAAI,WAAW,KAAK,UAAU,IAAI,GAAG;AAErC,QAAI,YAAY,MAAM;AACpB,iBAAW;QACT,UAAU;QACV,SAAS;;AAGX,WAAK,UAAU,IAAI,KAAK,QAAQ;IAClC;AAEA,WAAO;MACL,WAAAA;MACA,UAAU,SAAS;MACnB,MAAM;MACN,SAAS,SAAS;MAClB,cAAc,SAAS;;EAE3B;EAEA,IAAK,IAAa;AAChB,UAAM,MAAM,KAAK,MAAM,EAAE;AACzB,WAAO,KAAK,UAAU,IAAI,GAAG;EAC/B;EAEA,OAAQ,IAAa;AAhEvB,QAAAC;AAiEI,UAAM,MAAM,KAAK,MAAM,EAAE;AACzB,UAAM,uBAAqBA,OAAA,KAAK,UAAU,IAAI,GAAG,MAAtB,gBAAAA,KAAyB,aAAY;AAEhE,SAAK,IAAI,gCAAgC,EAAE;AAC3C,SAAK,UAAU,OAAO,GAAG;AAEzB,WAAO;EACT;EAEA,QAAS,IAAe,KAAW;AACjC,UAAM,MAAM,KAAK,MAAM,EAAE;AACzB,UAAM,WAAW,KAAK,UAAU,IAAI,GAAG,KAAK;MAC1C,UAAU;MACV,SAAS;MACT,cAAc;;AAGhB,UAAM,qBAAqB,SAAS;AAEpC,aAAS,WAAW;AACpB,aAAS,UAAU,KAAK,IAAG,IAAK;AAChC,aAAS,eAAe,KAAK,IAAG;AAEhC,SAAK,UAAU,IAAI,KAAK,QAAQ;AAEhC,WAAO;EACT;EAEA,UAAW,IAAe,KAAW;AACnC,UAAM,MAAM,KAAK,MAAM,EAAE;AACzB,UAAM,WAAW,KAAK,UAAU,IAAI,GAAG,KAAK;MAC1C,UAAU;MACV,SAAS;;AAGX,UAAM,qBAAqB,SAAS;AAEpC,aAAS,WAAW;AACpB,aAAS,UAAU,KAAK,IAAG,IAAK;AAEhC,SAAK,UAAU,IAAI,KAAK,QAAQ;AAEhC,WAAO;EACT;EAEQ,MAAO,IAAa;AAC1B,UAAM,UAAU,GAAG,UAAS;AAE5B,WAAO,GAAG,QAAQ,IAAI,IAAI,QAAQ,IAAI,IAAI,QAAQ,SAAS;EAC7D;;;;ACnGF,IAAM,aAAa;AAEZ,IAAMC,iBAAgB;EAC3B,sBAAsB;EACtB,wBAAwB,aAAa;EACrC,0BAA0B,aAAa;;AAyEzC,IAAM,uBAAuB,CAAC,UAAoC;AAKlE,SAAS,YAAa,IAAe,QAAc;AACjD,QAAM,oBAAoB,GAAG,UAAS;AAGtC,MAAI,qBAAqB,MAAM;AAC7B,UAAM,iBAAiB,iBAAiB,iBAAiB;AAGzD,QAAI,eAAe,OAAO,MAAM,GAAG;AACjC,WAAK,GAAG,YAAY,UAAU,QAAQ,OAAO,SAAQ,CAAE,EAAE,CAAC;IAC5D;EACF;AAEA,SAAO;AACT;AAhHA,IAAAC;AAkHM,IAAO,iBAAP,MAAqB;;;;;;;EAsBzB,YAAa,YAAsC,OAA2B,CAAA,GAAE;AArB/D;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuCR,wBAACA,KAAsB;AA9B9B,UAAM,EAAE,SAAS,CAAA,GAAI,WAAW,CAAA,GAAI,iBAAiB,CAAA,EAAE,IAAK;AAE5D,SAAK,aAAa;AAClB,SAAK,MAAM,WAAW,OAAO,aAAa,wBAAwB;AAClE,SAAK,SAAS,OAAO,IAAI,QAAM,GAAG,SAAQ,CAAE;AAC5C,SAAK,WAAW,IAAI,IAAI,SAAS,IAAI,QAAM,GAAG,SAAQ,CAAE,CAAC;AACzD,SAAK,iBAAiB,IAAI,IAAI,eAAe,IAAI,QAAM,GAAG,SAAQ,CAAE,CAAC;AACrE,SAAK,WAAW,IAAI,kBAAkB,YAAY,IAAI;AACtD,SAAK,cAAc,IAAI,YAAY,YAAY,IAAI;AACnD,SAAK,aAAa,IAAI,WAAW,YAAY,IAAI;AACjD,SAAK,qBAAqB,IAAI,mBAAmB,YAAY,IAAI;AACjE,SAAK,iBAAiB,KAAK,kBAAkB;AAC7C,SAAK,wBAAwB,2BAA2B,IAAI;AAC5D,SAAK,yBAAyB,KAAK,0BAA0BD,eAAc;AAC3E,SAAK,2BAA2B,KAAK,4BAA4BA,eAAc;AAI/E,SAAK,4BAA4B,SAAS,KAAK,0BAA0B,KAAK,IAAI,GAAG,GAAI;AAGzF,eAAW,OAAO,iBAAiB,uBAAuB,MAAK;AAC7D,WAAK,0BAAyB;IAChC,CAAC;AAED,eAAW,OAAO,iBAAiB,mBAAmB,MAAK;AACzD,WAAK,0BAAyB;IAChC,CAAC;EACH;EAIA,4BAAyB;AAGvB,UAAM,QAAQ,KAAK,aAAY,EAC5B,IAAI,QAAK;AAER,UAAI,GAAG,UAAS,MAAO,KAAK,WAAW,OAAO,SAAQ,GAAI;AACxD,eAAO,GAAG,YAAY,QAAQ,KAAK,WAAW,OAAO,SAAQ,CAAE,EAAE;MACnE;AAEA,aAAO;IACT,CAAC;AAEH,SAAK,WAAW,UAAU,MAAM,KAAK,WAAW,QAAQ;MACtD,YAAY;KACb,EACE,MAAM,SAAM;AACX,WAAK,IAAI,MAAM,4BAA4B,GAAG;IAChD,CAAC;EACL;;;;EAKA,iBAAc;AACZ,WAAO,MAAM,KAAK,KAAK,MAAM,EAAE,IAAI,CAAC,MAAM,UAAU,CAAC,CAAC;EACxD;;;;EAKA,mBAAgB;AACd,WAAO,MAAM,KAAK,KAAK,QAAQ,EAAE,IAAI,CAAC,MAAM,UAAU,CAAC,CAAC;EAC1D;;;;EAKA,yBAAsB;AACpB,WAAO,MAAM,KAAK,KAAK,cAAc,EAAE,IAAI,CAAC,MAAM,UAAU,CAAC,CAAC;EAChE;;;;EAKA,mBAAgB;AACd,WAAO,KAAK,SAAS,OAAM,EAAG,IAAI,UAAQ,KAAK,SAAS;EAC1D;;;;EAKA,gBAAiB,MAAe;AAC9B,UAAM,SAAS,KAAK,aAAY;AAChC,UAAM,gBAAgB,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,EAAE,CAAC,CAAC;AAGrD,QAAI,KAAK,sBAAsB,IAAI,aAAa,GAAG;AACjD;IACF;AAEA,SAAK,sBAAsB,IAAI,aAAa;AAE5C,WAAO,YAAY,MAAM,KAAK,WAAW,MAAM;AAG/C,QAAI,KAAK,WAAW,IAAI,IAAI,GAAG;AAC7B;IACF;AAGA,QAAI,KAAK,YAAY,IAAI,IAAI,GAAG;AAC9B;IACF;AAEA,SAAK,SAAS,IAAI,IAAI;EACxB;EAEA,oBAAqB,MAAiB,SAA+B;AACnE,WAAO,YAAY,MAAM,KAAK,WAAW,MAAM;AAC/C,QAAI,qBAAqB;AAEzB,SAAI,mCAAS,UAAS,cAAc,KAAK,SAAS,IAAI,IAAI,GAAG;AAC3D,2BAAqB,KAAK,SAAS,QAAQ,OAAM,mCAAS,QAAO,KAAK,sBAAsB;IAC9F;AAEA,SAAI,mCAAS,UAAS,eAAe,KAAK,mBAAmB,IAAI,IAAI,GAAG;AACtE,2BAAqB,KAAK,mBAAmB,QAAQ,OAAM,mCAAS,QAAO,KAAK,sBAAsB;IACxG;AAEA,SAAI,mCAAS,UAAS,iBAAiB,KAAK,YAAY,IAAI,IAAI,GAAG;AACjE,2BAAqB,KAAK,YAAY,QAAQ,OAAM,mCAAS,QAAO,KAAK,sBAAsB;IACjG;AAEA,SAAI,mCAAS,UAAS,gBAAgB,KAAK,WAAW,IAAI,IAAI,GAAG;AAC/D,2BAAqB,KAAK,WAAW,QAAQ,OAAM,mCAAS,QAAO,KAAK,sBAAsB;IAChG;AAGA,QAAI,CAAC,oBAAoB;AACvB,WAAK,0BAAyB;IAChC;EACF;EAEA,mBAAoB,MAAiB,SAA+B;AAClE,WAAO,YAAY,MAAM,KAAK,WAAW,MAAM;AAE/C,QAAI,qBAAqB;AAEzB,QAAI,KAAK,SAAS,IAAI,IAAI,GAAG;AAC3B,2BAAqB,KAAK,SAAS,OAAO,IAAI;IAChD;AAEA,QAAI,KAAK,mBAAmB,IAAI,IAAI,GAAG;AACrC,2BAAqB,KAAK,mBAAmB,UAAU,OAAM,mCAAS,QAAO,KAAK,wBAAwB;IAC5G;AAEA,QAAI,KAAK,YAAY,IAAI,IAAI,GAAG;AAC9B,2BAAqB,KAAK,YAAY,UAAU,OAAM,mCAAS,QAAO,KAAK,wBAAwB;IACrG;AAEA,QAAI,KAAK,WAAW,IAAI,IAAI,GAAG;AAC7B,2BAAqB,KAAK,WAAW,UAAU,OAAM,mCAAS,QAAO,KAAK,wBAAwB;IACpG;AAGA,QAAI,oBAAoB;AACtB,WAAK,0BAAyB;IAChC;EACF;EAEA,eAAY;AACV,UAAM,YAAY,oBAAI,IAAG;AAEzB,UAAM,aAAa,KAAK,yBAAwB,EAC7C,OAAO,UAAO;AACb,UAAI,CAAC,KAAK,UAAU;AAClB,eAAO;MACT;AAEA,YAAM,QAAQ,KAAK,UAAU,SAAQ;AAErC,UAAI,UAAU,IAAI,KAAK,GAAG;AACxB,eAAO;MACT;AAEA,gBAAU,IAAI,KAAK;AAEnB,aAAO;IACT,CAAC,EACA,IAAI,aAAW,QAAQ,SAAS;AAGnC,WAAO,KAAK,eACV,WAAW,IAAI,SAAM;AAnU3B,UAAAC;AAoUQ,YAAM,KAAK,UAAU,GAAG;AAGxB,YAAIA,OAAA,GAAG,OAAM,EAAG,IAAG,MAAf,gBAAAA,KAAmB,UAAS,MAAM;AACpC,eAAO;MACT;AAEA,UAAI,GAAG,UAAS,MAAO,KAAK,WAAW,OAAO,SAAQ,GAAI;AACxD,eAAO;MACT;AAEA,aAAO,GAAG,YAAY,QAAQ,KAAK,WAAW,OAAO,SAAQ,CAAE,EAAE;IACnE,CAAC,CAAC;EAEN;EAEA,2BAAwB;AACtB,UAAM,qBAAqB,KAAK,iBAAgB;AAEhD,QAAI,mBAAmB,SAAS,GAAG;AACjC,aAAO,mBAAmB,IAAI,CAAAC,gBAAc;QAC1C,WAAAA;QACA,UAAU;QACV,MAAM;QACN,SAAS,KAAK,IAAG,IAAK,KAAK;QAC3B,cAAc,KAAK,IAAG;QACtB;IACJ;AAEA,QAAI,YAA2B,CAAA;AAG/B,gBAAY,UAAU,OACpB,KAAK,WAAW,iBAAiB,SAAQ,EACtC,IAAI,CAAAA,eAAa,KAAK,mBAAmB,IAAIA,YAAW,KAAK,sBAAsB,CAAC,CAAC;AAI1F,gBAAY,UAAU,OACpB,KAAK,uBAAsB,EAAG,IAAI,CAAAA,gBAAc;MAC9C,WAAAA;MACA,UAAU;MACV,MAAM;MACN,SAAS,KAAK,IAAG,IAAK,KAAK;MAC3B,cAAc,KAAK,IAAG;MACtB,CAAC;AAIL,gBAAY,UAAU,OACpB,KAAK,SAAS,OAAM,CAAE;AAIxB,gBAAY,UAAU,OACpB,KAAK,WAAW,OAAO,SAAS,CAAC;AAInC,gBAAY,UAAU,OACpB,KAAK,YAAY,OAAO,SAAS,CAAC;AAGpC,WAAO;EACT;EAEA,cAAe,QAAgB,WAAmB;AAChD,SAAK,YAAY,IAAI,QAAQ,SAAS;EACxC;EAEA,iBAAkB,QAAc;AAC9B,QAAI,KAAK,YAAY,OAAO,UAAU,QAAQ,MAAM,EAAE,CAAC,GAAG;AACxD,WAAK,0BAAyB;IAChC;EACF;EAEA,wBAAyB,YAAoB,cAAsB,YAAoB,eAAuB,cAAc,WAA0B,OAAK;AACzJ,SAAK,WAAW,IAAI,YAAY,cAAc,YAAY,cAAc,QAAQ;AAGhF,SAAK,SAAS,eAAe,MAAM,OAAO,UAAU,IAAI,IAAI,CAAC,IAAI,UAAU,IAAI,QAAQ,IAAI,YAAY,EAAE;EAC3G;EAEA,2BAA4B,YAAoB,cAAsB,YAAoB,eAAuB,cAAc,WAA0B,OAAK;AAC5J,QAAI,KAAK,WAAW,OAAO,UAAU,MAAM,OAAO,UAAU,IAAI,IAAI,CAAC,IAAI,UAAU,IAAI,QAAQ,IAAI,YAAY,EAAE,CAAC,GAAG;AACnH,WAAK,0BAAyB;IAChC;EACF;;AApPUD,MAAA,OAAO;;;ACvKnB,IAAY;CAAZ,SAAYE,WAAQ;AAClB,EAAAA,UAAA,iBAAA,IAAA;AACA,EAAAA,UAAA,WAAA,IAAA;AACF,GAHY,aAAA,WAAQ,CAAA,EAAA;AAKd,IAAO,sBAAP,cAAmC,MAAK;EAC5C,YAAaC,WAAU,mBAAiB;AACtC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,gCAAP,cAA6C,MAAK;EACtD,YAAaA,WAAU,8BAA4B;AACjD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaA,WAAU,gCAA8B;AACnD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,qBAAP,cAAkC,MAAK;EAC3C,YAAaA,WAAU,6BAA2B;AAChD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,sBAAP,cAAmC,MAAK;EAC5C,YAAaA,WAAU,+BAA6B;AAClD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,yBAAP,cAAsC,MAAK;EAC/C,YAAaA,WAAU,4BAA0B;AAC/C,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,gCAAP,cAA6C,MAAK;EACtD,YAAaA,WAAU,oCAAkC;AACvD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,kBAAP,cAA+B,MAAK;EACxC,YAAaA,WAAU,qBAAmB;AACxC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaA,WAAU,sBAAoB;AACzC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,6BAAP,cAA0C,MAAK;EACnD,YAAaA,WAAU,0BAAwB;AAC7C,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaA,WAAU,qBAAmB;AACxC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaA,WAAU,6BAA2B;AAChD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,wBAAP,cAAqC,MAAK;EAC9C,YAAaA,WAAU,qBAAmB;AACxC,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AAGI,IAAO,4BAAP,cAAyC,MAAK;EAClD,YAAaA,WAAU,yBAAuB;AAC5C,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;;;AChDF,IAAM,oBAAN,MAAuB;EAIrB,YAAa,OAAuB,CAAA,GAAE;AAH/B,sCAAkC,CAAA;AACjC,oCAAW;AAGjB,SAAK,aAAa,CAAA;AAElB,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,IAAI,GAAG;AAC/C,WAAK,WAAW,GAAG,IAAI;IACzB;AAEA,QAAI,KAAK,WAAW,UAAU,MAAM;AAClC,WAAK,WAAW,SAAS,cAAa;IACxC;EACF;EAEA,YAAS;AACP,WAAO,KAAK;EACd;EAEQ,MAAM,uBAAwB,YAAwF;AAC5H,UAAM,QAAQ,IACZ,OAAO,OAAO,KAAK,UAAU,EAC1B,OAAO,SAAO,YAAY,GAAG,CAAC,EAC9B,IAAI,OAAO,cAAwB;AA5E5C,UAAAC;AA6EU,cAAMA,OAAA,UAAU,gBAAV,gBAAAA,KAAA;IACR,CAAC,CAAC;EAER;EAEA,MAAM,cAAW;AACf,UAAM,KAAK,uBAAuB,aAAa;EACjD;EAEA,MAAM,QAAK;AACT,UAAM,KAAK,uBAAuB,OAAO;AACzC,SAAK,WAAW;EAClB;EAEA,MAAM,aAAU;AACd,UAAM,KAAK,uBAAuB,YAAY;EAChD;EAEA,MAAM,aAAU;AACd,UAAM,KAAK,uBAAuB,YAAY;EAChD;EAEA,MAAM,OAAI;AACR,UAAM,KAAK,uBAAuB,MAAM;AACxC,SAAK,WAAW;EAClB;EAEA,MAAM,YAAS;AACb,UAAM,KAAK,uBAAuB,WAAW;EAC/C;;AAGF,IAAM,oBAAoB;EACxB;EACA;EACA;;AAGF,IAAM,yBAAyB;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGI,SAAU,kBAAmB,OAAuB,CAAA,GAAE;AAC1D,QAAM,aAAa,IAAI,kBAAkB,IAAI;AAE7C,QAAM,QAAQ,IAAI,MAAM,YAAY;IAClC,IAAK,QAAQ,MAAM,UAAQ;AACzB,UAAI,OAAO,SAAS,YAAY,CAAC,uBAAuB,SAAS,IAAI,GAAG;AACtE,cAAM,UAAU,WAAW,WAAW,IAAI;AAE1C,YAAI,WAAW,QAAQ,CAAC,kBAAkB,SAAS,IAAI,GAAG;AACxD,gBAAM,IAAI,oBAAoB,GAAG,IAAI,UAAU;QACjD;AAEA,eAAO;MACT;AAEA,aAAO,QAAQ,IAAI,QAAQ,MAAM,QAAQ;IAC3C;IAEA,IAAK,QAAQ,MAAM,OAAK;AACtB,UAAI,OAAO,SAAS,UAAU;AAC5B,mBAAW,WAAW,IAAI,IAAI;MAChC,OAAO;AACL,gBAAQ,IAAI,QAAQ,MAAM,KAAK;MACjC;AAEA,aAAO;IACT;GACD;AAGD,SAAO;AACT;AAEM,SAAU,yBAA0B,YAAsB;AAC9D,QAAMC,uBAAwD,CAAA;AAE9D,aAAW,WAAW,OAAO,OAAO,WAAW,UAAU,GAAG;AAC1D,eAAW,cAAc,uBAAuB,OAAO,GAAG;AACxD,MAAAA,qBAAoB,UAAU,IAAI;IACpC;EACF;AAEA,aAAW,WAAW,OAAO,OAAO,WAAW,UAAU,GAAG;AAC1D,eAAW,cAAc,uBAAuB,OAAO,GAAG;AACxD,UAAIA,qBAAoB,UAAU,MAAM,MAAM;AAC5C,cAAM,IAAI,8BAA8B,YAAY,eAAe,OAAO,CAAC,0BAA0B,UAAU,mHAAmH;MACpO;IACF;EACF;AACF;AAEA,SAAS,uBAAwB,SAAY;AAC3C,MAAI,MAAM,QAAQ,mCAAU,oBAAoB,GAAG;AACjD,WAAO,QAAQ,mBAAmB;EACpC;AAEA,SAAO,CAAA;AACT;AAEA,SAAS,uBAAwB,SAAY;AAC3C,MAAI,MAAM,QAAQ,mCAAU,oBAAoB,GAAG;AACjD,WAAO,QAAQ,mBAAmB;EACpC;AAEA,SAAO,CAAA;AACT;AAEA,SAAS,eAAgB,SAAY;AACnC,UAAO,mCAAU,OAAO,kBAAgB,mCAAS,eAAc;AACjE;;;AChMA,IAAMC,aAAY;AAClB,IAAMC,aAAY;AAWZ,SAAU,gBAAiB,QAAyB,CAAA,GAAE;AAC1D,SAAO;IACL,cAAc,YAAY;IAC1B,mBAAmB,OAAOC,eAAwB;AAEhD,UAAI,WAAW,QAAQA,UAAS,GAAG;AACjC,eAAO;MACT;AAEA,YAAM,SAASA,WAAU,aAAY;AAGrC,UAAI,OAAO,CAAC,EAAE,CAAC,MAAMF,cAAa,OAAO,CAAC,EAAE,CAAC,MAAMC,YAAW;AAC5D,eAAO,QAAQ,YAAY,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;MAC/C;AAEA,aAAO;IACT;IACA,uBAAuB,YAAY;IACnC,wBAAwB,YAAY;IACpC,gCAAgC,YAAY;IAC5C,iCAAiC,YAAY;IAC7C,+BAA+B,YAAY;IAC3C,gCAAgC,YAAY;IAC5C,wBAAwB,YAAY;IACpC,GAAG;;AAEP;;;ACzCA,IAAM,mBAAmB,MAAM;AAC9B,QAAM,QAAQ,IAAI,MAAM,eAAe;AACvC,QAAM,OAAO;AACb,SAAO;AACR;AAEA,IAAM,eAAe,oBAAI,QAAQ;AAE1B,SAAS,YAAY,EAAC,cAAc,cAAc,YAAY,WAAU,IAAI,CAAC,GAAG;AAEtF,SAAO,CAAC,cAAc,EAAC,OAAO,OAAM,IAAI,CAAC,MAAM;AAE9C,QAAI,iCAAQ,SAAS;AACpB,aAAO,QAAQ,OAAO,iBAAiB,CAAC;AAAA,IACzC;AAEA,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,UAAM,QAAQ,gBAAgB;AAE9B,UAAM,iBAAiB,MAAM;AAC5B,YAAM,SAAS;AACf,qBAAe,iBAAiB,CAAC;AAAA,IAClC;AAEA,UAAM,UAAU,MAAM;AACrB,UAAI,QAAQ;AACX,eAAO,oBAAoB,SAAS,cAAc;AAAA,MACnD;AAAA,IACD;AAEA,UAAM,eAAe,IAAI,QAAQ,CAAC,SAAS,WAAW;AACrD,eAAS,MAAM;AACd,gBAAQ;AACR,gBAAQ,KAAK;AAAA,MACd;AAEA,uBAAiB;AACjB,mBAAa,cAAc,YAAY,QAAQ,YAAY;AAAA,IAC5D,CAAC;AAED,QAAI,QAAQ;AACX,aAAO,iBAAiB,SAAS,gBAAgB,EAAC,MAAM,KAAI,CAAC;AAAA,IAC9D;AAEA,iBAAa,IAAI,cAAc,MAAM;AACpC,YAAM,SAAS;AACf,kBAAY;AACZ,aAAO;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACR;AACD;AAEA,IAAM,QAAQ,YAAY;AAE1B,IAAO,gBAAQ;;;ACxDT,IAAO,iBAAP,cAA8B,MAAK;EAMvC,YAAaE,WAAU,uBAAuB,OAAwB;AACpE,UAAMA,QAAO;AANf;AACA;AACA;AACA;AAIE,SAAK,OAAO;AACZ,SAAK,kBAAkB,MAAM;AAC7B,SAAK,eAAe,MAAM;AAC1B,SAAK,iBAAiB,MAAM;AAC5B,SAAK,oBAAoB,MAAM;EACjC;;AAGI,IAAO,iBAAP,cAA8B,MAAK;EAGvC,YAAaA,WAAkB,sBAAoB;AACjD,UAAMA,QAAO;AACb,SAAK,OAAO;EACd;;AALA,cADW,gBACJ,QAAO;;;ACwCV,IAAO,cAAP,MAAkB;EAStB,YAAa,OAAwB,CAAA,GAAE;AARvB;AACN;AACA;AACA;AACA;AACA;AACA;AAGR,SAAK,SAAS,KAAK,UAAU;AAC7B,SAAK,WAAW,KAAK,YAAY;AACjC,SAAK,gBAAgB,KAAK,iBAAiB;AAC3C,SAAK,aAAa,KAAK,cAAc;AACrC,SAAK,uBAAuB,KAAK,wBAAyB,KAAK,WAAW,MAAO,KAAK;AACtF,SAAK,YAAY,KAAK,aAAa;AACnC,SAAK,gBAAgB,IAAI,cAAa;EACxC;EAEA,MAAM,QAAS,KAAa,kBAA0B,GAAG,UAAoC,CAAA,GAAE;AAC7F,UAAM,QAAQ,KAAK,OAAO,GAAG;AAC7B,UAAM,cAAc,KAAK,mBAAmB,OAAO;AACnD,QAAI,MAAM,KAAK,cAAc,OAAO,OAAO,iBAAiB,WAAW;AACvE,QAAI,kBAAkB,KAAK,IAAI,KAAK,SAAS,IAAI,gBAAgB,CAAC;AAElE,QAAI,IAAI,iBAAiB,KAAK,QAAQ;AAEpC,UAAI,KAAK,gBAAgB,KAAK,IAAI,kBAAmB,KAAK,SAAS,iBAAkB;AAEnF,cAAM,KAAK,cAAc,IAAI,OAAO,IAAI,gBAAgB,KAAK,aAAa;MAC5E;AAEA,YAAM,IAAI,eAAe,uBAAuB,GAAG;IACrD,WAAW,KAAK,cAAc,IAAI,eAAe,KAAK,CAAC,IAAI,mBAAmB;AAE5E,UAAI,UAAU,KAAK,KAAK,IAAI,gBAAgB,IAAI,kBAAkB,EAAE;AACpE,UAAI,UAAU,KAAK,sBAAsB;AACvC,kBAAU,IAAI,iBAAiB,KAAK;MACtC;AAEA,YAAM,cAAM,OAAO;IACrB;AAEA,WAAO;EACT;EAEA,QAAS,KAAa,SAAiB,GAAG,UAAoC,CAAA,GAAE;AAC9E,UAAM,QAAQ,KAAK,OAAO,GAAG;AAC7B,UAAM,cAAc,KAAK,mBAAmB,OAAO;AACnD,UAAM,MAAM,KAAK,cAAc,OAAO,OAAO,QAAQ,WAAW;AAChE,QAAI,kBAAkB,KAAK,IAAI,KAAK,SAAS,IAAI,gBAAgB,CAAC;AAElE,WAAO;EACT;EAEA,OAAQ,KAAa,SAAiB,GAAG,UAAoC,CAAA,GAAE;AAC7E,UAAM,QAAQ,KAAK,OAAO,GAAG;AAC7B,UAAM,cAAc,KAAK,mBAAmB,OAAO;AACnD,UAAM,MAAM,KAAK,cAAc,OAAO,OAAO,CAAC,QAAQ,WAAW;AACjE,QAAI,kBAAkB,KAAK,IAAI,KAAK,SAAS,IAAI,gBAAgB,CAAC;AAElE,WAAO;EACT;;;;;;;EAQA,MAAO,KAAa,aAAmB;AACrC,UAAM,aAAa,cAAc;AACjC,UAAM,aAAa,KAAK,SAAS;AAEjC,SAAK,cAAc,IAAI,KAAK,OAAO,GAAG,GAAG,YAAY,WAAW;AAEhE,WAAO;MACL,iBAAiB;MACjB,cAAc,eAAe,IAAI,KAAK;MACtC,gBAAgB;MAChB,mBAAmB;;EAEvB;EAEA,IAAK,KAAa,QAAgB,cAAsB,GAAC;AACvD,UAAM,cAAc,eAAe,IAAI,cAAc,KAAK,YAAY;AAEtE,SAAK,cAAc,IAAI,KAAK,OAAO,GAAG,GAAG,QAAQ,WAAW;AAE5D,WAAO;MACL,iBAAiB;MACjB,cAAc,eAAe,IAAI,KAAK;MACtC,gBAAgB;MAChB,mBAAmB;;EAEvB;EAEA,IAAK,KAAW;AACd,UAAM,MAAM,KAAK,cAAc,IAAI,KAAK,OAAO,GAAG,CAAC;AAEnD,QAAI,OAAO,MAAM;AACf,UAAI,kBAAkB,KAAK,IAAI,KAAK,SAAS,IAAI,gBAAgB,CAAC;IACpE;AAEA,WAAO;EACT;EAEA,OAAQ,KAAW;AACjB,SAAK,cAAc,OAAO,KAAK,OAAO,GAAG,CAAC;EAC5C;EAEQ,mBAAoB,SAAkC;AAC5D,SAAI,mCAAS,mBAAkB,QAAQ,QAAQ,kBAAkB,GAAG;AAClE,aAAO,QAAQ;IACjB;AAEA,WAAO,KAAK;EACd;EAEA,OAAQ,KAAW;AACjB,WAAO,KAAK,UAAU,SAAS,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,KAAK;EAClE;EAEA,SAAU,OAAa;AACrB,WAAO,MAAM,UAAU,KAAK,UAAU,MAAM;EAC9C;;AAGI,IAAO,gBAAP,MAAoB;EAGxB,cAAA;AAFgB;AAGd,SAAK,UAAU,oBAAI,IAAG;EACxB;EAEA,OAAQ,KAAa,OAAe,aAAmB;AACrD,UAAM,WAAW,KAAK,QAAQ,IAAI,GAAG;AAErC,QAAI,YAAY,MAAM;AACpB,YAAM,kBAAkB,SAAS,aAAa,OAC1C,SAAS,UAAU,QAAO,KAAK,oBAAI,KAAI,GAAG,QAAO,IACjD;AAEJ,UAAI,SAAS,aAAa,QAAQ,kBAAkB,GAAG;AAErD,iBAAS,SAAS;AAElB,eAAO;UACL,iBAAiB;UACjB,cAAc;UACd,gBAAgB,SAAS;UACzB,mBAAmB;;MAEvB;AAEA,aAAO,KAAK,IAAI,KAAK,OAAO,WAAW;IACzC;AAEA,WAAO,KAAK,IAAI,KAAK,OAAO,WAAW;EACzC;EAEA,IAAK,KAAa,OAAe,aAAmB;AAClD,UAAM,aAAa,cAAc;AACjC,UAAM,WAAW,KAAK,QAAQ,IAAI,GAAG;AAErC,QAAI,YAAY,MAAM;AACpB,mBAAa,SAAS,SAAS;IACjC;AAEA,UAAM,SAAqB;MACzB;MACA,WAAW,aAAa,IAAI,IAAI,KAAK,KAAK,IAAG,IAAK,UAAU,IAAI;;AAGlE,SAAK,QAAQ,IAAI,KAAK,MAAM;AAE5B,QAAI,aAAa,GAAG;AAClB,aAAO,YAAY,WAAW,MAAK;AACjC,aAAK,QAAQ,OAAO,GAAG;MACzB,GAAG,UAAU;AAEb,UAAI,OAAO,UAAU,SAAS,MAAM;AAClC,eAAO,UAAU,MAAK;MACxB;IACF;AAEA,WAAO;MACL,iBAAiB;MACjB,cAAc,eAAe,IAAI,KAAK;MACtC,gBAAgB,OAAO;MACvB,mBAAmB;;EAEvB;EAEA,IAAK,KAAW;AACd,UAAM,WAAW,KAAK,QAAQ,IAAI,GAAG;AAErC,QAAI,YAAY,MAAM;AACpB,YAAM,kBAAkB,SAAS,aAAa,OAC1C,SAAS,UAAU,QAAO,KAAK,oBAAI,KAAI,GAAG,QAAO,IACjD;AACJ,aAAO;QACL,iBAAiB;QACjB,cAAc;QACd,gBAAgB,SAAS;QACzB,mBAAmB;;IAEvB;EACF;EAEA,OAAQ,KAAW;AACjB,UAAM,SAAS,KAAK,QAAQ,IAAI,GAAG;AAEnC,QAAI,UAAU,MAAM;AAClB,UAAI,OAAO,aAAa,MAAM;AAC5B,qBAAa,OAAO,SAAS;MAC/B;AAEA,WAAK,QAAQ,OAAO,GAAG;AAEvB,aAAO;IACT;AACA,WAAO;EACT;;;;AC/QI,SAAU,eAAgB,MAAsC;AACpE,MAAI,SAAS,IAAI,GAAG;AAClB,WAAO,EAAE,QAAQ,MAAM,YAAY,CAAA,EAAE;EACvC;AAEA,MAAI,CAAC,MAAM,QAAQ,IAAI,GAAG;AACxB,WAAO,CAAC,IAAI;EACd;AAEA,MAAI;AAEJ,MAAI,KAAK,SAAS,GAAG;AACnB,UAAM,YAAY,KAAK,CAAC,EAAE,UAAS;AACnC,aAAS,aAAa,OAAO,SAAY,iBAAiB,SAAS;AAGnE,SAAK,QAAQ,QAAK;AAChB,UAAI,CAAC,YAAY,EAAE,GAAG;AACpB,cAAM,IAAI,sBAAsB,mBAAmB;MACrD;AAEA,YAAM,cAAc,GAAG,UAAS;AAEhC,UAAI,eAAe,MAAM;AACvB,YAAI,UAAU,MAAM;AAClB,gBAAM,IAAI,uBAAuB,8DAA8D;QACjG;MACF,OAAO;AACL,cAAM,WAAW,iBAAiB,WAAW;AAE7C,aAAI,iCAAQ,OAAO,eAAc,MAAM;AACrC,gBAAM,IAAI,uBAAuB,8DAA8D;QACjG;MACF;IACF,CAAC;EACH;AAEA,SAAO;IACL;IACA,YAAY;;AAEhB;;;AClCA,IAAM,6BAA6B;;EAEjC;;EAGA;;EAGA;;EAGA;;AAiBF,eAAsB,8BAA+B,YAAyB,SAAsC;AA/CpH,MAAAC;AAgDE,QAAM,oBAAkBA,OAAA,yCAAY,YAAZ,gBAAAA,KAAqB,IAAI,YAAU,OAAO,cAAa,CAAA;AAC/E,QAAM,qBAAoB,mCAAS,sBAAqB;AAIxD,MAAI,gBAAgB,OAAO,WAAS,SAAS,QAAQ,CAAC,kBAAkB,SAAS,KAAK,CAAC,EAAE,SAAS,GAAG;AACnG;EACF;AAEA,MAAI;AACF,WAAM,yCAAY,MAAM;EAC1B,SAAS,KAAU;AACjB,6CAAY,MAAM;EACpB;AACF;;;AC7DO,IAAM,eAAe;AAKrB,IAAM,kBAAkB;AAKxB,IAAM,+BAA+B;AAKrC,IAAM,yBAAyB;AAK/B,IAAM,+BAA+B;AAKrC,IAAM,mCAAmC;AAKzC,IAAM,0BAA0B;AAUhC,IAAM,wBAAwB;AAO9B,IAAM,wBAAwB;AAK9B,IAAM,wBAAwB;;;AClD9B,IAAM,kBAAkB;AAKxB,IAAM,qBAAqB;;;ACFlC,eAAsB,kBAAmB,IAAe,SAAuC;AAE7F,MAAI,aAAa;AAEjB,aAAW,OAAO,UAAU,KAAI,GAAI;AAClC,iBAAa,GAAG,WAAU,EAAG,SAAS,GAAG;AAEzC,QAAI,YAAY;AACd;IACF;EACF;AAGA,MAAI,CAAC,YAAY;AACf,WAAO,CAAC,EAAE;EACZ;AAEA,QAAM,SAAS,MAAM,GAAG,QAAQ,OAAO;AAEvC,UAAQ,IAAI,kBAAkB,IAAI,OAAO,IAAI,CAAAC,QAAMA,IAAG,SAAQ,CAAE,CAAC;AAEjE,SAAO;AACT;AAYM,SAAU,iBAAkB,IAAsB;AACtD,MAAI;AACF,QAAI;AACJ,QAAI,OAAO,OAAO,UAAU;AAC1B,iBAAW,UAAU,EAAE;IACzB,OAAO;AACL,iBAAW;IACb;AAGA,QAAI,CAAC,SAAS,WAAU,EAAG,SAAS,QAAQ,GAAG;AAC7C,YAAMC,UAAS,SAAS,WAAU,EAAG,SAAS,KAAK;AACnD,YAAM,OAAOA,UAAS,gBAAgB;AACtC,iBAAW,SAAS,YAAY,IAAI;IACtC;AAEA,WAAO,eAAe,QAAQ;EAChC,SAAS,OAAO;AACd,UAAM,IAAI,MAAM,qDAAqD,EAAE,EAAE;EAC3E;AACF;;;ACzCA,IAAMC,kBAAiB;EACrB,gBAAgB;EAChB,OAAO,CAAA;;AAMH,IAAO,mBAAP,MAAuB;EAQ3B,YAAa,YAAwC,OAA6B,CAAA,GAAE;AAPnE;AACA;AACA;AACA;AACA;AACA;AAGf,SAAK,iBAAiB,KAAK,kBAAkBA,gBAAe;AAC5D,SAAK,SAAS,KAAK,SAAS,CAAA,GAAI,IAAI,QAAM,iBAAiB,EAAE,CAAC;AAC9D,SAAK,oBAAoB,WAAW;AACpC,SAAK,YAAY,WAAW;AAC5B,SAAK,SAAS,WAAW;AACzB,SAAK,MAAM,WAAW,OAAO,aAAa,6CAA6C;AACvF,SAAK,wBAAwB,KAAK,sBAAsB,KAAK,IAAI;EACnE;EAEA,QAAK;AACH,SAAK,OAAO,iBAAiB,mBAAmB,KAAK,qBAAqB;EAC5E;EAEA,OAAI;AACF,SAAK,OAAO,oBAAoB,mBAAmB,KAAK,qBAAqB;EAC/E;EAEA,wBAAqB;AACnB,SAAK,uBAAsB,EACxB,MAAM,SAAM;AACX,WAAK,IAAI,MAAM,sCAAsC,GAAG;IAC1D,CAAC;EACL;;;;;EAMQ,MAAM,yBAAsB;AAClC,UAAM,cAAc,KAAK,kBAAkB,eAAc;AACzD,UAAM,iBAAiB,YAAY;AAEnC,SAAK,IAAI,wCAAwC,gBAAgB,KAAK,cAAc;AAEpF,QAAI,kBAAkB,KAAK,gBAAgB;AACzC;IACF;AAEA,UAAM,aAAa,IAAI,QAAO;AAG9B,eAAW,cAAc,aAAa;AACpC,YAAM,aAAa,WAAW;AAE9B,UAAI,WAAW,IAAI,UAAU,GAAG;AAC9B;MACF;AAEA,iBAAW,IAAI,YAAY,CAAC;AAE5B,UAAI;AACF,cAAM,OAAO,MAAM,KAAK,UAAU,IAAI,UAAU;AAGhD,mBAAW,IAAI,YAAY,CAAC,GAAG,KAAK,KAAK,OAAM,CAAE,EAAE,OAAO,CAAC,KAAK,SAAQ;AACtE,iBAAO,MAAM,KAAK;QACpB,GAAG,CAAC,CAAC;MACP,SAAS,KAAU;AACjB,YAAI,IAAI,SAAS,iBAAiB;AAChC,eAAK,IAAI,MAAM,2BAA2B,GAAG;QAC/C;MACF;IACF;AAEA,UAAM,oBAAoB,KAAK,gBAAgB,aAAa,UAAU;AAGtE,UAAM,UAAU,KAAK,IAAI,iBAAiB,KAAK,gBAAgB,CAAC;AAChE,UAAM,UAAU,CAAA;AAEhB,eAAW,cAAc,mBAAmB;AAC1C,WAAK,IAAI,0DAA0D,WAAW,UAAU;AAExF,YAAM,wBAAwB,KAAK,MAAM,KAAK,CAAC,UAAS;AACtD,eAAO,MAAM,SAAS,WAAW,WAAW,YAAW,EAAG,OAAO;MACnE,CAAC;AAGD,UAAI,CAAC,uBAAuB;AAC1B,gBAAQ,KAAK,UAAU;MACzB;AAEA,UAAI,QAAQ,WAAW,SAAS;AAC9B;MACF;IACF;AAGA,UAAM,QAAQ,IACZ,QAAQ,IAAI,OAAM,eAAa;AAC7B,YAAM,8BAA8B,YAAY;QAC9C,QAAQ,YAAY,QAAQ,GAAI;OACjC;IACH,CAAC,CAAC;AAIJ,SAAK,OAAO,kBAAkB,oBAAoB,EAAE,QAAQ,QAAO,CAAE;EACvE;EAEA,gBAAiB,aAA2B,YAA2B;AACrE,WAAO,YAEJ,KAAK,CAAC,GAAG,MAAK;AACb,YAAM,sBAAsB,EAAE,SAAS;AACvC,YAAM,sBAAsB,EAAE,SAAS;AAEvC,UAAI,sBAAsB,qBAAqB;AAC7C,eAAO;MACT;AAEA,UAAI,sBAAsB,qBAAqB;AAC7C,eAAO;MACT;AAEA,aAAO;IACT,CAAC,EAEA,KAAK,CAAC,GAAG,MAAK;AACb,UAAI,EAAE,cAAc,cAAc,EAAE,cAAc,WAAW;AAC3D,eAAO;MACT;AAEA,UAAI,EAAE,cAAc,aAAa,EAAE,cAAc,YAAY;AAC3D,eAAO;MACT;AAEA,aAAO;IACT,CAAC,EAEA,KAAK,CAAC,GAAG,MAAK;AACb,UAAI,EAAE,QAAQ,SAAS,EAAE,QAAQ,QAAQ;AACvC,eAAO;MACT;AAEA,UAAI,EAAE,QAAQ,SAAS,EAAE,QAAQ,QAAQ;AACvC,eAAO;MACT;AAEA,aAAO;IACT,CAAC,EAEA,KAAK,CAAC,GAAG,MAAK;AACb,YAAM,aAAa,WAAW,IAAI,EAAE,UAAU,KAAK;AACnD,YAAM,aAAa,WAAW,IAAI,EAAE,UAAU,KAAK;AAEnD,UAAI,aAAa,YAAY;AAC3B,eAAO;MACT;AAEA,UAAI,aAAa,YAAY;AAC3B,eAAO;MACT;AAEA,aAAO;IACT,CAAC;EACL;;;;AChFI,IAAOC,cAAP,cAA0B,MAAK;EAInC,YAAaC,UAAkB,MAAa;AAC1C,UAAMA,YAAW,2BAA2B;AAJvC;AACA;AAIL,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,OAAO,QAAQ;EACtB;;AAgCF,eAAsB,UAAe,SAAsB,WAAmB,QAAsB,MAA0B;AAE5H,QAAM,QAAQ,IAAID,YAAW,6BAAM,cAAc,6BAAM,SAAS;AAEhE,OAAI,iCAAQ,aAAY,MAAM;AAC5B,WAAO,QAAQ,OAAO,KAAK;EAC7B;AAEA,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACrC,aAAS,kBAAe;AACtB,uCAAQ,oBAAoB,SAAS;AACrC,cAAQ,oBAAoB,WAAW,aAAa;AAEpD,WAAI,6BAAM,eAAc,MAAM;AAC5B,gBAAQ,oBAAoB,KAAK,YAAY,kBAAkB;MACjE;IACF;AAEA,UAAM,gBAAgB,CAAC,QAAkB;AA7K7C,UAAAE;AA8KM,UAAI;AACF,cAAIA,OAAA,6BAAM,WAAN,gBAAAA,KAAA,WAAe,UAAS,OAAO;AACjC;QACF;MACF,SAAS,KAAU;AACjB,wBAAe;AACf,eAAO,GAAG;AACV;MACF;AAEA,sBAAe;AACf,cAAQ,GAAG;IACb;AAEA,UAAM,qBAAqB,CAAC,QAAkB;AAC5C,sBAAe;AACf,aAAO,IAAI,MAAM;IACnB;AAEA,UAAM,gBAAgB,MAAW;AAC/B,sBAAe;AACf,aAAO,KAAK;IACd;AAEA,qCAAQ,iBAAiB,SAAS;AAClC,YAAQ,iBAAiB,WAAW,aAAa;AAEjD,SAAI,6BAAM,eAAc,MAAM;AAC5B,cAAQ,iBAAiB,KAAK,YAAY,kBAAkB;IAC9D;EACF,CAAC;AACH;;;ACzMM,IAAO,eAAP,MAAmB;EAIvB,YAAa,QAAoB;AAH1B;AACA;AANT,QAAAC;AASI,SAAK,SAAS;AACd,SAAK,WAAW,OAAM;AAEtB,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;AACrC,KAAAA,OAAA,KAAK,WAAL,gBAAAA,KAAa,iBAAiB,SAAS,KAAK;EAC9C;EAEA,UAAO;AAhBT,QAAAA;AAiBI,SAAK,SAAS,SAAOA,OAAA,KAAK,WAAL,gBAAAA,KAAa,WAAU,IAAI,WAAU,CAAE;EAC9D;EAEA,UAAO;AApBT,QAAAA;AAqBI,KAAAA,OAAA,KAAK,WAAL,gBAAAA,KAAa,oBAAoB,SAAS,KAAK;EACjD;;;;ACbF,SAAS,WAAQ;AACf,SAAO,GAAI,SAAS,OAAO,KAAK,OAAM,IAAK,GAAG,GAAG,EAAE,EAAG,SAAQ,CAAE,GAAG,KAAK,IAAG,CAAE;AAC/E;AAQM,IAAO,MAAP,MAAU;EASd,YAAa,IAAqD,SAAY;AARvE;AACA;AACA;AACA;AACA;AACS;AACC;AAGf,SAAK,KAAK,SAAQ;AAClB,SAAK,SAAS;AACd,SAAK,KAAK;AACV,SAAK,UAAU;AACf,SAAK,aAAa,CAAA;AAClB,SAAK,WAAW;MACd,SAAS,KAAK,IAAG;;AAGnB,SAAK,aAAa,IAAI,gBAAe;AACrC,oBAAgB,UAAU,KAAK,WAAW,MAAM;AAEhD,SAAK,UAAU,KAAK,QAAQ,KAAK,IAAI;EACvC;EAEA,MAAO,KAAU;AACf,SAAK,WAAW,MAAM,GAAG;EAC3B;EAEA,UAAO;AACL,UAAM,aAAa,KAAK,WAAW,OAAO,CAAC,KAAK,SAAQ;AAjD5D,UAAAC;AAkDM,aAAO,SAAQA,OAAA,KAAK,WAAL,gBAAAA,KAAa,aAAY;IAC1C,GAAG,IAAI;AAGP,QAAI,YAAY;AACd,WAAK,WAAW,MAAM,IAAI,WAAU,CAAE;AACtC,WAAK,QAAO;IACd;EACF;EAEA,MAAM,KAAM,UAAwB,CAAA,GAAE;AA5DxC,QAAAA;AA6DI,UAAM,YAAY,IAAI,aAA4B,QAAQ,MAAM;AAChE,SAAK,WAAW,KAAK,SAAS;AAE9B,KAAAA,OAAA,QAAQ,WAAR,gBAAAA,KAAgB,iBAAiB,SAAS,KAAK;AAE/C,WAAO,UAAU,SAAS;EAC5B;EAEA,MAAM,MAAG;AACP,SAAK,SAAS;AACd,SAAK,SAAS,UAAU,KAAK,IAAG;AAEhC,QAAI;AACF,WAAK,WAAW,OAAO,eAAc;AAErC,YAAM,SAAS,MAAM,WAAW,KAAK,GAAG;QACtC,GAAI,KAAK,WAAW,CAAA;QACpB,QAAQ,KAAK,WAAW;OACzB,GAAG,KAAK,WAAW,MAAM;AAE1B,WAAK,WAAW,QAAQ,eAAY;AAClC,kBAAU,SAAS,QAAQ,MAAM;MACnC,CAAC;AAED,WAAK,SAAS;IAChB,SAAS,KAAK;AACZ,WAAK,WAAW,QAAQ,eAAY;AAClC,kBAAU,SAAS,OAAO,GAAG;MAC/B,CAAC;AAED,WAAK,SAAS;IAChB;AACE,WAAK,SAAS,WAAW,KAAK,IAAG;AACjC,WAAK,QAAO;IACd;EACF;EAEA,UAAO;AACL,SAAK,WAAW,QAAQ,eAAY;AAnGxC,UAAAA;AAoGM,gBAAU,QAAO;AACjB,OAAAA,OAAA,UAAU,WAAV,gBAAAA,KAAkB,oBAAoB,SAAS,KAAK;IACtD,CAAC;EACH;;;;ACoBI,IAAO,QAAP,cAA8F,kBAAyD;EAO3J,YAAa,OAA6C,CAAA,GAAE;AAlI9D,QAAAC;AAmII,UAAK;AAPA;AACA;AACA;AACC;AACS;AAKf,SAAK,cAAc,KAAK,eAAe,OAAO;AAC9C,SAAK,UAAU,KAAK,WAAW,OAAO;AACtC,SAAK,UAAU;AAEf,QAAI,KAAK,cAAc,MAAM;AAC3B,OAAAA,OAAA,KAAK,YAAL,gBAAAA,KAAc,oBAAoB,KAAK,YAAY;QACjD,WAAW,MAAK;AACd,iBAAO;YACL,MAAM,KAAK,MAAM;YACjB,SAAS,KAAK;YACd,QAAQ,KAAK,MAAM,SAAS,KAAK;;QAErC;;IAEJ;AAEA,SAAK,OAAO,KAAK;AACjB,SAAK,QAAQ,CAAA;EACf;EAEQ,oBAAiB;AACvB,QAAI,KAAK,SAAS,GAAG;AAGnB,qBAAe,MAAK;AAClB,aAAK,kBAAkB,OAAO;MAChC,CAAC;AAED,UAAI,KAAK,YAAY,GAAG;AAGtB,uBAAe,MAAK;AAClB,eAAK,kBAAkB,MAAM;QAC/B,CAAC;MACH;AAEA,aAAO;IACT;AAEA,QAAI,KAAK,UAAU,KAAK,aAAa;AACnC,UAAI;AAEJ,iBAAW,KAAK,KAAK,OAAO;AAC1B,YAAI,EAAE,WAAW,UAAU;AACzB,gBAAM;AACN;QACF;MACF;AAEA,UAAI,OAAO,MAAM;AACf,eAAO;MACT;AAEA,WAAK,kBAAkB,QAAQ;AAE/B,WAAK;AAEL,WAAK,IAAI,IAAG,EACT,QAAQ,MAAK;AAEZ,iBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,cAAI,KAAK,MAAM,CAAC,MAAM,KAAK;AACzB,iBAAK,MAAM,OAAO,GAAG,CAAC;AACtB;UACF;QACF;AAEA,aAAK;AACL,aAAK,kBAAiB;AACtB,aAAK,kBAAkB,MAAM;MAC/B,CAAC;AAEH,aAAO;IACT;AAEA,WAAO;EACT;EAEQ,QAAS,KAAmC;AAClD,SAAK,MAAM,KAAK,GAAG;AAEnB,QAAI,KAAK,QAAQ,MAAM;AACrB,WAAK,MAAM,KAAK,KAAK,IAAI;IAC3B;EACF;;;;EAKA,MAAM,IAAK,IAA4C,SAAoB;AA9N7E,QAAAA;AA+NI,KAAAA,OAAA,mCAAS,WAAT,gBAAAA,KAAiB;AAEjB,QAAI,KAAK,SAAS,KAAK,SAAS;AAC9B,YAAM,IAAI,eAAc;IAC1B;AAEA,UAAM,MAAM,IAAI,IAA+B,IAAI,OAAO;AAC1D,SAAK,QAAQ,GAAG;AAChB,SAAK,kBAAkB,KAAK;AAC5B,SAAK,kBAAiB;AAEtB,WAAO,IAAI,KAAK,OAAO,EACpB,KAAK,YAAS;AACb,WAAK,kBAAkB,aAAa,EAAE,QAAQ,OAAM,CAAE;AACtD,WAAK,kBAAkB,WAAW,EAAE,QAAQ,EAAE,KAAK,OAAM,EAAE,CAAE;AAE7D,aAAO;IACT,CAAC,EACA,MAAM,SAAM;AACX,UAAI,IAAI,WAAW,UAAU;AAE3B,iBAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,cAAI,KAAK,MAAM,CAAC,MAAM,KAAK;AACzB,iBAAK,MAAM,OAAO,GAAG,CAAC;AACtB;UACF;QACF;MACF;AAEA,WAAK,kBAAkB,SAAS,EAAE,QAAQ,IAAG,CAAE;AAC/C,WAAK,kBAAkB,WAAW,EAAE,QAAQ,EAAE,KAAK,OAAO,IAAG,EAAE,CAAE;AAEjE,YAAM;IACR,CAAC;EACL;;;;EAKA,QAAK;AACH,SAAK,MAAM,OAAO,GAAG,KAAK,MAAM,MAAM;EACxC;;;;EAKA,QAAK;AACH,SAAK,MAAM,QAAQ,SAAM;AACvB,UAAI,MAAM,IAAI,WAAU,CAAE;IAC5B,CAAC;AAED,SAAK,MAAK;EACZ;;;;;;EAOA,MAAM,QAAS,SAAsB;AAEnC,QAAI,KAAK,SAAS,GAAG;AACnB;IACF;AAEA,UAAM,UAAU,MAAM,SAAS,mCAAS,MAAM;EAChD;;;;;;;;;;;;EAaA,MAAM,eAAgB,OAAe,SAAsB;AAEzD,QAAI,KAAK,OAAO,OAAO;AACrB;IACF;AAEA,UAAM,UAAU,MAAM,QAAQ,mCAAS,QAAQ;MAC7C,QAAQ,MAAM,KAAK,OAAO;KAC3B;EACH;;;;;;;;;EAUA,MAAM,OAAQ,SAAsB;AAElC,QAAI,KAAK,YAAY,KAAK,KAAK,SAAS,GAAG;AACzC;IACF;AAEA,UAAM,UAAU,MAAM,QAAQ,mCAAS,MAAM;EAC/C;;;;EAKA,IAAI,OAAI;AACN,WAAO,KAAK,MAAM;EACpB;;;;EAKA,IAAI,SAAM;AACR,WAAO,KAAK,MAAM,SAAS,KAAK;EAClC;;;;EAKA,IAAI,UAAO;AACT,WAAO,KAAK;EACd;;;;;;;;;;;EAYA,OAAQ,YAAa,SAAsB;AAzW7C,QAAAA,MAAAC,KAAA;AA0WI,KAAAD,OAAA,mCAAS,WAAT,gBAAAA,KAAiB;AAEjB,UAAM,SAAS,SAAwB;MACrC,YAAY;KACb;AAED,UAAM,UAAU,CAAC,QAAqB;AACpC,UAAI,OAAO,MAAM;AACf,aAAK,MAAK;MACZ,OAAO;AACL,aAAK,MAAK;MACZ;AAEA,aAAO,IAAI,GAAG;IAChB;AAEA,UAAM,qBAAqB,CAAC,QAAyC;AACnE,UAAI,IAAI,UAAU,MAAM;AACtB,eAAO,KAAK,IAAI,MAAM;MACxB;IACF;AAEA,UAAM,eAAe,CAAC,QAAiC;AACrD,cAAQ,IAAI,MAAM;IACpB;AAEA,UAAM,cAAc,MAAW;AAC7B,cAAO;IACT;AAGA,UAAM,gBAAgB,MAAW;AAC/B,cAAQ,IAAI,WAAW,eAAe,CAAC;IACzC;AAGA,SAAK,iBAAiB,aAAa,kBAAkB;AACrD,SAAK,iBAAiB,SAAS,YAAY;AAC3C,SAAK,iBAAiB,QAAQ,WAAW;AACzC,KAAAC,MAAA,mCAAS,WAAT,gBAAAA,IAAiB,iBAAiB,SAAS;AAE3C,QAAI;AACF,aAAQ;IACV;AAEE,WAAK,oBAAoB,aAAa,kBAAkB;AACxD,WAAK,oBAAoB,SAAS,YAAY;AAC9C,WAAK,oBAAoB,QAAQ,WAAW;AAC5C,+CAAS,WAAT,mBAAiB,oBAAoB,SAAS;AAG9C,cAAO;IACT;EACF;;;;ACvZI,IAAO,gBAAP,cAA0H,MAAgC;EAC9J,YAAa,OAA6C,CAAA,GAAE;AAC1D,UAAM;MACJ,GAAG;MACH,MAAM,CAAC,GAAG,MAAK;AACb,YAAI,EAAE,QAAQ,WAAW,EAAE,QAAQ,UAAU;AAC3C,iBAAO;QACT;AAEA,YAAI,EAAE,QAAQ,WAAW,EAAE,QAAQ,UAAU;AAC3C,iBAAO;QACT;AAEA,eAAO;MACT;KACD;EACH;;;;ACfI,SAAU,UAAW,SAA8C;AACvE,QAAM,aAAa,IAAI,WAAW,gBAAe;AAEjD,WAAS,UAAO;AACd,eAAW,MAAK;AAEhB,eAAWC,WAAU,SAAS;AAC5B,WAAIA,WAAA,gBAAAA,QAAQ,wBAAuB,MAAM;AACvC,QAAAA,QAAO,oBAAoB,SAAS,OAAO;;;EAGjD;AAEA,aAAWA,WAAU,SAAS;AAC5B,SAAIA,WAAA,gBAAAA,QAAQ,aAAY,MAAM;AAC5B,cAAO;AACP;;AAGF,SAAIA,WAAA,gBAAAA,QAAQ,qBAAoB,MAAM;AACpC,MAAAA,QAAO,iBAAiB,SAAS,OAAO;;;AAI5C,WAAS,QAAK;AACZ,eAAWA,WAAU,SAAS;AAC5B,WAAIA,WAAA,gBAAAA,QAAQ,wBAAuB,MAAM;AACvC,QAAAA,QAAO,oBAAoB,SAAS,OAAO;;;EAGjD;AAEA,QAAM,SAAS,WAAW;AAC1B,SAAO,QAAQ;AAEf,SAAO;AACT;;;AClCM,SAAU,wBAAyB,GAAY,GAAU;AAC7D,QAAM,SAAS,IAAI,WAAW,EAAE,SAAS;AACzC,QAAM,SAAS,IAAI,WAAW,EAAE,SAAS;AAEzC,MAAI,UAAU,CAAC,QAAQ;AACrB,WAAO;EACT;AAEA,MAAI,CAAC,UAAU,QAAQ;AACrB,WAAO;EACT;AAEA,QAAM,qBAAqB,iBAAiB,WAAW,EAAE,SAAS;AAClE,QAAM,qBAAqB,iBAAiB,WAAW,EAAE,SAAS;AAElE,MAAI,sBAAsB,CAAC,oBAAoB;AAC7C,WAAO;EACT;AAEA,MAAI,CAAC,sBAAsB,oBAAoB;AAC7C,WAAO;EACT;AAEA,QAAM,eAAe,WAAW,WAAW,EAAE,SAAS;AACtD,QAAM,eAAe,WAAW,WAAW,EAAE,SAAS;AAEtD,MAAI,gBAAgB,CAAC,cAAc;AACjC,WAAO;EACT;AAEA,MAAI,CAAC,gBAAgB,cAAc;AACjC,WAAO;EACT;AAEA,QAAM,YAAY,OAAO,WAAW,EAAE,SAAS;AAC/C,QAAM,YAAY,OAAO,WAAW,EAAE,SAAS;AAE/C,MAAI,aAAa,CAAC,WAAW;AAC3B,WAAO;EACT;AAEA,MAAI,CAAC,aAAa,WAAW;AAC3B,WAAO;EACT;AAEA,QAAM,kBAAkB,aAAa,WAAW,EAAE,SAAS;AAC3D,QAAM,kBAAkB,aAAa,WAAW,EAAE,SAAS;AAE3D,MAAI,mBAAmB,CAAC,iBAAiB;AACvC,WAAO;EACT;AAEA,MAAI,CAAC,mBAAmB,iBAAiB;AACvC,WAAO;EACT;AAEA,QAAM,kBAAkB,aAAa,WAAW,EAAE,SAAS;AAC3D,QAAM,kBAAkB,aAAa,WAAW,EAAE,SAAS;AAE3D,MAAI,mBAAmB,CAAC,iBAAiB;AACvC,WAAO;EACT;AAEA,MAAI,CAAC,mBAAmB,iBAAiB;AACvC,WAAO;EACT;AAGA,SAAO;AACT;AAMM,SAAU,qBAAsB,GAAY,GAAU;AAC1D,QAAM,aAAa,UAAU,EAAE,SAAS;AACxC,QAAM,aAAa,UAAU,EAAE,SAAS;AAExC,MAAI,cAAc,CAAC,YAAY;AAC7B,WAAO;EACT,WAAW,CAAC,cAAc,YAAY;AACpC,WAAO;EACT;AAEA,SAAO;AACT;AAMM,SAAU,wBAAyB,GAAY,GAAU;AAC7D,MAAI,EAAE,eAAe,CAAC,EAAE,aAAa;AACnC,WAAO;EACT,WAAW,CAAC,EAAE,eAAe,EAAE,aAAa;AAC1C,WAAO;EACT;AAEA,SAAO;AACT;AAMM,SAAU,0BAA2B,GAAY,GAAU;AAC/D,QAAM,aAAa,QAAQ,WAAW,EAAE,SAAS;AACjD,QAAM,aAAa,QAAQ,WAAW,EAAE,SAAS;AAEjD,MAAI,cAAc,CAAC,YAAY;AAC7B,WAAO;EACT,WAAW,CAAC,cAAc,YAAY;AACpC,WAAO;EACT;AAEA,SAAO;AACT;AAEM,SAAU,qBAAsB,WAAoB;AACxD,SAAO,UACJ,KAAK,uBAAuB,EAC5B,KAAK,uBAAuB,EAC5B,KAAK,yBAAyB,EAC9B,KAAK,oBAAoB;AAC9B;;;ACtFA,IAAMC,kBAAiB;EACrB,kBAAkB;EAClB,oBAAoB;EACpB,oBAAoB;EACpB,aAAa;EACb,WAAW;IACT,SAAS;;;AAeP,IAAO,YAAP,MAAgB;EAWpB,YAAa,YAAiC,OAAmB,CAAA,GAAE;AAV5D;AACU;AACA;AACA;AACA;AACA;AACT;AACS;AACA;AAGf,SAAK,gBAAgB,KAAK;AAC1B,SAAK,qBAAqB,KAAK,sBAAsBA,gBAAe;AACpE,SAAK,qBAAqB,KAAK,sBAAsBA,gBAAe;AACpE,SAAK,cAAc,KAAK,eAAeA,gBAAe;AACtD,SAAK,cAAc,KAAK,eAAe,IAAI,QAAO;AAClD,SAAK,MAAM,WAAW,OAAO,aAAa,sCAAsC;AAChF,SAAK,aAAa;AAElB,SAAK,qBAAqB,IAAI,gBAAe;AAC7C,oBAAgB,UAAU,KAAK,mBAAmB,MAAM;AAExD,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,aAAa,CAAA,CAAE,GAAG;AAC/D,gBAAU,IAAI,KAAK,KAAK;IAC1B;AAGA,SAAK,QAAQ,IAAI,cAAc;MAC7B,aAAa,KAAK,oBAAoBA,gBAAe;MACrD,YAAY;MACZ,SAAS,WAAW;KACrB;AAED,SAAK,MAAM,iBAAiB,SAAS,CAAC,UAAS;AAC7C,UAAI,MAAM,OAAO,SAAS,WAAW,MAAM;AACzC,aAAK,IAAI,MAAM,4BAA4B,MAAM,MAAM;MACzD;IACF,CAAC;EACH;EAEA,QAAK;AACH,SAAK,qBAAqB,IAAI,gBAAe;AAC7C,oBAAgB,UAAU,KAAK,mBAAmB,MAAM;EAC1D;;;;EAKA,OAAI;AACF,SAAK,mBAAmB,MAAK;AAC7B,SAAK,MAAM,MAAK;EAClB;;;;;;;;;;;;;EAcA,MAAM,KAAM,mBAAqD,UAAiC,CAAA,GAAE;AAzItG,QAAAC,MAAAC,KAAA;AA0II,UAAM,EAAE,QAAQ,WAAU,IAAK,eAAe,iBAAiB;AAI/D,UAAM,qBAAqB,MAAM,KAAK,KAAK,YAAY,OAAM,CAAE,EAAE,KAAI,EAAG,KAAK,UAAO;AAClF,UAAI,QAAQ,UAAU,MAAM;AAC1B,eAAO;MACT;AAEA,UAAI,KAAK,WAAW,OAAO,MAAM,GAAG;AAClC,eAAO;MACT;AAEA,aAAO,WAAW,KAAK,UAAO;AAC5B,eAAO,KAAK,OAAO,KAAK,UAAU;MACpC,CAAC;IACH,CAAC;AAED,SAAI,yDAAoB,YAAW,QAAQ;AACzC,WAAK,IAAI,2BAA2B,mBAAmB,UAAU;AACjE,OAAAD,OAAA,QAAQ,eAAR,gBAAAA,KAAA,cAAqB,IAAI,oBAAoB,8BAA8B;AAC3E,aAAO;IACT;AAIA,UAAM,eAAe,KAAK,MAAM,MAAM,KAAK,SAAM;AAC/C,WAAI,iCAAQ,OAAO,IAAI,QAAQ,aAAY,MAAM;AAC/C,eAAO;MACT;AAGA,YAAM,YAAY,IAAI,QAAQ;AAE9B,UAAI,aAAa,MAAM;AACrB,eAAO;MACT;AAEA,iBAAWE,cAAa,YAAY;AAClC,YAAI,UAAU,IAAIA,WAAU,SAAQ,CAAE,GAAG;AACvC,iBAAO;QACT;MACF;AAEA,aAAO;IACT,CAAC;AAED,QAAI,gBAAgB,MAAM;AACxB,WAAK,IAAI,uCAAuC,MAAM;AAGtD,iBAAWA,cAAa,YAAY;AAClC,qBAAa,QAAQ,WAAW,IAAIA,WAAU,SAAQ,CAAE;MAC1D;AAEA,OAAAD,MAAA,QAAQ,eAAR,gBAAAA,IAAA,cAAqB,IAAI,oBAAoB,kCAAkC;AAC/E,aAAO,aAAa,KAAK,OAAO;IAClC;AAEA,QAAI,KAAK,MAAM,QAAQ,KAAK,oBAAoB;AAC9C,YAAM,IAAI,UAAU,oBAAoB;IAC1C;AAEA,SAAK,IAAI,+BAA+B,QAAQ,WAAW,IAAI,QAAM,GAAG,SAAQ,CAAE,CAAC;AAEnF,kBAAQ,eAAR,iCAAqB,IAAI,oBAAoB,8BAA8B;AAC3E,WAAO,KAAK,MAAM,IAAI,OAAOE,aAAW;AA5M5C,UAAAH,MAAAC;AA6MM,OAAAD,OAAAG,YAAA,gBAAAA,SAAS,eAAT,gBAAAH,KAAA,KAAAG,UAAsB,IAAI,oBAAoB,uBAAuB;AAGrE,YAAM,SAAS,UAAU;QACvB,KAAK,mBAAmB;QACxBA,SAAQ;OACT;AACD,sBAAgB,UAAU,MAAM;AAEhC,UAAI;AAEJ,UAAI;AAGF,sBAAc,MAAM,KAAK,oBAAoB,QAAQA,YAAA,gBAAAA,SAAS,YAAY;UACxE,GAAGA;UACH;SACD;AAED,SAAAF,MAAAE,YAAA,gBAAAA,SAAS,eAAT,gBAAAF,IAAA,KAAAE,UAAsB,IAAI,oBAA+B,mCAAmC,WAAW;AAEvG,oBAAY,IAAI,CAAC,EAAE,WAAAD,WAAS,MAAOA,WAAU,SAAQ,CAAE,EAAE,QAAQ,UAAO;AACtE,UAAAC,YAAA,gBAAAA,SAAS,WAAW,IAAI;QAC1B,CAAC;MACH,SAAS,KAAK;AACZ,eAAO,MAAK;AACZ,cAAM;MACR;AAEA,UAAI;AACF,YAAI,SAAS;AACb,cAAM,SAAkB,CAAA;AAExB,mBAAW,WAAW,aAAa;AACjC,cAAI,WAAW,KAAK,oBAAoB;AACtC,iBAAK,IAAI,0EAA0E,QAAQ,MAAM;AAEjG,kBAAM,IAAI,UAAU,uCAAuC;UAC7D;AAEA;AAEA,cAAI;AACF,kBAAM,OAAO,MAAM,KAAK,WAAW,iBAAiB,KAAK,QAAQ,WAAW;cAC1E,GAAGA;cACH;aACD;AAED,iBAAK,IAAI,wBAAwB,QAAQ,SAAS;AAGlD,gBAAI;AACF,oBAAM,KAAK,WAAW,UAAU,MAAM,KAAK,YAAY;gBACrD,YAAY;kBACV,KAAK;;gBAEP,UAAU;kBACR,CAAC,qBAAqB,GAAG,WAAqB,KAAK,IAAG,EAAG,SAAQ,CAAE;;eAEtE;YACH,SAAS,KAAU;AACjB,mBAAK,IAAI,MAAM,iDAAiD,QAAQ,GAAG;YAC7E;AAEA,mBAAO;UACT,SAAS,KAAU;AACjB,iBAAK,IAAI,MAAM,qBAAqB,QAAQ,WAAW,GAAG;AAE1D,gBAAI,UAAU,MAAM;AAElB,kBAAI;AACF,sBAAM,KAAK,WAAW,UAAU,MAAM,QAAQ;kBAC5C,UAAU;oBACR,CAAC,qBAAqB,GAAG,WAAqB,KAAK,IAAG,EAAG,SAAQ,CAAE;;iBAEtE;cACH,SAASC,MAAU;AACjB,qBAAK,IAAI,MAAM,iDAAiD,QAAQA,IAAG;cAC7E;YACF;AAGA,gBAAI,OAAO,SAAS;AAClB,oBAAM,IAAI,aAAa,IAAI,OAAO;YACpC;AAEA,mBAAO,KAAK,GAAG;UACjB;QACF;AAEA,YAAI,OAAO,WAAW,GAAG;AACvB,gBAAM,OAAO,CAAC;QAChB;AAEA,cAAM,IAAI,eAAe,QAAQ,4BAA4B;MAC/D;AAEE,eAAO,MAAK;MACd;IACF,GAAG;MACD;MACA,UAAU,QAAQ,YAAY;MAC9B,YAAY,IAAI,IAAI,WAAW,IAAI,QAAM,GAAG,SAAQ,CAAE,CAAC;MACvD,QAAQ,QAAQ,UAAU,YAAY,QAAQ,KAAK,WAAW;MAC9D,YAAY,QAAQ;KACrB;EACH;;EAGQ,MAAM,oBAAqB,QAAiB,aAA0B,oBAAI,IAAG,GAAY,UAAiC,CAAA,GAAE;AA1TtI,QAAAJ,MAAAC;AA2TI,UAAM,QAAmB,CAAC,GAAG,UAAU,EAAE,IAAI,SAAO;MAClD,WAAW,UAAU,EAAE;MACvB,aAAa;MACb;AAGF,QAAI,UAAU,MAAM;AAClB,UAAI,KAAK,WAAW,OAAO,OAAO,MAAM,GAAG;AACzC,cAAM,IAAI,UAAU,oBAAoB;MAC1C;AAEA,UAAK,QAAMA,OAAAD,OAAA,KAAK,WAAW,iBAAgB,iBAAhC,gBAAAC,IAAA,KAAAD,MAA+C,aAAa,MAAM;AAC3E,cAAM,IAAI,gBAAgB,oDAAoD;MAChF;AAIA,UAAI,MAAM,WAAW,GAAG;AACtB,aAAK,IAAI,6BAA6B,MAAM;AAC5C,YAAI;AACF,gBAAM,OAAO,MAAM,KAAK,WAAW,UAAU,IAAI,MAAM;AACvD,gBAAM,KAAK,GAAG,KAAK,SAAS;AAC5B,eAAK,IAAI,4BAA4B,QAAQ,MAAM,IAAI,CAAC,EAAE,WAAAE,WAAS,MAAOA,WAAU,SAAQ,CAAE,CAAC;QACjG,SAAS,KAAU;AACjB,cAAI,IAAI,SAAS,iBAAiB;AAChC,kBAAM;UACR;QACF;MACF;AAIA,UAAI,MAAM,WAAW,GAAG;AACtB,aAAK,IAAI,oDAAoD,MAAM;AAEnE,YAAI;AACF,gBAAM,WAAW,MAAM,KAAK,WAAW,YAAY,SAAS,QAAQ,OAAO;AAE3E,eAAK,IAAI,+CAA+C,QAAQ,MAAM,IAAI,CAAC,EAAE,WAAAA,WAAS,MAAOA,WAAU,SAAQ,CAAE,CAAC;AAElH,gBAAM,KAAK,GAAG,SAAS,WAAW,IAAI,CAAAA,gBAAc;YAClD,WAAAA;YACA,aAAa;YACb,CAAC;QACL,SAAS,KAAU;AACjB,cAAI,IAAI,SAAS,sBAAsB;AACrC,iBAAK,IAAI,MAAM,2DAA2D,QAAQ,GAAG;UACvF;QACF;MACF;IACF;AAIA,QAAI,qBAAqB,MAAM,QAAQ,IACrC,MAAM,IAAI,OAAM,SAAO;AACrB,YAAM,SAAS,MAAM,kBAAkB,KAAK,WAAW;QACrD,KAAK,KAAK,WAAW;QACrB,GAAG;QACH,KAAK,KAAK;OACX;AAED,UAAI,OAAO,WAAW,KAAK,OAAO,CAAC,EAAE,OAAO,KAAK,SAAS,GAAG;AAC3D,eAAO;MACT;AAEA,aAAO,OAAO,IAAI,CAAAA,gBAAc;QAC9B,WAAAA;QACA,aAAa;QACb;IACJ,CAAC,CAAC,GAED,KAAI;AAGP,QAAI,UAAU,MAAM;AAClB,YAAM,kBAAkB,QAAQ,OAAO,SAAQ,CAAE;AACjD,0BAAoB,kBAAkB,IAAI,UAAO;AAC/C,cAAM,YAAY,KAAK,UAAU,OAAM,EAAG,IAAG;AAG7C,aAAI,uCAAW,UAAS,MAAM;AAC5B,iBAAO;QACT;AAGA,YAAI,KAAK,UAAU,UAAS,KAAM,MAAM;AACtC,iBAAO;YACL,WAAW,KAAK,UAAU,YAAY,eAAe;YACrD,aAAa,KAAK;;QAEtB;AAEA,eAAO;MACT,CAAC;IACH;AAEA,UAAM,gBAAgB,kBAAkB,OAAO,UAAO;AAEpD,UAAI,KAAK,WAAW,iBAAiB,0BAA0B,KAAK,SAAS,KAAK,MAAM;AACtF,eAAO;MACT;AAKA,YAAM,aAAa,KAAK,UAAU,UAAS;AAC3C,UAAI,UAAU,QAAQ,cAAc,MAAM;AACxC,eAAO,OAAO,OAAO,UAAU;MACjC;AAEA,aAAO;IACT,CAAC;AAGD,UAAM,eAAe,oBAAI,IAAG;AAE5B,eAAW,QAAQ,eAAe;AAChC,YAAM,QAAQ,KAAK,UAAU,SAAQ;AACrC,YAAM,WAAW,aAAa,IAAI,KAAK;AAEvC,UAAI,YAAY,MAAM;AACpB,iBAAS,cAAc,SAAS,eAAe,KAAK,eAAe;AACnE;MACF;AAEA,mBAAa,IAAI,OAAO,IAAI;IAC9B;AAEA,UAAM,oBAAoB,CAAC,GAAG,aAAa,OAAM,CAAE;AAGnD,QAAI,kBAAkB,WAAW,GAAG;AAClC,YAAM,IAAI,sBAAsB,yCAAyC;IAC3E;AAEA,UAAM,YAAuB,CAAA;AAE7B,eAAW,QAAQ,mBAAmB;AACpC,UAAI,KAAK,WAAW,gBAAgB,qBAAqB,QAAQ,MAAM,KAAK,WAAW,gBAAgB,kBAAkB,KAAK,SAAS,GAAG;AACxI;MACF;AAEA,gBAAU,KAAK,IAAI;IACrB;AAEA,UAAM,mBAAmB,KAAK,iBAAiB,OAAO,qBAAqB,SAAS,IAAI,UAAU,KAAK,KAAK,aAAa;AAGzH,QAAI,iBAAiB,WAAW,GAAG;AACjC,YAAM,IAAI,gBAAgB,+DAA+D;IAC3F;AAEA,SAAK,IAAI,MAAM,qCAAqC,UAAU,gBAAgB,kBAAkB,IAAI,CAAC,EAAE,WAAAA,WAAS,MAAOA,WAAU,SAAQ,CAAE,CAAC;AAC5I,SAAK,IAAI,MAAM,oCAAoC,UAAU,gBAAgB,iBAAiB,IAAI,CAAC,EAAE,WAAAA,WAAS,MAAOA,WAAU,SAAQ,CAAE,CAAC;AAE1I,WAAO;EACT;EAEA,MAAM,WAAYA,YAAoC,UAA6B,CAAA,GAAE;AACnF,QAAI,CAAC,MAAM,QAAQA,UAAS,GAAG;AAC7B,MAAAA,aAAY,CAACA,UAAS;IACxB;AAEA,QAAI;AACF,YAAM,YAAY,MAAM,KAAK,oBAAoB,QAAW,IAAI,IAAIA,WAAU,IAAI,QAAM,GAAG,SAAQ,CAAE,CAAC,GAAG,OAAO;AAEhH,UAAI,QAAQ,2BAA2B,OAAO;AAE5C,eAAO,UAAU,KAAK,UAAO;AAC3B,iBAAO,CAAC,QAAQ,QAAQ,KAAK,SAAS;QACxC,CAAC,KAAK;MACR;AAEA,aAAO;IACT,SAAS,KAAK;AACZ,WAAK,IAAI,MAAM,mDAAmD,GAAG;IACvE;AAEA,WAAO;EACT;;;;ACpeI,IAAO,YAAP,cAA6G,MAAgC;EACjJ,IAAK,QAAc;AACjB,WAAO,KAAK,KAAK,MAAM,KAAK;EAC9B;EAEA,KAAM,QAAc;AAClB,WAAO,KAAK,MAAM,KAAK,SAAM;AAC3B,aAAO,OAAO,OAAO,IAAI,QAAQ,MAAM;IACzC,CAAC;EACH;;;;ACpBF,mBAAkB;;;ACAlB,IAAM,iBAAiB,OAAO,UAAU;AAExC,IAAM,UAAU,WAAS,eAAe,KAAK,KAAK,MAAM;AAExD,IAAM,gBAAgB,oBAAI,IAAI;AAAA,EAC7B;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AACD,CAAC;AAEc,SAAR,eAAgC,OAAO;AAC7C,QAAM,UAAU,SACZ,QAAQ,KAAK,KACb,MAAM,SAAS,eACf,OAAO,MAAM,YAAY;AAE7B,MAAI,CAAC,SAAS;AACb,WAAO;AAAA,EACR;AAIA,MAAI,MAAM,YAAY,eAAe;AACpC,WAAO,MAAM,UAAU;AAAA,EACxB;AAEA,SAAO,cAAc,IAAI,MAAM,OAAO;AACvC;;;AD7BO,IAAMG,cAAN,cAAyB,MAAM;AAAA,EACrC,YAAYC,UAAS;AACpB,UAAM;AAEN,QAAIA,oBAAmB,OAAO;AAC7B,WAAK,gBAAgBA;AACrB,OAAC,EAAC,SAAAA,SAAO,IAAIA;AAAA,IACd,OAAO;AACN,WAAK,gBAAgB,IAAI,MAAMA,QAAO;AACtC,WAAK,cAAc,QAAQ,KAAK;AAAA,IACjC;AAEA,SAAK,OAAO;AACZ,SAAK,UAAUA;AAAA,EAChB;AACD;AAEA,IAAM,0BAA0B,CAAC,OAAO,eAAe,YAAY;AAElE,QAAM,cAAc,QAAQ,WAAW,gBAAgB;AAEvD,QAAM,gBAAgB;AACtB,QAAM,cAAc;AACpB,SAAO;AACR;AAEA,eAAO,OAA8B,OAAO,SAAS;AACpD,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,cAAU,EAAC,GAAG,QAAO;AACrB,YAAQ,oBAAR,QAAQ,kBAAoB,MAAM;AAAA,IAAC;AACnC,YAAQ,gBAAR,QAAQ,cAAgB,MAAM;AAC9B,YAAQ,YAAR,QAAQ,UAAY;AAEpB,UAAM,YAAY,aAAAC,QAAM,UAAU,OAAO;AAEzC,UAAM,eAAe,MAAM;AAtC7B,UAAAC;AAuCG,gBAAU,KAAK;AACf,cAAOA,OAAA,QAAQ,WAAR,gBAAAA,KAAgB,MAAM;AAAA,IAC9B;AAEA,QAAI,QAAQ,UAAU,CAAC,QAAQ,OAAO,SAAS;AAC9C,cAAQ,OAAO,iBAAiB,SAAS,cAAc,EAAC,MAAM,KAAI,CAAC;AAAA,IACpE;AAEA,UAAM,UAAU,MAAM;AA/CxB,UAAAA;AAgDG,OAAAA,OAAA,QAAQ,WAAR,gBAAAA,KAAgB,oBAAoB,SAAS;AAC7C,gBAAU,KAAK;AAAA,IAChB;AAEA,cAAU,QAAQ,OAAM,kBAAiB;AACxC,UAAI;AACH,cAAM,SAAS,MAAM,MAAM,aAAa;AACxC,gBAAQ;AACR,gBAAQ,MAAM;AAAA,MACf,SAAS,OAAO;AACf,YAAI;AACH,cAAI,EAAE,iBAAiB,QAAQ;AAC9B,kBAAM,IAAI,UAAU,0BAA0B,KAAK,kCAAkC;AAAA,UACtF;AAEA,cAAI,iBAAiBH,aAAY;AAChC,kBAAM,MAAM;AAAA,UACb;AAEA,cAAI,iBAAiB,aAAa,CAAC,eAAe,KAAK,GAAG;AACzD,kBAAM;AAAA,UACP;AAEA,kCAAwB,OAAO,eAAe,OAAO;AAErD,cAAI,CAAE,MAAM,QAAQ,YAAY,KAAK,GAAI;AACxC,sBAAU,KAAK;AACf,mBAAO,KAAK;AAAA,UACb;AAEA,gBAAM,QAAQ,gBAAgB,KAAK;AAEnC,cAAI,CAAC,UAAU,MAAM,KAAK,GAAG;AAC5B,kBAAM,UAAU,UAAU;AAAA,UAC3B;AAAA,QACD,SAAS,YAAY;AACpB,kCAAwB,YAAY,eAAe,OAAO;AAC1D,kBAAQ;AACR,iBAAO,UAAU;AAAA,QAClB;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AACF;;;AEjEM,IAAO,iBAAP,MAAqB;EAWzB,YAAa,YAAsC,OAA2B,CAAA,GAAE;AAV/D;AACA;AACT;AACS;AACA;AACA;AACA;AACA;AACA;AAGf,SAAK,MAAM,WAAW,OAAO,aAAa,wBAAwB;AAClE,SAAK,YAAY,WAAW;AAC5B,SAAK,oBAAoB,WAAW;AACpC,SAAK,QAAQ,IAAI,UAAU;MACzB,aAAa,KAAK,yBAAyB;MAC3C,YAAY;MACZ,SAAS,WAAW;KACrB;AACD,SAAK,UAAU;AACf,SAAK,UAAU,KAAK,WAAW;AAC/B,SAAK,gBAAgB,KAAK;AAC1B,SAAK,gBAAgB,KAAK;AAC1B,SAAK,SAAS,WAAW;AAEzB,eAAW,OAAO,iBAAiB,mBAAmB,CAAC,QAAO;AAC5D,WAAK,eAAe,IAAI,MAAM,EAC3B,MAAM,SAAM;AACX,aAAK,IAAI,MAAM,wCAAwC,IAAI,QAAQ,GAAG;MACxE,CAAC;IACL,CAAC;EACH;EAEQ,MAAM,eAAgB,QAAc;AAC1C,QAAI,CAAC,KAAK,SAAS;AACjB;IACF;AAEA,UAAM,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM;AAE5C,QAAI,CAAC,gBAAgB,IAAI,GAAG;AAC1B;IACF;AAEA,QAAI,KAAK,MAAM,IAAI,MAAM,GAAG;AAC1B;IACF;AAEA,SAAK,MAAM,IAAI,OAAO,YAAW;AAC/B,YAAM,OAAO,OAAO,YAAW;AAC7B,YAAI,CAAC,KAAK,SAAS;AACjB;QACF;AAEA,YAAI;AACF,gBAAM,KAAK,kBAAkB,eAAe,QAAQ;YAClD,QAAQ,mCAAS;WAClB;QACH,SAAS,KAAK;AACZ,eAAK,IAAI,mDAAmD,QAAQ,SAAS,KAAK,SAAS,GAAG;AAC9F,gBAAM;QACR;MACF,GAAG;QACD,QAAQ,mCAAS;QACjB,SAAS,KAAK;QACd,QAAQ,KAAK;QACb,YAAY,KAAK;OAClB;IACH,GAAG;MACD;KACD,EACE,MAAM,OAAM,QAAM;AACjB,WAAK,IAAI,MAAM,kCAAkC,QAAQ,GAAG;AAE5D,YAAM,OAAkC,CAAA;AAEvC,OAAC,GAAG,KAAK,KAAK,KAAI,CAAE,EAAE,QAAQ,SAAM;AACnC,YAAI,IAAI,WAAW,UAAU,GAAG;AAC9B,eAAK,GAAG,IAAI;QACd;MACF,CAAC;AAED,YAAM,KAAK,UAAU,MAAM,QAAQ;QACjC;OACD;AAED,WAAK,OAAO,kBAAkB,0BAA0B;QACtD,QAAQ;OACT;IACH,CAAC,EACA,MAAM,OAAM,QAAM;AACjB,WAAK,IAAI,MAAM,gDAAgD,QAAQ,GAAG;IAC5E,CAAC;EACL;EAEA,QAAK;AACH,SAAK,UAAU;EACjB;EAEA,MAAM,aAAU;AAEd,SAAK,QAAQ,QAAO,EACjB,KAAK,YAAW;AACf,YAAM,iBAAyB,MAAM,KAAK,UAAU,IAAI;QACtD,SAAS;UACP,CAAC,SAAS,gBAAgB,IAAI;;OAEjC;AAED,YAAM,QAAQ,IACZ,eAAe,IAAI,OAAM,SAAO;AAC9B,cAAM,KAAK,kBAAkB,eAAe,KAAK,EAAE,EAChD,MAAM,SAAM;AACX,eAAK,IAAI,MAAM,GAAG;QACpB,CAAC;MACL,CAAC,CAAC;IAEN,CAAC,EACA,MAAM,SAAM;AACX,WAAK,IAAI,MAAM,GAAG;IACpB,CAAC;EACL;EAEA,OAAI;AACF,SAAK,UAAU;AACf,SAAK,MAAM,MAAK;EAClB;;AAGF,SAAS,gBAAiB,MAAU;AAClC,aAAW,OAAO,KAAK,KAAK,KAAI,GAAI;AAClC,QAAI,IAAI,WAAW,UAAU,GAAG;AAC9B,aAAO;IACT;EACF;AAEA,SAAO;AACT;;;ACnJO,IAAM,wBAAwB;AA4IrC,IAAMI,kBAAiB;EACrB,gBAAgB;EAChB,4BAA4B;EAC5B,+BAA+B;;AAhKjC,IAAAC;AAiLM,IAAO,2BAAP,MAA+B;EAoBnC,YAAa,YAAgD,OAA8B,CAAA,GAAE;AAnBrF;AACS;AACA;AACA;AACA;AACT;AACA;AACS;AAED;AACA;AACA;AACC;AACA;AACA;AACA;AACA;AACA;AA0ER,wBAACA,KAAsB;AA7QlC,QAAAA;AAsMI,SAAK,iBAAiB,KAAK,kBAAkBD,gBAAe;AAE5D,QAAI,KAAK,iBAAiB,GAAG;AAC3B,YAAM,IAAI,uBAAuB,0DAA0D;IAC7F;AAKA,SAAK,cAAc,IAAI,QAAO;AAE9B,SAAK,UAAU;AACf,SAAK,SAAS,WAAW;AACzB,SAAK,YAAY,WAAW;AAC5B,SAAK,UAAU,WAAW;AAC1B,SAAK,SAAS,WAAW;AACzB,SAAK,MAAM,WAAW,OAAO,aAAa,2BAA2B;AAErE,SAAK,YAAY,KAAK,UAAU,KAAK,IAAI;AACzC,SAAK,eAAe,KAAK,aAAa,KAAK,IAAI;AAG/C,SAAK,SAAS,KAAK,SAAS,CAAA,GAAI,IAAI,SAAO,iBAAiB,GAAG,CAAC;AAChE,SAAK,QAAQ,KAAK,QAAQ,CAAA,GAAI,IAAI,SAAO,iBAAiB,GAAG,CAAC;AAE9D,SAAK,6BAA6B;AAClC,SAAK,gCAAgC,KAAK,iCAAiCA,gBAAe;AAC1F,SAAK,6BAA6B;AAGlC,SAAK,+BAA+B,IAAI,YAAY;MAClD,QAAQ,KAAK,8BAA8BA,gBAAe;MAC1D,UAAU;KACX;AAGD,SAAK,mBAAmB,IAAI,iBAAiB;MAC3C,mBAAmB;MACnB,WAAW,WAAW;MACtB,QAAQ,WAAW;MACnB,QAAQ,WAAW;OAClB;MACD,gBAAgB,KAAK;MACrB,QAAOC,OAAA,KAAK,UAAL,gBAAAA,KAAY,IAAI,OAAK,UAAU,CAAC;KACxC;AAED,SAAK,YAAY,IAAI,UAAU,YAAY;MACzC,eAAe,KAAK;MACpB,kBAAkB,KAAK,oBAAoB;MAC3C,oBAAoB,KAAK,sBAAsB;MAC/C,oBAAoB,KAAK,sBAAsB;MAC/C,aAAa,KAAK,eAAe;MACjC,WAAW,KAAK,aAAa;QAC3B,SAAS;;MAEX,aAAa,KAAK;KACnB;AAED,SAAK,iBAAiB,IAAI,eAAe;MACvC,QAAQ,WAAW;MACnB,WAAW,WAAW;MACtB,QAAQ,WAAW;MACnB,mBAAmB;OAClB;MACD,SAAS,KAAK;MACd,eAAe,KAAK;MACpB,eAAe,KAAK;MACpB,uBAAuB,KAAK;KAC7B;EACH;;;;;EAQA,MAAM,QAAK;AAnRb,QAAAA,MAAAC,KAAA;AAqRI,KAAAD,OAAA,KAAK,YAAL,gBAAAA,KAAc,oBAAoB,yCAAyC;MACzE,WAAW,MAAK;AACd,cAAM,SAAS;UACb,SAAS;UACT,mBAAmB,KAAK;UACxB,UAAU;UACV,oBAAoB,KAAK;;AAG3B,mBAAW,SAAS,KAAK,YAAY,OAAM,GAAI;AAC7C,qBAAW,QAAQ,OAAO;AACxB,mBAAO,KAAK,SAAS;UACvB;QACF;AAEA,eAAO;MACT;;AAIF,KAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAc,oBAAoB,iCAAiC;MACjE,OAAO;MACP,WAAW,MAAK;AACd,cAAM,SAAiC,CAAA;AAEvC,mBAAW,SAAS,KAAK,YAAY,OAAM,GAAI;AAC7C,qBAAW,QAAQ,OAAO;AACxB,uBAAW,UAAU,KAAK,SAAS;AACjC,oBAAM,MAAM,GAAG,OAAO,SAAS,IAAI,OAAO,YAAY,cAAc;AAEpE,qBAAO,GAAG,KAAK,OAAO,GAAG,KAAK,KAAK;YACrC;UACF;QACF;AAEA,eAAO;MACT;;AAIF,eAAK,YAAL,mBAAc,oBAAoB,6EAA6E;MAC7G,OAAO;MACP,WAAW,MAAK;AACd,cAAM,aAAuC,CAAA;AAE7C,mBAAW,SAAS,KAAK,YAAY,OAAM,GAAI;AAC7C,qBAAW,QAAQ,OAAO;AACxB,kBAAM,UAAkC,CAAA;AAExC,uBAAW,UAAU,KAAK,SAAS;AACjC,oBAAM,MAAM,GAAG,OAAO,SAAS,IAAI,OAAO,YAAY,cAAc;AAEpE,sBAAQ,GAAG,KAAK,QAAQ,GAAG,KAAK,KAAK;YACvC;AAEA,uBAAW,CAAC,UAAU,KAAK,KAAK,OAAO,QAAQ,OAAO,GAAG;AACvD,yBAAW,QAAQ,IAAI,WAAW,QAAQ,KAAK,CAAA;AAC/C,yBAAW,QAAQ,EAAE,KAAK,KAAK;YACjC;UACF;QACF;AAEA,cAAM,SAAiC,CAAA;AAEvC,iBAAS,CAAC,UAAU,MAAM,KAAK,OAAO,QAAQ,UAAU,GAAG;AACzD,mBAAS,OAAO,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAEpC,gBAAM,QAAQ,KAAK,MAAM,OAAO,SAAS,GAAG;AAC5C,iBAAO,QAAQ,IAAI,OAAO,KAAK;QACjC;AAEA,eAAO;MACT;;AAGF,SAAK,OAAO,iBAAiB,mBAAmB,KAAK,SAAS;AAC9D,SAAK,OAAO,iBAAiB,oBAAoB,KAAK,YAAY;AAElE,UAAM,MACJ,KAAK,WACL,KAAK,gBACL,KAAK,gBAAgB;AAGvB,SAAK,UAAU;AACf,SAAK,IAAI,SAAS;EACpB;;;;EAKA,MAAM,OAAI;AACR,SAAK,OAAO,oBAAoB,mBAAmB,KAAK,SAAS;AACjE,SAAK,OAAO,oBAAoB,oBAAoB,KAAK,YAAY;AAErE,UAAM,KACJ,KAAK,gBACL,KAAK,WACL,KAAK,gBAAgB;AAIvB,UAAM,QAA8B,CAAA;AACpC,eAAW,kBAAkB,KAAK,YAAY,OAAM,GAAI;AACtD,iBAAW,cAAc,gBAAgB;AACvC,cAAM,MAAM,YAAW;AACrB,cAAI;AACF,kBAAM,WAAW,MAAK;UACxB,SAAS,KAAK;AACZ,iBAAK,IAAI,MAAM,GAAG;UACpB;QACF,GAAE,CAAE;MACN;IACF;AAEA,SAAK,IAAI,0BAA0B,MAAM,MAAM;AAC/C,UAAM,QAAQ,IAAI,KAAK;AACvB,SAAK,YAAY,MAAK;AAEtB,SAAK,IAAI,SAAS;EACpB;EAEA,oBAAiB;AACf,WAAO,KAAK;EACd;EAEA,UAAW,KAA4B;AACrC,SAAK,KAAK,WAAW,GAAG,EAAE,MAAM,SAAM;AACpC,WAAK,IAAI,MAAM,GAAG;IACpB,CAAC;EACH;;;;EAKA,MAAM,WAAY,KAA4B;AAC5C,UAAM,EAAE,QAAQ,WAAU,IAAK;AAE/B,QAAI,CAAC,KAAK,SAAS;AAEjB,YAAM,WAAW,MAAK;AACtB;IACF;AAEA,QAAI,WAAW,WAAW,QAAQ;AAGhC;IACF;AAEA,UAAM,SAAS,WAAW;AAC1B,UAAM,YAAY,CAAC,KAAK,YAAY,IAAI,MAAM;AAC9C,UAAM,cAAc,KAAK,YAAY,IAAI,MAAM,KAAK,CAAA;AACpD,gBAAY,KAAK,UAAU;AAE3B,SAAK,YAAY,IAAI,QAAQ,WAAW;AAGxC,QAAI,OAAO,aAAa,QAAQ,OAAO,SAAS,OAAO;AACrD,YAAM,KAAK,UAAU,MAAM,QAAQ;QACjC,WAAW,OAAO;OACnB;IACH;AAEA,QAAI,WAAW;AACb,WAAK,OAAO,kBAAkB,gBAAgB,EAAE,QAAQ,WAAW,WAAU,CAAE;IACjF;EACF;;;;EAKA,aAAc,KAA4B;AACxC,UAAM,EAAE,QAAQ,WAAU,IAAK;AAC/B,UAAM,SAAS,WAAW;AAC1B,UAAM,YAAY,KAAK,YAAY,IAAI,MAAM,KAAK,CAAA;AAGlD,UAAM,oBAAoB,UAAU,OAAO,UAAQ,KAAK,OAAO,WAAW,EAAE;AAG5E,SAAK,YAAY,IAAI,QAAQ,iBAAiB;AAE9C,QAAI,kBAAkB,WAAW,GAAG;AAElC,WAAK,IAAI,mDAAmD,MAAM;AAClE,WAAK,YAAY,OAAO,MAAM;AAG9B,WAAK,OAAO,kBAAkB,mBAAmB,EAAE,QAAQ,WAAW,WAAU,CAAE;IACpF;EACF;EAEA,eAAgB,QAAe;AAC7B,QAAI,UAAU,MAAM;AAClB,aAAO,KAAK,YAAY,IAAI,MAAM,KAAK,CAAA;IACzC;AAEA,QAAI,QAAsB,CAAA;AAE1B,eAAW,KAAK,KAAK,YAAY,OAAM,GAAI;AACzC,cAAQ,MAAM,OAAO,CAAC;IACxB;AAEA,WAAO;EACT;EAEA,oBAAiB;AACf,WAAO,KAAK;EACd;EAEA,MAAM,eAAgB,mBAAqD,UAAiC,CAAA,GAAE;AAxehH,QAAAD,MAAAC;AAyeI,QAAI,CAAC,KAAK,SAAS;AACjB,YAAM,IAAI,gBAAgB,aAAa;IACzC;AAEA,SAAK;AAEL,QAAI;AACF,OAAAD,OAAA,QAAQ,WAAR,gBAAAA,KAAgB;AAEhB,YAAM,EAAE,OAAM,IAAK,eAAe,iBAAiB;AAEnD,UAAI,KAAK,OAAO,OAAO,MAAM,GAAG;AAC9B,cAAM,IAAI,mBAAmB,mBAAmB;MAClD;AAEA,UAAI,UAAU,QAAQ,QAAQ,UAAU,MAAM;AAC5C,aAAK,IAAI,WAAW,MAAM;AAC1B,cAAM,qBAAqB,KAAK,eAAe,MAAM,EAClD,KAAK,UAAQ,KAAK,UAAU,IAAI;AAEnC,YAAI,sBAAsB,MAAM;AAC9B,eAAK,IAAI,gDAAgD,MAAM;AAE/D,WAAAC,MAAA,QAAQ,eAAR,gBAAAA,IAAA,cAAqB,IAAI,oBAAoB,8BAA8B;AAC3E,iBAAO;QACT;MACF;AAEA,YAAM,aAAa,MAAM,KAAK,UAAU,KAAK,mBAAmB;QAC9D,GAAG;QACH,UAAU,QAAQ,YAAY;OAC/B;AAED,UAAI,WAAW,WAAW,QAAQ;AAChC,cAAM,IAAI,sBAAsB,yCAAyC;MAC3E;AAEA,UAAI,kBAAkB,KAAK,YAAY,IAAI,WAAW,UAAU;AAEhE,UAAI,mBAAmB,MAAM;AAC3B,0BAAkB,CAAA;AAClB,aAAK,YAAY,IAAI,WAAW,YAAY,eAAe;MAC7D;AAKA,UAAI,oBAAoB;AAExB,iBAAW,QAAQ,iBAAiB;AAClC,YAAI,KAAK,OAAO,WAAW,IAAI;AAC7B,8BAAoB;QACtB;AAGA,YAAI,QAAQ,UAAU,QAAQ,KAAK,OAAO,WAAW,MAAM,KAAK,WAAW,OAAO,WAAW,UAAU,GAAG;AACxG,qBAAW,MAAM,IAAI,sBAAsB,gCAAgC,CAAC;AAG5E,iBAAO;QACT;MACF;AAEA,UAAI,CAAC,mBAAmB;AACtB,wBAAgB,KAAK,UAAU;MACjC;AAEA,aAAO;IACT;AACE,WAAK;IACP;EACF;EAEA,MAAM,iBAAkB,QAAgB,UAAwB,CAAA,GAAE;AAChE,UAAM,cAAc,KAAK,YAAY,IAAI,MAAM,KAAK,CAAA;AAEpD,UAAM,QAAQ,IACZ,YAAY,IAAI,OAAM,eAAa;AACjC,UAAI;AACF,cAAM,WAAW,MAAM,OAAO;MAChC,SAAS,KAAU;AACjB,mBAAW,MAAM,GAAG;MACtB;IACF,CAAC,CAAC;EAEN;EAEA,MAAM,yBAA0B,QAA2B;AAEzD,UAAM,iBAAiB,KAAK,KAAK,KAAK,QAAK;AACzC,aAAO,GAAG,SAAS,OAAO,WAAW,YAAW,EAAG,OAAO;IAC5D,CAAC;AAED,QAAI,gBAAgB;AAClB,WAAK,IAAI,2EAA2E,OAAO,UAAU;AACrG,aAAO;IACT;AAGA,UAAM,kBAAkB,KAAK,MAAM,KAAK,WAAQ;AAC9C,aAAO,MAAM,SAAS,OAAO,WAAW,YAAW,EAAG,OAAO;IAC/D,CAAC;AAED,QAAI,iBAAiB;AACnB,WAAK;AAEL,aAAO;IACT;AAGA,QAAI,KAAK,+BAA+B,KAAK,+BAA+B;AAC1E,WAAK,IAAI,4EAA4E,OAAO,UAAU;AACtG,aAAO;IACT;AAEA,QAAI,OAAO,WAAW,mBAAkB,GAAI;AAC1C,YAAM,OAAO,OAAO,WAAW,YAAW,EAAG;AAE7C,UAAI;AACF,cAAM,KAAK,6BAA6B,QAAQ,MAAM,CAAC;MACzD,QAAQ;AACN,aAAK,IAAI,+EAA+E,OAAO,YAAY,IAAI;AAC/G,eAAO;MACT;IACF;AAEA,QAAI,KAAK,eAAc,EAAG,SAAS,KAAK,gBAAgB;AACtD,WAAK;AAEL,aAAO;IACT;AAEA,SAAK,IAAI,wDAAwD,OAAO,UAAU;AAClF,WAAO;EACT;EAEA,sBAAmB;AACjB,SAAK;EACP;EAEA,eAAY;AACV,UAAM,YAAkD;MACtD,QAAQ;MACR,SAAS;MACT,SAAS;MACT,UAAU;;AAGZ,WAAO,KAAK,UAAU,MAAM,MAAM,IAAI,SAAM;AAC1C,aAAO;QACL,IAAI,IAAI;QACR,QAAQ,UAAU,IAAI,MAAM;QAC5B,QAAQ,IAAI,QAAQ;QACpB,YAAY,CAAC,GAAG,IAAI,QAAQ,UAAU,EAAE,IAAI,QAAM,UAAU,EAAE,CAAC;;IAEnE,CAAC;EACH;EAEA,MAAM,WAAYC,YAAoC,UAA6B,CAAA,GAAE;AACnF,WAAO,KAAK,UAAU,WAAWA,YAAW,OAAO;EACrD;;AA5XUF,MAAA,OAAO;;;ACvQb,IAAO,gBAAP,MAAoB;EAQxB,YAAa,UAAgB;AAPtB;AACA;AACA;AACA;AACU;AACT;AAGN,SAAK,WAAW;AAChB,SAAK,gBAAgB;AACrB,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,WAAW;EAClB;EAEA,MAAO,GAAW,IAAU;AAC1B,WAAO,IAAK,KAAK,IAAI,EAAE,IAAI,MAAM,KAAK,QAAQ;EAChD;EAEA,KAAM,OAAe,OAAe,KAAK,IAAG,GAAE;AAC5C,QAAI,KAAK,gBAAgB,MAAM;AAE7B,YAAM,IAAI,KAAK,MAAM,MAAM,KAAK,YAAY;AAC5C,YAAM,OAAO,QAAQ,KAAK;AAC1B,YAAM,OAAO,IAAI;AACjB,WAAK,gBAAgB,IAAI,SAAS,IAAI,KAAK,KAAK;AAEhD,WAAK,YAAY,IAAI,MAAM,KAAK,WAAW,OAAO;AAClD,WAAK,YAAY,KAAK,KAAK,KAAK,QAAQ;AAExC,WAAK,WAAW,KAAK,gBAAgB,IAAI;IAC3C,OAAO;AACL,WAAK,gBAAgB;IACvB;AAEA,SAAK,eAAe;EACtB;;;;ACtCK,IAAM,6BAA6B;AACnC,IAAM,6BAA6B;AACnC,IAAM,sBAAsB;AAsB7B,IAAO,kBAAP,MAAsB;EAS1B,YAAa,OAA4B,CAAA,GAAE;AAR1B;AACA;AACA;AACA;AACA;AACA;AACA;AApCnB,QAAAG;AAuCI,SAAK,UAAU,IAAI,cAAc,KAAK,YAAY,GAAI;AACtD,SAAK,UAAU,IAAI,cAAc,KAAK,YAAY,GAAI;AACtD,SAAK,OAAO,IAAI,cAAc,KAAK,YAAY,GAAI;AACnD,SAAK,oBAAoB,KAAK,qBAAqB;AACnD,SAAK,oBAAoB,KAAK,qBAAqB;AACnD,SAAK,aAAa,KAAK,cAAc;AAErC,QAAI,KAAK,cAAc,MAAM;AAC3B,WAAK,UAASA,OAAA,KAAK,YAAL,gBAAAA,KAAc,oBAAoB,KAAK;IACvD;EACF;EAEA,iBAAkB,UAAmC,CAAA,GAAE;AAGrD,UAAM,UAAU,KAAK,IACnB,KAAK,MAAM,KAAK,KAAK,iBAAiB,QAAQ,iBAAiB,KAAK,kBAAkB,GACtF,KAAK,UAAU;AAEjB,UAAM,cAAc,YAAY,QAAQ,OAAO;AAC/C,UAAM,gBAAgB,UAAU,CAAC,QAAQ,QAAQ,WAAW,CAAC;AAC7D,oBAAgB,UAAU,eAAe,WAAW;AAEpD,kBAAc,QAAQ,KAAK,IAAG;AAC9B,kBAAc,UAAU;AAExB,WAAO;EACT;EAEA,QAAS,QAA6B;AApExC,QAAAA,MAAAC;AAqEI,UAAM,OAAO,KAAK,IAAG,IAAK,OAAO;AAEjC,QAAI,OAAO,SAAS;AAClB,WAAK,QAAQ,KAAK,IAAI;AACtB,WAAK,KAAK,KAAK,OAAO,KAAK,iBAAiB;AAC5C,OAAAD,OAAA,KAAK,WAAL,gBAAAA,KAAa,OAAO;QAClB,sBAAsB,KAAK,QAAQ;QACnC,kBAAkB,KAAK,QAAQ;QAC/B,iBAAiB,KAAK,QAAQ;QAC9B,iBAAiB,KAAK,QAAQ;QAC9B,SAAS;;IAEb,OAAO;AACL,WAAK,QAAQ,KAAK,IAAI;AACtB,WAAK,KAAK,KAAK,IAAI;AACnB,OAAAC,MAAA,KAAK,WAAL,gBAAAA,IAAa,OAAO;QAClB,sBAAsB,KAAK,QAAQ;QACnC,kBAAkB,KAAK,QAAQ;QAC/B,iBAAiB,KAAK,QAAQ;QAC9B,iBAAiB,KAAK,QAAQ;QAC9B,SAAS;;IAEb;EACF;;;;ACpFF,IAAM,2BAA2B;AACjC,IAAM,mBAAmB;AACzB,IAAM,gBAAgB;AACtB,IAAM,kBAAkB;AACxB,IAAM,cAAc;AACpB,IAAM,2CAA2C;AAbjD,IAAAC,KAAA;AA4DM,IAAO,oBAAP,MAAwB;EAU5B,YAAa,YAAyC,OAA8B,CAAA,GAAE;AATrE;AACA;AACA;AACT;AACS;AACT;AACS;AACA;AAgBR,wBAACA,KAAsB;AAEvB,wBAAC,IAAiC;MACzC;;AAhBA,SAAK,aAAa;AAClB,SAAK,WAAW,IAAI,KAAK,kBAAkB,eAAe,IAAI,aAAa,IAAI,gBAAgB;AAE/F,SAAK,MAAM,WAAW,OAAO,aAAa,2BAA2B;AACrE,SAAK,iBAAiB,KAAK,gBAAgB;AAC3C,SAAK,+BAA+B,KAAK,gCAAgC;AACzE,SAAK,UAAU,IAAI,gBAAgB;MACjC,GAAI,KAAK,eAAe,CAAA;MACxB,SAAS,WAAW;MACpB,YAAY;KACb;EACH;EAQA,QAAK;AACH,SAAK,kBAAkB,IAAI,gBAAe;AAC1C,oBAAgB,UAAU,KAAK,gBAAgB,MAAM;AAErD,SAAK,oBAAoB,YAAY,MAAK;AACxC,WAAK,WAAW,kBAAkB,eAAc,EAAG,QAAQ,UAAO;AAChE,gBAAQ,QAAO,EAAG,KAAK,YAAW;AAhG1C,cAAAA;AAiGU,cAAIC,SAAQ,KAAK,IAAG;AACpB,cAAI;AACF,kBAAM,SAAS,KAAK,QAAQ,iBAAiB;cAC3C,SAAQD,OAAA,KAAK,oBAAL,gBAAAA,KAAsB;aAC/B;AACD,kBAAM,SAAS,MAAM,KAAK,UAAU,KAAK,UAAU;cACjD;cACA,wBAAwB;aACzB;AACD,kBAAM,KAAK,WAAW,MAAM;AAC5B,YAAAC,SAAQ,KAAK,IAAG;AAEhB,kBAAM,QAAQ,IAAI;cAChB,GAAG,MAAM,YAAY,WAAW,GAAG;gBACjC;eACD;cACD,GAAG,KAAK,aAAa;gBACnB;eACD;aACF;AAED,iBAAK,MAAM,KAAK,IAAG,IAAKA;AAExB,kBAAM,GAAG,OAAM,EAAG,MAAM;cACtB;aACD;UACH,SAAS,KAAU;AACjB,gBAAI,IAAI,SAAS,4BAA4B;AAC3C,oBAAM;YACR;AAMA,iBAAK,OAAO,KAAK,IAAG,IAAKA,UAAS;UACpC;QACF,CAAC,EACE,MAAM,SAAM;AACX,eAAK,IAAI,MAAM,0BAA0B,GAAG;AAE5C,cAAI,KAAK,8BAA8B;AACrC,iBAAK,IAAI,MAAM,yCAAyC;AACxD,iBAAK,MAAM,GAAG;UAChB,OAAO;AACL,iBAAK,IAAI,mFAAmF;UAC9F;QACF,CAAC;MACL,CAAC;IACH,GAAG,KAAK,cAAc;EACxB;EAEA,OAAI;AArJN,QAAAD;AAsJI,KAAAA,OAAA,KAAK,oBAAL,gBAAAA,KAAsB;AAEtB,QAAI,KAAK,qBAAqB,MAAM;AAClC,oBAAc,KAAK,iBAAiB;IACtC;EACF;;AAvEUA,MAAA,OAAO,aAEP;;;ACtFZ,IAAAE;AAmBM,IAAO,yBAAP,MAA6B;EAKjC,YAAa,YAA8C,MAAgC;AAJ1E;AACT;AACS;AA0DR,wBAACA,KAAsB;AAhFlC,QAAAA,MAAAC,KAAA;AAyBI,SAAK,UAAU,KAAK,WAAW,CAAA;AAC/B,SAAK,UAAU;AACf,SAAK,aAAa;AAElB,SAAK,kBAAgBD,OAAA,WAAW,YAAX,gBAAAA,KAAoB,cAAc,uCAAuC,KAAK,cAAc,KAAK,IAAI,GAAG;MAC3H,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,GAAG,UAAS;AACtC,eAAO;UACL,GAAG;UACH,KAAK,IAAI,SAAQ;;MAErB;MACA,+BAA+B,CAAC,OAAO,UAAmC;AACxE,eAAO;UACL,GAAG;UACH,WAAW,CAAC,GAAI,MAAM,QAAQ,MAAM,SAAS,IAAI,MAAM,YAAY,CAAA,GAAK,MAAM,GAAG,SAAQ,CAAE;;MAE/F;WACI,KAAK;AACX,SAAK,YAAUC,MAAA,WAAW,YAAX,gBAAAA,IAAoB,cAAc,iCAAiC,KAAK,QAAQ,KAAK,IAAI,GAAG;MACzG,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,GAAG,UAAS;AACtC,eAAO;UACL,GAAG;UACH,KAAK,IAAI,SAAQ;;MAErB;WACI,KAAK;AACX,SAAK,oBAAkB,gBAAW,YAAX,mBAAoB,cAAc,yCAAyC,KAAK,gBAAgB,KAAK,IAAI,GAAG;MACjI,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,GAAG,UAAS;AACtC,eAAO;UACL,GAAG;UACH,KAAK,IAAI,SAAQ;;MAErB;WACI,KAAK;AACX,SAAK,QAAM,gBAAW,YAAX,mBAAoB,cAAc,6BAA6B,KAAK,IAAI,KAAK,IAAI,GAAG;MAC7F,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,MAAK;AAC/B,eAAO;UACL,KAAK,SAAmB,KAAK,QAAQ;;MAEzC;WACI,KAAK;AACX,SAAK,QAAM,gBAAW,YAAX,mBAAoB,cAAc,6BAA6B,KAAK,IAAI,KAAK,IAAI,GAAG;MAC7F,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,MAAK;AAC/B,eAAO;UACL,KAAK,SAAmB,KAAK,QAAQ;;MAEzC;WACI,KAAK;EACb;EAIA,YAAS;AACP,WAAO,KAAK;EACd;EAEA,MAAM,QAAK;AACT,SAAK,UAAU;EACjB;EAEA,MAAM,OAAI;AACR,SAAK,UAAU;EACjB;;;;EAKA,OAAQ,cAAe,KAAU,UAA0B,CAAA,GAAE;AAC3D,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,YAAM,IAAI,sBAAsB,8BAA8B;IAChE;AAEA,UAAM,OAAO;AACb,UAAM,OAAO,IAAI,QAAO;AAExB,qBAAiB,QAAQ,YACvB,GAAG,KAAK,QAAQ,IAAI,YAAU,OAAO,cAAc,KAAK,OAAO,CAAC,CAAC,GAChE;AAGD,UAAI,QAAQ,MAAM;AAChB;MACF;AAGA,UAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,cAAM,KAAK,WAAW,UAAU,MAAM,KAAK,IAAI;UAC7C,YAAY,KAAK;SAClB;MACH;AAGA,UAAI,KAAK,IAAI,KAAK,EAAE,GAAG;AACrB;MACF;AAEA,WAAK,IAAI,KAAK,EAAE;AAEhB,YAAM;IACR;EACF;;;;;EAMA,MAAM,QAAS,KAAU,UAAwB,CAAA,GAAE;AACjD,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,YAAM,IAAI,sBAAsB,8BAA8B;IAChE;AAEA,UAAM,QAAQ,IAAI,KAAK,QAAQ,IAAI,OAAO,WAAU;AAClD,YAAM,OAAO,QAAQ,KAAK,OAAO;IACnC,CAAC,CAAC;EACJ;EAEA,MAAM,gBAAiB,KAAU,UAAwB,CAAA,GAAE;AACzD,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,YAAM,IAAI,sBAAsB,8BAA8B;IAChE;AAEA,UAAM,QAAQ,IAAI,KAAK,QAAQ,IAAI,OAAO,WAAU;AAClD,YAAM,OAAO,gBAAgB,KAAK,OAAO;IAC3C,CAAC,CAAC;EACJ;;;;EAKA,MAAM,IAAK,KAAiB,OAAmB,SAAsB;AACnE,QAAI,CAAC,KAAK,UAAS,GAAI;AACrB,YAAM,IAAI,gBAAe;IAC3B;AAEA,UAAM,QAAQ,IAAI,KAAK,QAAQ,IAAI,OAAO,WAAU;AAClD,YAAM,OAAO,IAAI,KAAK,OAAO,OAAO;IACtC,CAAC,CAAC;EACJ;;;;;EAMA,MAAM,IAAK,KAAiB,SAAsB;AAChD,QAAI,CAAC,KAAK,UAAS,GAAI;AACrB,YAAM,IAAI,gBAAe;IAC3B;AAEA,WAAO,QAAQ,IAAI,KAAK,QAAQ,IAAI,OAAO,WAAU;AACnD,aAAO,OAAO,IAAI,KAAK,OAAO;IAChC,CAAC,CAAC;EACJ;;AArGUD,MAAA,OAAO;;;AChFnB,IAAAE;AAoBM,IAAO,qBAAP,MAAyB;EAM7B,YAAa,YAA0C,OAAwB,CAAA,GAAE;AALhE;AACA;AACA;AACA;AAkCR,wBAACA,KAAsB;AA1DlC,QAAAA,MAAAC;AA2BI,SAAK,MAAM,WAAW,OAAO,aAAa,qBAAqB;AAC/D,SAAK,SAAS,WAAW;AACzB,SAAK,YAAY,WAAW;AAC5B,SAAK,UAAU,KAAK,WAAW,CAAA;AAE/B,SAAK,aAAWD,OAAA,WAAW,YAAX,gBAAAA,KAAoB,cAAc,+BAA+B,KAAK,SAAS,KAAK,IAAI,GAAG;MACzG,cAAc;MACd,uBAAuB,CAAC,CAAC,IAAI,GAAG,UAAS;AACvC,eAAO;UACL,GAAG;UACH,MAAM,KAAK,SAAQ;;MAEvB;WACI,KAAK;AACX,SAAK,oBAAkBC,MAAA,WAAW,YAAX,gBAAAA,IAAoB,cAAc,sCAAsC,KAAK,gBAAgB,KAAK,IAAI,GAAG;MAC9H,cAAc;MACd,uBAAuB,CAAC,CAAC,GAAG,GAAG,UAAS;AACtC,eAAO;UACL,GAAG;UACH,KAAK,SAAmB,KAAK,QAAQ;;MAEzC;MACA,+BAA+B,CAAC,OAAO,UAA+B;AACpE,eAAO;UACL,GAAG;UACH,OAAO,CAAC,GAAI,MAAM,QAAQ,MAAM,KAAK,IAAI,MAAM,QAAQ,CAAA,GAAK,MAAM,GAAG,SAAQ,CAAE;;MAEnF;WACI,KAAK;EACb;;;;EAOA,MAAM,SAAU,IAAY,SAAwB;AAClD,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,YAAM,IAAI,mBAAmB,2BAA2B;IAC1D;AAEA,QAAI,GAAG,SAAQ,MAAO,KAAK,OAAO,SAAQ,GAAI;AAC5C,YAAM,IAAI,oBAAoB,6BAA6B;IAC7D;AAEA,UAAM,OAAO;AACb,UAAM,SAAS,YACb,GAAG,KAAK,QAAQ,IAAI,YAAW,mBAAgB;AAC7C,UAAI;AACF,cAAM,MAAM,OAAO,SAAS,IAAI,OAAO;MACzC,SAAS,KAAK;AACZ,aAAK,IAAI,MAAM,GAAG;MACpB;IACF,EAAE,CAAE,CAAC;AAGP,qBAAiB,QAAQ,QAAQ;AAC/B,UAAI,QAAQ,MAAM;AAChB;MACF;AAGA,UAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,cAAM,KAAK,UAAU,MAAM,KAAK,IAAI;UAClC,YAAY,KAAK;SAClB;MACH;AAEA,aAAO;IACT;AAEA,UAAM,IAAI,cAAa;EACzB;;;;EAKA,OAAQ,gBAAiB,KAAiB,UAA0B,CAAA,GAAE;AACpE,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC7B,YAAM,IAAI,mBAAmB,2BAA2B;IAC1D;AAEA,UAAM,OAAO;AACb,UAAM,OAAO,2BAA2B,IAAI;AAE5C,qBAAiB,QAAQ,SACvB,mBAAgB;AACd,YAAM,SAAS,YACb,GAAG,KAAK,QAAQ,IAAI,YAAU,OAAO,gBAAgB,KAAK,OAAO,CAAC,CAAC;AAGrE,qBAAeC,SAAQ,QAAQ;AAC7B,cAAM,YAAW;AAEf,cAAIA,MAAK,WAAW,WAAW,GAAG;AAChC,gBAAI;AACF,cAAAA,QAAO,MAAM,KAAK,SAASA,MAAK,IAAI;gBAClC,GAAG;gBACH,UAAU;eACX;YACH,SAAS,KAAK;AACZ,mBAAK,IAAI,MAAM,kCAAkC,GAAG;AACpD;YACF;UACF;AAEA,iBAAOA;QACT;MACF;IACF,EAAC,CAAE,GACF;AACD,UAAI,QAAQ,MAAM;AAChB;MACF;AAGA,UAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,cAAM,KAAK,UAAU,MAAM,KAAK,IAAI;UAClC,YAAY,KAAK;SAClB;MACH;AAGA,UAAI,KAAK,IAAI,KAAK,GAAG,YAAW,EAAG,KAAK,GAAG;AACzC;MACF;AAEA,WAAK,IAAI,KAAK,GAAG,YAAW,EAAG,KAAK;AAEpC,YAAM;IACR;EACF;;AApGUF,MAAA,OAAO;;;AC1DnB,IAAAG;AAmBM,IAAO,aAAP,cAA0B,kBAAmC;EASjE,YAAa,YAAgC;AAC3C,UAAK;AATU;AACA;AACT;AACA;AACA;AACA;AACA;AAeC,wBAACA,KAAsB;AAV9B,SAAK,MAAM,WAAW,OAAO,aAAa,oBAAoB;AAC9D,SAAK,cAAc,WAAW;AAC9B,SAAK,UAAU;AACf,SAAK,UAAU;AAGf,SAAK,qBAAqB,IAAI,gBAAe;AAC7C,oBAAgB,UAAU,KAAK,mBAAmB,MAAM;EAC1D;EAIA,QAAK;AACH,SAAK,qBAAqB,IAAI,gBAAe;AAC7C,oBAAgB,UAAU,KAAK,mBAAmB,MAAM;EAC1D;EAEA,OAAI;AACF,SAAK,mBAAmB,MAAK;EAC/B;EAEA,OAAQ,KAAM,SAAsB;AApDtC,QAAAA,MAAAC;AAqDI,QAAI,CAAC,KAAK,SAAS;AAEjB,WAAK,UAAS;IAChB;AAEA,SAAK;AACL,UAAM,SAAS,UAAU,CAAC,KAAK,mBAAmB,QAAQ,mCAAS,MAAM,CAAC;AAC1E,oBAAgB,UAAU,MAAM;AAEhC,QAAI;AACF,aAAO,MAAM;AAEX,SAAAD,OAAA,KAAK,aAAL,gBAAAA,KAAe;AACf,aAAK,WAAW,OAAM;AAGtB,cAAM,QAAQ,MAAM,UAAiC,MAAM,aAAa,QAAQ;UAC9E,YAAY;SACb;AAED,cAAM,MAAM;MACd;IACF;AACE,aAAO,MAAK;AACZ,WAAK;AAGL,UAAI,KAAK,YAAY,GAAG;AACtB,SAAAC,MAAA,KAAK,mBAAL,gBAAAA,IAAqB;AACrB,aAAK,iBAAiB;MACxB;IACF;EACF;EAEQ,YAAS;AACf,SAAK,UAAU;AAIf,SAAK,iBAAiB,IAAI,gBAAe;AACzC,oBAAgB,UAAU,KAAK,eAAe,MAAM;AAEpD,UAAM,SAAS,UAAU,CAAC,KAAK,eAAe,QAAQ,KAAK,mBAAmB,MAAM,CAAC;AACrF,oBAAgB,UAAU,MAAM;AAEhC,UAAMC,SAAQ,KAAK,IAAG;AACtB,QAAI,QAAQ;AAEZ,YAAQ,QAAO,EAAG,KAAK,YAAW;AAChC,WAAK,IAAI,YAAY;AAGrB,aAAO,KAAK,UAAU,GAAG;AACvB,YAAI;AACF,gBAAM,OAAO,YAAY,EAAE;AAC3B,cAAI,IAAI,KAAK,IAAG;AAEhB,2BAAiB,QAAQ,KAAK,YAAY,gBAAgB,MAAM,EAAE,OAAM,CAAE,GAAG;AAC3E,gBAAI,OAAO,SAAS;AAClB,mBAAK,IAAI,eAAe;YAC1B;AAEA,mBAAO,eAAc;AAErB,iBAAK,IAAI,2CAA2C,KAAK,IAAI,KAAK,IAAG,IAAK,GAAG,KAAK,OAAO;AACzF;AACA,iBAAK,kBAAkB,aAAa;cAClC,QAAQ;aACT;AAID,gBAAI,KAAK,YAAY,KAAK,KAAK,YAAY,MAAM;AAC/C,mBAAK,IAAI,oBAAoB;AAC7B,oBAAM,WAAW,KAAK,SAAS,SAAS,MAAM;YAChD;AAEA,gBAAI,KAAK,IAAG;UACd;AAEA,eAAK,IAAI,iEAAiE,MAAM,KAAK,SAAS,KAAK;QACrG,SAAS,KAAK;AACZ,eAAK,IAAI,MAAM,sBAAsB,GAAG;AAExC,eAAK,kBAAkB,cAAc;YACnC,QAAQ;WACT;QACH;MACF;AAEA,WAAK,IAAI,6BAA6B;IACxC,CAAC,EACE,MAAM,SAAM;AACX,WAAK,IAAI,MAAM,sBAAsB,GAAG;IAC1C,CAAC,EACA,QAAQ,MAAK;AACZ,WAAK,IAAI,4CAA4C,OAAO,KAAK,IAAG,IAAKA,MAAK;AAC9E,WAAK,UAAU;IACjB,CAAC;EACL;;AA/GUF,MAAA,OAAO;;;AClCZ,IAAM,8BAA8B;AACpC,IAAM,+BAA+B;AAR5C,IAAAG;AAoBM,IAAO,mBAAP,MAAuB;EAM3B,YAAa,YAA+B;AAL3B;AACA;AACA;AACA;AAiBR,wBAACA,KAAsB;AAd9B,SAAK,MAAM,WAAW,OAAO,aAAa,kBAAkB;AAC5D,SAAK,aAAa,oBAAI,IAAG;AACzB,SAAK,WAAW,oBAAI,IAAG;AACvB,SAAK,aAAa;AAElB,SAAK,gBAAgB,KAAK,cAAc,KAAK,IAAI;AACjD,SAAK,gBAAgB,KAAK,cAAc,KAAK,IAAI;AACjD,SAAK,kBAAkB,KAAK,gBAAgB,KAAK,IAAI;AAErD,SAAK,WAAW,OAAO,iBAAiB,mBAAmB,KAAK,aAAa;AAC7E,SAAK,WAAW,OAAO,iBAAiB,eAAe,KAAK,aAAa;AACzE,SAAK,WAAW,OAAO,iBAAiB,iBAAiB,KAAK,eAAe;EAC/E;EAIA,eAAY;AACV,WAAO,MAAM,KAAK,oBAAI,IAAY;MAChC,GAAG,KAAK,SAAS,KAAI;KACtB,CAAC,EAAE,KAAI;EACV;EAEA,WAAY,UAAgB;AAC1B,UAAM,UAAU,KAAK,SAAS,IAAI,QAAQ;AAE1C,QAAI,WAAW,MAAM;AACnB,YAAM,IAAa,uBAAuB,sCAAsC,QAAQ,EAAE;IAC5F;AAEA,WAAO;EACT;EAEA,cAAe,UAAgB;AAC7B,UAAM,aAAa,KAAK,WAAW,IAAI,QAAQ;AAE/C,QAAI,cAAc,MAAM;AACtB,aAAO,CAAA;IACT;AAEA,WAAO;MACL,GAAG,WAAW,OAAM;;EAExB;;;;EAKA,MAAM,OAAQ,UAAkB,SAAwB,MAA2B;AACjF,QAAI,KAAK,SAAS,IAAI,QAAQ,GAAG;AAC/B,YAAM,IAAa,8BAA8B,2CAA2C,QAAQ,EAAE;IACxG;AAEA,UAAM,UAAU,sBAAM,KAAK,EAAE,iBAAiB,KAAI,CAAE,EAAE;MACpD,mBAAmB;MACnB,oBAAoB;OACnB,IAAI;AAEP,SAAK,SAAS,IAAI,UAAU;MAC1B;MACA;KACD;AAGD,UAAM,KAAK,WAAW,UAAU,MAAM,KAAK,WAAW,QAAQ;MAC5D,WAAW,CAAC,QAAQ;KACrB;EACH;;;;;EAMA,MAAM,SAAU,WAA4B;AAC1C,UAAM,eAAe,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AAEtE,iBAAa,QAAQ,cAAW;AAC9B,WAAK,SAAS,OAAO,QAAQ;IAC/B,CAAC;AAGD,UAAM,KAAK,WAAW,UAAU,MAAM,KAAK,WAAW,QAAQ;MAC5D,WAAW,KAAK,aAAY;KAC7B;EACH;;;;EAKA,MAAM,SAAU,UAAkB,UAAkB;AAClD,QAAI,YAAY,MAAM;AACpB,YAAM,IAAI,uBAAuB,kBAAkB;IACrD;AAGA,UAAM,KAAK,IAAI,KAAK,OAAM,IAAK,KAAK,SAAS,EAAE,CAAC,GAAG,KAAK,IAAG,CAAE;AAE7D,QAAI,aAAa,KAAK,WAAW,IAAI,QAAQ;AAE7C,QAAI,cAAc,MAAM;AACtB,mBAAa,oBAAI,IAAG;AACpB,WAAK,WAAW,IAAI,UAAU,UAAU;IAC1C;AAEA,eAAW,IAAI,IAAI,QAAQ;AAE3B,WAAO;EACT;;;;EAKA,WAAY,IAAU;AACpB,eAAW,CAAC,UAAU,UAAU,KAAK,KAAK,WAAW,QAAO,GAAI;AAC9D,UAAI,WAAW,IAAI,EAAE,GAAG;AACtB,mBAAW,OAAO,EAAE;AAEpB,YAAI,WAAW,SAAS,GAAG;AACzB,eAAK,WAAW,OAAO,QAAQ;QACjC;MACF;IACF;EACF;;;;EAKA,cAAe,KAAwB;AACrC,UAAM,aAAa,IAAI;AAEvB,SAAK,KAAK,WAAW,UAAU,IAAI,UAAU,EAC1C,KAAK,UAAO;AA7JnB,UAAAA,MAAAC,KAAA;AA8JQ,iBAAW,YAAY,KAAK,WAAW;AACrC,cAAM,aAAa,KAAK,WAAW,IAAI,QAAQ;AAE/C,YAAI,cAAc,MAAM;AAEtB;QACF;AAEA,mBAAW,YAAY,WAAW,OAAM,GAAI;AAC1C,gBAAID,OAAA,SAAS,WAAT,gBAAAA,KAAiB,IAAI,iBAAgB,OAAO;AAC9C;UACF;AAEA,WAAAC,MAAA,SAAS,WAAT,gBAAAA,IAAiB,OAAO;AACxB,yBAAS,iBAAT,kCAAwB;QAC1B;MACF;IACF,CAAC,EACA,MAAM,SAAM;AACX,UAAI,IAAI,SAAS,iBAAiB;AAEhC;MACF;AAEA,WAAK,IAAI,MAAM,wDAAwD,YAAY,GAAG;IACxF,CAAC;EACL;;;;;EAMA,cAAe,KAA4B;AA9L7C,QAAAD,MAAAC,KAAA;AA+LI,UAAM,EAAE,MAAM,SAAQ,IAAK,IAAI;AAC/B,UAAM,YAAW,qCAAU,cAAa,CAAA,GAAI,OAAO,cAAY,CAAC,KAAK,UAAU,SAAS,QAAQ,CAAC;AAEjG,eAAW,YAAY,SAAS;AAC9B,YAAM,aAAa,KAAK,WAAW,IAAI,QAAQ;AAE/C,UAAI,cAAc,MAAM;AAEtB;MACF;AAEA,iBAAW,YAAY,WAAW,OAAM,GAAI;AAC1C,cAAID,OAAA,SAAS,WAAT,gBAAAA,KAAiB,IAAI,KAAK,SAAQ,OAAO;AAC3C;QACF;AAEA,SAAAC,MAAA,SAAS,WAAT,gBAAAA,IAAiB,OAAO,KAAK;AAC7B,uBAAS,iBAAT,kCAAwB,KAAK;MAC/B;IACF;EACF;;;;;EAMA,gBAAiB,KAAgC;AAzNnD,QAAAD,MAAAC,KAAA;AA0NI,UAAM,YAAY,IAAI,OAAO;AAC7B,UAAM,aAAa,IAAI,OAAO;AAC9B,UAAM,SAAS,IAAI,OAAO;AAE1B,eAAW,YAAY,WAAW;AAChC,YAAM,aAAa,KAAK,WAAW,IAAI,QAAQ;AAE/C,UAAI,cAAc,MAAM;AAEtB;MACF;AAEA,iBAAW,YAAY,WAAW,OAAM,GAAI;AAC1C,YAAI,WAAW,UAAU,QAAQ,SAAS,8BAA8B,MAAM;AAC5E;QACF;AAEA,cAAID,OAAA,SAAS,WAAT,gBAAAA,KAAiB,IAAI,aAAY,MAAM;AACzC;QACF;AAEA,SAAAC,MAAA,SAAS,WAAT,gBAAAA,IAAiB,IAAI;AACrB,uBAAS,cAAT,kCAAqB,QAAQ;MAC/B;IACF;EACF;;AA1MUD,MAAA,OAAO;;;AClCnB,IAAM,aAAN,cAA+B,IAAS;EAGtC,YAAa,MAAoB;AAC/B,UAAK;AAHU;AAKf,UAAM,EAAE,MAAAE,OAAM,QAAO,IAAK;AAE1B,SAAK,SAAS,QAAQ,eAAeA,KAAI;AACzC,SAAK,sBAAqB;EAC5B;EAEA,IAAK,KAAQ,OAAQ;AACnB,UAAM,IAAI,KAAK,KAAK;AACpB,SAAK,sBAAqB;AAC1B,WAAO;EACT;EAEA,OAAQ,KAAM;AACZ,UAAM,UAAU,MAAM,OAAO,GAAG;AAChC,SAAK,sBAAqB;AAC1B,WAAO;EACT;EAEA,QAAK;AACH,UAAM,MAAK;AACX,SAAK,sBAAqB;EAC5B;EAEQ,wBAAqB;AAC3B,SAAK,OAAO,OAAO,KAAK,IAAI;EAC9B;;AAeI,SAAU,WAAmB,QAA4B;AAC7D,QAAM,EAAE,MAAAA,OAAM,QAAO,IAAK;AAC1B,MAAI;AAEJ,MAAI,WAAW,MAAM;AACnB,UAAM,IAAI,WAAiB,EAAE,MAAAA,OAAM,QAAO,CAAE;EAC9C,OAAO;AACL,UAAM,oBAAI,IAAG;EACf;AAEA,SAAO;AACT;;;AChEA,IAAAC;AAoBM,IAAO,0BAAP,MAA8B;EAQlC,YAAa,YAA+C,OAA6B,CAAA,GAAE;AAP1E;AACA;AACA;AACA;AACA;AACT;AAcC,wBAACA,KAAsB;AAX9B,SAAK,MAAM,WAAW,OAAO,aAAa,mBAAmB;AAC7D,SAAK,aAAa;AAClB,SAAK,UAAU;AACf,SAAK,aAAa,oBAAI,IAAG;AACzB,SAAK,YAAY,WAAW;MAC1B,MAAM;MACN,SAAS,KAAK,WAAW;KAC1B;AACD,SAAK,iBAAiB,KAAK,kBAAkB,eAAe;EAC9D;;;;EAOA,IAAK,WAAoB;AACvB,UAAM,MAAM,UAAU,OAAO,WAAW;AAExC,QAAI,OAAO,MAAM;AACf,YAAM,IAAI,uBAAuB,iCAAiC;IACpE;AAEA,QAAI,KAAK,WAAW,IAAI,GAAG,GAAG;AAC5B,YAAM,IAAI,uBAAuB,6CAA6C,GAAG,EAAE;IACrF;AAEA,SAAK,IAAI,uBAAuB,GAAG;AAEnC,SAAK,WAAW,IAAI,KAAK,SAAS;AAElC,QAAI,CAAC,KAAK,UAAU,IAAI,GAAG,GAAG;AAC5B,WAAK,UAAU,IAAI,KAAK,CAAA,CAAE;IAC5B;EACF;EAEA,YAAS;AACP,WAAO,KAAK;EACd;EAEA,QAAK;AACH,SAAK,UAAU;EACjB;EAEA,MAAM,aAAU;AAEd,UAAM,QAAQ,KAAK,WAAW,eAAe,eAAc;AAE3D,UAAM,KAAK,OAAO,KAAK;EACzB;;;;EAKA,MAAM,OAAI;AACR,UAAM,QAAQ,CAAA;AACd,eAAW,CAAC,KAAK,SAAS,KAAK,KAAK,WAAW;AAC7C,WAAK,IAAI,4BAA4B,GAAG;AACxC,aAAO,UAAU,SAAS,GAAG;AAC3B,cAAM,WAAW,UAAU,IAAG;AAE9B,YAAI,YAAY,MAAM;AACpB;QACF;AAEA,cAAM,KAAK,SAAS,MAAK,CAAE;MAC7B;IACF;AAEA,UAAM,QAAQ,IAAI,KAAK;AACvB,SAAK,IAAI,sBAAsB;AAC/B,eAAW,OAAO,KAAK,UAAU,KAAI,GAAI;AACvC,WAAK,UAAU,IAAI,KAAK,CAAA,CAAE;IAC5B;AAEA,SAAK,UAAU;EACjB;;;;EAKA,MAAM,KAAM,IAAe,SAAqC;AA9GlE,QAAAA;AA+GI,UAAM,YAAY,KAAK,0BAA0B,EAAE;AAEnD,QAAI,aAAa,MAAM;AACrB,YAAM,IAAI,0BAA0B,sCAAsC,OAAO,EAAE,CAAC,EAAE;IACxF;AAEA,KAAAA,OAAA,mCAAS,eAAT,gBAAAA,KAAA,cAAsB,IAAI,oBAA4B,wCAAwC,UAAU,OAAO,WAAW,CAAC;AAK3H,WAAO,UAAU,KAAK,IAAI;MACxB,GAAG;MACH,UAAU,KAAK,WAAW;KAC3B;EACH;;;;EAKA,WAAQ;AACN,QAAI,QAAqB,CAAA;AACzB,eAAW,aAAa,KAAK,UAAU,OAAM,GAAI;AAC/C,iBAAW,YAAY,WAAW;AAChC,gBAAQ,CAAC,GAAG,OAAO,GAAG,SAAS,SAAQ,CAAE;MAC3C;IACF;AACA,WAAO;EACT;;;;EAKA,gBAAa;AACX,WAAO,MAAM,GAAG,GAAG,KAAK,WAAW,OAAM,CAAE;EAC7C;;;;EAKA,eAAY;AACV,WAAO,MAAM,GAAG,GAAG,KAAK,UAAU,OAAM,CAAE,EAAE,KAAI;EAClD;;;;EAKA,0BAA2B,IAAa;AACtC,eAAW,aAAa,KAAK,WAAW,OAAM,GAAI;AAChD,YAAM,QAAQ,UAAU,WAAW,CAAC,EAAE,CAAC;AAEvC,UAAI,MAAM,SAAS,GAAG;AACpB,eAAO;MACT;IACF;EACF;;;;EAKA,4BAA6B,IAAa;AACxC,eAAW,aAAa,KAAK,WAAW,OAAM,GAAI;AAChD,YAAM,QAAQ,UAAU,aAAa,CAAC,EAAE,CAAC;AAEzC,UAAI,MAAM,SAAS,GAAG;AACpB,eAAO;MACT;IACF;EACF;;;;EAKA,MAAM,OAAQ,OAAkB;AAC9B,QAAI,CAAC,KAAK,UAAS,GAAI;AACrB,YAAM,IAAI,gBAAgB,aAAa;IACzC;AAEA,QAAI,SAAS,QAAQ,MAAM,WAAW,GAAG;AACvC,WAAK,IAAI,kEAAkE;AAC3E;IACF;AAEA,UAAM,iBAAiB,CAAA;AAEvB,eAAW,CAAC,KAAK,SAAS,KAAK,KAAK,WAAW,QAAO,GAAI;AACxD,YAAM,iBAAiB,UAAU,aAAa,KAAK;AACnD,YAAM,QAAQ,CAAA;AAGd,iBAAW,QAAQ,gBAAgB;AACjC,aAAK,IAAI,kCAAkC,KAAK,IAAI;AACpD,cAAM,WAAW,UAAU,eAAe;UACxC,UAAU,KAAK,WAAW;SAC3B;AAED,YAAI,YAAwB,KAAK,UAAU,IAAI,GAAG,KAAK,CAAA;AAEvD,YAAI,aAAa,MAAM;AACrB,sBAAY,CAAA;AACZ,eAAK,UAAU,IAAI,KAAK,SAAS;QACnC;AAEA,kBAAU,KAAK,QAAQ;AAGvB,iBAAS,iBAAiB,aAAa,MAAK;AAC1C,eAAK,WAAW,OAAO,kBAAkB,uBAAuB;YAC9D,QAAQ;WACT;QACH,CAAC;AACD,iBAAS,iBAAiB,SAAS,MAAK;AACtC,gBAAM,QAAQ,UAAU,UAAU,OAAK,MAAM,QAAQ;AAGrD,oBAAU,OAAO,OAAO,CAAC;AAEzB,eAAK,WAAW,OAAO,kBAAkB,mBAAmB;YAC1D,QAAQ;WACT;QACH,CAAC;AAGD,cAAM,KAAK,SAAS,OAAO,IAAI,CAAC;MAClC;AAGA,UAAI,MAAM,WAAW,GAAG;AACtB,uBAAe,KAAK,GAAG;AACvB;MACF;AAEA,YAAM,UAAU,MAAM,QAAQ,WAAW,KAAK;AAK9C,YAAM,cAAc,QAAQ,KAAK,OAAK,EAAE,WAAW,WAAW;AAC9D,UAAK,eAAe,QAAS,KAAK,mBAAmB,eAAe,UAAU;AAC5E,cAAM,IAAI,sBAAsB,cAAc,GAAG,6CAA6C;MAChG;IACF;AAIA,QAAI,eAAe,WAAW,KAAK,WAAW,MAAM;AAClD,YAAMC,WAAU,oDAAoD,eAAe,KAAK,IAAI,CAAC;AAC7F,UAAI,KAAK,mBAAmB,eAAe,WAAW;AACpD,cAAM,IAAI,sBAAsBA,QAAO;MACzC;AACA,WAAK,IAAI,6BAA6BA,QAAO,EAAE;IACjD;EACF;;;;;EAMA,MAAM,OAAQ,KAAW;AACvB,UAAM,YAAY,KAAK,UAAU,IAAI,GAAG,KAAK,CAAA;AAC7C,SAAK,IAAI,MAAM,yBAAyB,GAAG;AAG3C,UAAM,QAAQ,CAAA;AACd,SAAK,IAAI,MAAM,4BAA4B,GAAG;AAC9C,WAAO,UAAU,SAAS,GAAG;AAC3B,YAAM,WAAW,UAAU,IAAG;AAE9B,UAAI,YAAY,MAAM;AACpB;MACF;AAEA,YAAM,KAAK,SAAS,MAAK,CAAE;IAC7B;AACA,UAAM,QAAQ,IAAI,KAAK;AAEvB,SAAK,WAAW,OAAO,GAAG;AAC1B,SAAK,UAAU,OAAO,GAAG;EAC3B;;;;;;;EAQA,MAAM,YAAS;AACb,UAAM,QAAQ,CAAA;AACd,eAAW,OAAO,KAAK,WAAW,KAAI,GAAI;AACxC,YAAM,KAAK,KAAK,OAAO,GAAG,CAAC;IAC7B;AAEA,UAAM,QAAQ,IAAI,KAAK;EACzB;;AAxQUD,MAAA,OAAO;;;ACxCZ,IAAM,cAAc;AAIpB,IAAM,sBAAsB;;;ACInC,IAAM,UAAU,WAAqB,IAAI;AAKzC,eAAsB,MAAO,QAAuG,QAAqC,SAAsB;AAC7L,QAAM,OAAO,MAAM,QAAQ,OAAO;AACpC;AAKA,eAAsB,SAAU,QAAuG,SAAuB,SAAsB;AAClL,QAAM,OAAO,OAAO,SAAS,OAAO;AACtC;AAKA,eAAsB,KAAM,QAAuG,SAAqC;AACtK,QAAM,MAAM,MAAM,OAAO,KAAK,OAAO;AAErC,MAAI,IAAI,eAAe,KAAK,IAAI,IAAI,IAAI,aAAa,CAAC,MAAM,QAAQ,CAAC,GAAG;AACtE,YAAQ,IAAI,MAAM,yCAAyC,GAAG;AAC9D,UAAM,IAAI,oBAAoB,iBAAiB;EACjD;AAEA,SAAO,IAAI,QAAQ,GAAG,EAAE;AAC1B;AAKA,eAAsB,WAAY,QAAuG,SAAqC;AAC5K,QAAM,MAAM,MAAM,KAAK,QAAQ,OAAO;AAEtC,SAAO,SAAmB,IAAI,SAAQ,CAAE;AAC1C;;;ACmBA,eAAsB,OAAsC,QAAgB,WAA8B,SAA8B;AACtI,cAAY,MAAM,QAAQ,SAAS,IAAI,CAAC,GAAG,SAAS,IAAI,CAAC,SAAS;AAElE,MAAI,UAAU,WAAW,KAAK,QAAQ,mBAAmB,OAAO;AAC9D,WAAO,iBAAiB,QAAQ,UAAU,CAAC,GAAG,OAAO;EACvD;AAEA,QAAM,KAAK,SAAS,QAAQ;IAC1B,GAAG;IACH,eAAe;GAChB;AACD,QAAM,WAAW,UAAU,MAAK;AAEhC,MAAI,YAAY,MAAM;AACpB,UAAM,IAAI,MAAM,yCAAyC;EAC3D;AAEA,UAAQ,IAAI,MAAM,8BAA8B,aAAa,QAAQ;AACrE,QAAM,KAAK,WAAqB,GAAG,WAAW;CAAI;AAClD,QAAM,KAAK,WAAqB,GAAG,QAAQ;CAAI;AAC/C,QAAkB,SAAS,IAAI,CAAC,IAAI,EAAE,GAAG,OAAO;AAEhD,UAAQ,IAAI,MAAM,2CAA2C;AAC7D,MAAI,WAAW,MAAkB,WAAW,IAAI,OAAO;AACvD,UAAQ,IAAI,MAAM,qBAAqB,QAAQ;AAG/C,MAAI,aAAa,aAAa;AAC5B,YAAQ,IAAI,MAAM,mCAAmC;AACrD,eAAW,MAAkB,WAAW,IAAI,OAAO;AACnD,YAAQ,IAAI,MAAM,qBAAqB,QAAQ;EACjD;AAGA,MAAI,aAAa,UAAU;AACzB,WAAO,EAAE,QAAQ,GAAG,OAAM,GAAI,SAAQ;EACxC;AAGA,aAAWE,aAAY,WAAW;AAChC,YAAQ,IAAI,MAAM,sBAAsBA,SAAQ;AAChD,UAAkB,MAAM,IAAI,WAAqB,GAAGA,SAAQ;CAAI,GAAG,OAAO;AAC1E,YAAQ,IAAI,MAAM,mCAAmC;AACrD,UAAMC,YAAW,MAAkB,WAAW,IAAI,OAAO;AACzD,YAAQ,IAAI,MAAM,8BAA8BA,WAAUD,SAAQ;AAElE,QAAIC,cAAaD,WAAU;AACzB,aAAO,EAAE,QAAQ,GAAG,OAAM,GAAI,UAAAA,UAAQ;IACxC;EACF;AAEA,QAAM,IAAI,yBAAyB,2BAA2B;AAChE;AAUA,SAAS,iBAAgD,QAAgB,UAAkB,SAA8B;AACvH,QAAM,eAAe,OAAO,KAAK,KAAK,MAAM;AAC5C,QAAM,iBAAiB,OAAO;AAE9B,MAAI,aAAa;AACjB,MAAI,cAAc;AAClB,QAAM,kBAAkB,OAAM;AAE9B,MAAI,eAAe;AACnB,MAAI,kBAAkB;AACtB,QAAM,sBAAsB,OAAM;AAElC,MAAI,eAAe;AACnB,MAAI,kBAAkB;AACtB,QAAM,sBAAsB,OAAM;AAElC,QAAM,KAAK,SAAS;IAClB,MAAM;IACN,QAAQ;KACP;IACD,GAAG;IACH,eAAe;GAChB;AAED,SAAO,OAAO,OAAM,WAAS;AAC3B,UAAM,EAAE,KAAI,IAAK,GAAG,OAAM;AAE1B,UAAM,KAAK,mBAAgB;AACzB,UAAI,WAAW;AAEf,uBAAiB,OAAO,QAAQ;AAE9B,YAAI,iBAAiB;AACnB,gBAAM,oBAAoB;QAC5B;AAGA,YAAI,CAAC,cAAc;AACjB,4BAAkB;AAElB,kBAAQ,IAAI,MAAM,oDAAoD,aAAa,UAAU,IAAI,UAAU;AAE3G,gBAAM,iBAAiB,GAAG,QAAQ;;AAGlC,gBAAM,IAAI;YACR,WAAW,KAAK,CAAC,EAAE,CAAC;;YACpB,WAAqB,GAAG,WAAW;CAAI;YAChC,OAAO,eAAe,MAAM;YACnC,WAAqB,cAAc;YACnC;UAAG,EACH,SAAQ;AAEV,kBAAQ,IAAI,MAAM,oDAAoD,aAAa,UAAU,IAAI,UAAU;AAE3G,yBAAe;AACf,4BAAkB;AAClB,8BAAoB,QAAO;AAG3B,oBAAS,EACN,MAAM,SAAM;AACX,oBAAQ,IAAI,MAAM,0DAA0D,UAAU,GAAG;UAC3F,CAAC;QACL,OAAO;AACL,gBAAM;QACR;AAEA,mBAAW;MACb;AAIA,UAAI,CAAC,UAAU;AACb,cAAM,UAAS;MACjB;IACF,EAAC,CAAE;EACL;AAEA,iBAAe,YAAS;AACtB,QAAI,aAAa;AACf,cAAQ,IAAI,MAAM,6CAA6C,QAAQ;AACvE,YAAM,gBAAgB;AACtB;IACF;AAEA,kBAAc;AAEd,QAAI;AAEF,UAAI,CAAC,cAAc;AACjB,gBAAQ,IAAI,MAAM,iDAAiD,QAAQ;AAC3E,cAAM,eAAc;MACtB;AAGA,UAAI,CAAC,cAAc;AACjB,gBAAQ,IAAI,MAAM,iDAAiD,QAAQ;AAC3E,cAAM,eAAc;MACtB;IACF;AACE,oBAAc;AACd,mBAAa;AACb,sBAAgB,QAAO;IACzB;EACF;AAEA,iBAAe,iBAAc;AAC3B,QAAI,iBAAiB;AACnB,YAAM,oBAAoB;AAC1B;IACF;AAEA,sBAAkB;AAElB,QAAI;AACF,cAAQ,IAAI,MAAM,kDAAkD,aAAa,QAAQ;AACzF,YAAM,GAAG,OAAO;QACd,WAAqB,GAAG,WAAW;CAAI;QACvC,WAAqB,GAAG,QAAQ;CAAI;OACrC;AACD,cAAQ,IAAI,MAAM,kDAAkD,aAAa,QAAQ;IAC3F;AACE,qBAAe;AACf,wBAAkB;AAClB,0BAAoB,QAAO;IAC7B;EACF;AAEA,iBAAe,iBAAc;AAC3B,QAAI,iBAAiB;AACnB,YAAM,oBAAoB;AAC1B;IACF;AAEA,sBAAkB;AAElB,QAAI;AACF,cAAQ,IAAI,MAAM,+CAA+C;AACjE,UAAI,WAAW,MAAkB,WAAW,IAAI,OAAO;AACvD,cAAQ,IAAI,MAAM,mDAAmD,QAAQ;AAE7E,UAAI,aAAa,aAAa;AAC5B,mBAAW,MAAkB,WAAW,IAAI,OAAO;MACrD;AAEA,cAAQ,IAAI,MAAM,kDAAkD,UAAU,QAAQ;AAEtF,UAAI,aAAa,UAAU;AACzB,cAAM,IAAI,yBAAyB,2BAA2B;MAChE;IACF;AACE,qBAAe;AACf,wBAAkB;AAClB,0BAAoB,QAAO;IAC7B;EACF;AAEA,SAAO,SAAU,mBAAgB;AAE/B,UAAM,UAAS;AAEf,YAAQ,IAAI,MAAM,6CAA6C,QAAQ;AACvE,WAAQ,GAAG,OAAM,EAAG;EACtB,EAAE;AAEF,MAAI,OAAO,aAAa,MAAM;AAC5B,UAAM,oBAAoB,OAAO,UAAU,KAAK,MAAM;AAEtD,WAAO,YAAY,OAAO,SAAQ;AAGhC,UAAI,CAAC,YAAY;AACf,cAAM,UAAS,EAAG,MAAM,SAAM;AAC5B,kBAAQ,IAAI,MAAM,kDAAkD,GAAG;QACzE,CAAC;MACH;AAGA,YAAM,kBAAkB,IAAI;IAC9B;EACF;AAEA,MAAI,OAAO,cAAc,MAAM;AAC7B,UAAM,qBAAqB,OAAO,WAAW,KAAK,MAAM;AAExD,WAAO,aAAa,OAAO,SAAQ;AAGjC,UAAI,CAAC,YAAY;AACf,cAAM,UAAS,EAAG,MAAM,SAAM;AAC5B,kBAAQ,IAAI,MAAM,mDAAmD,GAAG;QAC1E,CAAC;MACH;AAGA,YAAM,mBAAmB,IAAI;IAC/B;EACF;AAEA,MAAI,OAAO,SAAS,MAAM;AACxB,UAAM,gBAAgB,OAAO,MAAM,KAAK,MAAM;AAE9C,WAAO,QAAQ,OAAO,SAAQ;AAG5B,YAAM,QAAQ,CAAA;AAEd,UAAI,iBAAiB;AACnB,cAAM,KAAK,oBAAoB,OAAO;MACxC;AAEA,UAAI,iBAAiB;AACnB,cAAM,KAAK,oBAAoB,OAAO;MACxC;AAEA,UAAI,MAAM,SAAS,GAAG;AAEpB,cAAM,WACJ,QAAQ,IAAI,KAAK,GACjB,6BAAM,MAAM;MAEhB,OAAO;AAEL,qBAAa;AACb,sBAAc;AACd,wBAAgB,QAAO;MACzB;AAGA,YAAM,cAAc,IAAI;IAC1B;EACF;AAEA,SAAO;IACL;IACA;;AAEJ;;;ACrTA,eAAsB,OAA+C,QAAgB,WAA8B,SAA8B;AAC/I,cAAY,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AAC7D,UAAQ,IAAI,MAAM,kCAAkC,SAAS;AAE7D,QAAM,KAAK,SAAS,QAAQ;IAC1B,GAAG;IACH,eAAe;IACf,iBAAiB;;GAClB;AAED,SAAO,MAAM;AACX,YAAQ,IAAI,MAAM,iCAAiC;AACnD,UAAM,WAAW,MAAkB,WAAW,IAAI,OAAO;AACzD,YAAQ,IAAI,MAAM,qBAAqB,QAAQ;AAE/C,QAAI,aAAa,aAAa;AAC5B,cAAQ,IAAI,MAAM,sCAAsC,aAAa,QAAQ;AAC7E,YAAkB,MAAM,IAAI,WAAqB,GAAG,WAAW;CAAI,GAAG,OAAO;AAC7E,cAAQ,IAAI,MAAM,wCAAwC,aAAa,QAAQ;AAC/E;IACF;AAEA,QAAI,UAAU,SAAS,QAAQ,GAAG;AAChC,cAAQ,IAAI,MAAM,sCAAsC,UAAU,QAAQ;AAC1E,YAAkB,MAAM,IAAI,WAAqB,GAAG,QAAQ;CAAI,GAAG,OAAO;AAC1E,cAAQ,IAAI,MAAM,wCAAwC,UAAU,QAAQ;AAE5E,aAAO,EAAE,QAAQ,GAAG,OAAM,GAAI,SAAQ;IACxC;AAEA,QAAI,aAAa,MAAM;AAErB,YAAM,SAAS,IAAI,eACjB,GAAG,UAAU,IAAI,OAAKE,QAAO,OAAO,WAAqB,GAAG,CAAC;CAAI,CAAC,CAAC,GACnE,WAAqB,IAAI,CAAC;AAG5B,cAAQ,IAAI,MAAM,oCAAoC,WAAW,QAAQ;AACzE,YAAkB,MAAM,IAAI,QAAQ,OAAO;AAC3C,cAAQ,IAAI,MAAM,sCAAsC,WAAW,QAAQ;AAC3E;IACF;AAEA,YAAQ,IAAI,MAAM,sCAAsC,QAAQ;AAChE,UAAkB,MAAM,IAAI,WAAqB,MAAM,GAAG,OAAO;AACjE,YAAQ,IAAI,wCAAwC,QAAQ;EAC9D;AACF;;;AClGA,IAAM,gBAAgB;AAJtB,IAAAC,MAAAC;AA0BM,IAAO,iBAAP,MAAqB;;;;;EAmDzB,YAAa,MAAoB;AA/CjB;;;;AAKA;;;;AAKA;;;;AAET;AACA;AACA;AACA;AACA;AACA;AACS;AAMT;;;;;AAKU;;;;AAKA;;;;AAEA;AAKA;;;;AA+BR,wBAACD,MAAsB;AAEvB,wBAACC,KAAoB;AA1B5B,UAAM,EAAE,YAAY,YAAY,WAAW,OAAO,OAAO,WAAU,IAAK;AAExE,SAAK,KAAK,GAAI,SAAS,OAAO,KAAK,OAAM,IAAK,GAAG,CAAC,EAAG,SAAS,EAAE,CAAC,GAAG,KAAK,IAAG,CAAE;AAC9E,SAAK,aAAa;AAClB,SAAK,aAAa;AAClB,SAAK,YAAY,KAAK;AACtB,SAAK,SAAS;AACd,SAAK,WAAW,KAAK;AACrB,SAAK,cAAc,KAAK;AACxB,SAAK,aAAa,KAAK;AACvB,SAAK,SAAS,KAAK;AACnB,SAAK,MAAM,KAAK,OAAO,aAAa,qBAAqB,KAAK,SAAS,IAAI,KAAK,EAAE,EAAE;AAEpF,QAAI,KAAK,WAAW,UAAS,KAAM,MAAM;AACvC,WAAK,aAAa,KAAK,WAAW,YAAY,QAAQ,KAAK,UAAU,EAAE;IACzE;AAEA,SAAK,aAAa;AAClB,SAAK,SAAS;AACd,SAAK,SAAS;AACd,SAAK,cAAc;AACnB,SAAK,OAAO,CAAA;EACd;;;;EASA,IAAI,UAAO;AACT,WAAO,KAAK,YAAW;EACzB;;;;EAKA,MAAM,UAAW,WAA8B,SAA0B;AACvE,QAAI,KAAK,WAAW,WAAW;AAC7B,YAAM,IAAI,uBAAuB,gCAAgC;IACnE;AAEA,QAAI,KAAK,WAAW,UAAU;AAC5B,YAAM,IAAI,sBAAsB,0BAA0B;IAC5D;AAEA,QAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7B,kBAAY,CAAC,SAAS;IACxB;AAEA,QAAI,KAAK,UAAU,SAAQ,mCAAS,4BAA2B,MAAM;AACnE,YAAM,IAAI,uBAAuB,mDAAmD;IACtF;AAEA,UAAM,SAAS,MAAM,KAAK,WAAW,WAAW,OAAO;AAEvD,WAAO,YAAY;AAEnB,WAAO;EACT;;;;EAKA,MAAM,MAAO,UAAwB,CAAA,GAAE;AACrC,QAAI,KAAK,WAAW,YAAY,KAAK,WAAW,WAAW;AACzD;IACF;AAEA,SAAK,IAAI,4BAA4B,KAAK,UAAU;AAEpD,SAAK,SAAS;AAEd,QAAI,QAAQ,UAAU,MAAM;AAC1B,YAAM,SAAS,YAAY,QAAQ,aAAa;AAChD,sBAAgB,UAAU,MAAM;AAEhC,gBAAU;QACR,GAAG;QACH;;IAEJ;AAEA,QAAI;AACF,WAAK,IAAI,MAAM,8BAA8B;AAG7C,YAAM,KAAK,OAAO,OAAO;AAEzB,WAAK,IAAI,MAAM,mCAAmC;AAElD,WAAK,SAAS;AACd,WAAK,SAAS,QAAQ,KAAK,IAAG;IAChC,SAAS,KAAU;AACjB,WAAK,IAAI,MAAM,+DAA+D,KAAK,YAAY,GAAG;AAClG,WAAK,MAAM,GAAG;IAChB;EACF;EAEA,MAAO,KAAU;AACf,QAAI,KAAK,WAAW,UAAU;AAC5B;IACF;AAEA,SAAK,IAAI,MAAM,0CAA0C,KAAK,YAAY,GAAG;AAE7E,SAAK,SAAS;AAGd,SAAK,OAAO,GAAG;AAEf,SAAK,SAAS;AACd,SAAK,SAAS,QAAQ,KAAK,IAAG;EAChC;;AA1FUD,OAAA,OAAO,aAEPC,MAAA;AA2FN,SAAU,iBAAkB,MAAoB;AACpD,SAAO,IAAI,eAAe,IAAI;AAChC;;;AClIA,SAAS,wBAAyB,UAAkB,WAAoB;AACtE,MAAI;AACF,UAAM,EAAE,QAAO,IAAK,UAAU,WAAW,QAAQ;AAEjD,WAAO,QAAQ;EACjB,SAAS,KAAU;AACjB,QAAI,IAAI,SAAS,0BAA0B;AACzC,YAAM;IACR;EACF;AAEA,SAAO;AACT;AAEA,SAAS,wBAAyB,UAAkB,WAAsB,UAA4B,CAAA,GAAE;AACtG,MAAI;AACF,UAAM,EAAE,SAAAC,SAAO,IAAK,UAAU,WAAW,QAAQ;AAEjD,QAAIA,SAAQ,sBAAsB,MAAM;AACtC,aAAOA,SAAQ;IACjB;EACF,SAAS,KAAU;AACjB,QAAI,IAAI,SAAS,0BAA0B;AACzC,YAAM;IACR;EACF;AAEA,SAAO,QAAQ,sBAAsB;AACvC;AAEA,SAAS,aAAc,UAAkB,WAAmC,YAAsB;AAChG,MAAI,cAAc;AAElB,aAAW,QAAQ,QAAQ,YAAS;AAClC,QAAI,OAAO,cAAc,aAAa,OAAO,aAAa,UAAU;AAClE;IACF;EACF,CAAC;AAED,SAAO;AACT;AA3GA,IAAAC;AA2HM,IAAO,kBAAP,MAAsB;EAc1B,YAAa,YAAuC,MAAkB;AAbrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8BR,wBAACA,MAAsB;AAlKlC,QAAAA,MAAAC;AA0II,SAAK,aAAa;AAClB,SAAK,uBAAuB,oBAAI,IAAG;AAEnC,SAAK,qBAAqB,QAAQ,eAAY;AAC5C,WAAK,qBAAqB,IAAI,UAAU,UAAU,SAAS;IAC7D,CAAC;AAED,SAAK,eAAe,oBAAI,IAAG;AAE3B,SAAK,aAAa,QAAQ,WAAQ;AAChC,WAAK,aAAa,IAAI,MAAM,UAAU,KAAK;IAC7C,CAAC;AAED,SAAK,wBAAwB,KAAK,yBAAyB;AAC3D,SAAK,yBAAyB,KAAK,0BAA0B;AAC7D,SAAK,0CAA0C,KAAK,2CAA2C;AAC/F,SAAK,2CAA2C,KAAK,4CAA4C;AACjG,SAAK,SAAS,WAAW;AACzB,SAAK,UAAU;MACb,QAAOD,OAAA,WAAW,YAAX,gBAAAA,KAAoB,qBAAqB;MAChD,SAAQC,MAAA,WAAW,YAAX,gBAAAA,IAAoB,qBAAqB;;EAErD;EAMA,MAAM,sBAAuB,WAA2D,MAAW;AACjG,UAAM,gBAAqB,KAAK,WAAW,gBAAgB,MAAM;AAEjE,QAAI,iBAAiB,MAAM;AACzB;IACF;AAEA,UAAM,SAAS,MAAM,cAAc,MAAM,KAAK,WAAW,iBAAiB,IAAI;AAE9E,QAAI,WAAW,MAAM;AACnB,YAAM,IAAI,2BAA2B,gDAAgD,MAAM,EAAE;IAC/F;EACF;;;;EAKA,MAAM,eAAgB,QAA6B,OAAwB,CAAA,GAAE;AAvL/E,QAAAD,MAAAC;AAwLI,QAAI,WAAW;AAEf,QAAI;AACF,OAAAD,OAAA,KAAK,QAAQ,UAAb,gBAAAA,KAAoB,UAAU;QAC5B,SAAS;;AAGX,iBAAW,MAAM,KAAK,WAAW,kBAAkB,yBAAyB,MAAM;AAElF,UAAI,CAAC,UAAU;AACb,cAAM,IAAI,sBAAsB,mBAAmB;MACrD;AAEA,YAAM,KAAK,sBAAsB,yBAAyB,MAAM;AAEhE,YAAM,KAAK,gBAAgB,QAAQ,WAAW,IAAI;IACpD,SAAS,KAAK;AACZ,OAAAC,MAAA,KAAK,QAAQ,WAAb,gBAAAA,IAAqB,UAAU;QAC7B,SAAS;;AAGX,YAAM;IACR;AACE,UAAI,UAAU;AACZ,aAAK,WAAW,kBAAkB,oBAAmB;MACvD;IACF;EACF;;;;EAKA,MAAM,gBAAiB,QAA6B,OAAwB,CAAA,GAAE;AAxNhF,QAAAD,MAAAC;AAyNI,QAAI;AACF,OAAAD,OAAA,KAAK,QAAQ,UAAb,gBAAAA,KAAoB,UAAU;QAC5B,UAAU;;AAGZ,YAAM,QAAQ,OAAO,WAAW,UAAS;AACzC,UAAI;AAEJ,UAAI,SAAS,MAAM;AACjB,uBAAe,iBAAiB,KAAK;AACrC,cAAM,KAAK,sBAAsB,0BAA0B,cAAc,MAAM;MACjF;AAEA,aAAO,MAAM,KAAK,gBAAgB,QAAQ,YAAY,IAAI;IAC5D,SAAS,KAAK;AACZ,OAAAC,MAAA,KAAK,QAAQ,WAAb,gBAAAA,IAAqB,UAAU;QAC7B,UAAU;;AAGZ,YAAM;IACR;EACF;EAEQ,MAAM,gBAAiB,QAA6B,WAAmC,MAAqB;AAhPtH,QAAAD,MAAAC,KAAA;AAiPI,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,UAAM,uBAAuB,YAAY,QAAQ,cAAc,YAAY,KAAK,wBAAwB,KAAK,sBAAsB;AACnI,UAAM,SAAS,UAAU,CAAC,sBAAsB,KAAK,MAAM,CAAC;AAC5D,oBAAgB,UAAU,sBAAsB,MAAM;AACtD,SAAK,SAAS;AAEd,KAAAD,OAAA,KAAK,WAAW,YAAhB,gBAAAA,KAAyB,yBAAyB;AAElD,WAAO,IAAI,MAAM,sCAAsC,SAAS;AAGhE,QAAI,gBAAgB;AAEpB,SAAI,6BAAM,oBAAmB,MAAM;AACjC,YAAM,YAAY,KAAK,WAAW;AAElC,UAAI,aAAa,MAAM;AACrB,eAAO,IAAI,gCAAgC,SAAS;AACpD,wBAAgB,MAAM,UAAU,QAAQ,QAAQ,IAAI;MACtD;IACF;AAEA,QAAI;AAEF,sBAAgB;AAChB,WAAI,6BAAM,oBAAmB,MAAM;AACjC,SAAAC,MAAA,6BAAM,eAAN,gBAAAA,IAAA,WAAmB,IAAI,oBAAoB,oBAAoB,SAAS,aAAa;AAErF,SAAC;UACC,MAAM;UACN;UACA,UAAU;YACR,OAAO,cAAc,YACrB,KAAK,gBAAgB,eAAe;UACpC,GAAG;UACH;SACD,IACC,KAAK,iBAAiB,eAAe;UACrC,GAAG;UACH;SACD;AAGH,cAAMC,UAA8B;UAClC,GAAG;UACH,GAAG;;AAGL,cAAM,KAAK,sBAAsB,cAAc,YAAY,mCAAmC,mCAAmC,YAAYA,OAAM;MACrJ,OAAO;AACL,cAAM,QAAQ,OAAO,WAAW,UAAS;AAEzC,YAAI,SAAS,MAAM;AACjB,gBAAM,IAAI,sBAAsB,GAAG,SAAS,yDAAyD;QACvG;AAEA,cAAM,eAAe,iBAAiB,KAAK;AAE3C,yBAAiB;AACjB,qBAAa;MACf;AAIA,UAAI,WAAW,OAAO,KAAK,WAAW,MAAM,GAAG;AAC7C,cAAM,MAAM,IAAI,mBAAmB,mBAAmB;AACtD,eAAO,MAAM,GAAG;AAChB,cAAM;MACR;AAEA,qBAAe;AACf,WAAI,6BAAM,iBAAgB,MAAM;AAC9B,uBAAe,KAAK;MACtB,WAAW,KAAK,aAAa,OAAO,GAAG;AACrC,2CAAM,eAAN,8BAAmB,IAAI,oBAAoB,sBAAsB,SAAS,aAAa;AAGvF,cAAM,cAAc,OAAO,cAAc,YACrC,KAAK,kBAAkB;UACvB,GAAG;UACH,GAAG;WACF,KAAK,cAAc,IAAI,IACxB,KAAK,mBAAmB;UACxB,GAAG;UACH,GAAG;WACF,KAAK,cAAc,IAAI;AAC5B,uBAAe,YAAY;AAC3B,uBAAe,YAAY;MAC7B;IACF,SAAS,KAAU;AACjB,aAAO,IAAI,MAAM,mDAAmD,cAAc,YAAY,SAAS,MAAM,OAAO,YAAY,GAAG;AACnI,YAAM;IACR;AACE,aAAO,MAAK;IACd;AAEA,UAAM,KAAK,sBAAsB,cAAc,YAAY,kCAAkC,kCAAkC,YAAY,MAAM;AAEjJ,WAAO,IAAI,uCAAuC,SAAS;AAE3D,WAAO,KAAK,kBAAkB;MAC5B;MACA;MACA;MACA;MACA;MACA;MACA,QAAQ,6BAAM;KACf;EACH;;;;EAKA,kBAAmB,MAA6B;AAC9C,UAAM,EACJ,gBACA,WACA,QACA,cACA,YACA,cACA,OAAM,IACJ;AAEJ,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,QAAI,gBAAgB,MAAM;AAExB,cAAQ,aAAa,kBAAkB;QACrC;;QAEA,kBAAkB,iBAAc;AAC9B,cAAI,cAAc,MAAM;AACtB;UACF;AAEA,eAAK,QAAQ,QAAO,EACjB,KAAK,YAAW;AAlY7B,gBAAAF;AAmYc,kBAAM,YAAY,KAAK,WAAW,UAAU,aAAY;AACxD,kBAAM,SAAS,YAAY,QAAQ,KAAK,uCAAuC;AAC/E,4BAAgB,UAAU,MAAM;AAEhC,kBAAM,EAAE,QAAQ,SAAQ,IAAK,MAAU,OAAO,aAAa,WAAW;cACpE;cACA,KAAK,YAAY;cACjB,YAAY;aACb;AAED,gBAAI,cAAc,MAAM;AACtB;YACF;AAEA,uBAAW,IAAI,gCAAgC,QAAQ;AAEvD,kBAAM,gBAAgB,wBAAwB,UAAU,KAAK,WAAW,SAAS;AACjF,kBAAM,cAAc,aAAa,UAAU,WAAW,UAAU;AAEhE,gBAAI,gBAAgB,eAAe;AACjC,oBAAM,MAAM,IAAI,mCAAmC,mDAAmD,QAAQ,aAAa,aAAa,EAAE;AAC1I,0BAAY,MAAM,GAAG;AAErB,oBAAM;YACR;AAIA,wBAAY,SAAS,OAAO;AAC5B,wBAAY,OAAO,OAAO;AAC1B,wBAAY,WAAW;AAGvB,gBAAI,OAAO,cAAc,MAAM;AAC7B,0BAAY,aAAa,OAAO;YAClC;AAGA,gBAAI,OAAO,aAAa,MAAM;AAC5B,0BAAY,YAAY,OAAO;YACjC;AAGA,gBAAI,OAAO,SAAS,MAAM;AACxB,0BAAY,QAAQ,OAAO;YAC7B;AAIA,kBAAM,KAAK,WAAW,UAAU,MAAM,YAAY;cAChD,WAAW,CAAC,QAAQ;aACrB;AAED,aAAAA,OAAA,KAAK,WAAW,YAAhB,gBAAAA,KAAyB,oBAAoB,aAAa;AAE1D,iBAAK,UAAU,EAAE,YAAY,QAAQ,aAAa,SAAQ,CAAE;UAC9D,CAAC,EACA,MAAM,OAAM,QAAM;AACjB,uBAAW,IAAI,MAAM,6CAA6C,YAAY,IAAI,GAAG;AAErF,gBAAI,YAAY,SAAS,SAAS,MAAM;AACtC,oBAAM,YAAY,MAAK;YACzB;UACF,CAAC;QACL;OACD;AAED,kBAAY,OAAO,WAAqB,UAA4B,CAAA,MAAuB;AAtcjG,YAAAA;AAucQ,YAAI,SAAS,MAAM;AACjB,gBAAM,IAAI,sBAAsB,+BAA+B;QACjE;AAEA,mBAAW,IAAI,MAAM,wCAAwC,SAAS;AACtE,cAAM,cAAc,MAAM,MAAM,UAAS;AACzC,mBAAW,IAAI,MAAM,0CAA0C,YAAY,IAAI,SAAS;AAExF,YAAI;AACF,cAAI,QAAQ,UAAU,MAAM;AAC1B,wBAAY,IAAI,qGAAqG,SAAS;AAE9H,kBAAM,SAAS,YAAY,QAAQ,KAAK,wCAAwC;AAChF,4BAAgB,UAAU,MAAM;AAEhC,sBAAU;cACR,GAAG;cACH;;UAEJ;AAEA,sBAAY,IAAI,MAAM,wCAAwC,SAAS;AAEvE,gBAAM,EACJ,QACA,SAAQ,IACN,MAAU,OAAO,aAAa,WAAW;YAC3C,GAAG;YACH,KAAK,YAAY;YACjB,YAAY;WACb;AAED,sBAAY,IAAI,MAAM,wBAAwB,QAAQ;AAEtD,gBAAM,gBAAgB,wBAAwB,UAAU,KAAK,WAAW,WAAW,OAAO;AAC1F,gBAAM,cAAc,aAAa,UAAU,YAAY,UAAU;AAEjE,cAAI,eAAe,eAAe;AAChC,kBAAM,MAAM,IAAI,oCAAoC,oDAAoD,QAAQ,OAAO,WAAW,IAAI,aAAa,EAAE;AACrJ,wBAAY,MAAM,GAAG;AAErB,kBAAM;UACR;AAIA,gBAAM,KAAK,WAAW,UAAU,MAAM,YAAY;YAChD,WAAW,CAAC,QAAQ;WACrB;AAID,sBAAY,SAAS,OAAO;AAC5B,sBAAY,OAAO,OAAO;AAC1B,sBAAY,WAAW;AAGvB,cAAI,OAAO,cAAc,MAAM;AAC7B,wBAAY,aAAa,OAAO;UAClC;AAGA,cAAI,OAAO,aAAa,MAAM;AAC5B,wBAAY,YAAY,OAAO;UACjC;AAGA,cAAI,OAAO,SAAS,MAAM;AACxB,wBAAY,QAAQ,OAAO;UAC7B;AAEA,WAAAA,OAAA,KAAK,WAAW,YAAhB,gBAAAA,KAAyB,oBAAoB,aAAa;AAE1D,iBAAO;QACT,SAAS,KAAU;AACjB,qBAAW,IAAI,MAAM,kFAAkF,cAAc,YAAY,SAAS,MAAM,KAAK,OAAO,YAAY,WAAW,GAAG;AAEtL,cAAI,YAAY,SAAS,SAAS,MAAM;AACtC,wBAAY,MAAM,GAAG;UACvB;AAEA,gBAAM;QACR;MACF;AAGA,WAAK,QAAQ,IAAI;QACf,MAAM,KAAK,aAAa,MAAM;QAC9B,aAAa,KAAK,MAAM,MAAM;OAC/B,EAAE,MAAM,SAAM;AACb,mBAAW,IAAI,MAAM,wCAAwC,GAAG;MAClE,CAAC;IACH;AAEA,UAAM,YAAY,OAAO;AACzB,WAAO,WAAW,IAAI,MAAM,WAAW;MACrC,KAAK,IAAI,SAAQ;AACf,YAAI,KAAK,CAAC,MAAM,WAAW,KAAK,CAAC,KAAK,QAAQ,UAAU,SAAS,MAAM;AAErE,WAAC,YAAW;AACV,gBAAI;AACF,kBAAI,WAAW,WAAW,QAAQ;AAChC,sBAAM,WAAW,MAAK;cACxB;YACF,SAAS,KAAU;AACjB,yBAAW,IAAI,MAAM,oDAAoD,GAAG;YAC9E;AACE,mBAAK,OAAO,kBAAkB,oBAAoB;gBAChD,QAAQ;eACT;YACH;UACF,GAAE,EAAG,MAAM,SAAM;AACf,uBAAW,IAAI,MAAM,4DAA4D,GAAG;UACtF,CAAC;QACH;AAEA,eAAO,QAAQ,IAAI,GAAG,IAAI;MAC5B;KACD;AACD,WAAO,SAAS,WAAW,KAAK,IAAG;AAEnC,UAAM,8BAA8B,MAAU;AAC5C,YAAM,IAAI,sBAAsB,+BAA+B;IACjE;AAGA,iBAAa,iBAAiB;MAC5B,YAAY,OAAO;MACnB;MACA,QAAQ;MACR;MACA,UAAU,OAAO;MACjB,aAAa,+BAAO;MACpB,YAAY;MACZ;MACA,QAAQ,KAAK,WAAW;MACxB,WAAW,aAAa;MACxB,YAAY,MAAK;AACf,gBAAO,+BAAO,YAAW,CAAA;MAC3B;MACA,OAAO,OAAO,YAA0B;AAEtC,eAAM,+BAAO,MAAM;AAGnB,cAAM,OAAO,MAAM,OAAO;MAC5B;MACA,OAAO,CAAC,QAAO;AACb,eAAO,MAAM,GAAG;AAGhB,uCAAO,MAAM;MACf;KACD;AAED,SAAK,OAAO,kBAAkB,mBAAmB;MAC/C,QAAQ;KACT;AAGD,eAAW,mBAAmB;AAE9B,WAAO;EACT;;;;EAKA,UAAW,MAAqB;AAC9B,UAAM,EAAE,YAAY,QAAQ,SAAQ,IAAK;AACzC,UAAM,EAAE,SAAS,QAAO,IAAK,KAAK,WAAW,UAAU,WAAW,QAAQ;AAE1E,QAAI,WAAW,UAAU,QAAQ,QAAQ,2BAA2B,MAAM;AACxE,YAAM,IAAI,uBAAuB,mDAAmD;IACtF;AAEA,YAAQ,EAAE,YAAY,OAAM,CAAE;EAChC;;;;EAKA,MAAM,gBAAiB,YAAiC,SAAsB;AAC5E,UAAM,YAAY,MAAM,KAAK,KAAK,qBAAqB,KAAI,CAAE;AAE7D,QAAI;AACF,YAAM,EAAE,QAAQ,SAAQ,IAAK,MAAU,OAAO,YAAY,WAAW;QACnE,GAAG;QACH,KAAK,WAAW;OACjB;AACD,YAAM,YAAY,KAAK,qBAAqB,IAAI,QAAQ;AAExD,UAAI,aAAa,MAAM;AACrB,cAAM,IAAI,sBAAsB,8BAA8B,QAAQ,EAAE;MAC1E;AAEA,iBAAW,IAAI,gDAAgD,WAAW,YAAY,QAAQ;AAE9F,aAAO;QACL,GAAG,MAAM,UAAU,cAAc,QAAQ,OAAO;QAChD;;IAEJ,SAAS,KAAU;AACjB,iBAAW,IAAI,MAAM,gDAAgD,WAAW,YAAY,GAAG;AAC/F,YAAM,IAAI,sBAAsB,IAAI,OAAO;IAC7C;EACF;;;;;EAMA,MAAM,iBAAkB,YAAiC,SAAgC;AACvF,UAAM,YAAY,MAAM,KAAK,KAAK,qBAAqB,KAAI,CAAE;AAE7D,QAAI;AACF,iBAAW,IAAI,MAAM,+BAA+B,SAAS;AAE7D,YAAM,EAAE,QAAQ,SAAQ,IAAK,MAAU,OAAO,YAAY,WAAW;QACnE,GAAG;QACH,KAAK,WAAW;QAChB,YAAY;OACb;AACD,YAAM,YAAY,KAAK,qBAAqB,IAAI,QAAQ;AAExD,UAAI,aAAa,MAAM;AACrB,cAAM,IAAI,sBAAsB,8BAA8B,QAAQ,EAAE;MAC1E;AAEA,iBAAW,IAAI,iDAAiD,WAAW,YAAY,QAAQ;AAE/F,aAAO;QACL,GAAG,MAAM,UAAU,eAAe,QAAQ,OAAO;QACjD;;IAEJ,SAAS,KAAU;AACjB,iBAAW,IAAI,MAAM,+CAA+C,WAAW,YAAY,GAAG;AAC9F,YAAM,IAAI,sBAAsB,IAAI,OAAO;IAC7C;EACF;;;;;EAMA,MAAM,mBAAoB,YAAiC,QAAyC,SAAqB;AACvH,UAAM,YAAY,MAAM,KAAK,OAAO,KAAI,CAAE;AAC1C,eAAW,IAAI,+BAA+B,SAAS;AACvD,QAAI;AACF,iBAAW,IAAI,MAAM,kCAAkC,SAAS;AAEhE,YAAM,EACJ,QACA,SAAQ,IACN,MAAU,OAAO,YAAY,WAAW;QAC1C,GAAG;QACH,KAAK,WAAW;QAChB,YAAY;OACb;AAED,iBAAW,IAAI,iCAAiC,QAAQ;AACxD,YAAM,eAAe,OAAO,IAAI,QAAQ;AAExC,aAAO,EAAE,QAAQ,aAAY;IAC/B,SAAS,KAAU;AACjB,iBAAW,IAAI,MAAM,0CAA0C,GAAG;AAClE,YAAM,IAAI,sBAAsB,OAAO,GAAG,CAAC;IAC7C;EACF;;;;;EAMA,MAAM,kBAAmB,YAAiC,QAAyC,SAAqB;AACtH,UAAM,YAAY,MAAM,KAAK,OAAO,KAAI,CAAE;AAC1C,eAAW,IAAI,8BAA8B,SAAS;AACtD,QAAI;AACF,YAAM,EAAE,QAAQ,SAAQ,IAAK,MAAU,OAAO,YAAY,WAAW;QACnE,GAAG;QACH,KAAK,WAAW;OACjB;AACD,YAAM,eAAe,OAAO,IAAI,QAAQ;AAExC,aAAO,EAAE,QAAQ,aAAY;IAC/B,SAAS,KAAU;AACjB,iBAAW,IAAI,MAAM,yCAAyC,GAAG;AACjE,YAAM,IAAI,sBAAsB,OAAO,GAAG,CAAC;IAC7C;EACF;;AAtkBUA,OAAA,OAAO;;;AClKZ,IAAM,UAAU;AAChB,IAAM,OAAO;;;ACDpB;AA2BM,IAAO,SAAP,cAAyD,kBAA+B;EAa5F,YAAa,MAAwC;AAxCvD,QAAAG,MAAAC,KAAA;AAyCI,UAAK;AA0WP;;;;;AAvXO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACU;AAKf,SAAK,SAAS;AAId,UAAMC,UAAS,IAAI,kBAAiB;AACpC,UAAM,mBAAmBA,QAAO,cAAc,KAAKA,OAAM;AACzD,IAAAA,QAAO,gBAAgB,CAAC,QAAY;AAClC,YAAM,iBAAiB,iBAAiB,GAAG;AAC3C,YAAM,iBAAiB,KAAK,cAC1B,IAAI,YAAY,IAAI,MAAM,EAAE,QAAQ,IAAI,OAAM,CAAE,CAAC;AAGnD,aAAO,kBAAkB;IAC3B;AAGA,oBAAgB,UAAUA,OAAM;AAEhC,SAAK,SAAS,KAAK;AACnB,SAAK,SAAS,KAAK,UAAU,cAAa;AAC1C,SAAK,MAAM,KAAK,OAAO,aAAa,QAAQ;AAE5C,SAAK,WAAW,CAAA;AAEhB,UAAM,aAAa,KAAK,aAAa,kBAAkB;MACrD,QAAQ,KAAK;MACb,YAAY,KAAK;MACjB,UAAU,KAAK,YAAY;QACzB;QACA;;MAEF,QAAQ,KAAK;MACb,QAAAA;MACA,WAAW,KAAK,aAAa,IAAI,gBAAe;MAChD,iBAAiB,gBAAgB,KAAK,eAAe;MACrD,KAAK,KAAK;KACX;AAED,SAAK,YAAY,KAAK,mBAAmB,aAAa,oBAAoB,YAAY;MACpF,eAAe,KAAK,WAAW,gBAAgB;MAC/C,GAAG,KAAK;KACT,CAAC;AAGF,QAAI,KAAK,WAAW,MAAM;AACxB,WAAK,UAAU,KAAK,mBAAmB,WAAW,KAAK,QAAQ,KAAK,UAAU,CAAC;IACjF;AAEA,eAAW,OAAO,iBAAiB,eAAe,SAAM;AAEtD,UAAI,IAAI,OAAO,YAAY,MAAM;AAC/B,cAAM,WAAqB;UACzB,IAAI,IAAI,OAAO,KAAK;UACpB,YAAY,IAAI,OAAO,KAAK,UAAU,IAAI,OAAK,EAAE,SAAS;;AAG5D,mBAAW,OAAO,kBAAkB,kBAAkB,EAAE,QAAQ,SAAQ,CAAE;MAC5E;IACF,CAAC;AAGD,QAAI,KAAK,uBAAuB,MAAM;AACpC,WAAK,mBAAmB,uBAAuB,KAAK,oBAAoB,UAAU,CAAC;IACrF;AAGA,SAAK,WAAW,WAAW,IAAI,gBAAgB,KAAK,YAAY;MAC9D,uBAAuB,KAAK,wBAAwB,CAAA,GAAI,IAAI,CAAC,IAAI,UAAU,KAAK,mBAAmB,yBAAyB,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC,CAAC;MACzJ,eAAe,KAAK,gBAAgB,CAAA,GAAI,IAAI,CAAC,IAAI,UAAU,KAAK,mBAAmB,iBAAiB,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC,CAAC;MACjI,wBAAuBF,OAAA,KAAK,sBAAL,gBAAAA,KAAwB;MAC/C,yBAAwBC,MAAA,KAAK,sBAAL,gBAAAA,IAAwB;KACjD;AAGD,SAAK,mBAAmB,oBAAoB,IAAI,wBAAwB,KAAK,YAAY,KAAK,gBAAgB,CAAC;AAG/G,SAAK,mBAAmB,qBAAqB,IAAI,yBAAyB,KAAK,YAAY,KAAK,iBAAiB,CAAC;AAElH,UAAI,UAAK,sBAAL,mBAAwB,aAAY,OAAO;AAE7C,WAAK,mBAAmB,qBAAqB,IAAI,kBAAkB,KAAK,YAAY,KAAK,iBAAiB,CAAC;IAC7G;AAGA,SAAK,mBAAmB,aAAa,IAAI,iBAAiB,KAAK,UAAU,CAAC;AAG1E,SAAK,mBAAmB,kBAAkB,IAAI,eAAe,KAAK,YAAY,KAAK,SAAS,CAAC;AAG7F,UAAM,eAA8B,KAAK,eAAe,CAAA,GAAI,IAAI,CAAC,IAAI,UAAU,KAAK,mBAAmB,eAAe,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC,CAAC;AACnJ,SAAK,cAAc,KAAK,WAAW,cAAc,KAAK,mBAAmB,eAAe,IAAI,mBAAmB,KAAK,YAAY;MAC9H,SAAS;KACV,CAAC;AAGF,UAAM,kBAAoC,KAAK,kBAAkB,CAAA,GAAI,IAAI,CAAC,IAAI,UAAU,KAAK,mBAAmB,kBAAkB,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC,CAAC;AAC/J,SAAK,iBAAiB,KAAK,WAAW,iBAAiB,KAAK,mBAAmB,kBAAkB,IAAI,uBAAuB,KAAK,YAAY;MAC3I,SAAS;KACV,CAAC;AAGF,SAAK,mBAAmB,cAAc,IAAI,WAAW,KAAK,UAAU,CAAC;AAGpE,KAAC,KAAK,iBAAiB,CAAA,GAAI,QAAQ,CAAC,IAAI,UAAS;AAChD,YAAM,UAAU,KAAK,mBAAmB,kBAAkB,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC;AAEtF,cAAQ,iBAAiB,QAAQ,CAAC,QAAO;AACvC,8BAAK,sCAAL,WAAsB;MACxB,CAAC;IACH,CAAC;AAGD,eAAK,eAAL,mBAAiB,QAAQ,CAAC,IAAI,UAAS;AACrC,WAAK,WAAW,iBAAiB,IAAI,KAAK,mBAAmB,aAAa,KAAK,IAAI,GAAG,KAAK,UAAU,CAAC,CAAC;IACzG;AAGA,QAAI,KAAK,YAAY,MAAM;AACzB,iBAAWE,SAAQ,OAAO,KAAK,KAAK,QAAQ,GAAG;AAC7C,cAAM,gBAAgB,KAAK,SAASA,KAAI;AACxC,cAAM,UAAe,cAAc,KAAK,UAAU;AAElD,YAAI,WAAW,MAAM;AACnB,eAAK,IAAI,MAAM,0DAA0DA,KAAI;AAC7E;QACF;AAEA,aAAK,SAASA,KAAe,IAAI;AACjC,aAAK,mBAAmBA,OAAM,OAAO;AAErC,YAAI,QAAQ,oBAAoB,KAAK,MAAM;AACzC,eAAK,IAAI,8CAA8CA,KAAI;AAC3D,yBAAe,KAAK,QAAQ,oBAAoB,CAAC;QACnD;AAEA,YAAI,QAAQ,iBAAiB,KAAK,MAAM;AACtC,eAAK,IAAI,2CAA2CA,KAAI;AACxD,sBAAY,KAAK,QAAQ,iBAAiB,CAAC;QAC7C;AAEA,YAAI,QAAQ,mBAAmB,KAAK,MAAM;AACxC,eAAK,IAAI,6CAA6CA,KAAI;AAC1D,8BAAQ,mBAAmB,GAAE,qBAA7B,4BAAgD,QAAQ,CAAC,QAA8B;AACrF,kCAAK,sCAAL,WAAsB;UACxB;QACF;MACF;IACF;AAGA,6BAAyB,UAAU;EACrC;EAEQ,mBAAwBA,OAAc,WAAY;AACxD,QAAI,aAAa,MAAM;AACrB,WAAK,IAAI,MAAM,sCAAsCA,KAAI;IAC3D;AAGA,SAAK,WAAWA,KAAI,IAAI;AAExB,WAAO;EACT;;;;EAKA,MAAM,QAAK;AArNb,QAAAH,MAAAC,KAAA;AAsNI,QAAI,KAAK,WAAW,WAAW;AAC7B;IACF;AAEA,SAAK,SAAS;AAEd,SAAK,IAAI,oBAAoB;AAE7B,QAAI;AACF,cAAMA,OAAAD,OAAA,KAAK,YAAW,gBAAhB,gBAAAC,IAAA,KAAAD;AACN,YAAM,KAAK,WAAW,MAAK;AAC3B,cAAM,gBAAK,YAAW,eAAhB;AAEN,WAAK,SAAS;AACd,WAAK,kBAAkB,SAAS,EAAE,QAAQ,KAAI,CAAE;AAChD,WAAK,IAAI,oBAAoB;IAC/B,SAAS,KAAU;AACjB,WAAK,IAAI,MAAM,qCAAqC,GAAG;AAEvD,WAAK,SAAS;AACd,YAAM,KAAK,KAAI;AACf,YAAM;IACR;EACF;;;;EAKA,MAAM,OAAI;AAlPZ,QAAAA,MAAAC,KAAA;AAmPI,QAAI,KAAK,WAAW,WAAW;AAC7B;IACF;AAEA,SAAK,IAAI,oBAAoB;AAE7B,SAAK,SAAS;AAEd,YAAMA,OAAAD,OAAA,KAAK,YAAW,eAAhB,gBAAAC,IAAA,KAAAD;AACN,UAAM,KAAK,WAAW,KAAI;AAC1B,YAAM,gBAAK,YAAW,cAAhB;AAEN,SAAK,SAAS;AACd,SAAK,kBAAkB,QAAQ,EAAE,QAAQ,KAAI,CAAE;AAC/C,SAAK,IAAI,oBAAoB;EAC/B;EAEA,eAAgB,QAAe;AAC7B,WAAO,KAAK,WAAW,kBAAkB,eAAe,MAAM;EAChE;EAEA,eAAY;AACV,WAAO,KAAK,WAAW,kBAAkB,aAAY;EACvD;EAEA,WAAQ;AACN,UAAMI,WAAU,IAAI,QAAO;AAE3B,eAAW,QAAQ,KAAK,WAAW,kBAAkB,eAAc,GAAI;AACrE,MAAAA,SAAQ,IAAI,KAAK,UAAU;IAC7B;AAEA,WAAO,MAAM,KAAKA,QAAO;EAC3B;EAEA,MAAM,KAAM,MAAwC,UAAuB,CAAA,GAAE;AAC3E,WAAO,KAAK,WAAW,kBAAkB,eAAe,MAAM;;MAE5D,UAAU;MACV,GAAG;KACJ;EACH;EAEA,MAAM,aAAc,MAAwC,WAA8B,UAA4B,CAAA,GAAE;AACtH,QAAI,aAAa,MAAM;AACrB,YAAM,IAAI,uBAAuB,6CAA6C;IAChF;AAEA,gBAAY,MAAM,QAAQ,SAAS,IAAI,YAAY,CAAC,SAAS;AAE7D,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,IAAI,uBAAuB,6CAA6C;IAChF;AAEA,UAAM,aAAa,MAAM,KAAK,KAAK,MAAM,OAAO;AAEhD,WAAO,WAAW,UAAU,WAAW,OAAO;EAChD;EAEA,gBAAa;AACX,WAAO,KAAK,WAAW,eAAe,aAAY;EACpD;EAEA,eAAY;AACV,WAAO,KAAK,WAAW,UAAU,aAAY;EAC/C;EAEA,MAAM,OAAQ,MAA0B,UAAwB,CAAA,GAAE;AAChE,QAAI,YAAY,IAAI,GAAG;AACrB,aAAO,iBAAiB,KAAK,UAAS,KAAM,EAAE;IAChD;AAEA,UAAM,KAAK,WAAW,kBAAkB,iBAAiB,MAAM,OAAO;EACxE;EAUA,MAAM,aAAc,MAAc,UAAwB,CAAA,GAAE;AAC1D,SAAK,IAAI,mBAAmB,IAAI;AAEhC,QAAI,KAAK,aAAa,MAAM;AAC1B,aAAO,KAAK;IACd;AAEA,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,UAAU,IAAI,IAAI;AAE9C,UAAI,SAAS,GAAG,aAAa,MAAM;AACjC,eAAO,SAAS,GAAG;MACrB;IACF,SAAS,KAAU;AACjB,UAAI,IAAI,SAAS,iBAAiB;AAChC,cAAM;MACR;IACF;AAEA,UAAM,UAAU,OAAiB;MAC/B,WAAqB,MAAM;MAC3B,KAAK,YAAW,EAAG;KACpB;AAGD,UAAM,QAAQ,MAAM,KAAK,eAAe,IAAI,SAAS,OAAO;AAG5D,UAAM,YAAY,sBAAsB,KAAK;AAE7C,UAAM,KAAK,UAAU,MAAM,MAAM;MAC/B;KACD;AAED,WAAO;EACT;EAEA,MAAM,OAAQ,WAA8B,SAAwB,SAA8B;AAChG,QAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7B,kBAAY,CAAC,SAAS;IACxB;AAEA,UAAM,QAAQ,IACZ,UAAU,IAAI,OAAM,aAAW;AAC7B,YAAM,KAAK,WAAW,UAAU,OAAO,UAAU,SAAS,OAAO;IACnE,CAAC,CAAC;EAEN;EAEA,MAAM,SAAU,WAA4B;AAC1C,QAAI,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC7B,kBAAY,CAAC,SAAS;IACxB;AAEA,UAAM,QAAQ,IACZ,UAAU,IAAI,OAAM,aAAW;AAC7B,YAAM,KAAK,WAAW,UAAU,SAAS,QAAQ;IACnD,CAAC,CAAC;EAEN;EAEA,MAAM,SAAU,UAAkB,UAAkB;AAClD,WAAO,KAAK,WAAW,UAAU,SAAS,UAAU,QAAQ;EAC9D;EAEA,WAAY,IAAU;AACpB,SAAK,WAAW,UAAU,WAAW,EAAE;EACzC;EAEA,MAAM,WAAYC,YAAsB,UAA6B,CAAA,GAAE;AACrE,WAAO,KAAK,WAAW,kBAAkB,WAAWA,YAAW,OAAO;EACxE;;AAMA;qBAAgB,SAAE,KAA0B;AAC1C,QAAM,EAAE,QAAQ,KAAI,IAAK;AAEzB,MAAI,KAAK,GAAG,SAAQ,MAAO,KAAK,OAAO,SAAQ,GAAI;AACjD,SAAK,IAAI,MAAM,0CAA0C;AACzD;EACF;AAEA,OAAK,KAAK,WAAW,UAAU,MAAM,KAAK,IAAI;IAC5C,YAAY,KAAK;GAClB,EACE,MAAM,SAAM;AAAG,SAAK,IAAI,MAAM,GAAG;EAAE,CAAC;AACzC;;;ACzNF,eAAsB,aAAkD,UAA4B,CAAA,GAAE;AACpG,UAAQ,eAAR,QAAQ,aAAe,MAAM,gBAAgB,SAAS;AAEtD,QAAM,OAAO,IAAI,OAAY;IAC3B,GAAG,MAAM,eAAe,OAAO;IAC/B,QAAQ,qBAAqB,QAAQ,UAAU;GAChD;AAED,MAAI,QAAQ,UAAU,OAAO;AAC3B,UAAM,KAAK,MAAK;EAClB;AAEA,SAAO;AACT;",
  "names": ["cache", "Netmask", "start", "message", "original", "require_retry", "_a", "response", "hashlru", "_a", "_b", "resolvers", "RecordType", "message", "dnsaddrResolver", "ma", "_a", "_b", "peerIdFromString", "_a", "peerIdFromString", "peerId", "pbkdf2", "import_murmurhash3js_revisited", "fnv1a", "fnv1a", "_a", "_b", "fnv1a", "_a", "_b", "name", "Envelope", "message", "sort", "a", "b", "PeerRecord", "AddressInfo", "_codec", "_a", "_b", "PeerRecord", "src_default", "event", "name", "src_default", "name", "defaultOptions", "Peer", "Peer$metadataEntry", "_codec", "Peer$tagsEntry", "_a", "_b", "Address", "Tag", "multiaddr", "multiaddr", "_a", "src_default", "PeerRecord", "multiaddr", "message", "NotFoundError", "src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "NotFoundError", "_a", "tuple", "CODEC_IP4", "CODEC_IP6", "CODEC_IP4", "CODEC_IP6", "CODEC_DNS", "CODEC_DNS4", "CODEC_DNS6", "CODEC_DNSADDR", "_a", "defaultValues", "multiaddr", "_a", "defaultValues", "_a", "multiaddr", "messages", "message", "_a", "serviceCapabilities", "CODEC_IP4", "CODEC_IP6", "multiaddr", "message", "_a", "ma", "isIPv6", "defaultOptions", "AbortError", "message", "_a", "_a", "_a", "_a", "_b", "signal", "defaultOptions", "_a", "_b", "multiaddr", "options", "err", "AbortError", "message", "retry", "_a", "defaultOptions", "_a", "_b", "multiaddr", "_a", "_b", "_a", "start", "_a", "_b", "_a", "_b", "peer", "_a", "_b", "start", "_a", "_b", "name", "_a", "message", "protocol", "response", "encode", "_a", "_b", "options", "_a", "_b", "maConn", "_a", "_b", "events", "name", "peerSet", "multiaddr"]
}
