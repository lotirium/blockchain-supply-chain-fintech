import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-QY3AG7D4.js";

// node_modules/@libp2p/interface/dist/src/peer-discovery/index.js
var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

// node_modules/@libp2p/interface/dist/src/transport/index.js
var transportSymbol = Symbol.for("@libp2p/transport");
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/@libp2p/interface/dist/src/errors.js
var AbortError = class extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
};
__publicField(AbortError, "name", "AbortError");
var UnexpectedPeerError = class extends Error {
  constructor(message = "Unexpected Peer") {
    super(message);
    this.name = "UnexpectedPeerError";
  }
};
__publicField(UnexpectedPeerError, "name", "UnexpectedPeerError");
var InvalidParametersError = class extends Error {
  constructor(message = "Invalid parameters") {
    super(message);
    this.name = "InvalidParametersError";
  }
};
__publicField(InvalidParametersError, "name", "InvalidParametersError");
var InvalidPublicKeyError = class extends Error {
  constructor(message = "Invalid public key") {
    super(message);
    this.name = "InvalidPublicKeyError";
  }
};
__publicField(InvalidPublicKeyError, "name", "InvalidPublicKeyError");
var InvalidPrivateKeyError = class extends Error {
  constructor(message = "Invalid private key") {
    super(message);
    this.name = "InvalidPrivateKeyError";
  }
};
__publicField(InvalidPrivateKeyError, "name", "InvalidPrivateKeyError");
var ConnectionClosingError = class extends Error {
  constructor(message = "The connection is closing") {
    super(message);
    this.name = "ConnectionClosingError";
  }
};
__publicField(ConnectionClosingError, "name", "ConnectionClosingError");
var ConnectionClosedError = class extends Error {
  constructor(message = "The connection is closed") {
    super(message);
    this.name = "ConnectionClosedError";
  }
};
__publicField(ConnectionClosedError, "name", "ConnectionClosedError");
var ConnectionFailedError = class extends Error {
  constructor(message = "Connection failed") {
    super(message);
    this.name = "ConnectionFailedError";
  }
};
__publicField(ConnectionFailedError, "name", "ConnectionFailedError");
var MuxerClosedError = class extends Error {
  constructor(message = "The muxer is closed") {
    super(message);
    this.name = "MuxerClosedError";
  }
};
__publicField(MuxerClosedError, "name", "MuxerClosedError");
var StreamResetError = class extends Error {
  constructor(message = "The stream has been reset") {
    super(message);
    this.name = "StreamResetError";
  }
};
__publicField(StreamResetError, "name", "StreamResetError");
var StreamStateError = class extends Error {
  constructor(message = "The stream is in an invalid state") {
    super(message);
    this.name = "StreamStateError";
  }
};
__publicField(StreamStateError, "name", "StreamStateError");
var NotFoundError = class extends Error {
  constructor(message = "Not found") {
    super(message);
    this.name = "NotFoundError";
  }
};
__publicField(NotFoundError, "name", "NotFoundError");
var InvalidPeerIdError = class extends Error {
  constructor(message = "Invalid PeerID") {
    super(message);
    this.name = "InvalidPeerIdError";
  }
};
__publicField(InvalidPeerIdError, "name", "InvalidPeerIdError");
var InvalidMultiaddrError = class extends Error {
  constructor(message = "Invalid multiaddr") {
    super(message);
    this.name = "InvalidMultiaddrError";
  }
};
__publicField(InvalidMultiaddrError, "name", "InvalidMultiaddrError");
var InvalidCIDError = class extends Error {
  constructor(message = "Invalid CID") {
    super(message);
    this.name = "InvalidCIDError";
  }
};
__publicField(InvalidCIDError, "name", "InvalidCIDError");
var InvalidMultihashError = class extends Error {
  constructor(message = "Invalid Multihash") {
    super(message);
    this.name = "InvalidMultihashError";
  }
};
__publicField(InvalidMultihashError, "name", "InvalidMultihashError");
var UnsupportedProtocolError = class extends Error {
  constructor(message = "Unsupported protocol error") {
    super(message);
    this.name = "UnsupportedProtocolError";
  }
};
__publicField(UnsupportedProtocolError, "name", "UnsupportedProtocolError");
var InvalidMessageError = class extends Error {
  constructor(message = "Invalid message") {
    super(message);
    this.name = "InvalidMessageError";
  }
};
__publicField(InvalidMessageError, "name", "InvalidMessageError");
var ProtocolError = class extends Error {
  constructor(message = "Protocol error") {
    super(message);
    this.name = "ProtocolError";
  }
};
__publicField(ProtocolError, "name", "ProtocolError");
var TimeoutError = class extends Error {
  constructor(message = "Timed out") {
    super(message);
    this.name = "TimeoutError";
  }
};
__publicField(TimeoutError, "name", "TimeoutError");
var NotStartedError = class extends Error {
  constructor(message = "Not started") {
    super(message);
    this.name = "NotStartedError";
  }
};
__publicField(NotStartedError, "name", "NotStartedError");
var DialError = class extends Error {
  constructor(message = "Dial error") {
    super(message);
    this.name = "DialError";
  }
};
__publicField(DialError, "name", "DialError");
var ListenError = class extends Error {
  constructor(message = "Listen error") {
    super(message);
    this.name = "ListenError";
  }
};
__publicField(ListenError, "name", "ListenError");
var LimitedConnectionError = class extends Error {
  constructor(message = "Limited connection") {
    super(message);
    this.name = "LimitedConnectionError";
  }
};
__publicField(LimitedConnectionError, "name", "LimitedConnectionError");
var TooManyInboundProtocolStreamsError = class extends Error {
  constructor(message = "Too many inbound protocol streams") {
    super(message);
    this.name = "TooManyInboundProtocolStreamsError";
  }
};
__publicField(TooManyInboundProtocolStreamsError, "name", "TooManyInboundProtocolStreamsError");
var TooManyOutboundProtocolStreamsError = class extends Error {
  constructor(message = "Too many outbound protocol streams") {
    super(message);
    this.name = "TooManyOutboundProtocolStreamsError";
  }
};
__publicField(TooManyOutboundProtocolStreamsError, "name", "TooManyOutboundProtocolStreamsError");
var UnsupportedKeyTypeError = class extends Error {
  constructor(message = "Unsupported key type") {
    super(message);
    this.name = "UnsupportedKeyTypeError";
  }
};
__publicField(UnsupportedKeyTypeError, "name", "UnsupportedKeyTypeError");

// node_modules/@libp2p/interface/dist/src/events.browser.js
function setMaxListeners() {
}

// node_modules/@libp2p/interface/dist/src/events.js
var setMaxListeners2 = (n, ...eventTargets) => {
  try {
    setMaxListeners(n, ...eventTargets);
  } catch {
  }
};

// node_modules/@libp2p/interface/dist/src/event-target.js
var _listeners;
var TypedEventEmitter = class extends EventTarget {
  constructor() {
    super();
    __privateAdd(this, _listeners, /* @__PURE__ */ new Map());
    setMaxListeners2(Infinity, this);
  }
  listenerCount(type) {
    const listeners = __privateGet(this, _listeners).get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      list = [];
      __privateGet(this, _listeners).set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __privateGet(this, _listeners).get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __privateGet(this, _listeners).set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __privateGet(this, _listeners).get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __privateGet(this, _listeners).set(event.type, list);
    return result;
  }
  safeDispatchEvent(type, detail = {}) {
    return this.dispatchEvent(new CustomEvent(type, detail));
  }
};
_listeners = new WeakMap();

// node_modules/@libp2p/interface/dist/src/connection/index.js
var connectionSymbol = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/interface/dist/src/content-routing/index.js
var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

// node_modules/@libp2p/interface/dist/src/peer-id/index.js
var peerIdSymbol = Symbol.for("@libp2p/peer-id");
function isPeerId(other) {
  return Boolean(other == null ? void 0 : other[peerIdSymbol]);
}

// node_modules/@libp2p/interface/dist/src/peer-routing/index.js
var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

// node_modules/@libp2p/interface/dist/src/peer-store/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/@libp2p/interface/dist/src/pubsub/index.js
var TopicValidatorResult;
(function(TopicValidatorResult2) {
  TopicValidatorResult2["Accept"] = "accept";
  TopicValidatorResult2["Ignore"] = "ignore";
  TopicValidatorResult2["Reject"] = "reject";
})(TopicValidatorResult || (TopicValidatorResult = {}));
var pubSubSymbol = Symbol.for("@libp2p/pubsub");

// node_modules/@libp2p/interface/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}
async function start(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStart != null) {
      await s.beforeStart();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.start();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStart != null) {
      await s.afterStart();
    }
  }));
}
async function stop(...objs) {
  const startables = [];
  for (const obj of objs) {
    if (isStartable(obj)) {
      startables.push(obj);
    }
  }
  await Promise.all(startables.map(async (s) => {
    if (s.beforeStop != null) {
      await s.beforeStop();
    }
  }));
  await Promise.all(startables.map(async (s) => {
    await s.stop();
  }));
  await Promise.all(startables.map(async (s) => {
    if (s.afterStop != null) {
      await s.afterStop();
    }
  }));
}

// node_modules/@libp2p/interface/dist/src/index.js
var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

export {
  connectionSymbol,
  contentRoutingSymbol,
  peerDiscoverySymbol,
  peerIdSymbol,
  isPeerId,
  peerRoutingSymbol,
  KEEP_ALIVE,
  transportSymbol,
  FaultTolerance,
  AbortError,
  UnexpectedPeerError,
  InvalidParametersError,
  InvalidPublicKeyError,
  InvalidPrivateKeyError,
  ConnectionClosingError,
  ConnectionClosedError,
  ConnectionFailedError,
  MuxerClosedError,
  StreamResetError,
  StreamStateError,
  NotFoundError,
  InvalidPeerIdError,
  InvalidMultiaddrError,
  InvalidCIDError,
  InvalidMultihashError,
  UnsupportedProtocolError,
  InvalidMessageError,
  ProtocolError,
  TimeoutError,
  NotStartedError,
  DialError,
  ListenError,
  LimitedConnectionError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  UnsupportedKeyTypeError,
  setMaxListeners2 as setMaxListeners,
  TypedEventEmitter,
  isStartable,
  start,
  stop,
  serviceCapabilities,
  serviceDependencies
};
//# sourceMappingURL=chunk-W7L7L57K.js.map
