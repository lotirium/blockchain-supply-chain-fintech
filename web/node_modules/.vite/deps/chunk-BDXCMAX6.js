import {
  WebSockets,
  WebSocketsSecure
} from "./chunk-3F7GITD2.js";
import {
  getProtocol,
  multiaddr
} from "./chunk-4JGVO3XG.js";
import {
  raceSignal
} from "./chunk-LOB4GZJB.js";
import {
  AbortError,
  ConnectionFailedError,
  serviceCapabilities,
  transportSymbol
} from "./chunk-W7L7L57K.js";
import {
  CustomProgressEvent
} from "./chunk-2LXZBJZU.js";
import {
  fromString
} from "./chunk-AKRWU5PV.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-QY3AG7D4.js";

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve, reject) => {
                this.pullQueue.push({ resolve, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator2 = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports.EventIterator = EventIterator2;
    exports.default = EventIterator2;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports.subscribe = subscribe;
    exports.default = event_iterator_1.EventIterator;
  }
});

// node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
var ASSUME_HTTP_CODES = [
  getProtocol("tcp").code,
  getProtocol("dns").code,
  getProtocol("dnsaddr").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code
];
function extractSNI(ma) {
  var _a2;
  return (_a2 = extractTuple("sni", ma)) == null ? void 0 : _a2[1];
}
function extractPort(ma) {
  var _a2;
  const port = (_a2 = extractTuple("tcp", ma)) == null ? void 0 : _a2[1];
  if (port == null) {
    return "";
  }
  return `:${port}`;
}
function extractTuple(name, ma) {
  let code;
  try {
    code = getProtocol(name).code;
  } catch (e) {
    return;
  }
  for (const [proto, value] of ma) {
    if (proto === code && value != null) {
      return [proto, value];
    }
  }
}
function hasTLS(ma) {
  return ma.some(([proto, _]) => proto === getProtocol("tls").code);
}
function interpretNext(headProtoCode, headProtoVal, restMa) {
  const interpreter = interpreters[getProtocol(headProtoCode).name];
  if (interpreter == null) {
    throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
  }
  const restVal = interpreter(headProtoVal, restMa);
  if (headProtoCode === getProtocol("ip6").code) {
    return `[${restVal}]`;
  }
  return restVal;
}
var interpreters = {
  ip4: (value, restMa) => value,
  ip6: (value, restMa) => {
    if (restMa.length === 0) {
      return value;
    }
    return `[${value}]`;
  },
  tcp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  udp: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
  },
  dnsaddr: (value, restMa) => value,
  dns4: (value, restMa) => value,
  dns6: (value, restMa) => value,
  dns: (value, restMa) => value,
  ipfs: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}`;
  },
  p2p: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}`;
  },
  http: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    const port = extractPort(restMa);
    if (maHasTLS && sni != null) {
      return `https://${sni}${port}`;
    }
    const protocol = maHasTLS ? "https://" : "http://";
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  "http-path": (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    const decodedValue = decodeURIComponent(value);
    return `${baseVal}/${decodedValue}`;
  },
  tls: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  sni: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
  },
  https: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `https://${baseVal}`;
  },
  ws: (value, restMa) => {
    const maHasTLS = hasTLS(restMa);
    const sni = extractSNI(restMa);
    const port = extractPort(restMa);
    if (maHasTLS && sni != null) {
      return `wss://${sni}${port}`;
    }
    const protocol = maHasTLS ? "wss://" : "ws://";
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `${protocol}${baseVal}`;
  },
  wss: (value, restMa) => {
    const tailProto = restMa.pop();
    if (tailProto == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    baseVal = baseVal.replace("tcp://", "");
    return `wss://${baseVal}`;
  }
};
function multiaddrToUri(input, opts) {
  const ma = multiaddr(input);
  const parts = ma.stringTuples();
  const head = parts.pop();
  if (head == null) {
    throw new Error("Unexpected end of multiaddr");
  }
  const protocol = getProtocol(head[0]);
  const interpreter = interpreters[protocol.name];
  if (interpreter == null) {
    throw new Error(`No interpreter found for ${protocol.name}`);
  }
  let uri = interpreter(head[1] ?? "", parts);
  if ((opts == null ? void 0 : opts.assumeHttp) !== false && ASSUME_HTTP_CODES.includes(head[0])) {
    uri = uri.replace(/^.*:\/\//, "");
    if (head[1] === "443") {
      uri = `https://${uri}`;
    } else {
      uri = `http://${uri}`;
    }
  }
  if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
    uri = new URL(uri).toString();
    if (uri.endsWith("/")) {
      uri = uri.substring(0, uri.length - 1);
    }
  }
  return uri;
}

// node_modules/it-ws/dist/src/ready.js
var ready_default = async (socket) => {
  if (socket.readyState >= 2) {
    throw new Error("socket closed");
  }
  if (socket.readyState === 1) {
    return;
  }
  await new Promise((resolve, reject) => {
    function cleanup() {
      socket.removeEventListener("open", handleOpen);
      socket.removeEventListener("error", handleErr);
    }
    function handleOpen() {
      cleanup();
      resolve();
    }
    function handleErr(event) {
      cleanup();
      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
    }
    socket.addEventListener("open", handleOpen);
    socket.addEventListener("error", handleErr);
  });
};

// node_modules/it-ws/dist/src/sink.js
var sink_default = (socket, options) => {
  options = options ?? {};
  options.closeOnEnd = options.closeOnEnd !== false;
  const sink = async (source) => {
    for await (const data of source) {
      try {
        await ready_default(socket);
      } catch (err) {
        if (err.message === "socket closed")
          break;
        throw err;
      }
      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
        break;
      }
      socket.send(data);
    }
    if (options.closeOnEnd != null && socket.readyState <= 1) {
      await new Promise((resolve, reject) => {
        socket.addEventListener("close", (event) => {
          if (event.wasClean || event.code === 1006) {
            resolve();
          } else {
            const err = Object.assign(new Error("ws error"), { event });
            reject(err);
          }
        });
        setTimeout(() => {
          socket.close();
        });
      });
    }
  };
  return sink;
};

// node_modules/it-ws/dist/src/source.js
var import_event_iterator = __toESM(require_dom(), 1);
function isArrayBuffer(obj) {
  var _a2;
  return obj instanceof ArrayBuffer || ((_a2 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a2.name) === "ArrayBuffer" && typeof (obj == null ? void 0 : obj.byteLength) === "number";
}
var source_default = (socket) => {
  socket.binaryType = "arraybuffer";
  const connected = async () => {
    await new Promise((resolve, reject) => {
      if (isConnected) {
        resolve();
        return;
      }
      if (connError != null) {
        reject(connError);
        return;
      }
      const cleanUp = (cont) => {
        socket.removeEventListener("open", onOpen);
        socket.removeEventListener("error", onError);
        cont();
      };
      const onOpen = () => {
        cleanUp(resolve);
      };
      const onError = (event) => {
        cleanUp(() => {
          reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
        });
      };
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
  };
  const source = async function* () {
    const messages = new import_event_iterator.EventIterator(({ push, stop, fail }) => {
      const onMessage = (event) => {
        let data = null;
        if (typeof event.data === "string") {
          data = fromString(event.data);
        }
        if (isArrayBuffer(event.data)) {
          data = new Uint8Array(event.data);
        }
        if (event.data instanceof Uint8Array) {
          data = event.data;
        }
        if (data == null) {
          return;
        }
        push(data);
      };
      const onError = (event) => {
        fail(event.error ?? new Error("Socket error"));
      };
      socket.addEventListener("message", onMessage);
      socket.addEventListener("error", onError);
      socket.addEventListener("close", stop);
      return () => {
        socket.removeEventListener("message", onMessage);
        socket.removeEventListener("error", onError);
        socket.removeEventListener("close", stop);
      };
    }, { highWaterMark: Infinity });
    await connected();
    for await (const chunk of messages) {
      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
    }
  }();
  let isConnected = socket.readyState === 1;
  let connError;
  socket.addEventListener("open", () => {
    isConnected = true;
    connError = null;
  });
  socket.addEventListener("close", () => {
    isConnected = false;
    connError = null;
  });
  socket.addEventListener("error", (event) => {
    if (!isConnected) {
      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
    }
  });
  return Object.assign(source, {
    connected
  });
};

// node_modules/it-ws/dist/src/duplex.js
var duplex_default = (socket, options) => {
  options = options ?? {};
  const connectedSource = source_default(socket);
  let remoteAddress = options.remoteAddress;
  let remotePort = options.remotePort;
  if (socket.url != null) {
    try {
      const url = new URL(socket.url);
      remoteAddress = url.hostname;
      remotePort = parseInt(url.port, 10);
    } catch {
    }
  }
  if (remoteAddress == null || remotePort == null) {
    throw new Error("Remote connection did not have address and/or port");
  }
  const duplex = {
    sink: sink_default(socket, options),
    source: connectedSource,
    connected: async () => {
      await connectedSource.connected();
    },
    close: async () => {
      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
        await new Promise((resolve) => {
          socket.addEventListener("close", () => {
            resolve();
          });
          socket.close();
        });
      }
    },
    destroy: () => {
      if (socket.terminate != null) {
        socket.terminate();
      } else {
        socket.close();
      }
    },
    remoteAddress,
    remotePort,
    socket
  };
  return duplex;
};

// node_modules/it-ws/dist/src/web-socket.browser.js
var web_socket_browser_default = WebSocket;

// node_modules/it-ws/dist/src/ws-url.js
var map = { "http:": "ws:", "https:": "wss:" };
var defaultProtocol = "ws:";
var ws_url_default = (url, location) => {
  if (url.startsWith("//")) {
    url = `${(location == null ? void 0 : location.protocol) ?? defaultProtocol}${url}`;
  }
  if (url.startsWith("/") && location != null) {
    const proto = location.protocol ?? defaultProtocol;
    const host = location.host;
    const port = location.port != null && (host == null ? void 0 : host.endsWith(`:${location.port}`)) !== true ? `:${location.port}` : "";
    url = `${proto}//${host}${port}${url}`;
  }
  const wsUrl = new URL(url);
  for (const [httpProto, wsProto] of Object.entries(map)) {
    if (wsUrl.protocol === httpProto) {
      wsUrl.protocol = wsProto;
    }
  }
  return wsUrl;
};

// node_modules/it-ws/dist/src/client.js
function connect(addr, opts) {
  const location = typeof window === "undefined" ? void 0 : window.location;
  opts = opts ?? {};
  const url = ws_url_default(addr, location);
  const socket = new web_socket_browser_default(url.toString(), opts.websocket);
  return duplex_default(socket, opts);
}

// node_modules/@libp2p/websockets/dist/src/filters.js
function all(multiaddrs) {
  return multiaddrs.filter((ma) => {
    return WebSocketsSecure.exactMatch(ma) || WebSockets.exactMatch(ma);
  });
}

// node_modules/@libp2p/websockets/dist/src/listener.browser.js
function createListener() {
  throw new Error("WebSocket Servers can not be created in the browser!");
}

// node_modules/@libp2p/websockets/dist/src/constants.js
var CLOSE_TIMEOUT = 500;

// node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
function socketToMaConn(stream, remoteAddr, options) {
  const log = options.logger.forComponent("libp2p:websockets:maconn");
  const metrics = options.metrics;
  const metricPrefix = options.metricPrefix ?? "";
  const maConn = {
    log,
    async sink(source) {
      try {
        await stream.sink(async function* () {
          for await (const buf of source) {
            if (buf instanceof Uint8Array) {
              yield buf;
            } else {
              yield buf.subarray();
            }
          }
        }());
      } catch (err) {
        if (err.type !== "aborted") {
          log.error(err);
        }
      }
    },
    source: stream.source,
    remoteAddr,
    timeline: { open: Date.now() },
    async close(options2 = {}) {
      var _a2, _b2;
      const start = Date.now();
      if (options2.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
        options2 = {
          ...options2,
          signal
        };
      }
      const listener = () => {
        const { host, port } = maConn.remoteAddr.toOptions();
        log("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        this.abort(new AbortError("Socket close timeout"));
      };
      (_a2 = options2.signal) == null ? void 0 : _a2.addEventListener("abort", listener);
      try {
        await stream.close();
      } catch (err) {
        log.error("error closing WebSocket gracefully", err);
        this.abort(err);
      } finally {
        (_b2 = options2.signal) == null ? void 0 : _b2.removeEventListener("abort", listener);
        maConn.timeline.close = Date.now();
      }
    },
    abort(err) {
      const { host, port } = maConn.remoteAddr.toOptions();
      log("timeout closing stream to %s:%s due to error", host, port, err);
      stream.destroy();
      maConn.timeline.close = Date.now();
      metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}error`]: true });
    }
  };
  stream.socket.addEventListener("close", () => {
    metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}close`]: true });
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, { once: true });
  return maConn;
}

// node_modules/@libp2p/websockets/dist/src/index.js
var _a, _b, _c;
var WebSockets2 = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "init");
    __publicField(this, "logger");
    __publicField(this, "metrics");
    __publicField(this, "components");
    __publicField(this, _a, true);
    __publicField(this, _b, "@libp2p/websockets");
    __publicField(this, _c, [
      "@libp2p/transport"
    ]);
    this.log = components.logger.forComponent("libp2p:websockets");
    this.logger = components.logger;
    this.components = components;
    this.init = init;
    if (components.metrics != null) {
      this.metrics = {
        dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
          label: "event",
          help: "Total count of WebSockets dialer events by type"
        })
      };
    }
  }
  async dial(ma, options) {
    var _a2;
    this.log("dialing %s", ma);
    options = options ?? {};
    const socket = await this._connect(ma, options);
    const maConn = socketToMaConn(socket, ma, {
      logger: this.logger,
      metrics: (_a2 = this.metrics) == null ? void 0 : _a2.dialerEvents
    });
    this.log("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn, options);
    this.log("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma, options) {
    var _a2, _b2, _c2, _d, _e;
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const cOpts = ma.toOptions();
    this.log("dialing %s:%s", cOpts.host, cOpts.port);
    const errorPromise = pDefer();
    const rawSocket = connect(multiaddrToUri(ma), this.init);
    rawSocket.socket.addEventListener("error", () => {
      var _a3;
      const err = new ConnectionFailedError(`Could not connect to ${ma.toString()}`);
      this.log.error("connection error:", err);
      (_a3 = this.metrics) == null ? void 0 : _a3.dialerEvents.increment({ error: true });
      errorPromise.reject(err);
    });
    try {
      (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("websockets:open-connection"));
      await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options.signal);
    } catch (err) {
      if (((_c2 = options.signal) == null ? void 0 : _c2.aborted) === true) {
        (_d = this.metrics) == null ? void 0 : _d.dialerEvents.increment({ abort: true });
      }
      rawSocket.close().catch((err2) => {
        this.log.error("error closing raw socket", err2);
      });
      throw err;
    }
    this.log("connected %s", ma);
    (_e = this.metrics) == null ? void 0 : _e.dialerEvents.increment({ connect: true });
    return rawSocket;
  }
  /**
   * Creates a WebSockets listener. The provided `handler` function will be called
   * anytime a new incoming Connection has been successfully upgraded via
   * `upgrader.upgradeInbound`
   */
  createListener(options) {
    return createListener({
      logger: this.logger,
      events: this.components.events,
      metrics: this.components.metrics
    }, {
      ...this.init,
      ...options
    });
  }
  /**
   * Takes a list of `Multiaddr`s and returns only valid WebSockets addresses.
   * By default, in a browser environment only DNS+WSS multiaddr is accepted,
   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
   */
  listenFilter(multiaddrs) {
    var _a2, _b2;
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    if (((_a2 = this.init) == null ? void 0 : _a2.filter) != null) {
      return (_b2 = this.init) == null ? void 0 : _b2.filter(multiaddrs);
    }
    return all(multiaddrs);
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
};
_a = transportSymbol, _b = Symbol.toStringTag, _c = serviceCapabilities;
function webSockets(init = {}) {
  return (components) => {
    return new WebSockets2(components, init);
  };
}

export {
  multiaddrToUri,
  webSockets
};
//# sourceMappingURL=chunk-BDXCMAX6.js.map
