import {
  Uint8ArrayList
} from "./chunk-L26C3OVL.js";
import {
  raceSignal
} from "./chunk-LOB4GZJB.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  decode,
  encode,
  encodingLength
} from "./chunk-QINVXJCG.js";
import {
  allocUnsafe
} from "./chunk-UVKKAIIP.js";
import {
  __publicField
} from "./chunk-QY3AG7D4.js";

// node_modules/it-length-prefixed/dist/src/errors.js
var InvalidMessageLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};
var UnexpectedEOFError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/it-length-prefixed/dist/src/utils.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}

// node_modules/it-length-prefixed/dist/src/decode.js
var MAX_LENGTH_LENGTH = 8;
var MAX_DATA_LENGTH = 1024 * 1024 * 4;
var ReadMode;
(function(ReadMode2) {
  ReadMode2[ReadMode2["LENGTH"] = 0] = "LENGTH";
  ReadMode2[ReadMode2["DATA"] = 1] = "DATA";
})(ReadMode || (ReadMode = {}));
var defaultDecoder = (buf) => {
  const length = decode(buf);
  defaultDecoder.bytes = encodingLength(length);
  return length;
};
defaultDecoder.bytes = 0;
function decode2(source, options) {
  const buffer = new Uint8ArrayList();
  let mode = ReadMode.LENGTH;
  let dataLength = -1;
  const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder;
  const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH;
  const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
  function* maybeYield() {
    while (buffer.byteLength > 0) {
      if (mode === ReadMode.LENGTH) {
        try {
          dataLength = lengthDecoder(buffer);
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if (dataLength > maxDataLength) {
            throw new InvalidDataLengthError("Message length too long");
          }
          const dataLengthLength = lengthDecoder.bytes;
          buffer.consume(dataLengthLength);
          if ((options == null ? void 0 : options.onLength) != null) {
            options.onLength(dataLength);
          }
          mode = ReadMode.DATA;
        } catch (err) {
          if (err instanceof RangeError) {
            if (buffer.byteLength > maxLengthLength) {
              throw new InvalidDataLengthLengthError("Message length length too long");
            }
            break;
          }
          throw err;
        }
      }
      if (mode === ReadMode.DATA) {
        if (buffer.byteLength < dataLength) {
          break;
        }
        const data = buffer.sublist(0, dataLength);
        buffer.consume(dataLength);
        if ((options == null ? void 0 : options.onData) != null) {
          options.onData(data);
        }
        yield data;
        mode = ReadMode.LENGTH;
      }
    }
  }
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError("Unexpected end of input");
      }
    }();
  }
  return function* () {
    for (const buf of source) {
      buffer.append(buf);
      yield* maybeYield();
    }
    if (buffer.byteLength > 0) {
      throw new UnexpectedEOFError("Unexpected end of input");
    }
  }();
}
decode2.fromReader = (reader, options) => {
  let byteLength = 1;
  const varByteSource = async function* () {
    while (true) {
      try {
        const { done, value } = await reader.next(byteLength);
        if (done === true) {
          return;
        }
        if (value != null) {
          yield value;
        }
      } catch (err) {
        if (err.code === "ERR_UNDER_READ") {
          return { done: true, value: null };
        }
        throw err;
      } finally {
        byteLength = 1;
      }
    }
  }();
  const onLength = (l) => {
    byteLength = l;
  };
  return decode2(varByteSource, {
    ...options ?? {},
    onLength
  });
};

// node_modules/it-length-prefixed/dist/src/encode.js
var defaultEncoder = (length) => {
  const lengthLength = encodingLength(length);
  const lengthBuf = allocUnsafe(lengthLength);
  encode(length, lengthBuf);
  defaultEncoder.bytes = lengthLength;
  return lengthBuf;
};
defaultEncoder.bytes = 0;
function encode2(source, options) {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  function* maybeYield(chunk) {
    const length = encodeLength(chunk.byteLength);
    if (length instanceof Uint8Array) {
      yield length;
    } else {
      yield* length;
    }
    if (chunk instanceof Uint8Array) {
      yield chunk;
    } else {
      yield* chunk;
    }
  }
  if (isAsyncIterable(source)) {
    return async function* () {
      for await (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  return function* () {
    for (const chunk of source) {
      yield* maybeYield(chunk);
    }
  }();
}
encode2.single = (chunk, options) => {
  options = options ?? {};
  const encodeLength = options.lengthEncoder ?? defaultEncoder;
  return new Uint8ArrayList(encodeLength(chunk.byteLength), chunk);
};

// node_modules/it-queueless-pushable/dist/src/index.js
var QueuelessPushable = class {
  constructor() {
    __publicField(this, "readNext");
    __publicField(this, "haveNext");
    __publicField(this, "ended");
    __publicField(this, "nextResult");
    this.ended = false;
    this.readNext = pDefer();
    this.haveNext = pDefer();
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  async next() {
    if (this.nextResult == null) {
      await this.haveNext.promise;
    }
    if (this.nextResult == null) {
      throw new Error("HaveNext promise resolved but nextResult was undefined");
    }
    const nextResult = this.nextResult;
    this.nextResult = void 0;
    this.readNext.resolve();
    this.readNext = pDefer();
    return nextResult;
  }
  async throw(err) {
    this.ended = true;
    if (err != null) {
      this.haveNext.promise.catch(() => {
      });
      this.haveNext.reject(err);
    }
    const result = {
      done: true,
      value: void 0
    };
    return result;
  }
  async return() {
    const result = {
      done: true,
      value: void 0
    };
    await this._push(void 0);
    return result;
  }
  async push(value, options) {
    await this._push(value, options);
  }
  async end(err, options) {
    if (err != null) {
      await this.throw(err);
    } else {
      await this._push(void 0, options);
    }
  }
  async _push(value, options) {
    if (value != null && this.ended) {
      throw new Error("Cannot push value onto an ended pushable");
    }
    while (this.nextResult != null) {
      await this.readNext.promise;
    }
    if (value != null) {
      this.nextResult = { done: false, value };
    } else {
      this.ended = true;
      this.nextResult = { done: true, value: void 0 };
    }
    this.haveNext.resolve();
    this.haveNext = pDefer();
    await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
  }
};
function queuelessPushable() {
  return new QueuelessPushable();
}

// node_modules/it-byte-stream/dist/src/errors.js
var UnexpectedEOFError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedEOFError");
    __publicField(this, "code", "ERR_UNEXPECTED_EOF");
  }
};

// node_modules/it-byte-stream/dist/src/index.js
var CodeError = class extends Error {
  constructor(message, code) {
    super(message);
    __publicField(this, "code");
    this.code = code;
  }
};
var AbortError = class extends CodeError {
  constructor(message) {
    super(message, "ABORT_ERR");
    __publicField(this, "type");
    this.type = "aborted";
    this.name = "AbortError";
  }
};
function byteStream(duplex, opts) {
  const write = queuelessPushable();
  duplex.sink(write).catch(async (err) => {
    await write.end(err);
  });
  duplex.sink = async (source2) => {
    for await (const buf of source2) {
      await write.push(buf);
    }
    await write.end();
  };
  let source = duplex.source;
  if (duplex.source[Symbol.iterator] != null) {
    source = duplex.source[Symbol.iterator]();
  } else if (duplex.source[Symbol.asyncIterator] != null) {
    source = duplex.source[Symbol.asyncIterator]();
  }
  const readBuffer = new Uint8ArrayList();
  const W = {
    read: async (bytes, options) => {
      var _a, _b;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      let listener;
      const abortPromise = new Promise((resolve, reject) => {
        var _a2;
        listener = () => {
          reject(new AbortError("Read aborted"));
        };
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.addEventListener("abort", listener);
      });
      try {
        if (bytes == null) {
          const { done, value } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            return new Uint8ArrayList();
          }
          return value;
        }
        while (readBuffer.byteLength < bytes) {
          const { value, done } = await Promise.race([
            source.next(),
            abortPromise
          ]);
          if (done === true) {
            throw new UnexpectedEOFError2("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, bytes);
        readBuffer.consume(bytes);
        return buf;
      } finally {
        if (listener != null) {
          (_b = options == null ? void 0 : options.signal) == null ? void 0 : _b.removeEventListener("abort", listener);
        }
      }
    },
    write: async (data, options) => {
      var _a;
      (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
      if (data instanceof Uint8Array) {
        await write.push(data, options);
      } else {
        await write.push(data.subarray(), options);
      }
    },
    unwrap: () => {
      if (readBuffer.byteLength > 0) {
        const originalStream = duplex.source;
        duplex.source = async function* () {
          if ((opts == null ? void 0 : opts.yieldBytes) === false) {
            yield readBuffer;
          } else {
            yield* readBuffer;
          }
          yield* originalStream;
        }();
      }
      return duplex;
    }
  };
  return W;
}

// node_modules/it-length-prefixed-stream/dist/src/errors.js
var InvalidMessageLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidMessageLengthError");
    __publicField(this, "code", "ERR_INVALID_MSG_LENGTH");
  }
};
var InvalidDataLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthError");
    __publicField(this, "code", "ERR_MSG_DATA_TOO_LONG");
  }
};
var InvalidDataLengthLengthError2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidDataLengthLengthError");
    __publicField(this, "code", "ERR_MSG_LENGTH_TOO_LONG");
  }
};

// node_modules/it-length-prefixed-stream/dist/src/index.js
function lpStream(duplex, opts = {}) {
  const bytes = byteStream(duplex, opts);
  if (opts.maxDataLength != null && opts.maxLengthLength == null) {
    opts.maxLengthLength = encodingLength(opts.maxDataLength);
  }
  const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode;
  const encodeLength = (opts == null ? void 0 : opts.lengthEncoder) ?? encode;
  const W = {
    read: async (options) => {
      let dataLength = -1;
      const lengthBuffer = new Uint8ArrayList();
      while (true) {
        lengthBuffer.append(await bytes.read(1, options));
        try {
          dataLength = decodeLength(lengthBuffer);
        } catch (err) {
          if (err instanceof RangeError) {
            continue;
          }
          throw err;
        }
        if (dataLength < 0) {
          throw new InvalidMessageLengthError2("Invalid message length");
        }
        if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
          throw new InvalidDataLengthLengthError2("message length length too long");
        }
        if (dataLength > -1) {
          break;
        }
      }
      if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
        throw new InvalidDataLengthError2("message length too long");
      }
      return bytes.read(dataLength, options);
    },
    write: async (data, options) => {
      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options);
    },
    writeV: async (data, options) => {
      const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength(buf.byteLength), buf]));
      await bytes.write(list, options);
    },
    unwrap: () => {
      return bytes.unwrap();
    }
  };
  return W;
}

export {
  encode2 as encode,
  decode2 as decode,
  byteStream,
  lpStream
};
//# sourceMappingURL=chunk-BE2HJ7TE.js.map
