{
  "version": 3,
  "sources": ["../../uint8arraylist/src/index.ts", "../../it-pushable/src/fifo.ts", "../../it-pushable/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n"],
  "mappings": "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",
  "names": ["pushable", "options", "_pushable"]
}
