import {
  Circuit,
  TCP,
  WebRTC,
  WebRTCDirect,
  WebSockets,
  WebSocketsSecure,
  WebTransport
} from "./chunk-3F7GITD2.js";
import {
  convertToIpNet,
  getProtocol,
  isIPv4,
  isIPv6,
  isMultiaddr,
  multiaddr,
  resolvers
} from "./chunk-4JGVO3XG.js";
import {
  byteStream,
  encode as encode2,
  lpStream
} from "./chunk-JJZSNCOQ.js";
import {
  Chi,
  HashMD,
  Maj,
  ahash,
  anumber,
  asyncLoop,
  checkOpts,
  createView,
  generateKeyPair,
  hmac,
  peerIdFromCID,
  peerIdFromMultihash,
  peerIdFromPrivateKey,
  peerIdFromPublicKey,
  peerIdFromString,
  publicKeyFromProtobuf,
  publicKeyToProtobuf,
  randomBytes,
  rotl,
  sha256,
  sha512,
  toBytes,
  wrapConstructor
} from "./chunk-DGMPK36G.js";
import {
  toString
} from "./chunk-MWP5OEUY.js";
import {
  raceSignal
} from "./chunk-LOB4GZJB.js";
import {
  AbortError,
  ConnectionClosedError,
  ConnectionClosingError,
  DialError,
  FaultTolerance,
  InvalidMessageError,
  InvalidMultiaddrError,
  InvalidParametersError,
  InvalidPeerIdError,
  KEEP_ALIVE,
  LimitedConnectionError,
  NotFoundError,
  NotStartedError,
  TimeoutError,
  TooManyInboundProtocolStreamsError,
  TooManyOutboundProtocolStreamsError,
  TypedEventEmitter,
  UnsupportedProtocolError,
  connectionSymbol,
  contentRoutingSymbol,
  isPeerId,
  isStartable,
  peerDiscoverySymbol,
  peerRoutingSymbol,
  serviceCapabilities,
  serviceDependencies,
  setMaxListeners,
  start,
  stop
} from "./chunk-W7L7L57K.js";
import {
  PQueue,
  defaultLogger,
  merge_options_default,
  pTimeout,
  parallel,
  require_murmurhash3js_revisited,
  src_default as src_default2,
  src_default2 as src_default3
} from "./chunk-QWUFDZHL.js";
import {
  CustomProgressEvent
} from "./chunk-2LXZBJZU.js";
import {
  src_default
} from "./chunk-TDJ2YZLS.js";
import {
  MaxLengthError,
  MaxSizeError,
  decodeMessage,
  encodeMessage,
  message
} from "./chunk-5HCC54LS.js";
import {
  encode
} from "./chunk-QINVXJCG.js";
import {
  fromString
} from "./chunk-AKRWU5PV.js";
import {
  base64
} from "./chunk-LJV7FKKR.js";
import {
  CID,
  base32,
  base58btc,
  decode
} from "./chunk-LLHUIDBD.js";
import {
  Uint8ArrayList,
  pushable
} from "./chunk-L26C3OVL.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  concat,
  equals
} from "./chunk-SVJZTA62.js";
import {
  alloc
} from "./chunk-UVKKAIIP.js";
import {
  __commonJS,
  __privateAdd,
  __privateMethod,
  __publicField,
  __toESM
} from "./chunk-QY3AG7D4.js";

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache2 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache2[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache2;
          cache2 = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache2[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache2[key] !== void 0)
            cache2[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache2[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache2[key] !== void 0)
            cache2[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache2 = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base, dmax, i, n, start2;
        n = 0;
        base = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base = 8;
            dmax = "7";
          }
        }
        start2 = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base + (chr(s[i]) - chr0) >>> 0;
          } else if (base === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start2) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask2 = function() {
        function Netmask3(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask3.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask3(ip);
          }
          if (ip instanceof Netmask3) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask3.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask3.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask3.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask3;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask2;
    }).call(exports);
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/@multiformats/dns/dist/src/utils/get-types.js
function getTypes(types) {
  const DEFAULT_TYPES = [
    RecordType.A
  ];
  if (types == null) {
    return DEFAULT_TYPES;
  }
  if (Array.isArray(types)) {
    if (types.length === 0) {
      return DEFAULT_TYPES;
    }
    return types;
  }
  return [
    types
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
var DEFAULT_TTL = 60;
function toDNSResponse(obj) {
  return {
    Status: obj.Status ?? 0,
    TC: obj.TC ?? obj.flag_tc ?? false,
    RD: obj.RD ?? obj.flag_rd ?? false,
    RA: obj.RA ?? obj.flag_ra ?? false,
    AD: obj.AD ?? obj.flag_ad ?? false,
    CD: obj.CD ?? obj.flag_cd ?? false,
    Question: (obj.Question ?? obj.questions ?? []).map((question) => {
      return {
        name: question.name,
        type: RecordType[question.type]
      };
    }),
    Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
      return {
        name: answer.name,
        type: RecordType[answer.type],
        TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
        data: answer.data instanceof Uint8Array ? toString(answer.data) : answer.data
      };
    })
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
var DEFAULT_QUERY_CONCURRENCY = 4;
function dnsJsonOverHttps(url, init = {}) {
  const httpQueue = new PQueue({
    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
  });
  return async (fqdn, options = {}) => {
    var _a12;
    const searchParams = new URLSearchParams();
    searchParams.set("name", fqdn);
    getTypes(options.types).forEach((type) => {
      searchParams.append("type", RecordType[type]);
    });
    (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:query", { detail: fqdn }));
    const response = await httpQueue.add(async () => {
      var _a13;
      const res = await fetch(`${url}?${searchParams}`, {
        headers: {
          accept: "application/dns-json"
        },
        signal: options == null ? void 0 : options.signal
      });
      if (res.status !== 200) {
        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
      }
      const response2 = toDNSResponse(await res.json());
      (_a13 = options.onProgress) == null ? void 0 : _a13.call(options, new CustomProgressEvent("dns:response", { detail: response2 }));
      return response2;
    }, {
      signal: options.signal
    });
    if (response == null) {
      throw new Error("No DNS response received");
    }
    return response;
  };
}

// node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
function defaultResolver() {
  return [
    dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
    dnsJsonOverHttps("https://dns.google/resolve")
  ];
}

// node_modules/@multiformats/dns/dist/src/utils/cache.js
var import_hashlru = __toESM(require_hashlru(), 1);
var CachedAnswers = class {
  constructor(maxSize) {
    __publicField(this, "lru");
    this.lru = (0, import_hashlru.default)(maxSize);
  }
  get(fqdn, types) {
    let foundAllAnswers = true;
    const answers = [];
    for (const type of types) {
      const cached = this.getAnswers(fqdn, type);
      if (cached.length === 0) {
        foundAllAnswers = false;
        break;
      }
      answers.push(...cached);
    }
    if (foundAllAnswers) {
      return toDNSResponse({ answers });
    }
  }
  getAnswers(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    const answers = this.lru.get(key);
    if (answers != null) {
      const cachedAnswers = answers.filter((entry) => {
        return entry.expires > Date.now();
      }).map(({ expires, value }) => ({
        ...value,
        TTL: Math.round((expires - Date.now()) / 1e3),
        type: RecordType[value.type]
      }));
      if (cachedAnswers.length === 0) {
        this.lru.remove(key);
      }
      return cachedAnswers;
    }
    return [];
  }
  add(domain, answer) {
    const key = `${domain.toLowerCase()}-${answer.type}`;
    const answers = this.lru.get(key) ?? [];
    answers.push({
      expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
      value: answer
    });
    this.lru.set(key, answers);
  }
  remove(domain, type) {
    const key = `${domain.toLowerCase()}-${type}`;
    this.lru.remove(key);
  }
  clear() {
    this.lru.clear();
  }
};
function cache(size) {
  return new CachedAnswers(size);
}

// node_modules/@multiformats/dns/dist/src/dns.js
var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
var DNS = class {
  constructor(init) {
    __publicField(this, "resolvers");
    __publicField(this, "cache");
    this.resolvers = {};
    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
      if (!Array.isArray(resolver)) {
        resolver = [resolver];
      }
      if (!tld.endsWith(".")) {
        tld = `${tld}.`;
      }
      this.resolvers[tld] = resolver;
    });
    if (this.resolvers["."] == null) {
      this.resolvers["."] = defaultResolver();
    }
  }
  /**
   * Queries DNS resolvers for the passed record types for the passed domain.
   *
   * If cached records exist for all desired types they will be returned
   * instead.
   *
   * Any new responses will be added to the cache for subsequent requests.
   */
  async query(domain, options = {}) {
    var _a12, _b3, _c;
    const types = getTypes(options.types);
    const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
    if (cached != null) {
      (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dns:cache", { detail: cached }));
      return cached;
    }
    const tld = `${domain.split(".").pop()}.`;
    const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
      return Math.random() > 0.5 ? -1 : 1;
    });
    const errors = [];
    for (const resolver of resolvers2) {
      if (((_b3 = options.signal) == null ? void 0 : _b3.aborted) === true) {
        break;
      }
      try {
        const result = await resolver(domain, {
          ...options,
          types
        });
        for (const answer of result.Answer) {
          this.cache.add(domain, answer);
        }
        return result;
      } catch (err) {
        errors.push(err);
        (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dns:error", { detail: err }));
      }
    }
    if (errors.length === 1) {
      throw errors[0];
    }
    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
  }
};

// node_modules/@multiformats/dns/dist/src/index.js
var RecordType;
(function(RecordType2) {
  RecordType2[RecordType2["A"] = 1] = "A";
  RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
  RecordType2[RecordType2["TXT"] = 16] = "TXT";
  RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
})(RecordType || (RecordType = {}));
function dns(init = {}) {
  return new DNS(init);
}

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
var MAX_RECURSIVE_DEPTH = 32;
var { code: dnsaddrCode } = getProtocol("dnsaddr");
var RecursionLimitError = class extends Error {
  constructor(message2 = "Max recursive depth reached") {
    super(message2);
    this.name = "RecursionLimitError";
  }
};
var dnsaddrResolver = async function dnsaddrResolver2(ma, options = {}) {
  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
  if (recursionLimit === 0) {
    throw new RecursionLimitError("Max recursive depth reached");
  }
  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  const resolver = (options == null ? void 0 : options.dns) ?? dns();
  const result = await resolver.query(`_dnsaddr.${hostname}`, {
    signal: options == null ? void 0 : options.signal,
    types: [
      RecordType.TXT
    ]
  });
  const peerId = ma.getPeerId();
  const output = [];
  for (const answer of result.Answer) {
    const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
    if (addr == null) {
      continue;
    }
    if (peerId != null && !addr.includes(peerId)) {
      continue;
    }
    const ma2 = multiaddr(addr);
    if (addr.startsWith("/dnsaddr")) {
      const resolved = await ma2.resolve({
        ...options,
        maxRecursiveDepth: recursionLimit - 1
      });
      output.push(...resolved.map((ma3) => ma3.toString()));
    } else {
      output.push(ma2.toString());
    }
  }
  return output;
};

// node_modules/libp2p/dist/src/config.js
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  },
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  }
};
async function validateConfig(opts) {
  var _a12, _b3;
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.connectionProtector === null && ((_b3 = (_a12 = globalThis.process) == null ? void 0 : _a12.env) == null ? void 0 : _b3.LIBP2P_FORCE_PNET) != null) {
    throw new InvalidParametersError("Private network is enforced, but no protector was provided");
  }
  return resultingOptions;
}

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map(val)
      };
    }
  };
  return iterator;
}
function peerIdFromString2(str) {
  const multihash = decode(base58btc.decode(`z${str}`));
  return peerIdFromMultihash(multihash);
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map) {
    __publicField(this, "map");
    this.map = /* @__PURE__ */ new Map();
    if (map != null) {
      for (const [key, value] of map.entries()) {
        this.map.set(key.toString(), { key, value });
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    return this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [val[1].key, val[1].value];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value.value, value.key, this);
    });
  }
  get(peer) {
    var _a12;
    return (_a12 = this.map.get(peer.toString())) == null ? void 0 : _a12.value;
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), { key: peer, value });
  }
  keys() {
    return mapIterable(this.map.values(), (val) => {
      return val.key;
    });
  }
  values() {
    return mapIterable(this.map.values(), (val) => val.value);
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class _PeerSet {
  constructor(set) {
    __publicField(this, "set");
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString2(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const peerId = peerIdFromString2(str);
      predicate(peerId, peerId, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString2(val);
    });
  }
  intersection(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new _PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new _PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};
function peerSet() {
  return new PeerSet();
}

// node_modules/@libp2p/peer-collections/dist/src/list.js
var PeerList = class _PeerList {
  constructor(list) {
    __publicField(this, "list");
    this.list = [];
    if (list != null) {
      for (const value of list) {
        this.list.push(value);
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return val[1];
    });
  }
  concat(list) {
    const output = new _PeerList(this);
    for (const value of list) {
      output.push(value);
    }
    return output;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], val[1]];
    });
  }
  every(predicate) {
    return this.list.every((peerId, index) => {
      return predicate(peerId, index, this);
    });
  }
  filter(predicate) {
    const output = new _PeerList();
    this.list.forEach((peerId, index) => {
      if (predicate(peerId, index, this)) {
        output.push(peerId);
      }
    });
    return output;
  }
  find(predicate) {
    const peerId = this.list.find((peerId2, index) => {
      return predicate(peerId2, index, this);
    });
    if (peerId == null) {
      return void 0;
    }
    return peerId;
  }
  findIndex(predicate) {
    return this.list.findIndex((peerId, index) => {
      return predicate(peerId, index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((peerId, index) => {
      predicate(peerId, index, this);
    });
  }
  includes(peerId) {
    return this.includes(peerId);
  }
  indexOf(peerId) {
    return this.list.findIndex((id) => id.equals(peerId));
  }
  pop() {
    const peerId = this.list.pop();
    if (peerId == null) {
      return void 0;
    }
    return peerId;
  }
  push(...peerIds) {
    for (const peerId of peerIds) {
      this.list.push(peerId);
    }
  }
  shift() {
    const peerId = this.list.shift();
    if (peerId == null) {
      return void 0;
    }
    return peerId;
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i = peerIds.length - 1; i > -1; i--) {
      len = this.list.unshift(peerIds[i]);
    }
    return len;
  }
  clear() {
    this.list = [];
  }
  get length() {
    return this.list.length;
  }
};

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash, _password, _salt, _opts) {
  ahash(hash);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@noble/hashes/esm/sha1.js
var SHA1_IV = new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K;
      if (i < 20) {
        F = Chi(B, C, D);
        K = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K = 2400959708;
      } else {
        F = B ^ C ^ D;
        K = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha1 = wrapConstructor(() => new SHA1());

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var hashName = {
  sha1,
  "sha2-256": sha256,
  "sha2-512": sha512
};
function pbkdf22(password, salt, iterations, keySize, hash) {
  if (hash !== "sha1" && hash !== "sha2-256" && hash !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw new InvalidParametersError(`Hash '${hash}' is unknown or not supported. Must be ${types}`);
  }
  const hasher = hashName[hash];
  const dek = pbkdf2(hasher, password, salt, {
    c: iterations,
    dkLen: keySize
  });
  return base64.encode(dek).substring(1);
}

// node_modules/@libp2p/utils/dist/src/filters/bloom-filter.js
var import_murmurhash3js_revisited = __toESM(require_murmurhash3js_revisited(), 1);
var LN2_SQUARED = Math.LN2 * Math.LN2;

// node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
var MAX_FINGERPRINT_SIZE = 64;
var Fingerprint = class {
  constructor(buf, hash, seed, fingerprintSize = 2) {
    __publicField(this, "fp");
    __publicField(this, "h");
    __publicField(this, "seed");
    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
      throw new TypeError("Invalid Fingerprint Size");
    }
    const fnv = hash.hashV(buf, seed);
    const fp = alloc(fingerprintSize);
    for (let i = 0; i < fp.length; i++) {
      fp[i] = fnv[i];
    }
    if (fp.length === 0) {
      fp[0] = 7;
    }
    this.fp = fp;
    this.h = hash;
    this.seed = seed;
  }
  hash() {
    return this.h.hash(this.fp, this.seed);
  }
  equals(other) {
    if (!((other == null ? void 0 : other.fp) instanceof Uint8Array)) {
      return false;
    }
    return equals(this.fp, other.fp);
  }
};

// node_modules/@libp2p/utils/dist/src/filters/utils.js
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

// node_modules/@libp2p/utils/dist/src/filters/bucket.js
var Bucket = class {
  constructor(size) {
    __publicField(this, "contents");
    this.contents = new Array(size).fill(null);
  }
  has(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    return this.contents.some((fp) => {
      return fingerprint.equals(fp);
    });
  }
  add(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    for (let i = 0; i < this.contents.length; i++) {
      if (this.contents[i] == null) {
        this.contents[i] = fingerprint;
        return true;
      }
    }
    return true;
  }
  swap(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const i = getRandomInt(0, this.contents.length - 1);
    const current = this.contents[i];
    this.contents[i] = fingerprint;
    return current;
  }
  remove(fingerprint) {
    if (!(fingerprint instanceof Fingerprint)) {
      throw new TypeError("Invalid Fingerprint");
    }
    const found = this.contents.findIndex((fp) => {
      return fingerprint.equals(fp);
    });
    if (found > -1) {
      this.contents[found] = null;
      return true;
    } else {
      return false;
    }
  }
};

// node_modules/@sindresorhus/fnv1a/index.js
var FNV_PRIMES = {
  32: 16777619n,
  64: 1099511628211n,
  128: 309485009821345068724781371n,
  256: 374144419156711147060143317175368453031918731002211n,
  512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
  1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
};
var FNV_OFFSETS = {
  32: 2166136261n,
  64: 14695981039346656037n,
  128: 144066263297769815596495629667062367629n,
  256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
  512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
  1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
};
var cachedEncoder = new globalThis.TextEncoder();
function fnv1aUint8Array(uint8Array, size) {
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  for (let index = 0; index < uint8Array.length; index++) {
    hash ^= BigInt(uint8Array[index]);
    hash = BigInt.asUintN(size, hash * fnvPrime);
  }
  return hash;
}
function fnv1aEncodeInto(string, size, utf8Buffer) {
  if (utf8Buffer.length === 0) {
    throw new Error("The `utf8Buffer` option must have a length greater than zero");
  }
  const fnvPrime = FNV_PRIMES[size];
  let hash = FNV_OFFSETS[size];
  let remaining = string;
  while (remaining.length > 0) {
    const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
    remaining = remaining.slice(result.read);
    for (let index = 0; index < result.written; index++) {
      hash ^= BigInt(utf8Buffer[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
  }
  return hash;
}
function fnv1a(value, { size = 32, utf8Buffer } = {}) {
  if (!FNV_PRIMES[size]) {
    throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
  }
  if (typeof value === "string") {
    if (utf8Buffer) {
      return fnv1aEncodeInto(value, size, utf8Buffer);
    }
    value = cachedEncoder.encode(value);
  }
  return fnv1aUint8Array(value, size);
}

// node_modules/@libp2p/utils/dist/src/filters/hashes.js
var import_murmurhash3js_revisited2 = __toESM(require_murmurhash3js_revisited(), 1);
var fnv1a2 = {
  hash: (input) => {
    return Number(fnv1a(input, {
      size: 32
    }));
  },
  hashV: (input, seed) => {
    return numberToBuffer(fnv1a2.hash(input, seed));
  }
};
function numberToBuffer(num) {
  let hex = num.toString(16);
  if (hex.length % 2 === 1) {
    hex = `0${hex}`;
  }
  return fromString(hex, "base16");
}

// node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
var maxCuckooCount = 500;
var CuckooFilter = class {
  constructor(init) {
    __publicField(this, "bucketSize");
    __publicField(this, "filterSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.filterSize = init.filterSize;
    this.bucketSize = init.bucketSize ?? 4;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.count = 0;
    this.buckets = [];
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    if (this.buckets[j] == null) {
      this.buckets[j] = new Bucket(this.bucketSize);
    }
    if (this.buckets[k] == null) {
      this.buckets[k] = new Bucket(this.bucketSize);
    }
    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
      this.count++;
      return true;
    }
    const rand = [j, k];
    let i = rand[getRandomInt(0, rand.length - 1)];
    if (this.buckets[i] == null) {
      this.buckets[i] = new Bucket(this.bucketSize);
    }
    for (let n = 0; n < maxCuckooCount; n++) {
      const swapped = this.buckets[i].swap(fingerprint);
      if (swapped == null) {
        continue;
      }
      i = (i ^ swapped.hash()) % this.filterSize;
      if (this.buckets[i] == null) {
        this.buckets[i] = new Bucket(this.bucketSize);
      }
      if (this.buckets[i].add(swapped)) {
        this.count++;
        return true;
      } else {
        continue;
      }
    }
    return false;
  }
  has(item) {
    var _a12, _b3;
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a12 = this.buckets[j]) == null ? void 0 : _a12.has(fingerprint)) ?? false;
    if (inJ) {
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    return ((_b3 = this.buckets[k]) == null ? void 0 : _b3.has(fingerprint)) ?? false;
  }
  remove(item) {
    var _a12, _b3;
    if (typeof item === "string") {
      item = fromString(item);
    }
    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
    const j = this.hash.hash(item, this.seed) % this.filterSize;
    const inJ = ((_a12 = this.buckets[j]) == null ? void 0 : _a12.remove(fingerprint)) ?? false;
    if (inJ) {
      this.count--;
      return inJ;
    }
    const k = (j ^ fingerprint.hash()) % this.filterSize;
    const inK = ((_b3 = this.buckets[k]) == null ? void 0 : _b3.remove(fingerprint)) ?? false;
    if (inK) {
      this.count--;
    }
    return inK;
  }
  get reliable() {
    return Math.floor(100 * (this.count / this.filterSize)) <= 90;
  }
};
var MAX_LOAD = {
  1: 0.5,
  2: 0.84,
  4: 0.95,
  8: 0.98
};
function calculateBucketSize(errorRate = 1e-3) {
  if (errorRate > 2e-3) {
    return 2;
  }
  if (errorRate > 1e-5) {
    return 4;
  }
  return 8;
}
function optimize(maxItems, errorRate = 1e-3) {
  const bucketSize = calculateBucketSize(errorRate);
  const load = MAX_LOAD[bucketSize];
  const filterSize = Math.round(maxItems / load);
  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
  return {
    filterSize,
    bucketSize,
    fingerprintSize
  };
}

// node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
var ScalableCuckooFilter = class {
  constructor(init) {
    __publicField(this, "filterSize");
    __publicField(this, "bucketSize");
    __publicField(this, "fingerprintSize");
    __publicField(this, "scale");
    __publicField(this, "filterSeries");
    __publicField(this, "hash");
    __publicField(this, "seed");
    this.bucketSize = init.bucketSize ?? 4;
    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
    this.fingerprintSize = init.fingerprintSize ?? 2;
    this.scale = init.scale ?? 2;
    this.hash = init.hash ?? fnv1a2;
    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    this.filterSeries = [
      new CuckooFilter({
        filterSize: this.filterSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      })
    ];
  }
  add(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    if (this.has(item)) {
      return true;
    }
    let current = this.filterSeries.find((cuckoo) => {
      return cuckoo.reliable;
    });
    if (current == null) {
      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
      current = new CuckooFilter({
        filterSize: curSize,
        bucketSize: this.bucketSize,
        fingerprintSize: this.fingerprintSize,
        hash: this.hash,
        seed: this.seed
      });
      this.filterSeries.push(current);
    }
    return current.add(item);
  }
  has(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].has(item)) {
        return true;
      }
    }
    return false;
  }
  remove(item) {
    if (typeof item === "string") {
      item = fromString(item);
    }
    for (let i = 0; i < this.filterSeries.length; i++) {
      if (this.filterSeries[i].remove(item)) {
        return true;
      }
    }
    return false;
  }
  get count() {
    return this.filterSeries.reduce((acc, curr) => {
      return acc + curr.count;
    }, 0);
  }
};
function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
  return new ScalableCuckooFilter({
    ...optimize(maxItems, errorRate),
    ...options ?? {}
  });
}

// node_modules/@libp2p/peer-collections/dist/src/filter.js
var PeerFilter = class {
  constructor(size, errorRate) {
    __publicField(this, "filter");
    this.filter = createScalableCuckooFilter(size, errorRate);
  }
  has(peerId) {
    return this.filter.has(peerId.toMultihash().bytes);
  }
  add(peerId) {
    this.filter.add(peerId.toMultihash().bytes);
  }
  remove(peerId) {
    var _a12, _b3;
    (_b3 = (_a12 = this.filter).remove) == null ? void 0 : _b3.call(_a12, peerId.toMultihash().bytes);
  }
};
function peerFilter(size, errorRate = 1e-3) {
  return new PeerFilter(size, errorRate);
}

// node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
var TrackedPeerMap = class extends PeerMap {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name2, metrics } = init;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedPeerMap(config) {
  const { name: name2, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedPeerMap({ name: name2, metrics });
  } else {
    map = new PeerMap();
  }
  return map;
}

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          publicKey: alloc(0),
          payloadType: alloc(0),
          payload: alloc(0),
          signature: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 2: {
              obj.payloadType = reader.bytes();
              break;
            }
            case 3: {
              obj.payload = reader.bytes();
              break;
            }
            case 5: {
              obj.signature = reader.bytes();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf, opts) => {
    return decodeMessage(buf, Envelope2.codec(), opts);
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
var InvalidSignatureError = class extends Error {
  constructor(message2 = "Invalid signature") {
    super(message2);
    this.name = "InvalidSignatureError";
  }
};

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _RecordEnvelope = class _RecordEnvelope {
  /**
   * The Envelope is responsible for keeping an arbitrary signed record
   * by a libp2p peer.
   */
  constructor(init) {
    __publicField(this, "publicKey");
    __publicField(this, "payloadType");
    __publicField(this, "payload");
    __publicField(this, "signature");
    __publicField(this, "marshaled");
    const { publicKey, payloadType, payload, signature } = init;
    this.publicKey = publicKey;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  /**
   * Marshal the envelope content
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: publicKeyToProtobuf(this.publicKey),
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  /**
   * Verifies if the other Envelope is identical to this one
   */
  equals(other) {
    return equals(this.marshal(), other.marshal());
  }
  /**
   * Validate envelope data signature for the given domain
   */
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    return this.publicKey.verify(signData.subarray(), this.signature);
  }
};
/**
 * Unmarshal a serialized Envelope protobuf message
 */
__publicField(_RecordEnvelope, "createFromProtobuf", async (data) => {
  const envelopeData = Envelope.decode(data);
  const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
  return new _RecordEnvelope({
    publicKey,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
});
/**
 * Seal marshals the given Record, places the marshaled bytes inside an Envelope
 * and signs it with the given peerId's private key
 */
__publicField(_RecordEnvelope, "seal", async (record, privateKey) => {
  if (privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const signature = await privateKey.sign(signData.subarray());
  return new _RecordEnvelope({
    publicKey: privateKey.publicKey,
    payloadType,
    payload,
    signature
  });
});
/**
 * Open and certify a given marshalled envelope.
 * Data is unmarshalled and the signature validated for the given domain.
 */
__publicField(_RecordEnvelope, "openAndCertify", async (data, domain) => {
  const envelope = await _RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
  }
  return envelope;
});
var RecordEnvelope = _RecordEnvelope;
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString(domain);
  const domainLength = encode(domainUint8Array.byteLength);
  const payloadTypeLength = encode(payloadType.length);
  const payloadLength = encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, AddressInfo2.codec(), opts);
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (obj.seq != null && obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a12, _b3;
        const obj = {
          peerId: alloc(0),
          seq: 0n,
          addresses: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.peerId = reader.bytes();
              break;
            }
            case 2: {
              obj.seq = reader.uint64();
              break;
            }
            case 3: {
              if (((_a12 = opts.limits) == null ? void 0 : _a12.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                limits: (_b3 = opts.limits) == null ? void 0 : _b3.addresses$
              }));
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf, opts) => {
    return decodeMessage(buf, PeerRecord3.codec(), opts);
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var _PeerRecord = class _PeerRecord {
  constructor(init) {
    __publicField(this, "peerId");
    __publicField(this, "multiaddrs");
    __publicField(this, "seqNumber");
    __publicField(this, "domain", _PeerRecord.DOMAIN);
    __publicField(this, "codec", _PeerRecord.CODEC);
    __publicField(this, "marshaled");
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  /**
   * Marshal a record to be used in an envelope
   */
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toMultihash().bytes,
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  /**
   * Returns true if `this` record equals the `other`
   */
  equals(other) {
    if (!(other instanceof _PeerRecord)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
/**
 * Unmarshal Peer Record Protobuf
 */
__publicField(_PeerRecord, "createFromProtobuf", (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId = peerIdFromMultihash(decode(peerRecord.peerId));
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new _PeerRecord({ peerId, multiaddrs, seqNumber });
});
__publicField(_PeerRecord, "DOMAIN", ENVELOPE_DOMAIN_PEER_RECORD);
__publicField(_PeerRecord, "CODEC", ENVELOPE_PAYLOAD_TYPE_PEER_RECORD);
var PeerRecord2 = _PeerRecord;

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default4 = observable;

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/mortice/dist/src/utils.js
var nanoid = (size = 21) => {
  return Math.random().toString().substring(2);
};

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if ((event2 == null ? void 0 : event2.data) == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return new Promise((resolve) => {
      const listener = (event) => {
        if ((event == null ? void 0 : event.data) == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default4.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default4.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => pTimeout((async () => {
    await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return p;
}
var createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return readPromise;
    },
    async writeLock() {
      readQueue = null;
      return createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions2 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions2, options);
  if (implementation == null) {
    implementation = browser_default(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => event.data.handler().finally(() => {
          release();
        }));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let Peer$metadataEntry;
  (function(Peer$metadataEntry2) {
    let _codec2;
    Peer$metadataEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w.uint32(18);
            w.bytes(obj.value);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          const obj = {
            key: "",
            value: alloc(0)
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$metadataEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$metadataEntry2.codec());
    };
    Peer$metadataEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
    };
  })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
  let Peer$tagsEntry;
  (function(Peer$tagsEntry2) {
    let _codec2;
    Peer$tagsEntry2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (obj.key != null && obj.key !== "") {
            w.uint32(10);
            w.string(obj.key);
          }
          if (obj.value != null) {
            w.uint32(18);
            Tag.codec().encode(obj.value, w);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader, length, opts = {}) => {
          var _a12;
          const obj = {
            key: ""
          };
          const end = length == null ? reader.len : reader.pos + length;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.string();
                break;
              }
              case 2: {
                obj.value = Tag.codec().decode(reader, reader.uint32(), {
                  limits: (_a12 = opts.limits) == null ? void 0 : _a12.value
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer$tagsEntry2.encode = (obj) => {
      return encodeMessage(obj, Peer$tagsEntry2.codec());
    };
    Peer$tagsEntry2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
    };
  })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value, w);
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (obj.publicKey != null) {
          w.uint32(34);
          w.bytes(obj.publicKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (obj.metadata != null && obj.metadata.size !== 0) {
          for (const [key, value] of obj.metadata.entries()) {
            w.uint32(50);
            Peer2.Peer$metadataEntry.codec().encode({ key, value }, w);
          }
        }
        if (obj.tags != null && obj.tags.size !== 0) {
          for (const [key, value] of obj.tags.entries()) {
            w.uint32(58);
            Peer2.Peer$tagsEntry.codec().encode({ key, value }, w);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        var _a12, _b3, _c, _d, _e, _f;
        const obj = {
          addresses: [],
          protocols: [],
          metadata: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (((_a12 = opts.limits) == null ? void 0 : _a12.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
              }
              obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                limits: (_b3 = opts.limits) == null ? void 0 : _b3.addresses$
              }));
              break;
            }
            case 2: {
              if (((_c = opts.limits) == null ? void 0 : _c.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
              }
              obj.protocols.push(reader.string());
              break;
            }
            case 4: {
              obj.publicKey = reader.bytes();
              break;
            }
            case 5: {
              obj.peerRecordEnvelope = reader.bytes();
              break;
            }
            case 6: {
              if (((_d = opts.limits) == null ? void 0 : _d.metadata) != null && obj.metadata.size === opts.limits.metadata) {
                throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
              }
              const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
              obj.metadata.set(entry.key, entry.value);
              break;
            }
            case 7: {
              if (((_e = opts.limits) == null ? void 0 : _e.tags) != null && obj.tags.size === opts.limits.tags) {
                throw new MaxSizeError('Decode error - map field "tags" had too many elements');
              }
              const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                limits: {
                  value: (_f = opts.limits) == null ? void 0 : _f.tags$value
                }
              });
              obj.tags.set(entry.key, entry.value);
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf, opts) => {
    return decodeMessage(buf, Peer2.codec(), opts);
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          multiaddr: alloc(0)
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.multiaddr = reader.bytes();
              break;
            }
            case 2: {
              obj.isCertified = reader.bool();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage(obj, Address2.codec());
  };
  Address2.decode = (buf, opts) => {
    return decodeMessage(buf, Address2.codec(), opts);
  };
})(Address || (Address = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.value != null && obj.value !== 0) {
          w.uint32(8);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(16);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length, opts = {}) => {
        const obj = {
          value: 0
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              obj.value = reader.uint32();
              break;
            }
            case 2: {
              obj.expiry = reader.uint64();
              break;
            }
            default: {
              reader.skipType(tag & 7);
              break;
            }
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage(obj, Tag2.codec());
  };
  Tag2.decode = (buf, opts) => {
    return decodeMessage(buf, Tag2.codec(), opts);
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
function bytesToPeer(peerId, buf) {
  const peer = Peer.decode(buf);
  if (peer.publicKey != null && peerId.publicKey == null) {
    const publicKey = publicKeyFromProtobuf(peer.publicKey);
    peerId = peerIdFromPublicKey(publicKey);
  }
  const tags = /* @__PURE__ */ new Map();
  const now = BigInt(Date.now());
  for (const [key, tag] of peer.tags.entries()) {
    if (tag.expiry != null && tag.expiry < now) {
      continue;
    }
    tags.set(key, tag);
  }
  return {
    ...peer,
    id: peerId,
    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
      return {
        multiaddr: multiaddr(ma),
        isCertified: isCertified ?? false
      };
    }),
    metadata: peer.metadata,
    peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
    tags
  };
}

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class _Key {
  /**
   * @param {string | Uint8Array} s
   * @param {boolean} [clean]
   */
  constructor(s, clean) {
    __publicField(this, "_buf");
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  /**
   * Convert to the string representation
   *
   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.
   * @returns {string}
   */
  toString(encoding = "utf8") {
    return toString(this._buf, encoding);
  }
  /**
   * Return the Uint8Array representation of the key
   *
   * @returns {Uint8Array}
   */
  uint8Array() {
    return this._buf;
  }
  /**
   * Return string representation of the key
   *
   * @returns {string}
   */
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  /**
   * Constructs a key out of a namespace array.
   *
   * @param {Array<string>} list - The array of namespaces
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.withNamespaces(['one', 'two'])
   * // => Key('/one/two')
   * ```
   */
  static withNamespaces(list) {
    return new _Key(list.join(pathSepS));
  }
  /**
   * Returns a randomly (uuid) generated key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * Key.random()
   * // => Key('/344502982398')
   * ```
   */
  static random() {
    return new _Key(Math.random().toString().substring(2));
  }
  /**
   * @param {*} other
   */
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new _Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new _Key(other.uint8Array());
    }
    return null;
  }
  /**
   * Cleanup the current key
   *
   * @returns {void}
   */
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  /**
   * Check if the given key is sorted lower than ourself.
   *
   * @param {Key} key - The other Key to check against
   * @returns {boolean}
   */
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  /**
   * Returns the key with all parts in reversed order.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
   * ```
   */
  reverse() {
    return _Key.withNamespaces(this.list().slice().reverse());
  }
  /**
   * Returns the `namespaces` making up this Key.
   *
   * @returns {Array<string>}
   */
  namespaces() {
    return this.list();
  }
  /** Returns the "base" namespace of this key.
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
   * // => 'Actor:JohnCleese'
   * ```
   */
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  /**
   * Returns the `list` representation of this key.
   *
   * @returns {Array<string>}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
   * ```
   */
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  /**
   * Returns the "type" of this key (value of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
   * // => 'Actor'
   * ```
   */
  type() {
    return namespaceType(this.baseNamespace());
  }
  /**
   * Returns the "name" of this key (field of last namespace).
   *
   * @returns {string}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
   * // => 'JohnCleese'
   * ```
   */
  name() {
    return namespaceValue(this.baseNamespace());
  }
  /**
   * Returns an "instance" of this type key (appends value to namespace).
   *
   * @param {string} s - The string to append.
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  instance(s) {
    return new _Key(this.toString() + ":" + s);
  }
  /**
   * Returns the "path" of this key (parent + type).
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
   * // => Key('/Comedy/MontyPython/Actor')
   * ```
   */
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new _Key(p);
  }
  /**
   * Returns the `parent` Key of this Key.
   *
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
   * // => Key("/Comedy/MontyPython")
   * ```
   */
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new _Key(pathSepS);
    }
    return new _Key(list.slice(0, -1).join(pathSepS));
  }
  /**
   * Returns the `child` Key of this Key.
   *
   * @param {Key} key - The child Key to add
   * @returns {Key}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
   * ```
   */
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new _Key(this.toString() + key.toString(), false);
  }
  /**
   * Returns whether this key is a prefix of `other`
   *
   * @param {Key} other - The other key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
   * // => true
   * ```
   */
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  /**
   * Returns whether this key is a contains another as prefix.
   *
   * @param {Key} other - The other Key to test against
   * @returns {boolean}
   *
   * @example
   * ```js
   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
   * // => true
   * ```
   */
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  /**
   * Checks if this key has only one namespace.
   *
   * @returns {boolean}
   */
  isTopLevel() {
    return this.list().length === 1;
  }
  /**
   * Concats one or more Keys into one new Key.
   *
   * @param {Array<Key>} keys - The array of keys to concatenate
   * @returns {Key}
   */
  concat(...keys) {
    return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
var NAMESPACE_COMMON = "/peers/";
function peerIdToDatastoreKey(peerId) {
  if (!isPeerId(peerId) || peerId.type == null) {
    throw new InvalidParametersError("Invalid PeerId");
  }
  const b32key = peerId.toCID().toString();
  return new Key(`${NAMESPACE_COMMON}${b32key}`);
}

// node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
async function dedupeFilterAndSortAddresses(peerId, filter, addresses) {
  const addressMap = /* @__PURE__ */ new Map();
  for (const addr of addresses) {
    if (addr == null) {
      continue;
    }
    if (addr.multiaddr instanceof Uint8Array) {
      addr.multiaddr = multiaddr(addr.multiaddr);
    }
    if (!isMultiaddr(addr.multiaddr)) {
      throw new InvalidParametersError("Multiaddr was invalid");
    }
    if (!await filter(peerId, addr.multiaddr)) {
      continue;
    }
    const isCertified = addr.isCertified ?? false;
    const maStr = addr.multiaddr.toString();
    const existingAddr = addressMap.get(maStr);
    if (existingAddr != null) {
      addr.isCertified = existingAddr.isCertified || isCertified;
    } else {
      addressMap.set(maStr, {
        multiaddr: addr.multiaddr,
        isCertified
      });
    }
  }
  return [...addressMap.values()].sort((a, b) => {
    return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
  }).map(({ isCertified, multiaddr: multiaddr2 }) => ({
    isCertified,
    multiaddr: multiaddr2.bytes
  }));
}

// node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
async function toPeerPB(peerId, data, strategy, options) {
  if (data == null) {
    throw new InvalidParametersError("Invalid PeerData");
  }
  if (data.publicKey != null && peerId.publicKey != null && !data.publicKey.equals(peerId.publicKey)) {
    throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
  }
  const existingPeer = options.existingPeer;
  if (existingPeer != null && !peerId.equals(existingPeer.id)) {
    throw new InvalidParametersError("peer id did not match existing peer id");
  }
  let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
  let protocols = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
  let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
  let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
  let peerRecordEnvelope = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
  if (strategy === "patch") {
    if (data.multiaddrs != null || data.addresses != null) {
      addresses = [];
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
    }
    if (data.protocols != null) {
      protocols = new Set(data.protocols);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      metadata = createSortedMap(metadataEntries, {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      tags = createSortedMap(tagsEntries, {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  if (strategy === "merge") {
    if (data.multiaddrs != null) {
      addresses.push(...data.multiaddrs.map((multiaddr2) => ({
        isCertified: false,
        multiaddr: multiaddr2
      })));
    }
    if (data.addresses != null) {
      addresses.push(...data.addresses);
    }
    if (data.protocols != null) {
      protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
    }
    if (data.metadata != null) {
      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
      for (const [key, value] of metadataEntries) {
        if (value == null) {
          metadata.delete(key);
        } else {
          metadata.set(key, value);
        }
      }
      metadata = createSortedMap([...metadata.entries()], {
        validate: validateMetadata
      });
    }
    if (data.tags != null) {
      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
      const mergedTags = new Map(tags);
      for (const [key, value] of tagsEntries) {
        if (value == null) {
          mergedTags.delete(key);
        } else {
          mergedTags.set(key, value);
        }
      }
      tags = createSortedMap([...mergedTags.entries()], {
        validate: validateTag,
        map: mapTag
      });
    }
    if (data.peerRecordEnvelope != null) {
      peerRecordEnvelope = data.peerRecordEnvelope;
    }
  }
  let publicKey;
  if ((existingPeer == null ? void 0 : existingPeer.id.publicKey) != null) {
    publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
  } else if (data.publicKey != null) {
    publicKey = publicKeyToProtobuf(data.publicKey);
  } else if (peerId.publicKey != null) {
    publicKey = publicKeyToProtobuf(peerId.publicKey);
  }
  const output = {
    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),
    protocols: [...protocols.values()].sort((a, b) => {
      return a.localeCompare(b);
    }),
    metadata,
    tags,
    publicKey,
    peerRecordEnvelope
  };
  if (peerId.type !== "RSA") {
    delete output.publicKey;
  }
  return output;
}
function createSortedMap(entries, options) {
  var _a12;
  const output = /* @__PURE__ */ new Map();
  for (const [key, value] of entries) {
    if (value == null) {
      continue;
    }
    options.validate(key, value);
  }
  for (const [key, value] of entries.sort(([a], [b]) => {
    return a.localeCompare(b);
  })) {
    if (value != null) {
      output.set(key, ((_a12 = options.map) == null ? void 0 : _a12.call(options, key, value)) ?? value);
    }
  }
  return output;
}
function validateMetadata(key, value) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Metadata key must be a string");
  }
  if (!(value instanceof Uint8Array)) {
    throw new InvalidParametersError("Metadata value must be a Uint8Array");
  }
}
function validateTag(key, tag) {
  if (typeof key !== "string") {
    throw new InvalidParametersError("Tag name must be a string");
  }
  if (tag.value != null) {
    if (parseInt(`${tag.value}`, 10) !== tag.value) {
      throw new InvalidParametersError("Tag value must be an integer");
    }
    if (tag.value < 0 || tag.value > 100) {
      throw new InvalidParametersError("Tag value must be between 0-100");
    }
  }
  if (tag.ttl != null) {
    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
      throw new InvalidParametersError("Tag ttl must be an integer");
    }
    if (tag.ttl < 0) {
      throw new InvalidParametersError("Tag ttl must be between greater than 0");
    }
  }
}
function mapTag(key, tag) {
  let expiry;
  if (tag.expiry != null) {
    expiry = tag.expiry;
  }
  if (tag.ttl != null) {
    expiry = BigInt(Date.now() + Number(tag.ttl));
  }
  return {
    value: tag.value ?? 0,
    expiry
  };
}

// node_modules/@libp2p/peer-store/dist/src/store.js
function decodePeer(key, value) {
  const base32Str = key.toString().split("/")[2];
  const buf = CID.parse(base32Str, base32);
  const peerId = peerIdFromCID(buf);
  return bytesToPeer(peerId, value);
}
function mapQuery(query) {
  if (query == null) {
    return {};
  }
  return {
    prefix: NAMESPACE_COMMON,
    filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
      return fn(decodePeer(key, value));
    }),
    orders: (query.orders ?? []).map((fn) => (a, b) => {
      return fn(decodePeer(a.key, a.value), decodePeer(b.key, b.value));
    })
  };
}
var _findExistingPeer, findExistingPeer_fn, _saveIfDifferent, saveIfDifferent_fn;
var PersistentStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _findExistingPeer);
    __privateAdd(this, _saveIfDifferent);
    __publicField(this, "peerId");
    __publicField(this, "datastore");
    __publicField(this, "lock");
    __publicField(this, "addressFilter");
    __publicField(this, "log");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.peerId = components.peerId;
    this.datastore = components.datastore;
    this.addressFilter = init.addressFilter;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  async has(peerId) {
    return this.datastore.has(peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    if (this.peerId.equals(peerId)) {
      throw new InvalidParametersError("Cannot delete self peer");
    }
    await this.datastore.delete(peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf = await this.datastore.get(peerIdToDatastoreKey(peerId));
    return bytesToPeer(peerId, buf);
  }
  async save(peerId, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId, peerPb, existingBuf, existingPeer);
  }
  async patch(peerId, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "patch", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId, peerPb, existingBuf, existingPeer);
  }
  async merge(peerId, data) {
    const { existingBuf, existingPeer } = await __privateMethod(this, _findExistingPeer, findExistingPeer_fn).call(this, peerId);
    const peerPb = await toPeerPB(peerId, data, "merge", {
      addressFilter: this.addressFilter,
      existingPeer
    });
    return __privateMethod(this, _saveIfDifferent, saveIfDifferent_fn).call(this, peerId, peerPb, existingBuf, existingPeer);
  }
  async *all(query) {
    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}))) {
      const peer = decodePeer(key, value);
      if (peer.id.equals(this.peerId)) {
        continue;
      }
      yield peer;
    }
  }
};
_findExistingPeer = new WeakSet();
findExistingPeer_fn = async function(peerId) {
  try {
    const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId));
    const existingPeer = bytesToPeer(peerId, existingBuf);
    return {
      existingBuf,
      existingPeer
    };
  } catch (err) {
    if (err.name !== "NotFoundError") {
      this.log.error("invalid peer data found in peer store - %e", err);
    }
  }
  return {};
};
_saveIfDifferent = new WeakSet();
saveIfDifferent_fn = async function(peerId, peer, existingBuf, existingPeer) {
  const buf = Peer.encode(peer);
  if (existingBuf != null && equals(buf, existingBuf)) {
    return {
      peer: bytesToPeer(peerId, buf),
      previous: existingPeer,
      updated: false
    };
  }
  await this.datastore.put(peerIdToDatastoreKey(peerId), buf);
  return {
    peer: bytesToPeer(peerId, buf),
    previous: existingPeer,
    updated: true
  };
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var _a, _emitIfUpdated, emitIfUpdated_fn;
var PersistentPeerStore = class {
  constructor(components, init = {}) {
    __privateAdd(this, _emitIfUpdated);
    __publicField(this, "store");
    __publicField(this, "events");
    __publicField(this, "peerId");
    __publicField(this, "log");
    __publicField(this, _a, "@libp2p/peer-store");
    this.log = components.logger.forComponent("libp2p:peer-store");
    this.events = components.events;
    this.peerId = components.peerId;
    this.store = new PersistentStore(components, init);
  }
  async forEach(fn, query) {
    this.log.trace("forEach await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("forEach got read lock");
    try {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    } finally {
      this.log.trace("forEach release read lock");
      release();
    }
  }
  async all(query) {
    this.log.trace("all await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("all got read lock");
    try {
      return await src_default2(this.store.all(query));
    } finally {
      this.log.trace("all release read lock");
      release();
    }
  }
  async delete(peerId) {
    this.log.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      this.log.trace("delete release write lock");
      release();
    }
  }
  async has(peerId) {
    this.log.trace("has await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      this.log.trace("has release read lock");
      release();
    }
  }
  async get(peerId) {
    this.log.trace("get await read lock");
    const release = await this.store.lock.readLock();
    this.log.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      this.log.trace("get release read lock");
      release();
    }
  }
  async save(id, data) {
    this.log.trace("save await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("save got write lock");
    try {
      const result = await this.store.save(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("save release write lock");
      release();
    }
  }
  async patch(id, data) {
    this.log.trace("patch await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("patch got write lock");
    try {
      const result = await this.store.patch(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("patch release write lock");
      release();
    }
  }
  async merge(id, data) {
    this.log.trace("merge await write lock");
    const release = await this.store.lock.writeLock();
    this.log.trace("merge got write lock");
    try {
      const result = await this.store.merge(id, data);
      __privateMethod(this, _emitIfUpdated, emitIfUpdated_fn).call(this, id, result);
      return result.peer;
    } finally {
      this.log.trace("merge release write lock");
      release();
    }
  }
  async consumePeerRecord(buf, expectedPeer) {
    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN);
    const peerId = peerIdFromCID(envelope.publicKey.toCID());
    if ((expectedPeer == null ? void 0 : expectedPeer.equals(peerId)) === false) {
      this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId);
      return false;
    }
    const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
    let peer;
    try {
      peer = await this.get(peerId);
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
      const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
      if (storedRecord.seqNumber >= peerRecord.seqNumber) {
        this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
        return false;
      }
    }
    await this.patch(peerRecord.peerId, {
      peerRecordEnvelope: buf,
      addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }))
    });
    return true;
  }
};
_a = Symbol.toStringTag;
_emitIfUpdated = new WeakSet();
emitIfUpdated_fn = function(id, result) {
  if (!result.updated) {
    return;
  }
  if (this.peerId.equals(id)) {
    this.events.safeDispatchEvent("self:peer:update", { detail: result });
  } else {
    this.events.safeDispatchEvent("peer:update", { detail: result });
  }
};
function persistentPeerStore(components, init = {}) {
  return new PersistentPeerStore(components, init);
}

// node_modules/interface-store/dist/src/errors.js
var _NotFoundError = class _NotFoundError extends Error {
  constructor(message2 = "Not Found") {
    super(message2);
    __publicField(this, "name", _NotFoundError.name);
    __publicField(this, "code", _NotFoundError.code);
  }
};
__publicField(_NotFoundError, "name", "NotFoundError");
__publicField(_NotFoundError, "code", "ERR_NOT_FOUND");
var NotFoundError2 = _NotFoundError;

// node_modules/it-drain/dist/src/index.js
function isAsyncIterable(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function drain(source) {
  if (isAsyncIterable(source)) {
    return (async () => {
      for await (const _ of source) {
      }
    })();
  } else {
    for (const _ of source) {
    }
  }
}
var src_default5 = drain;

// node_modules/it-sort/dist/src/index.js
function isAsyncIterable2(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function sort(source, sorter) {
  if (isAsyncIterable2(source)) {
    return async function* () {
      const arr = await src_default2(source);
      yield* arr.sort(sorter);
    }();
  }
  return function* () {
    const arr = src_default2(source);
    yield* arr.sort(sorter);
  }();
}
var src_default6 = sort;

// node_modules/it-take/dist/src/index.js
function isAsyncIterable3(thing) {
  return thing[Symbol.asyncIterator] != null;
}
function take(source, limit) {
  if (isAsyncIterable3(source)) {
    return async function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  return function* () {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  }();
}
var src_default7 = take;

// node_modules/datastore-core/dist/src/base.js
var BaseDatastore = class {
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield key;
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield {
        key,
        value: await this.get(key, options)
      };
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await src_default5(this.putMany(puts, options));
        puts = [];
        await src_default5(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  /**
   * Extending classes should override `query` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  /**
   * Extending classes should override `queryKeys` or implement this method
   */
  // eslint-disable-next-line require-yield
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default3(it, (e) => e.key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default3(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      const offset = q.offset;
      it = src_default3(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      const prefix = q.prefix;
      it = src_default3(it, (key) => key.toString().startsWith(prefix));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => src_default3(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
    }
    if (q.offset != null) {
      const offset = q.offset;
      let i = 0;
      it = src_default3(it, () => i++ >= offset);
    }
    if (q.limit != null) {
      it = src_default7(it, q.limit);
    }
    return it;
  }
};

// node_modules/datastore-core/dist/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    __publicField(this, "data");
    this.data = /* @__PURE__ */ new Map();
  }
  put(key, val) {
    this.data.set(key.toString(), val);
    return key;
  }
  get(key) {
    const result = this.data.get(key.toString());
    if (result == null) {
      throw new NotFoundError2();
    }
    return result;
  }
  has(key) {
    return this.data.has(key.toString());
  }
  delete(key) {
    this.data.delete(key.toString());
  }
  *_all() {
    for (const [key, value] of this.data.entries()) {
      yield { key: new Key(key), value };
    }
  }
  *_allKeys() {
    for (const key of this.data.keys()) {
      yield new Key(key);
    }
  }
};

// node_modules/@libp2p/utils/dist/src/debounce.js
function debounce(func, wait) {
  let timeout;
  const output = function() {
    const later = function() {
      timeout = void 0;
      void func();
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
  output.start = () => {
  };
  output.stop = () => {
    clearTimeout(timeout);
  };
  return output;
}

// node_modules/@libp2p/utils/dist/src/private-ip.js
var import_netmask = __toESM(require_netmask());
var PRIVATE_IP_RANGES = [
  "0.0.0.0/8",
  "10.0.0.0/8",
  "100.64.0.0/10",
  "127.0.0.0/8",
  "169.254.0.0/16",
  "172.16.0.0/12",
  "192.0.0.0/24",
  "192.0.0.0/29",
  "192.0.0.8/32",
  "192.0.0.9/32",
  "192.0.0.10/32",
  "192.0.0.170/32",
  "192.0.0.171/32",
  "192.0.2.0/24",
  "192.31.196.0/24",
  "192.52.193.0/24",
  "192.88.99.0/24",
  "192.168.0.0/16",
  "192.175.48.0/24",
  "198.18.0.0/15",
  "198.51.100.0/24",
  "203.0.113.0/24",
  "240.0.0.0/4",
  "255.255.255.255/32"
];
var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask.Netmask(ipRange));
function ipv4Check(ipAddr) {
  for (const r of NETMASK_RANGES) {
    if (r.contains(ipAddr))
      return true;
  }
  return false;
}
function isIpv4MappedIpv6(ipAddr) {
  return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
}
function ipv4MappedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  if (parts.length < 2) {
    return false;
  }
  const octet34 = parts[parts.length - 1].padStart(4, "0");
  const octet12 = parts[parts.length - 2].padStart(4, "0");
  const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
  return ipv4Check(ip4);
}
function isIpv4EmbeddedIpv6(ipAddr) {
  return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
}
function ipv4EmbeddedIpv6Check(ipAddr) {
  const parts = ipAddr.split(":");
  const ip4 = parts[parts.length - 1];
  return ipv4Check(ip4);
}
function ipv6Check(ipAddr) {
  return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
}
function isPrivateIp(ip) {
  if (isIPv4(ip))
    return ipv4Check(ip);
  else if (isIpv4MappedIpv6(ip))
    return ipv4MappedIpv6Check(ip);
  else if (isIpv4EmbeddedIpv6(ip))
    return ipv4EmbeddedIpv6Check(ip);
  else if (isIPv6(ip))
    return ipv6Check(ip);
  else
    return void 0;
}

// node_modules/libp2p/dist/src/address-manager/dns-mappings.js
var MAX_DATE = 864e13;
var CODEC_TLS = 448;
var CODEC_SNI = 449;
var CODEC_DNS = 53;
var CODEC_DNS4 = 54;
var CODEC_DNS6 = 55;
var CODEC_DNSADDR = 56;
var DNSMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
    this.mappings = /* @__PURE__ */ new Map();
  }
  has(ma) {
    const host = this.findHost(ma);
    for (const mapping of this.mappings.values()) {
      if (mapping.domain === host) {
        return true;
      }
    }
    return false;
  }
  add(domain, addresses) {
    addresses.forEach((ip) => {
      this.log("add DNS mapping %s to %s", ip, domain);
      const verified = isPrivateIp(ip) === true;
      this.mappings.set(ip, {
        domain,
        verified,
        expires: verified ? MAX_DATE - Date.now() : 0,
        lastVerified: verified ? MAX_DATE - Date.now() : void 0
      });
    });
  }
  remove(ma) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
        this.mappings.delete(ip);
        wasConfident = wasConfident || mapping.verified;
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const dnsMappedAddresses = [];
    for (let i = 0; i < addresses.length; i++) {
      const address = addresses[i];
      const tuples = address.multiaddr.stringTuples();
      const host = tuples[0][1];
      if (host == null) {
        continue;
      }
      for (const [ip, mapping] of this.mappings.entries()) {
        if (host !== ip) {
          continue;
        }
        const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
        if (mappedIp) {
          addresses.splice(i, 1);
          i--;
          dnsMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple) => {
              return [
                getProtocol(tuple[0]).name,
                tuple[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "dns-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
    }
    return dnsMappedAddresses;
  }
  maybeAddSNITuple(tuples, domain) {
    var _a12;
    for (let j = 0; j < tuples.length; j++) {
      if (tuples[j][0] === CODEC_TLS && ((_a12 = tuples[j + 1]) == null ? void 0 : _a12[0]) !== CODEC_SNI) {
        tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
        return true;
      }
    }
    return false;
  }
  confirm(ma, ttl) {
    const host = this.findHost(ma);
    let startingConfidence = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
        startingConfidence = mapping.verified;
        mapping.verified = true;
        mapping.expires = Date.now() + ttl;
        mapping.lastVerified = Date.now();
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const host = this.findHost(ma);
    let wasConfident = false;
    for (const [ip, mapping] of this.mappings.entries()) {
      if (mapping.domain === host) {
        this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
        wasConfident = wasConfident || mapping.verified;
        mapping.verified = false;
        mapping.expires = Date.now() + ttl;
      }
    }
    return wasConfident;
  }
  findHost(ma) {
    for (const tuple of ma.stringTuples()) {
      if (tuple[0] === CODEC_SNI) {
        return tuple[1];
      }
      if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
        return tuple[1];
      }
    }
  }
};

// node_modules/libp2p/dist/src/address-manager/ip-mappings.js
var CODEC_IP4 = 4;
var CODEC_IP6 = 41;
var CODEC_TCP = 6;
var CODEC_UDP = 273;
var IPMappings = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "mappings");
    this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
    this.mappings = /* @__PURE__ */ new Map();
  }
  has(ma) {
    const tuples = ma.stringTuples();
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === tuples[0][1]) {
          return true;
        }
      }
    }
    return false;
  }
  add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    const key = `${internalIp}-${internalPort}-${protocol}`;
    const mappings = this.mappings.get(key) ?? [];
    const mapping = {
      internalIp,
      internalPort,
      externalIp,
      externalPort,
      externalFamily: isIPv4(externalIp) ? 4 : 6,
      protocol,
      verified: false,
      expires: 0
    };
    mappings.push(mapping);
    this.mappings.set(key, mappings);
  }
  remove(ma) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const [key, mappings] of this.mappings.entries()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mappings.splice(i, 1);
          i--;
        }
      }
      if (mappings.length === 0) {
        this.mappings.delete(key);
      }
    }
    return wasConfident;
  }
  getAll(addresses) {
    const ipMappedAddresses = [];
    for (const { multiaddr: ma } of addresses) {
      const tuples = ma.stringTuples();
      let tuple;
      if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
      } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
        tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
      }
      if (tuple == null) {
        continue;
      }
      const mappings = this.mappings.get(tuple);
      if (mappings == null) {
        continue;
      }
      for (const mapping of mappings) {
        tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
        tuples[0][1] = mapping.externalIp;
        tuples[1][1] = `${mapping.externalPort}`;
        ipMappedAddresses.push({
          multiaddr: multiaddr(`/${tuples.map((tuple2) => {
            return [
              getProtocol(tuple2[0]).name,
              tuple2[1]
            ].join("/");
          }).join("/")}`),
          verified: mapping.verified,
          type: "ip-mapping",
          expires: mapping.expires,
          lastVerified: mapping.lastVerified
        });
      }
    }
    return ipMappedAddresses;
  }
  confirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1];
    let startingConfidence = false;
    for (const mappings of this.mappings.values()) {
      for (const mapping of mappings) {
        if (mapping.externalIp === host) {
          this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
    }
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const tuples = ma.stringTuples();
    const host = tuples[0][1] ?? "";
    const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
    const port = parseInt(tuples[1][1] ?? "0");
    let wasConfident = false;
    for (const mappings of this.mappings.values()) {
      for (let i = 0; i < mappings.length; i++) {
        const mapping = mappings[i];
        if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
          this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
    }
    return wasConfident;
  }
};

// node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
var CODEC_IP42 = 4;
var CODEC_IP62 = 41;
function isLinkLocal(ma) {
  try {
    const [[codec, value]] = ma.stringTuples();
    if (value == null) {
      return false;
    }
    if (codec === CODEC_IP42) {
      return value.startsWith("169.254.");
    }
    if (codec === CODEC_IP62) {
      return value.toLowerCase().startsWith("fe80");
    }
  } catch {
  }
  return false;
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
var CODEC_IP43 = 4;
var CODEC_IP63 = 41;
var CODEC_DNS2 = 53;
var CODEC_DNS42 = 54;
var CODEC_DNS62 = 55;
var CODEC_DNSADDR2 = 56;
function isPrivate(ma) {
  try {
    const [[codec, value]] = ma.stringTuples();
    if (value == null) {
      return true;
    }
    if (codec === CODEC_DNS2 || codec === CODEC_DNS42 || codec === CODEC_DNS62 || codec === CODEC_DNSADDR2) {
      return false;
    }
    if (codec === CODEC_IP43 || codec === CODEC_IP63) {
      return isPrivateIp(value) ?? false;
    }
  } catch {
  }
  return true;
}

// node_modules/libp2p/dist/src/address-manager/observed-addresses.js
var defaultValues = {
  maxObservedAddresses: 10
};
var ObservedAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = /* @__PURE__ */ new Map();
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
  }
  has(ma) {
    return this.addresses.has(ma.toString());
  }
  removePrefixed(prefix) {
    for (const key of this.addresses.keys()) {
      if (key.toString().startsWith(prefix)) {
        this.addresses.delete(key);
      }
    }
  }
  add(ma) {
    if (this.addresses.size === this.maxObservedAddresses) {
      return;
    }
    if (isPrivate(ma) || isLinkLocal(ma)) {
      return;
    }
    this.log("adding observed address %a", ma);
    this.addresses.set(ma.toString(), {
      verified: false,
      expires: 0
    });
  }
  getAll() {
    return Array.from(this.addresses).map(([ma, metadata]) => ({
      multiaddr: multiaddr(ma),
      verified: metadata.verified,
      type: "observed",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    }));
  }
  remove(ma) {
    var _a12;
    const startingConfidence = ((_a12 = this.addresses.get(ma.toString())) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(ma.toString());
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const addrString = ma.toString();
    const metadata = this.addresses.get(addrString) ?? {
      verified: false,
      expires: Date.now() + ttl,
      lastVerified: Date.now()
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.lastVerified = Date.now();
    this.log("marking observed address %a as verified", addrString);
    this.addresses.set(addrString, metadata);
    return startingConfidence;
  }
};

// node_modules/libp2p/dist/src/address-manager/transport-addresses.js
var defaultValues2 = {
  maxObservedAddresses: 10
};
var TransportAddresses = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "addresses");
    __publicField(this, "maxObservedAddresses");
    this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
    this.addresses = /* @__PURE__ */ new Map();
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
  }
  get(multiaddr2, ttl) {
    if (isPrivate(multiaddr2)) {
      return {
        multiaddr: multiaddr2,
        verified: true,
        type: "transport",
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
    }
    const key = this.toKey(multiaddr2);
    let metadata = this.addresses.get(key);
    if (metadata == null) {
      metadata = {
        verified: false,
        expires: 0
      };
      this.addresses.set(key, metadata);
    }
    return {
      multiaddr: multiaddr2,
      verified: metadata.verified,
      type: "transport",
      expires: metadata.expires,
      lastVerified: metadata.lastVerified
    };
  }
  has(ma) {
    const key = this.toKey(ma);
    return this.addresses.has(key);
  }
  remove(ma) {
    var _a12;
    const key = this.toKey(ma);
    const startingConfidence = ((_a12 = this.addresses.get(key)) == null ? void 0 : _a12.verified) ?? false;
    this.log("removing observed address %a", ma);
    this.addresses.delete(key);
    return startingConfidence;
  }
  confirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0,
      lastVerified: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = true;
    metadata.expires = Date.now() + ttl;
    metadata.lastVerified = Date.now();
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  unconfirm(ma, ttl) {
    const key = this.toKey(ma);
    const metadata = this.addresses.get(key) ?? {
      verified: false,
      expires: 0
    };
    const startingConfidence = metadata.verified;
    metadata.verified = false;
    metadata.expires = Date.now() + ttl;
    this.addresses.set(key, metadata);
    return startingConfidence;
  }
  toKey(ma) {
    const options = ma.toOptions();
    return `${options.host}-${options.port}-${options.transport}`;
  }
};

// node_modules/libp2p/dist/src/address-manager/index.js
var ONE_MINUTE = 6e4;
var defaultValues3 = {
  maxObservedAddresses: 10,
  addressVerificationTTL: ONE_MINUTE * 10,
  addressVerificationRetry: ONE_MINUTE * 5
};
var defaultAddressFilter = (addrs) => addrs;
function stripPeerId(ma, peerId) {
  const observedPeerIdStr = ma.getPeerId();
  if (observedPeerIdStr != null) {
    const observedPeerId = peerIdFromString(observedPeerIdStr);
    if (observedPeerId.equals(peerId)) {
      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`));
    }
  }
  return ma;
}
var _a2;
var AddressManager = class {
  /**
   * Responsible for managing the peer addresses.
   * Peers can specify their listen and announce addresses.
   * The listen addresses will be used by the libp2p transports to listen for new connections,
   * while the announce addresses will be used for the peer addresses' to other peers in the network.
   */
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    __publicField(this, "listen");
    __publicField(this, "announce");
    __publicField(this, "appendAnnounce");
    __publicField(this, "announceFilter");
    __publicField(this, "observed");
    __publicField(this, "dnsMappings");
    __publicField(this, "ipMappings");
    __publicField(this, "transportAddresses");
    __publicField(this, "observedAddressFilter");
    __publicField(this, "addressVerificationTTL");
    __publicField(this, "addressVerificationRetry");
    __publicField(this, _a2, "@libp2p/address-manager");
    const { listen = [], announce = [], appendAnnounce = [] } = init;
    this.components = components;
    this.log = components.logger.forComponent("libp2p:address-manager");
    this.listen = listen.map((ma) => ma.toString());
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
    this.observed = new ObservedAddresses(components, init);
    this.dnsMappings = new DNSMappings(components, init);
    this.ipMappings = new IPMappings(components, init);
    this.transportAddresses = new TransportAddresses(components, init);
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
    this.observedAddressFilter = createScalableCuckooFilter(1024);
    this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues3.addressVerificationTTL;
    this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues3.addressVerificationRetry;
    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1e3);
    components.events.addEventListener("transport:listening", () => {
      this._updatePeerStoreAddresses();
    });
    components.events.addEventListener("transport:close", () => {
      this._updatePeerStoreAddresses();
    });
  }
  _updatePeerStoreAddresses() {
    const addrs = this.getAddresses().map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
      }
      return ma;
    });
    this.components.peerStore.patch(this.components.peerId, {
      multiaddrs: addrs
    }).catch((err) => {
      this.log.error("error updating addresses", err);
    });
  }
  /**
   * Get peer listen multiaddrs
   */
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  /**
   * Get peer announcing multiaddrs
   */
  getAppendAnnounceAddrs() {
    return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
  }
  /**
   * Get observed multiaddrs
   */
  getObservedAddrs() {
    return this.observed.getAll().map((addr) => addr.multiaddr);
  }
  /**
   * Add peer observed addresses
   */
  addObservedAddr(addr) {
    const tuples = addr.stringTuples();
    const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
    if (this.observedAddressFilter.has(socketAddress)) {
      return;
    }
    this.observedAddressFilter.add(socketAddress);
    addr = stripPeerId(addr, this.components.peerId);
    if (this.ipMappings.has(addr)) {
      return;
    }
    if (this.dnsMappings.has(addr)) {
      return;
    }
    this.observed.add(addr);
  }
  confirmObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = true;
    if ((options == null ? void 0 : options.type) === "observed" || this.observed.has(addr)) {
      startingConfidence = this.observed.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
    }
    if ((options == null ? void 0 : options.type) === "transport" || this.transportAddresses.has(addr)) {
      startingConfidence = this.transportAddresses.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
    }
    if ((options == null ? void 0 : options.type) === "dns-mapping" || this.dnsMappings.has(addr)) {
      startingConfidence = this.dnsMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
    }
    if ((options == null ? void 0 : options.type) === "ip-mapping" || this.ipMappings.has(addr)) {
      startingConfidence = this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
    }
    if (!startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  removeObservedAddr(addr, options) {
    addr = stripPeerId(addr, this.components.peerId);
    let startingConfidence = false;
    if (this.observed.has(addr)) {
      startingConfidence = this.observed.remove(addr);
    }
    if (this.transportAddresses.has(addr)) {
      startingConfidence = this.transportAddresses.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
    }
    if (this.dnsMappings.has(addr)) {
      startingConfidence = this.dnsMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
    }
    if (this.ipMappings.has(addr)) {
      startingConfidence = this.ipMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
    }
    if (startingConfidence) {
      this._updatePeerStoreAddresses();
    }
  }
  getAddresses() {
    const addresses = /* @__PURE__ */ new Set();
    const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
      if (!addr.verified) {
        return false;
      }
      const maStr = addr.multiaddr.toString();
      if (addresses.has(maStr)) {
        return false;
      }
      addresses.add(maStr);
      return true;
    }).map((address) => address.multiaddr);
    return this.announceFilter(multiaddrs.map((str) => {
      var _a12;
      const ma = multiaddr(str);
      if (((_a12 = ma.protos().pop()) == null ? void 0 : _a12.path) === true) {
        return ma;
      }
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    }));
  }
  getAddressesWithMetadata() {
    const announceMultiaddrs = this.getAnnounceAddrs();
    if (announceMultiaddrs.length > 0) {
      return announceMultiaddrs.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        verified: true,
        type: "announce",
        expires: Date.now() + this.addressVerificationTTL,
        lastVerified: Date.now()
      }));
    }
    let addresses = [];
    addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
    addresses = addresses.concat(this.getAppendAnnounceAddrs().map((multiaddr2) => ({
      multiaddr: multiaddr2,
      verified: true,
      type: "announce",
      expires: Date.now() + this.addressVerificationTTL,
      lastVerified: Date.now()
    })));
    addresses = addresses.concat(this.observed.getAll());
    addresses = addresses.concat(this.ipMappings.getAll(addresses));
    addresses = addresses.concat(this.dnsMappings.getAll(addresses));
    return addresses;
  }
  addDNSMapping(domain, addresses) {
    this.dnsMappings.add(domain, addresses);
  }
  removeDNSMapping(domain) {
    if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
      this._updatePeerStoreAddresses();
    }
  }
  addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
    this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
  }
  removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
    if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
      this._updatePeerStoreAddresses();
    }
  }
};
_a2 = Symbol.toStringTag;

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var MissingServiceError = class extends Error {
  constructor(message2 = "Missing service") {
    super(message2);
    this.name = "MissingServiceError";
  }
};
var UnmetServiceDependenciesError = class extends Error {
  constructor(message2 = "Unmet service dependencies") {
    super(message2);
    this.name = "UnmetServiceDependenciesError";
  }
};
var NoContentRoutersError = class extends Error {
  constructor(message2 = "No content routers available") {
    super(message2);
    this.name = "NoContentRoutersError";
  }
};
var NoPeerRoutersError = class extends Error {
  constructor(message2 = "No peer routers available") {
    super(message2);
    this.name = "NoPeerRoutersError";
  }
};
var QueriedForSelfError = class extends Error {
  constructor(message2 = "Should not try to find self") {
    super(message2);
    this.name = "QueriedForSelfError";
  }
};
var UnhandledProtocolError = class extends Error {
  constructor(message2 = "Unhandled protocol error") {
    super(message2);
    this.name = "UnhandledProtocolError";
  }
};
var DuplicateProtocolHandlerError = class extends Error {
  constructor(message2 = "Duplicate protocol handler error") {
    super(message2);
    this.name = "DuplicateProtocolHandlerError";
  }
};
var DialDeniedError = class extends Error {
  constructor(message2 = "Dial denied error") {
    super(message2);
    this.name = "DialDeniedError";
  }
};
var NoValidAddressesError = class extends Error {
  constructor(message2 = "No valid addresses") {
    super(message2);
    this.name = "NoValidAddressesError";
  }
};
var ConnectionInterceptedError = class extends Error {
  constructor(message2 = "Connection intercepted") {
    super(message2);
    this.name = "ConnectionInterceptedError";
  }
};
var ConnectionDeniedError = class extends Error {
  constructor(message2 = "Connection denied") {
    super(message2);
    this.name = "ConnectionDeniedError";
  }
};
var MuxerUnavailableError = class extends Error {
  constructor(message2 = "Stream is not multiplexed") {
    super(message2);
    this.name = "MuxerUnavailableError";
  }
};
var EncryptionFailedError = class extends Error {
  constructor(message2 = "Encryption failed") {
    super(message2);
    this.name = "EncryptionFailedError";
  }
};
var TransportUnavailableError = class extends Error {
  constructor(message2 = "Transport unavailable") {
    super(message2);
    this.name = "TransportUnavailableError";
  }
};

// node_modules/libp2p/dist/src/components.js
var DefaultComponents = class {
  constructor(init = {}) {
    __publicField(this, "components", {});
    __publicField(this, "_started", false);
    this.components = {};
    for (const [key, value] of Object.entries(init)) {
      this.components[key] = value;
    }
    if (this.components.logger == null) {
      this.components.logger = defaultLogger();
    }
  }
  isStarted() {
    return this._started;
  }
  async _invokeStartableMethod(methodName) {
    await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
      var _a12;
      await ((_a12 = startable[methodName]) == null ? void 0 : _a12.call(startable));
    }));
  }
  async beforeStart() {
    await this._invokeStartableMethod("beforeStart");
  }
  async start() {
    await this._invokeStartableMethod("start");
    this._started = true;
  }
  async afterStart() {
    await this._invokeStartableMethod("afterStart");
  }
  async beforeStop() {
    await this._invokeStartableMethod("beforeStop");
  }
  async stop() {
    await this._invokeStartableMethod("stop");
    this._started = false;
  }
  async afterStop() {
    await this._invokeStartableMethod("afterStop");
  }
};
var OPTIONAL_SERVICES = [
  "metrics",
  "connectionProtector",
  "dns"
];
var NON_SERVICE_PROPERTIES = [
  "components",
  "isStarted",
  "beforeStart",
  "start",
  "afterStart",
  "beforeStop",
  "stop",
  "afterStop",
  "then",
  "_invokeStartableMethod"
];
function defaultComponents(init = {}) {
  const components = new DefaultComponents(init);
  const proxy = new Proxy(components, {
    get(target, prop, receiver) {
      if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
        const service = components.components[prop];
        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
          throw new MissingServiceError(`${prop} not set`);
        }
        return service;
      }
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value) {
      if (typeof prop === "string") {
        components.components[prop] = value;
      } else {
        Reflect.set(target, prop, value);
      }
      return true;
    }
  });
  return proxy;
}
function checkServiceDependencies(components) {
  const serviceCapabilities2 = {};
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceCapabilities(service)) {
      serviceCapabilities2[capability] = true;
    }
  }
  for (const service of Object.values(components.components)) {
    for (const capability of getServiceDependencies(service)) {
      if (serviceCapabilities2[capability] !== true) {
        throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
      }
    }
  }
}
function getServiceCapabilities(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceCapabilities])) {
    return service[serviceCapabilities];
  }
  return [];
}
function getServiceDependencies(service) {
  if (Array.isArray(service == null ? void 0 : service[serviceDependencies])) {
    return service[serviceDependencies];
  }
  return [];
}
function getServiceName(service) {
  return (service == null ? void 0 : service[Symbol.toStringTag]) ?? (service == null ? void 0 : service.toString()) ?? "unknown";
}

// node_modules/libp2p/dist/src/config/connection-gater.browser.js
var CODEC_IP44 = 4;
var CODEC_IP64 = 41;
function connectionGater(gater = {}) {
  return {
    denyDialPeer: async () => false,
    denyDialMultiaddr: async (multiaddr2) => {
      if (WebSockets.matches(multiaddr2)) {
        return false;
      }
      const tuples = multiaddr2.stringTuples();
      if (tuples[0][0] === CODEC_IP44 || tuples[0][0] === CODEC_IP64) {
        return Boolean(isPrivateIp(`${tuples[0][1]}`));
      }
      return false;
    },
    denyInboundConnection: async () => false,
    denyOutboundConnection: async () => false,
    denyInboundEncryptedConnection: async () => false,
    denyOutboundEncryptedConnection: async () => false,
    denyInboundUpgradedConnection: async () => false,
    denyOutboundUpgradedConnection: async () => false,
    filterMultiaddrForPeer: async () => true,
    ...gater
  };
}

// node_modules/delay/index.js
var createAbortError = () => {
  const error = new Error("Delay aborted");
  error.name = "AbortError";
  return error;
};
var clearMethods = /* @__PURE__ */ new WeakMap();
function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
  return (milliseconds, { value, signal } = {}) => {
    if (signal == null ? void 0 : signal.aborted) {
      return Promise.reject(createAbortError());
    }
    let timeoutId;
    let settle;
    let rejectFunction;
    const clear = defaultClear ?? clearTimeout;
    const signalListener = () => {
      clear(timeoutId);
      rejectFunction(createAbortError());
    };
    const cleanup = () => {
      if (signal) {
        signal.removeEventListener("abort", signalListener);
      }
    };
    const delayPromise = new Promise((resolve, reject) => {
      settle = () => {
        cleanup();
        resolve(value);
      };
      rejectFunction = reject;
      timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
    });
    if (signal) {
      signal.addEventListener("abort", signalListener, { once: true });
    }
    clearMethods.set(delayPromise, () => {
      clear(timeoutId);
      timeoutId = null;
      settle();
    });
    return delayPromise;
  };
}
var delay = createDelay();
var delay_default = delay;

// node_modules/@libp2p/utils/dist/src/errors.js
var RateLimitError = class extends Error {
  constructor(message2 = "Rate limit exceeded", props) {
    super(message2);
    __publicField(this, "remainingPoints");
    __publicField(this, "msBeforeNext");
    __publicField(this, "consumedPoints");
    __publicField(this, "isFirstInDuration");
    this.name = "RateLimitError";
    this.remainingPoints = props.remainingPoints;
    this.msBeforeNext = props.msBeforeNext;
    this.consumedPoints = props.consumedPoints;
    this.isFirstInDuration = props.isFirstInDuration;
  }
};
var QueueFullError = class extends Error {
  constructor(message2 = "The queue was full") {
    super(message2);
    this.name = "QueueFullError";
  }
};
__publicField(QueueFullError, "name", "QueueFullError");

// node_modules/@libp2p/utils/dist/src/rate-limiter.js
var RateLimiter = class {
  constructor(opts = {}) {
    __publicField(this, "memoryStorage");
    __publicField(this, "points");
    __publicField(this, "duration");
    __publicField(this, "blockDuration");
    __publicField(this, "execEvenly");
    __publicField(this, "execEvenlyMinDelayMs");
    __publicField(this, "keyPrefix");
    this.points = opts.points ?? 4;
    this.duration = opts.duration ?? 1;
    this.blockDuration = opts.blockDuration ?? 0;
    this.execEvenly = opts.execEvenly ?? false;
    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
    this.keyPrefix = opts.keyPrefix ?? "rlflx";
    this.memoryStorage = new MemoryStorage();
  }
  async consume(key, pointsToConsume = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    if (res.consumedPoints > this.points) {
      if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
      }
      throw new RateLimitError("Rate limit exceeded", res);
    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
      if (delayMs < this.execEvenlyMinDelayMs) {
        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
      }
      await delay_default(delayMs);
    }
    return res;
  }
  penalty(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  reward(key, points = 1, options = {}) {
    const rlKey = this.getKey(key);
    const secDuration = this._getKeySecDuration(options);
    const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    return res;
  }
  /**
   * Block any key for secDuration seconds
   *
   * @param key
   * @param secDuration
   */
  block(key, secDuration) {
    const msDuration = secDuration * 1e3;
    const initPoints = this.points + 1;
    this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: initPoints,
      isFirstInDuration: false
    };
  }
  set(key, points, secDuration = 0) {
    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
    this.memoryStorage.set(this.getKey(key), points, secDuration);
    return {
      remainingPoints: 0,
      msBeforeNext: msDuration === 0 ? -1 : msDuration,
      consumedPoints: points,
      isFirstInDuration: false
    };
  }
  get(key) {
    const res = this.memoryStorage.get(this.getKey(key));
    if (res != null) {
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
    }
    return res;
  }
  delete(key) {
    this.memoryStorage.delete(this.getKey(key));
  }
  _getKeySecDuration(options) {
    if ((options == null ? void 0 : options.customDuration) != null && options.customDuration >= 0) {
      return options.customDuration;
    }
    return this.duration;
  }
  getKey(key) {
    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
  }
  parseKey(rlKey) {
    return rlKey.substring(this.keyPrefix.length);
  }
};
var MemoryStorage = class {
  constructor() {
    __publicField(this, "storage");
    this.storage = /* @__PURE__ */ new Map();
  }
  incrby(key, value, durationSec) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      if (existing.expiresAt == null || msBeforeExpires > 0) {
        existing.value += value;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
      return this.set(key, value, durationSec);
    }
    return this.set(key, value, durationSec);
  }
  set(key, value, durationSec) {
    const durationMs = durationSec * 1e3;
    const existing = this.storage.get(key);
    if (existing != null) {
      clearTimeout(existing.timeoutId);
    }
    const record = {
      value,
      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
    };
    this.storage.set(key, record);
    if (durationMs > 0) {
      record.timeoutId = setTimeout(() => {
        this.storage.delete(key);
      }, durationMs);
      if (record.timeoutId.unref != null) {
        record.timeoutId.unref();
      }
    }
    return {
      remainingPoints: 0,
      msBeforeNext: durationMs === 0 ? -1 : durationMs,
      consumedPoints: record.value,
      isFirstInDuration: true
    };
  }
  get(key) {
    const existing = this.storage.get(key);
    if (existing != null) {
      const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
      return {
        remainingPoints: 0,
        msBeforeNext: msBeforeExpires,
        consumedPoints: existing.value,
        isFirstInDuration: false
      };
    }
  }
  delete(key) {
    const record = this.storage.get(key);
    if (record != null) {
      if (record.timeoutId != null) {
        clearTimeout(record.timeoutId);
      }
      this.storage.delete(key);
      return true;
    }
    return false;
  }
};

// node_modules/libp2p/dist/src/get-peer.js
function getPeerAddress(peer) {
  if (isPeerId(peer)) {
    return { peerId: peer, multiaddrs: [] };
  }
  if (!Array.isArray(peer)) {
    peer = [peer];
  }
  let peerId;
  if (peer.length > 0) {
    const peerIdStr = peer[0].getPeerId();
    peerId = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
    peer.forEach((ma) => {
      if (!isMultiaddr(ma)) {
        throw new InvalidMultiaddrError("Invalid multiaddr");
      }
      const maPeerIdStr = ma.getPeerId();
      if (maPeerIdStr == null) {
        if (peerId != null) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      } else {
        const maPeerId = peerIdFromString(maPeerIdStr);
        if ((peerId == null ? void 0 : peerId.equals(maPeerId)) !== true) {
          throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
        }
      }
    });
  }
  return {
    peerId,
    multiaddrs: peer
  };
}

// node_modules/@libp2p/utils/dist/src/close.js
var DEFAULT_CLOSABLE_PROTOCOLS = [
  // identify
  "/ipfs/id/1.0.0",
  // identify-push
  "/ipfs/id/push/1.0.0",
  // autonat
  "/libp2p/autonat/1.0.0",
  // dcutr
  "/libp2p/dcutr"
];
async function safelyCloseConnectionIfUnused(connection, options) {
  var _a12;
  const streamProtocols = ((_a12 = connection == null ? void 0 : connection.streams) == null ? void 0 : _a12.map((stream) => stream.protocol)) ?? [];
  const closableProtocols = (options == null ? void 0 : options.closableProtocols) ?? DEFAULT_CLOSABLE_PROTOCOLS;
  if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
    return;
  }
  try {
    await (connection == null ? void 0 : connection.close(options));
  } catch (err) {
    connection == null ? void 0 : connection.abort(err);
  }
}

// node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
var DIAL_TIMEOUT = 5e3;
var UPGRADE_TIMEOUT = 3e3;
var PROTOCOL_NEGOTIATION_TIMEOUT = 2e3;
var MAX_PEER_ADDRS_TO_DIAL = 25;
var INBOUND_CONNECTION_THRESHOLD = 5;
var MAX_INCOMING_PENDING_CONNECTIONS = 10;
var MAX_PARALLEL_RECONNECTS = 5;
var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
var MAX_DIAL_QUEUE_LENGTH = 500;

// node_modules/libp2p/dist/src/connection-manager/constants.browser.js
var MAX_CONNECTIONS = 100;
var MAX_PARALLEL_DIALS = 50;

// node_modules/libp2p/dist/src/connection-manager/utils.js
async function resolveMultiaddrs(ma, options) {
  let resolvable = false;
  for (const key of resolvers.keys()) {
    resolvable = ma.protoNames().includes(key);
    if (resolvable) {
      break;
    }
  }
  if (!resolvable) {
    return [ma];
  }
  const output = await ma.resolve(options);
  options.log("resolved %s to", ma, output.map((ma2) => ma2.toString()));
  return output;
}
function multiaddrToIpNet(ma) {
  try {
    let parsedMa;
    if (typeof ma === "string") {
      parsedMa = multiaddr(ma);
    } else {
      parsedMa = ma;
    }
    if (!parsedMa.protoNames().includes("ipcidr")) {
      const isIPv62 = parsedMa.protoNames().includes("ip6");
      const cidr = isIPv62 ? "/ipcidr/128" : "/ipcidr/32";
      parsedMa = parsedMa.encapsulate(cidr);
    }
    return convertToIpNet(parsedMa);
  } catch (error) {
    throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
  }
}

// node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
var defaultOptions3 = {
  maxConnections: MAX_CONNECTIONS,
  allow: []
};
var ConnectionPruner = class {
  constructor(components, init = {}) {
    __publicField(this, "maxConnections");
    __publicField(this, "connectionManager");
    __publicField(this, "peerStore");
    __publicField(this, "allow");
    __publicField(this, "events");
    __publicField(this, "log");
    this.maxConnections = init.maxConnections ?? defaultOptions3.maxConnections;
    this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
    this.connectionManager = components.connectionManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
    this.maybePruneConnections = this.maybePruneConnections.bind(this);
  }
  start() {
    this.events.addEventListener("connection:open", this.maybePruneConnections);
  }
  stop() {
    this.events.removeEventListener("connection:open", this.maybePruneConnections);
  }
  maybePruneConnections() {
    this._maybePruneConnections().catch((err) => {
      this.log.error("error while pruning connections %e", err);
    });
  }
  /**
   * If we have more connections than our maximum, select some excess connections
   * to prune based on peer value
   */
  async _maybePruneConnections() {
    const connections = this.connectionManager.getConnections();
    const numConnections = connections.length;
    this.log("checking max connections limit %d/%d", numConnections, this.maxConnections);
    if (numConnections <= this.maxConnections) {
      return;
    }
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      peerValues.set(remotePeer, 0);
      try {
        const peer = await this.peerStore.get(remotePeer);
        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
          return acc + curr.value;
        }, 0));
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("error loading peer tags", err);
        }
      }
    }
    const sortedConnections = this.sortConnections(connections, peerValues);
    const toPrune = Math.max(numConnections - this.maxConnections, 0);
    const toClose = [];
    for (const connection of sortedConnections) {
      this.log("too many connections open - closing a connection to %p", connection.remotePeer);
      const connectionInAllowList = this.allow.some((ipNet) => {
        return ipNet.contains(connection.remoteAddr.nodeAddress().address);
      });
      if (!connectionInAllowList) {
        toClose.push(connection);
      }
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      await safelyCloseConnectionIfUnused(connection, {
        signal: AbortSignal.timeout(1e3)
      });
    }));
    this.events.safeDispatchEvent("connection:prune", { detail: toClose });
  }
  sortConnections(connections, peerValues) {
    return connections.sort((a, b) => {
      const connectionALifespan = a.timeline.open;
      const connectionBLifespan = b.timeline.open;
      if (connectionALifespan < connectionBLifespan) {
        return 1;
      }
      if (connectionALifespan > connectionBLifespan) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.direction === "outbound" && b.direction === "inbound") {
        return 1;
      }
      if (a.direction === "inbound" && b.direction === "outbound") {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      if (a.streams.length > b.streams.length) {
        return 1;
      }
      if (a.streams.length < b.streams.length) {
        return -1;
      }
      return 0;
    }).sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
  }
};

// node_modules/race-event/dist/src/index.js
var AbortError2 = class extends Error {
  constructor(message2, code) {
    super(message2 ?? "The operation was aborted");
    __publicField(this, "type");
    __publicField(this, "code");
    this.type = "aborted";
    this.name = "AbortError";
    this.code = code ?? "ABORT_ERR";
  }
};
async function raceEvent(emitter, eventName, signal, opts) {
  const error = new AbortError2(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode);
  if ((signal == null ? void 0 : signal.aborted) === true) {
    return Promise.reject(error);
  }
  return new Promise((resolve, reject) => {
    function removeListeners() {
      signal == null ? void 0 : signal.removeEventListener("abort", abortListener);
      emitter.removeEventListener(eventName, eventListener);
      if ((opts == null ? void 0 : opts.errorEvent) != null) {
        emitter.removeEventListener(opts.errorEvent, errorEventListener);
      }
    }
    const eventListener = (evt) => {
      var _a12;
      try {
        if (((_a12 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a12.call(opts, evt)) === false) {
          return;
        }
      } catch (err) {
        removeListeners();
        reject(err);
        return;
      }
      removeListeners();
      resolve(evt);
    };
    const errorEventListener = (evt) => {
      removeListeners();
      reject(evt.detail);
    };
    const abortListener = () => {
      removeListeners();
      reject(error);
    };
    signal == null ? void 0 : signal.addEventListener("abort", abortListener);
    emitter.addEventListener(eventName, eventListener);
    if ((opts == null ? void 0 : opts.errorEvent) != null) {
      emitter.addEventListener(opts.errorEvent, errorEventListener);
    }
  });
}

// node_modules/@libp2p/utils/dist/src/queue/recipient.js
var JobRecipient = class {
  constructor(signal) {
    __publicField(this, "deferred");
    __publicField(this, "signal");
    var _a12;
    this.signal = signal;
    this.deferred = pDefer();
    this.onAbort = this.onAbort.bind(this);
    (_a12 = this.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
  }
  onAbort() {
    var _a12;
    this.deferred.reject(((_a12 = this.signal) == null ? void 0 : _a12.reason) ?? new AbortError());
  }
  cleanup() {
    var _a12;
    (_a12 = this.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
  }
};

// node_modules/@libp2p/utils/dist/src/queue/job.js
function randomId() {
  return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
}
var Job = class {
  constructor(fn, options) {
    __publicField(this, "id");
    __publicField(this, "fn");
    __publicField(this, "options");
    __publicField(this, "recipients");
    __publicField(this, "status");
    __publicField(this, "timeline");
    __publicField(this, "controller");
    this.id = randomId();
    this.status = "queued";
    this.fn = fn;
    this.options = options;
    this.recipients = [];
    this.timeline = {
      created: Date.now()
    };
    this.controller = new AbortController();
    setMaxListeners(Infinity, this.controller.signal);
    this.onAbort = this.onAbort.bind(this);
  }
  abort(err) {
    this.controller.abort(err);
  }
  onAbort() {
    const allAborted = this.recipients.reduce((acc, curr) => {
      var _a12;
      return acc && ((_a12 = curr.signal) == null ? void 0 : _a12.aborted) === true;
    }, true);
    if (allAborted) {
      this.controller.abort(new AbortError());
      this.cleanup();
    }
  }
  async join(options = {}) {
    var _a12;
    const recipient = new JobRecipient(options.signal);
    this.recipients.push(recipient);
    (_a12 = options.signal) == null ? void 0 : _a12.addEventListener("abort", this.onAbort);
    return recipient.deferred.promise;
  }
  async run() {
    this.status = "running";
    this.timeline.started = Date.now();
    try {
      this.controller.signal.throwIfAborted();
      const result = await raceSignal(this.fn({
        ...this.options ?? {},
        signal: this.controller.signal
      }), this.controller.signal);
      this.recipients.forEach((recipient) => {
        recipient.deferred.resolve(result);
      });
      this.status = "complete";
    } catch (err) {
      this.recipients.forEach((recipient) => {
        recipient.deferred.reject(err);
      });
      this.status = "errored";
    } finally {
      this.timeline.finished = Date.now();
      this.cleanup();
    }
  }
  cleanup() {
    this.recipients.forEach((recipient) => {
      var _a12;
      recipient.cleanup();
      (_a12 = recipient.signal) == null ? void 0 : _a12.removeEventListener("abort", this.onAbort);
    });
  }
};

// node_modules/@libp2p/utils/dist/src/queue/index.js
var Queue = class extends TypedEventEmitter {
  constructor(init = {}) {
    var _a12;
    super();
    __publicField(this, "concurrency");
    __publicField(this, "maxSize");
    __publicField(this, "queue");
    __publicField(this, "pending");
    __publicField(this, "sort");
    this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
    this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
    this.pending = 0;
    if (init.metricName != null) {
      (_a12 = init.metrics) == null ? void 0 : _a12.registerMetricGroup(init.metricName, {
        calculate: () => {
          return {
            size: this.queue.length,
            running: this.pending,
            queued: this.queue.length - this.pending
          };
        }
      });
    }
    this.sort = init.sort;
    this.queue = [];
  }
  tryToStartAnother() {
    if (this.size === 0) {
      queueMicrotask(() => {
        this.safeDispatchEvent("empty");
      });
      if (this.running === 0) {
        queueMicrotask(() => {
          this.safeDispatchEvent("idle");
        });
      }
      return false;
    }
    if (this.pending < this.concurrency) {
      let job;
      for (const j of this.queue) {
        if (j.status === "queued") {
          job = j;
          break;
        }
      }
      if (job == null) {
        return false;
      }
      this.safeDispatchEvent("active");
      this.pending++;
      void job.run().finally(() => {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
        this.pending--;
        this.tryToStartAnother();
        this.safeDispatchEvent("next");
      });
      return true;
    }
    return false;
  }
  enqueue(job) {
    this.queue.push(job);
    if (this.sort != null) {
      this.queue.sort(this.sort);
    }
  }
  /**
   * Adds a sync or async task to the queue. Always returns a promise.
   */
  async add(fn, options) {
    var _a12;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    if (this.size === this.maxSize) {
      throw new QueueFullError();
    }
    const job = new Job(fn, options);
    this.enqueue(job);
    this.safeDispatchEvent("add");
    this.tryToStartAnother();
    return job.join(options).then((result) => {
      this.safeDispatchEvent("completed", { detail: result });
      this.safeDispatchEvent("success", { detail: { job, result } });
      return result;
    }).catch((err) => {
      if (job.status === "queued") {
        for (let i = 0; i < this.queue.length; i++) {
          if (this.queue[i] === job) {
            this.queue.splice(i, 1);
            break;
          }
        }
      }
      this.safeDispatchEvent("error", { detail: err });
      this.safeDispatchEvent("failure", { detail: { job, error: err } });
      throw err;
    });
  }
  /**
   * Clear the queue
   */
  clear() {
    this.queue.splice(0, this.queue.length);
  }
  /**
   * Abort all jobs in the queue and clear it
   */
  abort() {
    this.queue.forEach((job) => {
      job.abort(new AbortError());
    });
    this.clear();
  }
  /**
   * Can be called multiple times. Useful if you for example add additional items at a later time.
   *
   * @returns A promise that settles when the queue becomes empty.
   */
  async onEmpty(options) {
    if (this.size === 0) {
      return;
    }
    await raceEvent(this, "empty", options == null ? void 0 : options.signal);
  }
  /**
   * @returns A promise that settles when the queue size is less than the given
   * limit: `queue.size < limit`.
   *
   * If you want to avoid having the queue grow beyond a certain size you can
   * `await queue.onSizeLessThan()` before adding a new item.
   *
   * Note that this only limits the number of items waiting to start. There
   * could still be up to `concurrency` jobs already running that this call does
   * not include in its calculation.
   */
  async onSizeLessThan(limit, options) {
    if (this.size < limit) {
      return;
    }
    await raceEvent(this, "next", options == null ? void 0 : options.signal, {
      filter: () => this.size < limit
    });
  }
  /**
   * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
   * from the queue has finished. `.onEmpty` merely signals that the queue is
   * empty, but it could mean that some promises haven't completed yet.
   *
   * @returns A promise that settles when the queue becomes empty, and all
   * promises have completed; `queue.size === 0 && queue.pending === 0`.
   */
  async onIdle(options) {
    if (this.pending === 0 && this.size === 0) {
      return;
    }
    await raceEvent(this, "idle", options == null ? void 0 : options.signal);
  }
  /**
   * Size of the queue including running items
   */
  get size() {
    return this.queue.length;
  }
  /**
   * The number of queued items waiting to run.
   */
  get queued() {
    return this.queue.length - this.pending;
  }
  /**
   * The number of items currently running.
   */
  get running() {
    return this.pending;
  }
  /**
   * Returns an async generator that makes it easy to iterate over the results
   * of jobs added to the queue.
   *
   * The generator will end when the queue becomes idle, that is there are no
   * jobs running and no jobs that have yet to run.
   *
   * If you need to keep the queue open indefinitely, consider using it-pushable
   * instead.
   */
  async *toGenerator(options) {
    var _a12, _b3, _c;
    (_a12 = options == null ? void 0 : options.signal) == null ? void 0 : _a12.throwIfAborted();
    const stream = pushable({
      objectMode: true
    });
    const cleanup = (err) => {
      if (err != null) {
        this.abort();
      } else {
        this.clear();
      }
      stream.end(err);
    };
    const onQueueJobComplete = (evt) => {
      if (evt.detail != null) {
        stream.push(evt.detail);
      }
    };
    const onQueueError = (evt) => {
      cleanup(evt.detail);
    };
    const onQueueIdle = () => {
      cleanup();
    };
    const onSignalAbort = () => {
      cleanup(new AbortError("Queue aborted"));
    };
    this.addEventListener("completed", onQueueJobComplete);
    this.addEventListener("error", onQueueError);
    this.addEventListener("idle", onQueueIdle);
    (_b3 = options == null ? void 0 : options.signal) == null ? void 0 : _b3.addEventListener("abort", onSignalAbort);
    try {
      yield* stream;
    } finally {
      this.removeEventListener("completed", onQueueJobComplete);
      this.removeEventListener("error", onQueueError);
      this.removeEventListener("idle", onQueueIdle);
      (_c = options == null ? void 0 : options.signal) == null ? void 0 : _c.removeEventListener("abort", onSignalAbort);
      cleanup();
    }
  }
};

// node_modules/@libp2p/utils/dist/src/priority-queue.js
var PriorityQueue = class extends Queue {
  constructor(init = {}) {
    super({
      ...init,
      sort: (a, b) => {
        if (a.options.priority > b.options.priority) {
          return -1;
        }
        if (a.options.priority < b.options.priority) {
          return 1;
        }
        return 0;
      }
    });
  }
};

// node_modules/any-signal/dist/src/index.js
function anySignal(signals) {
  const controller = new globalThis.AbortController();
  function onAbort() {
    controller.abort();
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  for (const signal2 of signals) {
    if ((signal2 == null ? void 0 : signal2.aborted) === true) {
      onAbort();
      break;
    }
    if ((signal2 == null ? void 0 : signal2.addEventListener) != null) {
      signal2.addEventListener("abort", onAbort);
    }
  }
  function clear() {
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
        signal2.removeEventListener("abort", onAbort);
      }
    }
  }
  const signal = controller.signal;
  signal.clear = clear;
  return signal;
}

// node_modules/libp2p/dist/src/connection-manager/address-sorter.js
function reliableTransportsFirst(a, b) {
  const isATCP = TCP.exactMatch(a.multiaddr);
  const isBTCP = TCP.exactMatch(b.multiaddr);
  if (isATCP && !isBTCP) {
    return -1;
  }
  if (!isATCP && isBTCP) {
    return 1;
  }
  const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr);
  const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
  if (isAWebSocketSecure && !isBWebSocketSecure) {
    return -1;
  }
  if (!isAWebSocketSecure && isBWebSocketSecure) {
    return 1;
  }
  const isAWebSocket = WebSockets.exactMatch(a.multiaddr);
  const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
  if (isAWebSocket && !isBWebSocket) {
    return -1;
  }
  if (!isAWebSocket && isBWebSocket) {
    return 1;
  }
  const isAWebRTC = WebRTC.exactMatch(a.multiaddr);
  const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
  if (isAWebRTC && !isBWebRTC) {
    return -1;
  }
  if (!isAWebRTC && isBWebRTC) {
    return 1;
  }
  const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr);
  const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
  if (isAWebRTCDirect && !isBWebRTCDirect) {
    return -1;
  }
  if (!isAWebRTCDirect && isBWebRTCDirect) {
    return 1;
  }
  const isAWebTransport = WebTransport.exactMatch(a.multiaddr);
  const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
  if (isAWebTransport && !isBWebTransport) {
    return -1;
  }
  if (!isAWebTransport && isBWebTransport) {
    return 1;
  }
  return 0;
}
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  return 0;
}
function certifiedAddressesFirst(a, b) {
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}
function circuitRelayAddressesLast(a, b) {
  const isACircuit = Circuit.exactMatch(a.multiaddr);
  const isBCircuit = Circuit.exactMatch(b.multiaddr);
  if (isACircuit && !isBCircuit) {
    return 1;
  } else if (!isACircuit && isBCircuit) {
    return -1;
  }
  return 0;
}
function defaultAddressSorter(addresses) {
  return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst);
}

// node_modules/libp2p/dist/src/connection-manager/dial-queue.js
var defaultOptions4 = {
  maxParallelDials: MAX_PARALLEL_DIALS,
  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
  dialTimeout: DIAL_TIMEOUT,
  resolvers: {
    dnsaddr: dnsaddrResolver
  }
};
var DialQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "queue");
    __publicField(this, "components");
    __publicField(this, "addressSorter");
    __publicField(this, "maxPeerAddrsToDial");
    __publicField(this, "maxDialQueueLength");
    __publicField(this, "dialTimeout");
    __publicField(this, "shutDownController");
    __publicField(this, "connections");
    __publicField(this, "log");
    this.addressSorter = init.addressSorter;
    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions4.maxPeerAddrsToDial;
    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions4.maxDialQueueLength;
    this.dialTimeout = init.dialTimeout ?? defaultOptions4.dialTimeout;
    this.connections = init.connections ?? new PeerMap();
    this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
    this.components = components;
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
    this.queue = new PriorityQueue({
      concurrency: init.maxParallelDials ?? defaultOptions4.maxParallelDials,
      metricName: "libp2p_dial_queue",
      metrics: components.metrics
    });
    this.queue.addEventListener("error", (event) => {
      if (event.detail.name !== AbortError.name) {
        this.log.error("error in dial queue - %e", event.detail);
      }
    });
  }
  start() {
    this.shutDownController = new AbortController();
    setMaxListeners(Infinity, this.shutDownController.signal);
  }
  /**
   * Clears any pending dials
   */
  stop() {
    this.shutDownController.abort();
    this.queue.abort();
  }
  /**
   * Connects to a given peer, multiaddr or list of multiaddrs.
   *
   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
   * multiaddrs are passed only those will be dialled.
   *
   * Where a list of multiaddrs is passed, if any contain a peer id then all
   * multiaddrs in the list must contain the same peer id.
   *
   * The dial to the first address that is successfully able to upgrade a
   * connection will be used, all other dials will be aborted when that happens.
   */
  async dial(peerIdOrMultiaddr, options = {}) {
    var _a12, _b3, _c;
    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
    const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
      if (options.force === true) {
        return false;
      }
      if (conn.remotePeer.equals(peerId)) {
        return true;
      }
      return multiaddrs.find((addr) => {
        return addr.equals(conn.remoteAddr);
      });
    });
    if ((existingConnection == null ? void 0 : existingConnection.status) === "open") {
      this.log("already connected to %a", existingConnection.remoteAddr);
      (_a12 = options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("dial-queue:already-connected"));
      return existingConnection;
    }
    const existingDial = this.queue.queue.find((job) => {
      if ((peerId == null ? void 0 : peerId.equals(job.options.peerId)) === true) {
        return true;
      }
      const addresses = job.options.multiaddrs;
      if (addresses == null) {
        return false;
      }
      for (const multiaddr2 of multiaddrs) {
        if (addresses.has(multiaddr2.toString())) {
          return true;
        }
      }
      return false;
    });
    if (existingDial != null) {
      this.log("joining existing dial target for %p", peerId);
      for (const multiaddr2 of multiaddrs) {
        existingDial.options.multiaddrs.add(multiaddr2.toString());
      }
      (_b3 = options.onProgress) == null ? void 0 : _b3.call(options, new CustomProgressEvent("dial-queue:already-in-dial-queue"));
      return existingDial.join(options);
    }
    if (this.queue.size >= this.maxDialQueueLength) {
      throw new DialError("Dial queue is full");
    }
    this.log("creating dial target for %p", peerId, multiaddrs.map((ma) => ma.toString()));
    (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dial-queue:add-to-dial-queue"));
    return this.queue.add(async (options2) => {
      var _a13, _b4;
      (_a13 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _a13.call(options2, new CustomProgressEvent("dial-queue:start-dial"));
      const signal = anySignal([
        this.shutDownController.signal,
        options2.signal
      ]);
      setMaxListeners(Infinity, signal);
      let addrsToDial;
      try {
        addrsToDial = await this.calculateMultiaddrs(peerId, options2 == null ? void 0 : options2.multiaddrs, {
          ...options2,
          signal
        });
        (_b4 = options2 == null ? void 0 : options2.onProgress) == null ? void 0 : _b4.call(options2, new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
        addrsToDial.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()).forEach((addr) => {
          options2 == null ? void 0 : options2.multiaddrs.add(addr);
        });
      } catch (err) {
        signal.clear();
        throw err;
      }
      try {
        let dialed = 0;
        const errors = [];
        for (const address of addrsToDial) {
          if (dialed === this.maxPeerAddrsToDial) {
            this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, peerId);
            throw new DialError("Peer had more than maxPeerAddrsToDial");
          }
          dialed++;
          try {
            const conn = await this.components.transportManager.dial(address.multiaddr, {
              ...options2,
              signal
            });
            this.log("dial to %a succeeded", address.multiaddr);
            try {
              await this.components.peerStore.merge(conn.remotePeer, {
                multiaddrs: [
                  conn.remoteAddr
                ],
                metadata: {
                  [LAST_DIAL_SUCCESS_KEY]: fromString(Date.now().toString())
                }
              });
            } catch (err) {
              this.log.error("could not update last dial failure key for %p", peerId, err);
            }
            return conn;
          } catch (err) {
            this.log.error("dial failed to %a", address.multiaddr, err);
            if (peerId != null) {
              try {
                await this.components.peerStore.merge(peerId, {
                  metadata: {
                    [LAST_DIAL_FAILURE_KEY]: fromString(Date.now().toString())
                  }
                });
              } catch (err2) {
                this.log.error("could not update last dial failure key for %p", peerId, err2);
              }
            }
            if (signal.aborted) {
              throw new TimeoutError(err.message);
            }
            errors.push(err);
          }
        }
        if (errors.length === 1) {
          throw errors[0];
        }
        throw new AggregateError(errors, "All multiaddr dials failed");
      } finally {
        signal.clear();
      }
    }, {
      peerId,
      priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
      multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
      signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
      onProgress: options.onProgress
    });
  }
  // eslint-disable-next-line complexity
  async calculateMultiaddrs(peerId, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
    var _a12, _b3;
    const addrs = [...multiaddrs].map((ma) => ({
      multiaddr: multiaddr(ma),
      isCertified: false
    }));
    if (peerId != null) {
      if (this.components.peerId.equals(peerId)) {
        throw new DialError("Tried to dial self");
      }
      if (await ((_b3 = (_a12 = this.components.connectionGater).denyDialPeer) == null ? void 0 : _b3.call(_a12, peerId)) === true) {
        throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
      }
      if (addrs.length === 0) {
        this.log("loading multiaddrs for %p", peerId);
        try {
          const peer = await this.components.peerStore.get(peerId);
          addrs.push(...peer.addresses);
          this.log("loaded multiaddrs for %p", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (addrs.length === 0) {
        this.log("looking up multiaddrs for %p in the peer routing", peerId);
        try {
          const peerInfo = await this.components.peerRouting.findPeer(peerId, options);
          this.log("found multiaddrs for %p in the peer routing", peerId, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
            multiaddr: multiaddr2,
            isCertified: false
          })));
        } catch (err) {
          if (err.name !== "NoPeerRoutersError") {
            this.log.error("looking up multiaddrs for %p in the peer routing failed", peerId, err);
          }
        }
      }
    }
    let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
      const result = await resolveMultiaddrs(addr.multiaddr, {
        dns: this.components.dns,
        ...options,
        log: this.log
      });
      if (result.length === 1 && result[0].equals(addr.multiaddr)) {
        return addr;
      }
      return result.map((multiaddr2) => ({
        multiaddr: multiaddr2,
        isCertified: false
      }));
    }))).flat();
    if (peerId != null) {
      const peerIdMultiaddr = `/p2p/${peerId.toString()}`;
      resolvedAddresses = resolvedAddresses.map((addr) => {
        const lastProto = addr.multiaddr.protos().pop();
        if ((lastProto == null ? void 0 : lastProto.path) === true) {
          return addr;
        }
        if (addr.multiaddr.getPeerId() == null) {
          return {
            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
            isCertified: addr.isCertified
          };
        }
        return addr;
      });
    }
    const filteredAddrs = resolvedAddresses.filter((addr) => {
      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
        return false;
      }
      const addrPeerId = addr.multiaddr.getPeerId();
      if (peerId != null && addrPeerId != null) {
        return peerId.equals(addrPeerId);
      }
      return true;
    });
    const dedupedAddrs = /* @__PURE__ */ new Map();
    for (const addr of filteredAddrs) {
      const maStr = addr.multiaddr.toString();
      const existing = dedupedAddrs.get(maStr);
      if (existing != null) {
        existing.isCertified = existing.isCertified || addr.isCertified || false;
        continue;
      }
      dedupedAddrs.set(maStr, addr);
    }
    const dedupedMultiaddrs = [...dedupedAddrs.values()];
    if (dedupedMultiaddrs.length === 0) {
      throw new NoValidAddressesError("The dial request has no valid addresses");
    }
    const gatedAdrs = [];
    for (const addr of dedupedMultiaddrs) {
      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
        continue;
      }
      gatedAdrs.push(addr);
    }
    const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAdrs) : gatedAdrs.sort(this.addressSorter);
    if (sortedGatedAddrs.length === 0) {
      throw new DialDeniedError("The connection gater denied all addresses in the dial request");
    }
    this.log.trace("addresses for %p before filtering", peerId ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    this.log.trace("addresses for %p after filtering", peerId ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
    return sortedGatedAddrs;
  }
  async isDialable(multiaddr2, options = {}) {
    if (!Array.isArray(multiaddr2)) {
      multiaddr2 = [multiaddr2];
    }
    try {
      const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
      if (options.runOnLimitedConnection === false) {
        return addresses.find((addr) => {
          return !Circuit.matches(addr.multiaddr);
        }) != null;
      }
      return true;
    } catch (err) {
      this.log.trace("error calculating if multiaddr(s) were dialable", err);
    }
    return false;
  }
};

// node_modules/@libp2p/utils/dist/src/peer-queue.js
var PeerQueue = class extends Queue {
  has(peerId) {
    return this.find(peerId) != null;
  }
  find(peerId) {
    return this.queue.find((job) => {
      return peerId.equals(job.options.peerId);
    });
  }
};

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}

// node_modules/p-retry/index.js
var AbortError3 = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = { ...options };
    options.onFailedAttempt ?? (options.onFailedAttempt = () => {
    });
    options.shouldRetry ?? (options.shouldRetry = () => true);
    options.retries ?? (options.retries = 10);
    const operation = import_retry.default.operation(options);
    const abortHandler = () => {
      var _a12;
      operation.stop();
      reject((_a12 = options.signal) == null ? void 0 : _a12.reason);
    };
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      var _a12;
      (_a12 = options.signal) == null ? void 0 : _a12.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError3) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options);
          if (!await options.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
var ReconnectQueue = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "queue");
    __publicField(this, "started");
    __publicField(this, "peerStore");
    __publicField(this, "retries");
    __publicField(this, "retryInterval");
    __publicField(this, "backoffFactor");
    __publicField(this, "connectionManager");
    __publicField(this, "events");
    this.log = components.logger.forComponent("libp2p:reconnect-queue");
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.queue = new PeerQueue({
      concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
      metricName: "libp2p_reconnect_queue",
      metrics: components.metrics
    });
    this.started = false;
    this.retries = init.retries ?? 5;
    this.backoffFactor = init.backoffFactor;
    this.retryInterval = init.retryInterval;
    this.events = components.events;
    components.events.addEventListener("peer:disconnect", (evt) => {
      this.maybeReconnect(evt.detail).catch((err) => {
        this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
      });
    });
  }
  async maybeReconnect(peerId) {
    if (!this.started) {
      return;
    }
    const peer = await this.peerStore.get(peerId);
    if (!hasKeepAliveTag(peer)) {
      return;
    }
    if (this.queue.has(peerId)) {
      return;
    }
    this.queue.add(async (options) => {
      await pRetry(async (attempt) => {
        if (!this.started) {
          return;
        }
        try {
          await this.connectionManager.openConnection(peerId, {
            signal: options == null ? void 0 : options.signal
          });
        } catch (err) {
          this.log("reconnecting to %p attempt %d of %d failed - %e", peerId, attempt, this.retries, err);
          throw err;
        }
      }, {
        signal: options == null ? void 0 : options.signal,
        retries: this.retries,
        factor: this.backoffFactor,
        minTimeout: this.retryInterval
      });
    }, {
      peerId
    }).catch(async (err) => {
      this.log.error("failed to reconnect to %p - %e", peerId, err);
      const tags = {};
      [...peer.tags.keys()].forEach((key) => {
        if (key.startsWith(KEEP_ALIVE)) {
          tags[key] = void 0;
        }
      });
      await this.peerStore.merge(peerId, {
        tags
      });
      this.events.safeDispatchEvent("peer:reconnect-failure", {
        detail: peerId
      });
    }).catch(async (err) => {
      this.log.error("failed to remove keep-alive tag from %p - %e", peerId, err);
    });
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    void Promise.resolve().then(async () => {
      const keepAlivePeers = await this.peerStore.all({
        filters: [
          (peer) => hasKeepAliveTag(peer)
        ]
      });
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.connectionManager.openConnection(peer.id).catch((err) => {
          this.log.error(err);
        });
      }));
    }).catch((err) => {
      this.log.error(err);
    });
  }
  stop() {
    this.started = false;
    this.queue.abort();
  }
};
function hasKeepAliveTag(peer) {
  for (const tag of peer.tags.keys()) {
    if (tag.startsWith(KEEP_ALIVE)) {
      return true;
    }
  }
  return false;
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var DEFAULT_DIAL_PRIORITY = 50;
var defaultOptions5 = {
  maxConnections: MAX_CONNECTIONS,
  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
};
var _a3;
var DefaultConnectionManager = class {
  constructor(components, init = {}) {
    __publicField(this, "started");
    __publicField(this, "connections");
    __publicField(this, "allow");
    __publicField(this, "deny");
    __publicField(this, "maxIncomingPendingConnections");
    __publicField(this, "incomingPendingConnections");
    __publicField(this, "outboundPendingConnections");
    __publicField(this, "maxConnections");
    __publicField(this, "dialQueue");
    __publicField(this, "reconnectQueue");
    __publicField(this, "connectionPruner");
    __publicField(this, "inboundConnectionRateLimiter");
    __publicField(this, "peerStore");
    __publicField(this, "metrics");
    __publicField(this, "events");
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, _a3, "@libp2p/connection-manager");
    var _a12;
    this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
    if (this.maxConnections < 1) {
      throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
    }
    this.connections = new PeerMap();
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.metrics = components.metrics;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:connection-manager");
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
    this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
    this.incomingPendingConnections = 0;
    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions5.maxIncomingPendingConnections;
    this.outboundPendingConnections = 0;
    this.inboundConnectionRateLimiter = new RateLimiter({
      points: init.inboundConnectionThreshold ?? defaultOptions5.inboundConnectionThreshold,
      duration: 1
    });
    this.connectionPruner = new ConnectionPruner({
      connectionManager: this,
      peerStore: components.peerStore,
      events: components.events,
      logger: components.logger
    }, {
      maxConnections: this.maxConnections,
      allow: (_a12 = init.allow) == null ? void 0 : _a12.map((a) => multiaddr(a))
    });
    this.dialQueue = new DialQueue(components, {
      addressSorter: init.addressSorter,
      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
      resolvers: init.resolvers ?? {
        dnsaddr: dnsaddrResolver
      },
      connections: this.connections
    });
    this.reconnectQueue = new ReconnectQueue({
      events: components.events,
      peerStore: components.peerStore,
      logger: components.logger,
      connectionManager: this
    }, {
      retries: init.reconnectRetries,
      retryInterval: init.reconnectRetryInterval,
      backoffFactor: init.reconnectBackoffFactor,
      maxParallelReconnects: init.maxParallelReconnects
    });
  }
  /**
   * Starts the Connection Manager. If Metrics are not enabled on libp2p
   * only event loop and connection limits will be monitored.
   */
  async start() {
    var _a12, _b3, _c;
    (_a12 = this.metrics) == null ? void 0 : _a12.registerMetricGroup("libp2p_connection_manager_connections", {
      calculate: () => {
        const metric = {
          inbound: 0,
          "inbound pending": this.incomingPendingConnections,
          outbound: 0,
          "outbound pending": this.outboundPendingConnections
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            metric[conn.direction]++;
          }
        }
        return metric;
      }
    });
    (_b3 = this.metrics) == null ? void 0 : _b3.registerMetricGroup("libp2p_protocol_streams_total", {
      label: "protocol",
      calculate: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    (_c = this.metrics) == null ? void 0 : _c.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
      label: "protocol",
      calculate: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.events.addEventListener("connection:open", this.onConnect);
    this.events.addEventListener("connection:close", this.onDisconnect);
    await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
    this.started = true;
    this.log("started");
  }
  /**
   * Stops the Connection Manager
   */
  async stop() {
    this.events.removeEventListener("connection:open", this.onConnect);
    this.events.removeEventListener("connection:close", this.onDisconnect);
    await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            this.log.error(err);
          }
        })());
      }
    }
    this.log("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
    this.log("stopped");
  }
  getMaxConnections() {
    return this.maxConnections;
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      this.log.error(err);
    });
  }
  /**
   * Tracks the incoming connection and check the connection limit
   */
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    if (connection.status !== "open") {
      return;
    }
    const peerId = connection.remotePeer;
    const isNewPeer = !this.connections.has(peerId);
    const storedConns = this.connections.get(peerId) ?? [];
    storedConns.push(connection);
    this.connections.set(peerId, storedConns);
    if (peerId.publicKey != null && peerId.type === "RSA") {
      await this.peerStore.patch(peerId, {
        publicKey: peerId.publicKey
      });
    }
    if (isNewPeer) {
      this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
    }
  }
  /**
   * Removes the connection from tracking
   */
  onDisconnect(evt) {
    const { detail: connection } = evt;
    const peerId = connection.remotePeer;
    const peerConns = this.connections.get(peerId) ?? [];
    const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
    this.connections.set(peerId, filteredPeerConns);
    if (filteredPeerConns.length === 0) {
      this.log("onDisconnect remove all connections for peer %p", peerId);
      this.connections.delete(peerId);
      this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  getConnectionsMap() {
    return this.connections;
  }
  async openConnection(peerIdOrMultiaddr, options = {}) {
    var _a12, _b3;
    if (!this.started) {
      throw new NotStartedError("Not started");
    }
    this.outboundPendingConnections++;
    try {
      (_a12 = options.signal) == null ? void 0 : _a12.throwIfAborted();
      const { peerId } = getPeerAddress(peerIdOrMultiaddr);
      if (this.peerId.equals(peerId)) {
        throw new InvalidPeerIdError("Can not dial self");
      }
      if (peerId != null && options.force !== true) {
        this.log("dial %p", peerId);
        const existingConnection = this.getConnections(peerId).find((conn) => conn.limits == null);
        if (existingConnection != null) {
          this.log("had an existing non-limited connection to %p", peerId);
          (_b3 = options.onProgress) == null ? void 0 : _b3.call(options, new CustomProgressEvent("dial-queue:already-connected"));
          return existingConnection;
        }
      }
      const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
        ...options,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY
      });
      if (connection.status !== "open") {
        throw new ConnectionClosedError("Remote closed connection during opening");
      }
      let peerConnections = this.connections.get(connection.remotePeer);
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(connection.remotePeer, peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
        if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
          connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
          return conn;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      this.outboundPendingConnections--;
    }
  }
  async closeConnections(peerId, options = {}) {
    const connections = this.connections.get(peerId) ?? [];
    await Promise.all(connections.map(async (connection) => {
      try {
        await connection.close(options);
      } catch (err) {
        connection.abort(err);
      }
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return ma.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (denyConnection) {
      this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ipNet) => {
      return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
      this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
        return false;
      }
    }
    if (this.getConnections().length < this.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
  getDialQueue() {
    const statusMap = {
      queued: "queued",
      running: "active",
      errored: "error",
      complete: "success"
    };
    return this.dialQueue.queue.queue.map((job) => {
      return {
        id: job.id,
        status: statusMap[job.status],
        peerId: job.options.peerId,
        multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
      };
    });
  }
  async isDialable(multiaddr2, options = {}) {
    return this.dialQueue.isDialable(multiaddr2, options);
  }
};
_a3 = Symbol.toStringTag;

// node_modules/@libp2p/utils/dist/src/moving-average.js
var MovingAverage = class {
  constructor(timespan) {
    __publicField(this, "movingAverage");
    __publicField(this, "variance");
    __publicField(this, "deviation");
    __publicField(this, "forecast");
    __publicField(this, "timespan");
    __publicField(this, "previousTime");
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(value, time = Date.now()) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};

// node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
var DEFAULT_FAILURE_MULTIPLIER = 2;
var DEFAULT_MIN_TIMEOUT = 2e3;
var AdaptiveTimeout = class {
  constructor(init = {}) {
    __publicField(this, "success");
    __publicField(this, "failure");
    __publicField(this, "next");
    __publicField(this, "metric");
    __publicField(this, "timeoutMultiplier");
    __publicField(this, "failureMultiplier");
    __publicField(this, "minTimeout");
    var _a12;
    this.success = new MovingAverage(init.interval ?? 5e3);
    this.failure = new MovingAverage(init.interval ?? 5e3);
    this.next = new MovingAverage(init.interval ?? 5e3);
    this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
    this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
    this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
    if (init.metricName != null) {
      this.metric = (_a12 = init.metrics) == null ? void 0 : _a12.registerMetricGroup(init.metricName);
    }
  }
  getTimeoutSignal(options = {}) {
    const timeout = Math.max(Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier)), this.minTimeout);
    const sendTimeout = AbortSignal.timeout(timeout);
    const timeoutSignal = anySignal([options.signal, sendTimeout]);
    setMaxListeners(Infinity, timeoutSignal, sendTimeout);
    timeoutSignal.start = Date.now();
    timeoutSignal.timeout = timeout;
    return timeoutSignal;
  }
  cleanUp(signal) {
    var _a12, _b3;
    const time = Date.now() - signal.start;
    if (signal.aborted) {
      this.failure.push(time);
      this.next.push(time * this.failureMultiplier);
      (_a12 = this.metric) == null ? void 0 : _a12.update({
        failureMovingAverage: this.failure.movingAverage,
        failureDeviation: this.failure.deviation,
        failureForecast: this.failure.forecast,
        failureVariance: this.failure.variance,
        failure: time
      });
    } else {
      this.success.push(time);
      this.next.push(time);
      (_b3 = this.metric) == null ? void 0 : _b3.update({
        successMovingAverage: this.success.movingAverage,
        successDeviation: this.success.deviation,
        successForecast: this.success.forecast,
        successVariance: this.success.variance,
        success: time
      });
    }
  }
};

// node_modules/libp2p/dist/src/connection-monitor.js
var DEFAULT_PING_INTERVAL_MS = 1e4;
var PROTOCOL_VERSION = "1.0.0";
var PROTOCOL_NAME = "ping";
var PROTOCOL_PREFIX = "ipfs";
var PING_LENGTH = 32;
var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
var _a4, _b;
var ConnectionMonitor = class {
  constructor(components, init = {}) {
    __publicField(this, "protocol");
    __publicField(this, "components");
    __publicField(this, "log");
    __publicField(this, "heartbeatInterval");
    __publicField(this, "pingIntervalMs");
    __publicField(this, "abortController");
    __publicField(this, "timeout");
    __publicField(this, "abortConnectionOnPingFailure");
    __publicField(this, _a4, "@libp2p/connection-monitor");
    __publicField(this, _b, [
      "@libp2p/connection-monitor"
    ]);
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.log = components.logger.forComponent("libp2p:connection-monitor");
    this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
    this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
    this.timeout = new AdaptiveTimeout({
      ...init.pingTimeout ?? {},
      metrics: components.metrics,
      metricName: "libp2p_connection_monitor_ping_time_milliseconds"
    });
  }
  start() {
    this.abortController = new AbortController();
    setMaxListeners(Infinity, this.abortController.signal);
    this.heartbeatInterval = setInterval(() => {
      this.components.connectionManager.getConnections().forEach((conn) => {
        Promise.resolve().then(async () => {
          var _a12;
          let start2 = Date.now();
          try {
            const signal = this.timeout.getTimeoutSignal({
              signal: (_a12 = this.abortController) == null ? void 0 : _a12.signal
            });
            const stream = await conn.newStream(this.protocol, {
              signal,
              runOnLimitedConnection: true
            });
            const bs = byteStream(stream);
            start2 = Date.now();
            await Promise.all([
              bs.write(randomBytes(PING_LENGTH), {
                signal
              }),
              bs.read(PING_LENGTH, {
                signal
              })
            ]);
            conn.rtt = Date.now() - start2;
            await bs.unwrap().close({
              signal
            });
          } catch (err) {
            if (err.name !== "UnsupportedProtocolError") {
              throw err;
            }
            conn.rtt = (Date.now() - start2) / 2;
          }
        }).catch((err) => {
          this.log.error("error during heartbeat", err);
          if (this.abortConnectionOnPingFailure) {
            this.log.error("aborting connection due to ping failure");
            conn.abort(err);
          } else {
            this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
          }
        });
      });
    }, this.pingIntervalMs);
  }
  stop() {
    var _a12;
    (_a12 = this.abortController) == null ? void 0 : _a12.abort();
    if (this.heartbeatInterval != null) {
      clearInterval(this.heartbeatInterval);
    }
  }
};
_a4 = Symbol.toStringTag, _b = serviceCapabilities;

// node_modules/libp2p/dist/src/content-routing.js
var _a5;
var CompoundContentRouting = class {
  constructor(components, init) {
    __publicField(this, "routers");
    __publicField(this, "started");
    __publicField(this, "components");
    __publicField(this, _a5, "@libp2p/content-routing");
    var _a12, _b3, _c, _d, _e;
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
    this.findProviders = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
        };
      }
    })) ?? this.findProviders;
    this.provide = ((_b3 = components.metrics) == null ? void 0 : _b3.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.provide;
    this.cancelReprovide = ((_c = components.metrics) == null ? void 0 : _c.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([cid], attrs) => {
        return {
          ...attrs,
          cid: cid.toString()
        };
      }
    })) ?? this.cancelReprovide;
    this.put = ((_d = components.metrics) == null ? void 0 : _d.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
      optionsIndex: 2,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.put;
    this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key]) => {
        return {
          key: toString(key, "base36")
        };
      }
    })) ?? this.get;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  /**
   * Iterates over all content routers in parallel to find providers of the given key
   */
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    const self = this;
    const seen = new PeerSet();
    for await (const peer of src_default(...self.routers.map((router) => router.findProviders(key, options)))) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.components.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id)) {
        continue;
      }
      seen.add(peer.id);
      yield peer;
    }
  }
  /**
   * Iterates over all content routers in parallel to notify it is
   * a provider of the given key
   */
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.provide(key, options);
    }));
  }
  async cancelReprovide(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoContentRoutersError("No content routers available");
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.cancelReprovide(key, options);
    }));
  }
  /**
   * Store the given key/value pair in the available content routings
   */
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    await Promise.all(this.routers.map(async (router) => {
      await router.put(key, value, options);
    }));
  }
  /**
   * Get the value to the given key.
   * Times out after 1 minute by default.
   */
  async get(key, options) {
    if (!this.isStarted()) {
      throw new NotStartedError();
    }
    return Promise.any(this.routers.map(async (router) => {
      return router.get(key, options);
    }));
  }
};
_a5 = Symbol.toStringTag;

// node_modules/libp2p/dist/src/peer-routing.js
var _a6;
var DefaultPeerRouting = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "routers");
    __publicField(this, _a6, "@libp2p/peer-routing");
    var _a12, _b3;
    this.log = components.logger.forComponent("libp2p:peer-routing");
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.routers = init.routers ?? [];
    this.findPeer = ((_a12 = components.metrics) == null ? void 0 : _a12.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([peer], attrs) => {
        return {
          ...attrs,
          peer: peer.toString()
        };
      }
    })) ?? this.findPeer;
    this.getClosestPeers = ((_b3 = components.metrics) == null ? void 0 : _b3.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
      optionsIndex: 1,
      getAttributesFromArgs: ([key], attrs) => {
        return {
          ...attrs,
          key: toString(key, "base36")
        };
      },
      getAttributesFromYieldedValue: (value, attrs) => {
        return {
          ...attrs,
          peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
        };
      }
    })) ?? this.getClosestPeers;
  }
  /**
   * Iterates over all peer routers in parallel to find the given peer
   */
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    if (id.toString() === this.peerId.toString()) {
      throw new QueriedForSelfError("Should not try to find self");
    }
    const self = this;
    const source = src_default(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        self.log.error(err);
      }
    }()));
    for await (const peer of source) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      return peer;
    }
    throw new NotFoundError();
  }
  /**
   * Attempt to find the closest peers on the network to the given key
   */
  async *getClosestPeers(key, options = {}) {
    if (this.routers.length === 0) {
      throw new NoPeerRoutersError("No peer routers available");
    }
    const self = this;
    const seen = createScalableCuckooFilter(1024);
    for await (const peer of parallel(async function* () {
      const source = src_default(...self.routers.map((router) => router.getClosestPeers(key, options)));
      for await (let peer2 of source) {
        yield async () => {
          if (peer2.multiaddrs.length === 0) {
            try {
              peer2 = await self.findPeer(peer2.id, {
                ...options,
                useCache: false
              });
            } catch (err) {
              self.log.error("could not find peer multiaddrs", err);
              return;
            }
          }
          return peer2;
        };
      }
    }())) {
      if (peer == null) {
        continue;
      }
      if (peer.multiaddrs.length > 0) {
        await this.peerStore.merge(peer.id, {
          multiaddrs: peer.multiaddrs
        });
      }
      if (seen.has(peer.id.toMultihash().bytes)) {
        continue;
      }
      seen.add(peer.id.toMultihash().bytes);
      yield peer;
    }
  }
};
_a6 = Symbol.toStringTag;

// node_modules/libp2p/dist/src/random-walk.js
var _a7;
var RandomWalk = class extends TypedEventEmitter {
  constructor(components) {
    super();
    __publicField(this, "peerRouting");
    __publicField(this, "log");
    __publicField(this, "walking");
    __publicField(this, "walkers");
    __publicField(this, "shutdownController");
    __publicField(this, "walkController");
    __publicField(this, "needNext");
    __publicField(this, _a7, "@libp2p/random-walk");
    this.log = components.logger.forComponent("libp2p:random-walk");
    this.peerRouting = components.peerRouting;
    this.walkers = 0;
    this.walking = false;
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  start() {
    this.shutdownController = new AbortController();
    setMaxListeners(Infinity, this.shutdownController.signal);
  }
  stop() {
    this.shutdownController.abort();
  }
  async *walk(options) {
    var _a12, _b3;
    if (!this.walking) {
      this.startWalk();
    }
    this.walkers++;
    const signal = anySignal([this.shutdownController.signal, options == null ? void 0 : options.signal]);
    setMaxListeners(Infinity, signal);
    try {
      while (true) {
        (_a12 = this.needNext) == null ? void 0 : _a12.resolve();
        this.needNext = pDefer();
        const event = await raceEvent(this, "walk:peer", signal, {
          errorEvent: "walk:error"
        });
        yield event.detail;
      }
    } finally {
      signal.clear();
      this.walkers--;
      if (this.walkers === 0) {
        (_b3 = this.walkController) == null ? void 0 : _b3.abort();
        this.walkController = void 0;
      }
    }
  }
  startWalk() {
    this.walking = true;
    this.walkController = new AbortController();
    setMaxListeners(Infinity, this.walkController.signal);
    const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
    setMaxListeners(Infinity, signal);
    const start2 = Date.now();
    let found = 0;
    Promise.resolve().then(async () => {
      this.log("start walk");
      while (this.walkers > 0) {
        try {
          const data = randomBytes(32);
          let s = Date.now();
          for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
            if (signal.aborted) {
              this.log("aborting walk");
            }
            signal.throwIfAborted();
            this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s, this.walkers);
            found++;
            this.safeDispatchEvent("walk:peer", {
              detail: peer
            });
            if (this.walkers === 1 && this.needNext != null) {
              this.log("wait for need next");
              await raceSignal(this.needNext.promise, signal);
            }
            s = Date.now();
          }
          this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
        } catch (err) {
          this.log.error("randomwalk errored", err);
          this.safeDispatchEvent("walk:error", {
            detail: err
          });
        }
      }
      this.log("no walkers left, ended walk");
    }).catch((err) => {
      this.log.error("randomwalk errored", err);
    }).finally(() => {
      this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
      this.walking = false;
    });
  }
};
_a7 = Symbol.toStringTag;

// node_modules/libp2p/dist/src/registrar.js
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var _a8;
var DefaultRegistrar = class {
  constructor(components) {
    __publicField(this, "log");
    __publicField(this, "topologies");
    __publicField(this, "handlers");
    __publicField(this, "components");
    __publicField(this, _a8, "@libp2p/registrar");
    this.log = components.logger.forComponent("libp2p:registrar");
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onPeerUpdate = this._onPeerUpdate.bind(this);
    this._onPeerIdentify = this._onPeerIdentify.bind(this);
    this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.events.addEventListener("peer:update", this._onPeerUpdate);
    this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  /**
   * Registers the `handler` for each protocol
   */
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.merge(this.components.peerId, {
      protocols: [protocol]
    });
  }
  /**
   * Removes the handler for each protocol. The protocol
   * will no longer be supported on streams.
   */
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.patch(this.components.peerId, {
      protocols: this.getProtocols()
    });
  }
  /**
   * Register handlers for a set of multicodecs given
   */
  async register(protocol, topology) {
    if (topology == null) {
      throw new InvalidParametersError("invalid topology");
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    return id;
  }
  /**
   * Unregister topology
   */
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  /**
   * Remove a disconnected peer from the record
   */
  _onDisconnect(evt) {
    const remotePeer = evt.detail;
    void this.components.peerStore.get(remotePeer).then((peer) => {
      var _a12, _b3, _c;
      for (const protocol of peer.protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (((_a12 = topology.filter) == null ? void 0 : _a12.has(remotePeer)) === false) {
            continue;
          }
          (_b3 = topology.filter) == null ? void 0 : _b3.remove(remotePeer);
          (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, remotePeer);
        }
      }
    }).catch((err) => {
      if (err.name === "NotFoundError") {
        return;
      }
      this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
    });
  }
  /**
   * When a peer is updated, if they have removed supported protocols notify any
   * topologies interested in the removed protocols.
   */
  _onPeerUpdate(evt) {
    var _a12, _b3, _c;
    const { peer, previous } = evt.detail;
    const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peer.id)) === false) {
          continue;
        }
        (_b3 = topology.filter) == null ? void 0 : _b3.remove(peer.id);
        (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, peer.id);
      }
    }
  }
  /**
   * After identify has completed and we have received the list of supported
   * protocols, notify any topologies interested in those protocols.
   */
  _onPeerIdentify(evt) {
    var _a12, _b3, _c;
    const protocols = evt.detail.protocols;
    const connection = evt.detail.connection;
    const peerId = evt.detail.peerId;
    for (const protocol of protocols) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
          continue;
        }
        if (((_a12 = topology.filter) == null ? void 0 : _a12.has(peerId)) === true) {
          continue;
        }
        (_b3 = topology.filter) == null ? void 0 : _b3.add(peerId);
        (_c = topology.onConnect) == null ? void 0 : _c.call(topology, peerId, connection);
      }
    }
  }
};
_a8 = Symbol.toStringTag;

// node_modules/@libp2p/utils/dist/src/tracked-map.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    __publicField(this, "metric");
    const { name: name2, metrics } = init;
    this.metric = metrics.registerMetric(name2);
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metric.update(this.size);
  }
};
function trackedMap(config) {
  const { name: name2, metrics } = config;
  let map;
  if (metrics != null) {
    map = new TrackedMap({ name: name2, metrics });
  } else {
    map = /* @__PURE__ */ new Map();
  }
  return map;
}

// node_modules/libp2p/dist/src/transport-manager.js
var _a9;
var DefaultTransportManager = class {
  constructor(components, init = {}) {
    __publicField(this, "log");
    __publicField(this, "components");
    __publicField(this, "transports");
    __publicField(this, "listeners");
    __publicField(this, "faultTolerance");
    __publicField(this, "started");
    __publicField(this, _a9, "@libp2p/transport-manager");
    this.log = components.logger.forComponent("libp2p:transports");
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      name: "libp2p_transport_manager_listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  /**
   * Adds a `Transport` to the manager
   */
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw new InvalidParametersError("Transport must have a valid tag");
    }
    if (this.transports.has(tag)) {
      throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
    }
    this.log("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  async afterStart() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
  }
  /**
   * Stops all listeners
   */
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      this.log("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    this.log("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  /**
   * Dials the given Multiaddr over it's supported transport
   */
  async dial(ma, options) {
    var _a12;
    const transport = this.dialTransportForMultiaddr(ma);
    if (transport == null) {
      throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
    }
    (_a12 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a12.call(options, new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
    return transport.dial(ma, {
      ...options,
      upgrader: this.components.upgrader
    });
  }
  /**
   * Returns all Multiaddr's the listeners are using
   */
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  /**
   * Returns all the transports instances
   */
  getTransports() {
    return Array.of(...this.transports.values());
  }
  /**
   * Returns all the listener instances
   */
  getListeners() {
    return Array.of(...this.listeners.values()).flat();
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  dialTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.dialFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Finds a transport that matches the given Multiaddr
   */
  listenTransportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.listenFilter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  /**
   * Starts listeners for each listen Multiaddr
   */
  async listen(addrs) {
    if (!this.isStarted()) {
      throw new NotStartedError("Not started");
    }
    if (addrs == null || addrs.length === 0) {
      this.log("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.listenFilter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        this.log("creating listener for %s on %a", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key) ?? [];
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.components.events.safeDispatchEvent("transport:listening", {
            detail: listener
          });
        });
        listener.addEventListener("close", () => {
          const index = listeners.findIndex((l) => l === listener);
          listeners.splice(index, 1);
          this.components.events.safeDispatchEvent("transport:close", {
            detail: listener
          });
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await Promise.allSettled(tasks);
      const isListening = results.find((r) => r.status === "fulfilled");
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw new NoValidAddressesError(`Transport (${key}) could not listen on any available address`);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message2 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw new NoValidAddressesError(message2);
      }
      this.log(`libp2p in dial mode only: ${message2}`);
    }
  }
  /**
   * Removes the given transport from the manager.
   * If a transport has any running listeners, they will be closed.
   */
  async remove(key) {
    const listeners = this.listeners.get(key) ?? [];
    this.log.trace("removing transport %s", key);
    const tasks = [];
    this.log.trace("closing listeners for %s", key);
    while (listeners.length > 0) {
      const listener = listeners.pop();
      if (listener == null) {
        continue;
      }
      tasks.push(listener.close());
    }
    await Promise.all(tasks);
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  /**
   * Removes all transports from the manager.
   * If any listeners are running, they will be closed.
   *
   * @async
   */
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
_a9 = Symbol.toStringTag;

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";
var MAX_PROTOCOL_LENGTH = 1024;

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString("\n");
async function write(writer, buffer, options) {
  await writer.write(buffer, options);
}
async function writeAll(writer, buffers, options) {
  await writer.writeV(buffers, options);
}
async function read(reader, options) {
  const buf = await reader.read(options);
  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
    options.log.error("Invalid mss message - missing newline", buf);
    throw new InvalidMessageError("Missing newline");
  }
  return buf.sublist(0, -1);
}
async function readString(reader, options) {
  const buf = await read(reader, options);
  return toString(buf.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
async function select(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  if (protocols.length === 1 && options.negotiateFully === false) {
    return optimisticSelect(stream, protocols[0], options);
  }
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  options.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString(`${PROTOCOL_ID}
`);
  const p2 = fromString(`${protocol}
`);
  await writeAll(lp, [p1, p2], options);
  options.log.trace("select: reading multistream-select header");
  let response = await readString(lp, options);
  options.log.trace('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    options.log.trace("select: reading protocol response");
    response = await readString(lp, options);
    options.log.trace('select: read "%s"', response);
  }
  if (response === protocol) {
    return { stream: lp.unwrap(), protocol };
  }
  for (const protocol2 of protocols) {
    options.log.trace('select: write "%s"', protocol2);
    await write(lp, fromString(`${protocol2}
`), options);
    options.log.trace("select: reading protocol response");
    const response2 = await readString(lp, options);
    options.log.trace('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      return { stream: lp.unwrap(), protocol: protocol2 };
    }
  }
  throw new UnsupportedProtocolError("protocol selection failed");
}
function optimisticSelect(stream, protocol, options) {
  const originalSink = stream.sink.bind(stream);
  const originalSource = stream.source;
  let negotiated = false;
  let negotiating = false;
  const doneNegotiating = pDefer();
  let sentProtocol = false;
  let sendingProtocol = false;
  const doneSendingProtocol = pDefer();
  let readProtocol = false;
  let readingProtocol = false;
  const doneReadingProtocol = pDefer();
  const lp = lpStream({
    sink: originalSink,
    source: originalSource
  }, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH
  });
  stream.sink = async (source) => {
    const { sink } = lp.unwrap();
    await sink(async function* () {
      let sentData = false;
      for await (const buf of source) {
        if (sendingProtocol) {
          await doneSendingProtocol.promise;
        }
        if (!sentProtocol) {
          sendingProtocol = true;
          options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          const protocolString = `${protocol}
`;
          yield new Uint8ArrayList(
            Uint8Array.from([19]),
            // length of PROTOCOL_ID plus newline
            fromString(`${PROTOCOL_ID}
`),
            encode(protocolString.length),
            fromString(protocolString),
            buf
          ).subarray();
          options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
          sentProtocol = true;
          sendingProtocol = false;
          doneSendingProtocol.resolve();
          negotiate().catch((err) => {
            options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
          });
        } else {
          yield buf;
        }
        sentData = true;
      }
      if (!sentData) {
        await negotiate();
      }
    }());
  };
  async function negotiate() {
    if (negotiating) {
      options.log.trace("optimistic: already negotiating %s stream", protocol);
      await doneNegotiating.promise;
      return;
    }
    negotiating = true;
    try {
      if (!sentProtocol) {
        options.log.trace("optimistic: doing send protocol for %s stream", protocol);
        await doSendProtocol();
      }
      if (!readProtocol) {
        options.log.trace("optimistic: doing read protocol for %s stream", protocol);
        await doReadProtocol();
      }
    } finally {
      negotiating = false;
      negotiated = true;
      doneNegotiating.resolve();
    }
  }
  async function doSendProtocol() {
    if (sendingProtocol) {
      await doneSendingProtocol.promise;
      return;
    }
    sendingProtocol = true;
    try {
      options.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      await lp.writeV([
        fromString(`${PROTOCOL_ID}
`),
        fromString(`${protocol}
`)
      ]);
      options.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
    } finally {
      sentProtocol = true;
      sendingProtocol = false;
      doneSendingProtocol.resolve();
    }
  }
  async function doReadProtocol() {
    if (readingProtocol) {
      await doneReadingProtocol.promise;
      return;
    }
    readingProtocol = true;
    try {
      options.log.trace("optimistic: reading multistream select header");
      let response = await readString(lp, options);
      options.log.trace('optimistic: read multistream select header "%s"', response);
      if (response === PROTOCOL_ID) {
        response = await readString(lp, options);
      }
      options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
      if (response !== protocol) {
        throw new UnsupportedProtocolError("protocol selection failed");
      }
    } finally {
      readProtocol = true;
      readingProtocol = false;
      doneReadingProtocol.resolve();
    }
  }
  stream.source = async function* () {
    await negotiate();
    options.log.trace('optimistic: reading data from "%s" stream', protocol);
    yield* lp.unwrap().source;
  }();
  if (stream.closeRead != null) {
    const originalCloseRead = stream.closeRead.bind(stream);
    stream.closeRead = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close read", err);
        });
      }
      await originalCloseRead(opts);
    };
  }
  if (stream.closeWrite != null) {
    const originalCloseWrite = stream.closeWrite.bind(stream);
    stream.closeWrite = async (opts) => {
      if (!negotiated) {
        await negotiate().catch((err) => {
          options.log.error("could not negotiate protocol before close write", err);
        });
      }
      await originalCloseWrite(opts);
    };
  }
  if (stream.close != null) {
    const originalClose = stream.close.bind(stream);
    stream.close = async (opts) => {
      const tasks = [];
      if (sendingProtocol) {
        tasks.push(doneSendingProtocol.promise);
      }
      if (readingProtocol) {
        tasks.push(doneReadingProtocol.promise);
      }
      if (tasks.length > 0) {
        await raceSignal(Promise.all(tasks), opts == null ? void 0 : opts.signal);
      } else {
        negotiated = true;
        negotiating = false;
        doneNegotiating.resolve();
      }
      await originalClose(opts);
    };
  }
  return {
    stream,
    protocol
  };
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  options.log.trace("handle: available protocols %s", protocols);
  const lp = lpStream(stream, {
    ...options,
    maxDataLength: MAX_PROTOCOL_LENGTH,
    maxLengthLength: 2
    // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
  });
  while (true) {
    options.log.trace("handle: reading incoming string");
    const protocol = await readString(lp, options);
    options.log.trace('handle: read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      options.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      await write(lp, fromString(`${PROTOCOL_ID}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
      continue;
    }
    if (protocols.includes(protocol)) {
      options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
      await write(lp, fromString(`${protocol}
`), options);
      options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
      return { stream: lp.unwrap(), protocol };
    }
    if (protocol === "ls") {
      const protos = new Uint8ArrayList(...protocols.map((p) => encode2.single(fromString(`${p}
`))), fromString("\n"));
      options.log.trace('handle: respond with "%s" for %s', protocols, protocol);
      await write(lp, protos, options);
      options.log.trace('handle: responded with "%s" for %s', protocols, protocol);
      continue;
    }
    options.log.trace('handle: respond with "na" for "%s"', protocol);
    await write(lp, fromString("na\n"), options);
    options.log('handle: responded with "na" for "%s"', protocol);
  }
}

// node_modules/libp2p/dist/src/connection/index.js
var CLOSE_TIMEOUT = 500;
var _a10, _b2;
var ConnectionImpl = class {
  /**
   * An implementation of the js-libp2p connection.
   * Any libp2p transport should use an upgrader to return this connection.
   */
  constructor(init) {
    /**
     * Connection identifier.
     */
    __publicField(this, "id");
    /**
     * Observed multiaddr of the remote peer
     */
    __publicField(this, "remoteAddr");
    /**
     * Remote peer id
     */
    __publicField(this, "remotePeer");
    __publicField(this, "direction");
    __publicField(this, "timeline");
    __publicField(this, "multiplexer");
    __publicField(this, "encryption");
    __publicField(this, "status");
    __publicField(this, "limits");
    __publicField(this, "log");
    /**
     * User provided tags
     *
     */
    __publicField(this, "tags");
    /**
     * Reference to the new stream function of the multiplexer
     */
    __publicField(this, "_newStream");
    /**
     * Reference to the close function of the raw connection
     */
    __publicField(this, "_close");
    __publicField(this, "_abort");
    /**
     * Reference to the getStreams function of the muxer
     */
    __publicField(this, "_getStreams");
    __publicField(this, _a10, "Connection");
    __publicField(this, _b2, true);
    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.direction = init.direction;
    this.status = "open";
    this.timeline = init.timeline;
    this.multiplexer = init.multiplexer;
    this.encryption = init.encryption;
    this.limits = init.limits;
    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
    if (this.remoteAddr.getPeerId() == null) {
      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
    }
    this._newStream = newStream;
    this._close = close;
    this._abort = abort;
    this._getStreams = getStreams;
    this.tags = [];
  }
  /**
   * Get all the streams of the muxer
   */
  get streams() {
    return this._getStreams();
  }
  /**
   * Create a new stream from this connection
   */
  async newStream(protocols, options) {
    if (this.status === "closing") {
      throw new ConnectionClosingError("the connection is being closed");
    }
    if (this.status === "closed") {
      throw new ConnectionClosedError("the connection is closed");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    if (this.limits != null && (options == null ? void 0 : options.runOnLimitedConnection) !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    const stream = await this._newStream(protocols, options);
    stream.direction = "outbound";
    return stream;
  }
  /**
   * Close the connection
   */
  async close(options = {}) {
    if (this.status === "closed" || this.status === "closing") {
      return;
    }
    this.log("closing connection to %a", this.remoteAddr);
    this.status = "closing";
    if (options.signal == null) {
      const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      this.log.trace("closing underlying transport");
      await this._close(options);
      this.log.trace("updating timeline with close time");
      this.status = "closed";
      this.timeline.close = Date.now();
    } catch (err) {
      this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
      this.abort(err);
    }
  }
  abort(err) {
    if (this.status === "closed") {
      return;
    }
    this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
    this.status = "closing";
    this._abort(err);
    this.status = "closed";
    this.timeline.close = Date.now();
  }
};
_a10 = Symbol.toStringTag, _b2 = connectionSymbol;
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/upgrader.js
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar, options = {}) {
  try {
    const { options: options2 } = registrar.getHandler(protocol);
    if (options2.maxOutboundStreams != null) {
      return options2.maxOutboundStreams;
    }
  } catch (err) {
    if (err.name !== "UnhandledProtocolError") {
      throw err;
    }
  }
  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.direction === direction && stream.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var _a11;
var DefaultUpgrader = class {
  constructor(components, init) {
    __publicField(this, "components");
    __publicField(this, "connectionEncrypters");
    __publicField(this, "streamMuxers");
    __publicField(this, "inboundUpgradeTimeout");
    __publicField(this, "outboundUpgradeTimeout");
    __publicField(this, "inboundStreamProtocolNegotiationTimeout");
    __publicField(this, "outboundStreamProtocolNegotiationTimeout");
    __publicField(this, "events");
    __publicField(this, "metrics");
    __publicField(this, _a11, "@libp2p/upgrader");
    var _a12, _b3;
    this.components = components;
    this.connectionEncrypters = /* @__PURE__ */ new Map();
    init.connectionEncrypters.forEach((encrypter) => {
      this.connectionEncrypters.set(encrypter.protocol, encrypter);
    });
    this.streamMuxers = /* @__PURE__ */ new Map();
    init.streamMuxers.forEach((muxer) => {
      this.streamMuxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? UPGRADE_TIMEOUT;
    this.outboundUpgradeTimeout = init.outboundUpgradeTimeout ?? UPGRADE_TIMEOUT;
    this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
    this.events = components.events;
    this.metrics = {
      dials: (_a12 = components.metrics) == null ? void 0 : _a12.registerCounterGroup("libp2p_connection_manager_dials_total"),
      errors: (_b3 = components.metrics) == null ? void 0 : _b3.registerCounterGroup("libp2p_connection_manager_dial_errors_total")
    };
  }
  async shouldBlockConnection(method, ...args) {
    const denyOperation = this.components.connectionGater[method];
    if (denyOperation == null) {
      return;
    }
    const result = await denyOperation.apply(this.components.connectionGater, args);
    if (result === true) {
      throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
    }
  }
  /**
   * Upgrades an inbound connection
   */
  async upgradeInbound(maConn, opts = {}) {
    var _a12, _b3;
    let accepted = false;
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        inbound: true
      });
      accepted = await this.components.connectionManager.acceptIncomingConnection(maConn);
      if (!accepted) {
        throw new ConnectionDeniedError("Connection denied");
      }
      await this.shouldBlockConnection("denyInboundConnection", maConn);
      await this._performUpgrade(maConn, "inbound", opts);
    } catch (err) {
      (_b3 = this.metrics.errors) == null ? void 0 : _b3.increment({
        inbound: true
      });
      throw err;
    } finally {
      if (accepted) {
        this.components.connectionManager.afterUpgradeInbound();
      }
    }
  }
  /**
   * Upgrades an outbound connection
   */
  async upgradeOutbound(maConn, opts = {}) {
    var _a12, _b3;
    try {
      (_a12 = this.metrics.dials) == null ? void 0 : _a12.increment({
        outbound: true
      });
      const idStr = maConn.remoteAddr.getPeerId();
      let remotePeerId;
      if (idStr != null) {
        remotePeerId = peerIdFromString(idStr);
        await this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn);
      }
      return await this._performUpgrade(maConn, "outbound", opts);
    } catch (err) {
      (_b3 = this.metrics.errors) == null ? void 0 : _b3.increment({
        outbound: true
      });
      throw err;
    }
  }
  async _performUpgrade(maConn, direction, opts) {
    var _a12, _b3, _c;
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    const upgradeTimeoutSignal = AbortSignal.timeout(direction === "inbound" ? this.inboundUpgradeTimeout : this.outboundUpgradeTimeout);
    const signal = anySignal([upgradeTimeoutSignal, opts.signal]);
    setMaxListeners(Infinity, upgradeTimeoutSignal, signal);
    opts.signal = signal;
    (_a12 = this.components.metrics) == null ? void 0 : _a12.trackMultiaddrConnection(maConn);
    maConn.log.trace("starting the %s connection upgrade", direction);
    let protectedConn = maConn;
    if ((opts == null ? void 0 : opts.skipProtection) !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        maConn.log("protecting the %s connection", direction);
        protectedConn = await protector.protect(maConn, opts);
      }
    }
    try {
      encryptedConn = protectedConn;
      if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
        (_b3 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _b3.call(opts, new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await (direction === "inbound" ? this._encryptInbound(protectedConn, {
          ...opts,
          signal
        }) : this._encryptOutbound(protectedConn, {
          ...opts,
          signal
        })));
        const maConn2 = {
          ...protectedConn,
          ...encryptedConn
        };
        await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
      } else {
        const idStr = maConn.remoteAddr.getPeerId();
        if (idStr == null) {
          throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
        }
        const remotePeerId = peerIdFromString(idStr);
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      if (remotePeer.equals(this.components.peerId)) {
        const err = new InvalidPeerIdError("Can not dial self");
        maConn.abort(err);
        throw err;
      }
      upgradedConn = encryptedConn;
      if ((opts == null ? void 0 : opts.muxerFactory) != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.streamMuxers.size > 0) {
        (_c = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _c.call(opts, new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
        const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts) : this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.streamMuxers, opts));
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
      throw err;
    } finally {
      signal.clear();
    }
    await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
    maConn.log("successfully upgraded %s connection", direction);
    return this._createConnection({
      cryptoProtocol,
      direction,
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer,
      limits: opts == null ? void 0 : opts.limits
    });
  }
  /**
   * A convenience method for generating a new `Connection`
   */
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        // Run anytime a remote stream is created
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            var _a12;
            const protocols = this.components.registrar.getProtocols();
            const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            const { stream, protocol } = await handle(muxedStream, protocols, {
              signal,
              log: muxedStream.log,
              yieldBytes: false
            });
            if (connection == null) {
              return;
            }
            connection.log("incoming stream opened on %s", protocol);
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream, connection);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch(async (err) => {
            connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
            if (muxedStream.timeline.close == null) {
              await muxedStream.close();
            }
          });
        }
      });
      newStream = async (protocols, options = {}) => {
        var _a12;
        if (muxer == null) {
          throw new MuxerUnavailableError("Connection is not multiplexed");
        }
        connection.log.trace("starting new stream for protocols %s", protocols);
        const muxedStream = await muxer.newStream();
        connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
        try {
          if (options.signal == null) {
            muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            options = {
              ...options,
              signal
            };
          }
          muxedStream.log.trace("selecting protocol from protocols %s", protocols);
          const { stream, protocol } = await select(muxedStream, protocols, {
            ...options,
            log: muxedStream.log,
            yieldBytes: true
          });
          muxedStream.log.trace("selected protocol %s", protocol);
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount >= outgoingLimit) {
            const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
            muxedStream.abort(err);
            throw err;
          }
          await this.components.peerStore.merge(remotePeer, {
            protocols: [protocol]
          });
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.protocol = protocol;
          if (stream.closeWrite != null) {
            muxedStream.closeWrite = stream.closeWrite;
          }
          if (stream.closeRead != null) {
            muxedStream.closeRead = stream.closeRead;
          }
          if (stream.close != null) {
            muxedStream.close = stream.close;
          }
          (_a12 = this.components.metrics) == null ? void 0 : _a12.trackProtocolStream(muxedStream, connection);
          return muxedStream;
        } catch (err) {
          connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols, err);
          if (muxedStream.timeline.close == null) {
            muxedStream.abort(err);
          }
          throw err;
        }
      };
      void Promise.all([
        muxer.sink(upgradedConn.source),
        upgradedConn.sink(muxer.source)
      ]).catch((err) => {
        connection.log.error("error piping data through muxer - %e", err);
      });
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.status === "open") {
                await connection.close();
              }
            } catch (err) {
              connection.log.error("error closing connection after timeline close %e", err);
            } finally {
              this.events.safeDispatchEvent("connection:close", {
                detail: connection
              });
            }
          })().catch((err) => {
            connection.log.error("error thrown while dispatching connection:close event %e", err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw new MuxerUnavailableError("Connection is not multiplexed");
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      status: "open",
      direction,
      timeline: maConn.timeline,
      multiplexer: muxer == null ? void 0 : muxer.protocol,
      encryption: cryptoProtocol,
      limits,
      logger: this.components.logger,
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => {
        return (muxer == null ? void 0 : muxer.streams) ?? [];
      },
      close: async (options) => {
        await (muxer == null ? void 0 : muxer.close(options));
        await maConn.close(options);
      },
      abort: (err) => {
        maConn.abort(err);
        muxer == null ? void 0 : muxer.abort(err);
      }
    });
    this.events.safeDispatchEvent("connection:open", {
      detail: connection
    });
    connection.__maConnTimeline = _timeline;
    return connection;
  }
  /**
   * Routes incoming streams to the correct handler
   */
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler, options } = this.components.registrar.getHandler(protocol);
    if (connection.limits != null && options.runOnLimitedConnection !== true) {
      throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
    }
    handler({ connection, stream });
  }
  /**
   * Attempts to encrypt the incoming `connection` with the provided `cryptos`
   */
  async _encryptInbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        ...options,
        log: connection.log
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureInbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Attempts to encrypt the given `connection` with the provided connection encrypters.
   * The first `ConnectionEncrypter` module to succeed will be used
   */
  async _encryptOutbound(connection, options) {
    const protocols = Array.from(this.connectionEncrypters.keys());
    try {
      connection.log.trace("selecting encrypter from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      const encrypter = this.connectionEncrypters.get(protocol);
      if (encrypter == null) {
        throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
      }
      connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
      return {
        ...await encrypter.secureOutbound(stream, options),
        protocol
      };
    } catch (err) {
      connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
      throw new EncryptionFailedError(err.message);
    }
  }
  /**
   * Selects one of the given muxers via multistream-select. That
   * muxer will be used for all future streams on the connection.
   */
  async _multiplexOutbound(connection, muxers, options) {
    const protocols = Array.from(muxers.keys());
    connection.log("outbound selecting muxer %s", protocols);
    try {
      connection.log.trace("selecting stream muxer from %s", protocols);
      const { stream, protocol } = await select(connection, protocols, {
        ...options,
        log: connection.log,
        yieldBytes: true
      });
      connection.log("selected %s as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing outbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
  /**
   * Registers support for one of the given muxers via multistream-select. The
   * selected muxer will be used for all future streams on the connection.
   */
  async _multiplexInbound(connection, muxers, options) {
    const protocols = Array.from(muxers.keys());
    connection.log("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        ...options,
        log: connection.log
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      connection.log.error("error multiplexing inbound connection", err);
      throw new MuxerUnavailableError(String(err));
    }
  }
};
_a11 = Symbol.toStringTag;

// node_modules/libp2p/dist/src/version.js
var version = "2.5.0";
var name = "js-libp2p";

// node_modules/libp2p/dist/src/libp2p.js
var _onDiscoveryPeer, onDiscoveryPeer_fn;
var Libp2p = class extends TypedEventEmitter {
  constructor(init) {
    var _a12, _b3, _c, _d, _e, _f;
    super();
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    __privateAdd(this, _onDiscoveryPeer);
    __publicField(this, "peerId");
    __publicField(this, "peerStore");
    __publicField(this, "contentRouting");
    __publicField(this, "peerRouting");
    __publicField(this, "metrics");
    __publicField(this, "services");
    __publicField(this, "logger");
    __publicField(this, "status");
    __publicField(this, "components");
    __publicField(this, "log");
    this.status = "stopped";
    const events2 = new TypedEventEmitter();
    const originalDispatch = events2.dispatchEvent.bind(events2);
    events2.dispatchEvent = (evt) => {
      const internalResult = originalDispatch(evt);
      const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
      return internalResult || externalResult;
    };
    setMaxListeners(Infinity, events2);
    this.peerId = init.peerId;
    this.logger = init.logger ?? defaultLogger();
    this.log = this.logger.forComponent("libp2p");
    this.services = {};
    const components = this.components = defaultComponents({
      peerId: init.peerId,
      privateKey: init.privateKey,
      nodeInfo: init.nodeInfo ?? {
        name,
        version
      },
      logger: this.logger,
      events: events2,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: connectionGater(init.connectionGater),
      dns: init.dns
    });
    this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    }));
    if (init.metrics != null) {
      this.metrics = this.configureComponent("metrics", init.metrics(this.components));
    }
    components.events.addEventListener("peer:update", (evt) => {
      if (evt.detail.previous == null) {
        const peerInfo = {
          id: evt.detail.peer.id,
          multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
        };
        components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
      }
    });
    if (init.connectionProtector != null) {
      this.configureComponent("connectionProtector", init.connectionProtector(components));
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
      streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
      inboundUpgradeTimeout: (_a12 = init.connectionManager) == null ? void 0 : _a12.inboundUpgradeTimeout,
      outboundUpgradeTimeout: (_b3 = init.connectionManager) == null ? void 0 : _b3.outboundUpgradeTimeout
    });
    this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
    this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
    if (((_c = init.connectionMonitor) == null ? void 0 : _c.enabled) !== false) {
      this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
    }
    this.configureComponent("registrar", new DefaultRegistrar(this.components));
    this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
    const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
    this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
    this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    this.configureComponent("randomWalk", new RandomWalk(this.components));
    (init.peerDiscovery ?? []).forEach((fn, index) => {
      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
      service.addEventListener("peer", (evt) => {
        __privateMethod(this, _onDiscoveryPeer, onDiscoveryPeer_fn).call(this, evt);
      });
    });
    (_d = init.transports) == null ? void 0 : _d.forEach((fn, index) => {
      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
    });
    if (init.services != null) {
      for (const name2 of Object.keys(init.services)) {
        const createService = init.services[name2];
        const service = createService(this.components);
        if (service == null) {
          this.log.error("service factory %s returned null or undefined instance", name2);
          continue;
        }
        this.services[name2] = service;
        this.configureComponent(name2, service);
        if (service[contentRoutingSymbol] != null) {
          this.log("registering service %s for content routing", name2);
          contentRouters.push(service[contentRoutingSymbol]);
        }
        if (service[peerRoutingSymbol] != null) {
          this.log("registering service %s for peer routing", name2);
          peerRouters.push(service[peerRoutingSymbol]);
        }
        if (service[peerDiscoverySymbol] != null) {
          this.log("registering service %s for peer discovery", name2);
          (_f = (_e = service[peerDiscoverySymbol]).addEventListener) == null ? void 0 : _f.call(_e, "peer", (evt) => {
            __privateMethod(this, _onDiscoveryPeer, onDiscoveryPeer_fn).call(this, evt);
          });
        }
      }
    }
    checkServiceDependencies(components);
  }
  configureComponent(name2, component) {
    if (component == null) {
      this.log.error("component %s was null or undefined", name2);
    }
    this.components[name2] = component;
    return component;
  }
  /**
   * Starts the libp2p node and all its subsystems
   */
  async start() {
    var _a12, _b3, _c, _d;
    if (this.status !== "stopped") {
      return;
    }
    this.status = "starting";
    this.log("libp2p is starting");
    try {
      await ((_b3 = (_a12 = this.components).beforeStart) == null ? void 0 : _b3.call(_a12));
      await this.components.start();
      await ((_d = (_c = this.components).afterStart) == null ? void 0 : _d.call(_c));
      this.status = "started";
      this.safeDispatchEvent("start", { detail: this });
      this.log("libp2p has started");
    } catch (err) {
      this.log.error("An error occurred starting libp2p", err);
      this.status = "started";
      await this.stop();
      throw err;
    }
  }
  /**
   * Stop the libp2p node by closing its listeners and open connections
   */
  async stop() {
    var _a12, _b3, _c, _d;
    if (this.status !== "started") {
      return;
    }
    this.log("libp2p is stopping");
    this.status = "stopping";
    await ((_b3 = (_a12 = this.components).beforeStop) == null ? void 0 : _b3.call(_a12));
    await this.components.stop();
    await ((_d = (_c = this.components).afterStop) == null ? void 0 : _d.call(_c));
    this.status = "stopped";
    this.safeDispatchEvent("stop", { detail: this });
    this.log("libp2p has stopped");
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getDialQueue() {
    return this.components.connectionManager.getDialQueue();
  }
  getPeers() {
    const peerSet2 = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet2.add(conn.remotePeer);
    }
    return Array.from(peerSet2);
  }
  async dial(peer, options = {}) {
    return this.components.connectionManager.openConnection(peer, {
      // ensure any userland dials take top priority in the queue
      priority: 75,
      ...options
    });
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw new InvalidParametersError("no protocols were provided to open a stream");
    }
    const connection = await this.dial(peer, options);
    return connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  getProtocols() {
    return this.components.registrar.getProtocols();
  }
  async hangUp(peer, options = {}) {
    if (isMultiaddr(peer)) {
      peer = peerIdFromString(peer.getPeerId() ?? "");
    }
    await this.components.connectionManager.closeConnections(peer, options);
  }
  async getPublicKey(peer, options = {}) {
    this.log("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    try {
      const peerInfo = await this.peerStore.get(peer);
      if (peerInfo.id.publicKey != null) {
        return peerInfo.id.publicKey;
      }
    } catch (err) {
      if (err.name !== "NotFoundError") {
        throw err;
      }
    }
    const peerKey = concat([
      fromString("/pk/"),
      peer.toMultihash().bytes
    ]);
    const bytes = await this.contentRouting.get(peerKey, options);
    const publicKey = publicKeyFromProtobuf(bytes);
    await this.peerStore.patch(peer, {
      publicKey
    });
    return publicKey;
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  async register(protocol, topology) {
    return this.components.registrar.register(protocol, topology);
  }
  unregister(id) {
    this.components.registrar.unregister(id);
  }
  async isDialable(multiaddr2, options = {}) {
    return this.components.connectionManager.isDialable(multiaddr2, options);
  }
};
_onDiscoveryPeer = new WeakSet();
onDiscoveryPeer_fn = function(evt) {
  const { detail: peer } = evt;
  if (peer.id.toString() === this.peerId.toString()) {
    this.log.error("peer discovery mechanism discovered self");
    return;
  }
  void this.components.peerStore.merge(peer.id, {
    multiaddrs: peer.multiaddrs
  }).catch((err) => {
    this.log.error(err);
  });
};

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options = {}) {
  options.privateKey ?? (options.privateKey = await generateKeyPair("Ed25519"));
  const node = new Libp2p({
    ...await validateConfig(options),
    peerId: peerIdFromPrivateKey(options.privateKey)
  });
  if (options.start !== false) {
    await node.start();
  }
  return node;
}

export {
  anySignal,
  raceEvent,
  Queue,
  PeerQueue,
  src_default5 as src_default,
  src_default7 as src_default2,
  PeerMap,
  PeerSet,
  peerSet,
  pbkdf2Async,
  pbkdf22 as pbkdf2,
  createScalableCuckooFilter,
  peerFilter,
  trackedPeerMap,
  dns,
  Key,
  createMortice,
  NotFoundError2 as NotFoundError,
  trackedMap,
  isPrivateIp,
  MemoryDatastore,
  isPrivate,
  RecordEnvelope,
  PeerRecord2 as PeerRecord,
  delay_default,
  AdaptiveTimeout,
  RateLimiter,
  version,
  name,
  createLibp2p
};
//# sourceMappingURL=chunk-S4I5QFW2.js.map
