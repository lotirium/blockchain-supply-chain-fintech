{
  "version": 3,
  "sources": ["../../get-iterator/src/index.ts", "../../@chainsafe/libp2p-yamux/src/errors.ts", "../../@chainsafe/libp2p-yamux/src/constants.ts", "../../@chainsafe/libp2p-yamux/src/config.ts", "../../@chainsafe/libp2p-yamux/src/frame.ts", "../../@chainsafe/libp2p-yamux/src/decode.ts", "../../@chainsafe/libp2p-yamux/src/encode.ts", "../../@libp2p/utils/src/is-promise.ts", "../../@libp2p/utils/src/close-source.ts", "../../@libp2p/utils/src/abstract-stream.ts", "../../it-foreach/node_modules/it-peekable/src/index.ts", "../../it-foreach/src/index.ts", "../../@chainsafe/libp2p-yamux/src/stream.ts", "../../@chainsafe/libp2p-yamux/src/muxer.ts", "../../@chainsafe/libp2p-yamux/src/index.ts"],
  "sourcesContent": ["\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n", "export class InvalidFrameError extends Error {\n  static name = 'InvalidFrameError'\n\n  constructor (message = 'The frame was invalid') {\n    super(message)\n    this.name = 'InvalidFrameError'\n  }\n}\n\nexport class UnrequestedPingError extends Error {\n  static name = 'UnrequestedPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'UnrequestedPingError'\n  }\n}\n\nexport class NotMatchingPingError extends Error {\n  static name = 'NotMatchingPingError'\n\n  constructor (message = 'Unrequested ping error') {\n    super(message)\n    this.name = 'NotMatchingPingError'\n  }\n}\n\nexport class InvalidStateError extends Error {\n  static name = 'InvalidStateError'\n\n  constructor (message = 'Invalid state') {\n    super(message)\n    this.name = 'InvalidStateError'\n  }\n}\n\nexport class StreamAlreadyExistsError extends Error {\n  static name = 'StreamAlreadyExistsError'\n\n  constructor (message = 'Strean already exists') {\n    super(message)\n    this.name = 'StreamAlreadyExistsError'\n  }\n}\n\nexport class DecodeInvalidVersionError extends Error {\n  static name = 'DecodeInvalidVersionError'\n\n  constructor (message = 'Decode invalid version') {\n    super(message)\n    this.name = 'DecodeInvalidVersionError'\n  }\n}\n\nexport class BothClientsError extends Error {\n  static name = 'BothClientsError'\n\n  constructor (message = 'Both clients') {\n    super(message)\n    this.name = 'BothClientsError'\n  }\n}\n\nexport class ReceiveWindowExceededError extends Error {\n  static name = 'ReceiveWindowExceededError'\n\n  constructor (message = 'Receive window exceeded') {\n    super(message)\n    this.name = 'ReceiveWindowExceededError'\n  }\n}\n", "// Protocol violation errors\n\nimport { BothClientsError, DecodeInvalidVersionError, InvalidFrameError, NotMatchingPingError, ReceiveWindowExceededError, StreamAlreadyExistsError, UnrequestedPingError } from './errors.js'\n\nexport const PROTOCOL_ERRORS = new Set([\n  InvalidFrameError.name,\n  UnrequestedPingError.name,\n  NotMatchingPingError.name,\n  StreamAlreadyExistsError.name,\n  DecodeInvalidVersionError.name,\n  BothClientsError.name,\n  ReceiveWindowExceededError.name\n])\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\n\n// TOOD use config items or delete them\nexport interface Config {\n  /**\n   * Used to do periodic keep alive messages using a ping.\n   */\n  enableKeepAlive: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval: number\n\n  /**\n   * Maximum number of concurrent inbound streams that we accept.\n   * If the peer tries to open more streams, those will be reset immediately.\n   */\n  maxInboundStreams: number\n\n  /**\n   * Maximum number of concurrent outbound streams that we accept.\n   * If the application tries to open more streams, the call to `newStream` will throw\n   */\n  maxOutboundStreams: number\n\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize: number\n\n  /**\n   * Maximum size of a message that we'll send on a stream.\n   * This ensures that a single stream doesn't hog a connection.\n   */\n  maxMessageSize: number\n}\n\nexport const defaultConfig: Config = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n  maxStreamWindowSize: MAX_STREAM_WINDOW,\n  maxMessageSize: 64 * 1024\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval <= 0) {\n    throw new InvalidParametersError('keep-alive interval must be positive')\n  }\n  if (config.maxInboundStreams < 0) {\n    throw new InvalidParametersError('max inbound streams must be larger or equal 0')\n  }\n  if (config.maxOutboundStreams < 0) {\n    throw new InvalidParametersError('max outbound streams must be larger or equal 0')\n  }\n  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new InvalidParametersError('InitialStreamWindowSize must be larger or equal 256 kB')\n  }\n  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize')\n  }\n  if (config.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new InvalidParametersError('MaxStreamWindowSize must be less than equal MAX_UINT32')\n  }\n  if (config.maxMessageSize < 1024) {\n    throw new InvalidParametersError('MaxMessageSize must be greater than a kilobyte')\n  }\n}\n", "export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3,\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8,\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2,\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * * Data - provides the length of bytes following the header\n   * * Window update - provides a delta update to the window size\n   * * Ping - Contains an opaque value, echoed back\n   * * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport { InvalidFrameError, InvalidStateError } from './errors.js'\nimport { type FrameHeader, FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { Source } from 'it-stream-types'\n\n// used to bitshift in decoding\n// native bitshift can overflow into a negative number, so we bitshift by multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new InvalidFrameError('Invalid frame version')\n  }\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  private readonly source: Source<Uint8Array | Uint8ArrayList>\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n  /** Used to sanity check against decoding while in an inconsistent state */\n  private frameInProgress: boolean\n\n  constructor (source: Source<Uint8Array | Uint8ArrayList>) {\n    // Normally, when entering a for-await loop with an iterable/async iterable, the only ways to exit the loop are:\n    // 1. exhaust the iterable\n    // 2. throw an error - slow, undesirable if there's not actually an error\n    // 3. break or return - calls the iterable's `return` method, finalizing the iterable, no more iteration possible\n    //\n    // In this case, we want to enter (and exit) a for-await loop per chunked data frame and continue processing the iterable.\n    // To do this, we strip the `return` method from the iterator and can now `break` early and continue iterating.\n    // Exiting the main for-await is still possible via 1. and 2.\n    this.source = returnlessSource(source)\n    this.buffer = new Uint8ArrayList()\n    this.frameInProgress = false\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  async * emitFrames (): AsyncGenerator<{ header: FrameHeader, readData?(): Promise<Uint8ArrayList> }> {\n    for await (const chunk of this.source) {\n      this.buffer.append(chunk)\n\n      // Loop to consume as many bytes from the buffer as possible\n      // Eg: when a single chunk contains several frames\n      while (true) {\n        const header = this.readHeader()\n        if (header === undefined) {\n          break\n        }\n\n        const { type, length } = header\n        if (type === FrameType.Data) {\n          // This is a data frame, the frame body must still be read\n          // `readData` must be called before the next iteration here\n          this.frameInProgress = true\n          yield {\n            header,\n            readData: this.readBytes.bind(this, length)\n          }\n        } else {\n          yield { header }\n        }\n      }\n    }\n  }\n\n  private readHeader (): FrameHeader | undefined {\n    // Sanity check to ensure a header isn't read when another frame is partially decoded\n    // In practice this shouldn't happen\n    if (this.frameInProgress) {\n      throw new InvalidStateError('decoding frame already in progress')\n    }\n\n    if (this.buffer.length < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n    this.buffer.consume(HEADER_LENGTH)\n    return header\n  }\n\n  private async readBytes (length: number): Promise<Uint8ArrayList> {\n    if (this.buffer.length < length) {\n      for await (const chunk of this.source) {\n        this.buffer.append(chunk)\n\n        if (this.buffer.length >= length) {\n          // see note above, the iterator is not `return`ed here\n          break\n        }\n      }\n    }\n\n    const out = this.buffer.sublist(0, length)\n    this.buffer.consume(length)\n\n    // The next frame can now be decoded\n    this.frameInProgress = false\n\n    return out\n  }\n}\n\n/**\n * Strip the `return` method from a `Source`\n */\nexport function returnlessSource<T> (source: Source<T>): Source<T> {\n  if ((source as Iterable<T>)[Symbol.iterator] !== undefined) {\n    const iterator = (source as Iterable<T>)[Symbol.iterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.iterator] () { return iterator }\n    }\n  } else if ((source as AsyncIterable<T>)[Symbol.asyncIterator] !== undefined) {\n    const iterator = (source as AsyncIterable<T>)[Symbol.asyncIterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.asyncIterator] () { return iterator }\n    }\n  } else {\n    throw new Error('a source must be either an iterable or an async iterable')\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { getIterator } from 'get-iterator'\nimport { isPromise } from './is-promise.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nexport function closeSource (source: Source<unknown>, log: Logger): void {\n  const res = getIterator(source).return?.()\n\n  if (isPromise(res)) {\n    res.catch(err => {\n      log.error('could not cause iterator to return', err)\n    })\n  }\n}\n", "import { StreamResetError, StreamStateError } from '@libp2p/interface'\nimport { type Pushable, pushable } from 'it-pushable'\nimport defer, { type DeferredPromise } from 'p-defer'\nimport pDefer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { closeSource } from './close-source.js'\nimport type { AbortOptions, Direction, ReadStatus, Stream, StreamStatus, StreamTimeline, WriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000\n\nexport interface AbstractStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * User specific stream metadata\n   */\n  metadata?: Record<string, unknown>\n\n  /**\n   * Invoked when the stream ends\n   */\n  onEnd?(err?: Error | undefined): void\n\n  /**\n   * Invoked when the readable end of the stream is closed\n   */\n  onCloseRead?(): void\n\n  /**\n   * Invoked when the writable end of the stream is closed\n   */\n  onCloseWrite?(): void\n\n  /**\n   * Invoked when the stream has been reset by the remote\n   */\n  onReset?(): void\n\n  /**\n   * Invoked when the stream has errored\n   */\n  onAbort?(err: Error): void\n\n  /**\n   * How long to wait in ms for stream data to be written to the underlying\n   * connection when closing the writable end of the stream.\n   *\n   * @default 500\n   */\n  closeTimeout?: number\n\n  /**\n   * After the stream sink has closed, a limit on how long it takes to send\n   * a close-write message to the remote peer.\n   */\n  sendCloseWriteTimeout?: number\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n\nexport abstract class AbstractStream implements Stream {\n  public id: string\n  public direction: Direction\n  public timeline: StreamTimeline\n  public protocol?: string\n  public metadata: Record<string, unknown>\n  public source: AsyncGenerator<Uint8ArrayList, void, unknown>\n  public status: StreamStatus\n  public readStatus: ReadStatus\n  public writeStatus: WriteStatus\n  public readonly log: Logger\n\n  private readonly sinkController: AbortController\n  private readonly sinkEnd: DeferredPromise<void>\n  private readonly closed: DeferredPromise<void>\n  private endErr: Error | undefined\n  private readonly streamSource: Pushable<Uint8ArrayList>\n  private readonly onEnd?: (err?: Error | undefined) => void\n  private readonly onCloseRead?: () => void\n  private readonly onCloseWrite?: () => void\n  private readonly onReset?: () => void\n  private readonly onAbort?: (err: Error) => void\n  private readonly sendCloseWriteTimeout: number\n  private sendingData?: DeferredPromise<void>\n\n  constructor (init: AbstractStreamInit) {\n    this.sinkController = new AbortController()\n    this.sinkEnd = defer()\n    this.closed = defer()\n    this.log = init.log\n\n    // stream status\n    this.status = 'open'\n    this.readStatus = 'ready'\n    this.writeStatus = 'ready'\n\n    this.id = init.id\n    this.metadata = init.metadata ?? {}\n    this.direction = init.direction\n    this.timeline = {\n      open: Date.now()\n    }\n    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT\n\n    this.onEnd = init.onEnd\n    this.onCloseRead = init?.onCloseRead\n    this.onCloseWrite = init?.onCloseWrite\n    this.onReset = init?.onReset\n    this.onAbort = init?.onAbort\n\n    this.source = this.streamSource = pushable<Uint8ArrayList>({\n      onEnd: (err) => {\n        if (err != null) {\n          this.log.trace('source ended with error', err)\n        } else {\n          this.log.trace('source ended')\n        }\n\n        this.onSourceEnd(err)\n      }\n    })\n\n    // necessary because the libp2p upgrader wraps the sink function\n    this.sink = this.sink.bind(this)\n  }\n\n  async sink (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> {\n    if (this.writeStatus !== 'ready') {\n      throw new StreamStateError(`writable end state is \"${this.writeStatus}\" not \"ready\"`)\n    }\n\n    try {\n      this.writeStatus = 'writing'\n\n      const options: AbortOptions = {\n        signal: this.sinkController.signal\n      }\n\n      if (this.direction === 'outbound') { // If initiator, open a new stream\n        const res = this.sendNewStream(options)\n\n        if (isPromise(res)) {\n          await res\n        }\n      }\n\n      const abortListener = (): void => {\n        closeSource(source, this.log)\n      }\n\n      try {\n        this.sinkController.signal.addEventListener('abort', abortListener)\n\n        this.log.trace('sink reading from source')\n\n        for await (let data of source) {\n          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n\n          const res = this.sendData(data, options)\n\n          if (isPromise(res)) {\n            this.sendingData = pDefer()\n            await res\n            this.sendingData.resolve()\n            this.sendingData = undefined\n          }\n        }\n      } finally {\n        this.sinkController.signal.removeEventListener('abort', abortListener)\n      }\n\n      this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus)\n\n      if (this.writeStatus === 'writing') {\n        this.writeStatus = 'closing'\n\n        this.log.trace('send close write to remote')\n        await this.sendCloseWrite({\n          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n        })\n\n        this.writeStatus = 'closed'\n      }\n\n      this.onSinkEnd()\n    } catch (err: any) {\n      this.log.trace('sink ended with error, calling abort with error', err)\n      this.abort(err)\n\n      throw err\n    } finally {\n      this.log.trace('resolve sink end')\n      this.sinkEnd.resolve()\n    }\n  }\n\n  protected onSourceEnd (err?: Error): void {\n    if (this.timeline.closeRead != null) {\n      return\n    }\n\n    this.timeline.closeRead = Date.now()\n    this.readStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseRead?.()\n\n    if (this.timeline.closeWrite != null) {\n      this.log.trace('source and sink ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('source ended, waiting for sink to end')\n    }\n  }\n\n  protected onSinkEnd (err?: Error): void {\n    if (this.timeline.closeWrite != null) {\n      return\n    }\n\n    this.timeline.closeWrite = Date.now()\n    this.writeStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseWrite?.()\n\n    if (this.timeline.closeRead != null) {\n      this.log.trace('sink and source ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('sink ended, waiting for source to end')\n    }\n  }\n\n  // Close for both Reading and Writing\n  async close (options?: AbortOptions): Promise<void> {\n    if (this.status !== 'open') {\n      return\n    }\n\n    this.log.trace('closing gracefully')\n\n    this.status = 'closing'\n\n    // wait for read and write ends to close\n    await raceSignal(Promise.all([\n      this.closeWrite(options),\n      this.closeRead(options),\n      this.closed.promise\n    ]), options?.signal)\n\n    this.status = 'closed'\n\n    this.log.trace('closed gracefully')\n  }\n\n  async closeRead (options: AbortOptions = {}): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus)\n\n    const readStatus = this.readStatus\n    this.readStatus = 'closing'\n\n    if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n      this.log.trace('send close read to remote')\n      await this.sendCloseRead(options)\n    }\n\n    if (readStatus === 'ready') {\n      this.log.trace('ending internal source queue with %d queued bytes', this.streamSource.readableLength)\n      this.streamSource.end()\n    }\n\n    this.log.trace('closed readable end of stream')\n  }\n\n  async closeWrite (options: AbortOptions = {}): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus)\n\n    if (this.writeStatus === 'ready') {\n      this.log.trace('sink was never sunk, sink an empty array')\n\n      await raceSignal(this.sink([]), options.signal)\n    }\n\n    if (this.writeStatus === 'writing') {\n      // try to let sending outgoing data succeed\n      if (this.sendingData != null) {\n        await raceSignal(this.sendingData.promise, options.signal)\n      }\n\n      // stop reading from the source passed to `.sink`\n      this.log.trace('aborting source passed to .sink')\n      this.sinkController.abort()\n      await raceSignal(this.sinkEnd.promise, options.signal)\n    }\n\n    this.writeStatus = 'closed'\n\n    this.log.trace('closed writable end of stream')\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    this.log('abort with error', err)\n\n    // try to send a reset message\n    this.log('try to send reset to remote')\n    const res = this.sendReset()\n\n    if (isPromise(res)) {\n      res.catch((err) => {\n        this.log.error('error sending reset message', err)\n      })\n    }\n\n    this.status = 'aborted'\n    this.timeline.abort = Date.now()\n    this._closeSinkAndSource(err)\n    this.onAbort?.(err)\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  reset (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    const err = new StreamResetError('stream reset')\n\n    this.status = 'reset'\n    this.timeline.reset = Date.now()\n    this._closeSinkAndSource(err)\n    this.onReset?.()\n  }\n\n  _closeSinkAndSource (err?: Error): void {\n    this._closeSink(err)\n    this._closeSource(err)\n  }\n\n  _closeSink (err?: Error): void {\n    // if the sink function is running, cause it to end\n    if (this.writeStatus === 'writing') {\n      this.log.trace('end sink source')\n      this.sinkController.abort()\n    }\n\n    this.onSinkEnd(err)\n  }\n\n  _closeSource (err?: Error): void {\n    // if the source is not ending, end it\n    if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n      this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength)\n      this.readStatus = 'closing'\n      this.streamSource.end(err)\n    }\n  }\n\n  /**\n   * The remote closed for writing so we should expect to receive no more\n   * messages\n   */\n  remoteCloseWrite (): void {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('received remote close write but local source is already closed')\n      return\n    }\n\n    this.log.trace('remote close write')\n    this._closeSource()\n  }\n\n  /**\n   * The remote closed for reading so we should not send any more\n   * messages\n   */\n  remoteCloseRead (): void {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      this.log('received remote close read but local sink is already closed')\n      return\n    }\n\n    this.log.trace('remote close read')\n    this._closeSink()\n  }\n\n  /**\n   * The underlying muxer has closed, no more messages can be sent or will\n   * be received, close immediately to free up resources\n   */\n  destroy (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      this.log('received destroy but we are already closed')\n      return\n    }\n\n    this.log.trace('stream destroyed')\n\n    this._closeSinkAndSource()\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  sourcePush (data: Uint8ArrayList): void {\n    this.streamSource.push(data)\n  }\n\n  /**\n   * Returns the amount of unread data - can be used to prevent large amounts of\n   * data building up when the stream consumer is too slow.\n   */\n  sourceReadableLength (): number {\n    return this.streamSource.readableLength\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened\n   */\n  abstract sendNewStream (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  abstract sendData (buf: Uint8ArrayList, options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  abstract sendReset (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  abstract sendCloseWrite (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  abstract sendCloseRead (options?: AbortOptions): void | Promise<void>\n}\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing?.then != null\n}\n\n/**\n * Invokes the passed function for each item in an iterable\n */\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => void): Generator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  // if fn function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  if (typeof res?.then === 'function') {\n    return (async function * () {\n      yield value\n\n      for await (const val of peekable) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => void\n\n  return (function * () {\n    yield value\n\n    for (const val of peekable) {\n      func(val, index++)\n      yield val\n    }\n  })()\n}\n\nexport default forEach\n", "import { AbortError } from '@libp2p/interface'\nimport { AbstractStream, type AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport each from 'it-foreach'\nimport { INITIAL_STREAM_WINDOW } from './constants.js'\nimport { ReceiveWindowExceededError } from './errors.js'\nimport { Flag, type FrameHeader, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Config } from './config.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished,\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  name?: string\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): void\n  getRTT(): number\n  config: Config\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  name?: string\n  state: StreamState\n\n  private readonly config: Config\n  private readonly _id: number\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** Callback to notify that the sendWindowCapacity has been updated */\n  private sendWindowCapacityUpdate?: () => void\n\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => void\n\n  constructor (init: YamuxStreamInit) {\n    super({\n      ...init,\n      onEnd: (err?: Error) => {\n        this.state = StreamState.Finished\n        init.onEnd?.(err)\n      }\n    })\n\n    this.config = init.config\n    this._id = parseInt(init.id, 10)\n    this.name = init.name\n    this.state = init.state\n    this.sendWindowCapacity = INITIAL_STREAM_WINDOW\n    this.recvWindow = this.config.initialStreamWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n\n    this.sendFrame = init.sendFrame\n\n    this.source = each(this.source, () => {\n      this.sendWindowUpdate()\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened.\n   *\n   * This is a noop for Yamux because the first window update is sent when\n   * .newStream is called on the muxer which opens the stream on the remote.\n   */\n  async sendNewStream (): Promise<void> {\n\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  async sendData (buf: Uint8ArrayList, options: AbortOptions = {}): Promise<void> {\n    buf = buf.sublist()\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength !== 0) {\n      // wait for the send window to refill\n      if (this.sendWindowCapacity === 0) {\n        this.log?.trace('wait for send window capacity, status %s', this.status)\n        await this.waitForSendWindowCapacity(options)\n\n        // check we didn't close while waiting for send window capacity\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n          this.log?.trace('%s while waiting for send window capacity', this.status)\n          return\n        }\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length)\n      const flags = this.getSendFlags()\n\n      this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this._id,\n        length: toSend\n      }, buf.sublist(0, toSend))\n\n      this.sendWindowCapacity -= toSend\n\n      buf.consume(toSend)\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  async sendReset (): Promise<void> {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  async sendCloseRead (): Promise<void> {\n\n  }\n\n  /**\n   * Wait for the send window to be non-zero\n   *\n   * Will throw with ERR_STREAM_ABORT if the stream gets aborted\n   */\n  async waitForSendWindowCapacity (options: AbortOptions = {}): Promise<void> {\n    if (this.sendWindowCapacity > 0) {\n      return\n    }\n\n    let resolve: () => void\n    let reject: (err: Error) => void\n    const abort = (): void => {\n      if (this.status === 'open' || this.status === 'closing') {\n        reject(new AbortError('Stream aborted'))\n      } else {\n        // the stream was closed already, ignore the failure to send\n        resolve()\n      }\n    }\n    options.signal?.addEventListener('abort', abort)\n\n    try {\n      await new Promise<void>((_resolve, _reject) => {\n        this.sendWindowCapacityUpdate = () => {\n          _resolve()\n        }\n        reject = _reject\n        resolve = _resolve\n      })\n    } finally {\n      options.signal?.removeEventListener('abort', abort)\n    }\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (header: FrameHeader): void {\n    this.log?.trace('stream received window update id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // increase send window\n    const available = this.sendWindowCapacity\n    this.sendWindowCapacity += header.length\n    // if the update increments a 0 availability, notify the stream that sending can resume\n    if (available === 0 && header.length > 0) {\n      this.sendWindowCapacityUpdate?.()\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  async handleData (header: FrameHeader, readData: () => Promise<Uint8ArrayList>): Promise<void> {\n    this.log?.trace('stream received data id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < header.length) {\n      throw new ReceiveWindowExceededError('Receive window exceeded')\n    }\n\n    const data = await readData()\n    this.recvWindowCapacity -= header.length\n\n    this.sourcePush(data)\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.remoteCloseWrite()\n    }\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.reset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * potentially sends a window update enabling further writes to take place.\n   */\n  sendWindowUpdate (): void {\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: delta\n    })\n  }\n}\n", "import { InvalidParametersError, MuxerClosedError, TooManyOutboundProtocolStreamsError, serviceCapabilities, setMaxListeners } from '@libp2p/interface'\nimport { getIterator } from 'get-iterator'\nimport { pushable, type Pushable } from 'it-pushable'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { type Config, defaultConfig, verifyConfig } from './config.js'\nimport { PROTOCOL_ERRORS } from './constants.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { InvalidFrameError, NotMatchingPingError, UnrequestedPingError } from './errors.js'\nimport { Flag, type FrameHeader, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { YamuxMuxerComponents } from './index.js'\nimport type { AbortOptions, ComponentLogger, Logger, Stream, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\nimport type { Sink, Source } from 'it-stream-types'\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\nconst CLOSE_TIMEOUT = 500\n\nexport interface YamuxMuxerInit extends StreamMuxerInit, Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _components: YamuxMuxerComponents\n  private readonly _init: YamuxMuxerInit\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit = {}) {\n    this._components = components\n    this._init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-yamux'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/stream-multiplexing'\n  ]\n\n  createStreamMuxer (init?: YamuxMuxerInit): YamuxMuxer {\n    return new YamuxMuxer(this._components, {\n      ...this._init,\n      ...init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport class YamuxMuxer implements StreamMuxer {\n  protocol = YAMUX_PROTOCOL_ID\n  source: Pushable<Uint8ArrayList | Uint8Array>\n  sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>\n\n  private readonly config: Config\n  private readonly log?: Logger\n  private readonly logger: ComponentLogger\n\n  /** Used to close the muxer from either the sink or source */\n  private readonly closeController: AbortController\n\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n  /** Primary stream mapping, streamID => stream */\n  private readonly _streams: Map<number, YamuxStream>\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: { id: number, promise: Promise<void>, resolve(): void }\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private readonly client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private readonly onIncomingStream?: (stream: Stream) => void\n  private readonly onStreamEnd?: (stream: Stream) => void\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit) {\n    this.client = init.direction === 'outbound'\n    this.config = { ...defaultConfig, ...init }\n    this.logger = components.logger\n    this.log = this.logger.forComponent('libp2p:yamux')\n    verifyConfig(this.config)\n\n    this.closeController = new AbortController()\n    setMaxListeners(Infinity, this.closeController.signal)\n\n    this.onIncomingStream = init.onIncomingStream\n    this.onStreamEnd = init.onStreamEnd\n\n    this._streams = new Map()\n\n    this.source = pushable({\n      onEnd: (): void => {\n        this.log?.trace('muxer source ended')\n\n        this._streams.forEach(stream => {\n          stream.destroy()\n        })\n      }\n    })\n\n    this.sink = async (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> => {\n      const shutDownListener = (): void => {\n        const iterator = getIterator(source)\n\n        if (iterator.return != null) {\n          const res = iterator.return()\n\n          if (isPromise(res)) {\n            res.catch(err => {\n              this.log?.('could not cause sink source to return', err)\n            })\n          }\n        }\n      }\n\n      let reason, error\n      try {\n        const decoder = new Decoder(source)\n\n        try {\n          this.closeController.signal.addEventListener('abort', shutDownListener)\n\n          for await (const frame of decoder.emitFrames()) {\n            await this.handleFrame(frame.header, frame.readData)\n          }\n        } finally {\n          this.closeController.signal.removeEventListener('abort', shutDownListener)\n        }\n\n        reason = GoAwayCode.NormalTermination\n      } catch (err: any) {\n        // either a protocol or internal error\n        if (PROTOCOL_ERRORS.has(err.name)) {\n          this.log?.error('protocol error in sink', err)\n          reason = GoAwayCode.ProtocolError\n        } else {\n          this.log?.error('internal error in sink', err)\n          reason = GoAwayCode.InternalError\n        }\n\n        error = err as Error\n      }\n\n      this.log?.trace('muxer sink ended')\n\n      if (error != null) {\n        this.abort(error, reason)\n      } else {\n        await this.close({ reason })\n      }\n    }\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log?.trace('muxer created')\n\n    if (this.config.enableKeepAlive) {\n      this.keepAliveLoop().catch(e => this.log?.error('keepalive error: %s', e))\n    }\n\n    // send an initial ping to establish RTT\n    this.ping().catch(e => this.log?.error('ping error: %s', e))\n  }\n\n  get streams (): YamuxStream[] {\n    return Array.from(this._streams.values())\n  }\n\n  newStream (name?: string | undefined): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {\n      throw new TooManyOutboundProtocolStreamsError('max outbound streams exceeded')\n    }\n\n    this.log?.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, name, StreamState.Init, 'outbound')\n    this._streams.set(id, stream)\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end\n    stream.sendWindowUpdate()\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed remotely')\n    }\n    if (this.localGoAway !== undefined) {\n      throw new MuxerClosedError('Muxer closed locally')\n    }\n\n    // An active ping does not yet exist, handle the process here\n    if (this.activePing === undefined) {\n      // create active ping\n      let _resolve = (): void => {}\n      this.activePing = {\n        id: this.nextPingID++,\n        // this promise awaits resolution or the close controller aborting\n        promise: new Promise<void>((resolve, reject) => {\n          const closed = (): void => {\n            reject(new MuxerClosedError('Muxer closed locally'))\n          }\n          this.closeController.signal.addEventListener('abort', closed, { once: true })\n          _resolve = (): void => {\n            this.closeController.signal.removeEventListener('abort', closed)\n            resolve()\n          }\n        }),\n        resolve: _resolve\n      }\n      // send ping\n      const start = Date.now()\n      this.sendPing(this.activePing.id)\n      // await pong\n      try {\n        await this.activePing.promise\n      } finally {\n        // clean-up active ping\n        delete this.activePing\n      }\n      // update rtt\n      const end = Date.now()\n      this.rtt = end - start\n    } else {\n      // an active ping is already in progress, piggyback off that\n      await this.activePing.promise\n    }\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n    this.log?.trace('muxer close reason=%s', reason)\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      await Promise.all(\n        [...this._streams.values()].map(async s => s.close(options))\n      )\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n\n      this._closeMuxer()\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error, reason?: GoAwayCode): void {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    reason = reason ?? GoAwayCode.InternalError\n\n    // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n    this.log?.error('muxer abort reason=%s error=%s', reason, err)\n\n    // Abort all underlying streams\n    for (const stream of this._streams.values()) {\n      stream.abort(err)\n    }\n\n    // send reason to the other side, allow the other side to close gracefully\n    this.sendGoAway(reason)\n\n    this._closeMuxer()\n  }\n\n  isClosed (): boolean {\n    return this.closeController.signal.aborted\n  }\n\n  /**\n   * Called when either the local or remote shuts down the muxer\n   */\n  private _closeMuxer (): void {\n    // stop the sink and any other processes\n    this.closeController.abort()\n\n    // stop the source\n    this.source.end()\n  }\n\n  /** Create a new stream */\n  private _newStream (id: number, name: string | undefined, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this._streams.get(id) != null) {\n      throw new InvalidParametersError('Stream already exists with that id')\n    }\n\n    const stream = new YamuxStream({\n      id: id.toString(),\n      name,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      onEnd: () => {\n        this.closeStream(id)\n        this.onStreamEnd?.(stream)\n      },\n      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),\n      config: this.config,\n      getRTT: this.getRTT.bind(this)\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n    this._streams.delete(id)\n  }\n\n  private async keepAliveLoop (): Promise<void> {\n    const abortPromise = new Promise((_resolve, reject) => { this.closeController.signal.addEventListener('abort', reject, { once: true }) })\n    this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval)\n    while (true) {\n      let timeoutId\n      try {\n        await Promise.race([\n          abortPromise,\n          new Promise((resolve) => {\n            timeoutId = setTimeout(resolve, this.config.keepAliveInterval)\n          })\n        ])\n        this.ping().catch(e => this.log?.error('ping error: %s', e))\n      } catch (e) {\n        // closed\n        clearInterval(timeoutId)\n        return\n      }\n    }\n  }\n\n  private async handleFrame (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const {\n      streamID,\n      type,\n      length\n    } = header\n    this.log?.trace('received frame %o', header)\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    } else {\n      switch (header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { await this.handleStreamMessage(header, readData); return }\n        default:\n          // Invalid state\n          throw new InvalidFrameError('Invalid frame type')\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log?.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log?.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new InvalidFrameError('Invalid frame flag')\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new UnrequestedPingError('ping not requested')\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new NotMatchingPingError('ping doesn\\'t match our id')\n    }\n\n    // valid ping response\n    this.activePing.resolve()\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log?.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    // If the other side is friendly, they would have already closed all streams before sending a GoAway\n    // In case they weren't, reset all streams\n    for (const stream of this._streams.values()) {\n      stream.reset()\n    }\n\n    this._closeMuxer()\n  }\n\n  private async handleStreamMessage (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const { streamID, flag, type } = header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this._streams.get(streamID)\n    if (stream === undefined) {\n      if (type === FrameType.Data) {\n        this.log?.('discarding data for stream id=%s', streamID)\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n        await readData()\n      } else {\n        this.log?.trace('frame for missing stream id=%s', streamID)\n      }\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(header); return\n      }\n      case FrameType.Data: {\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n\n        await stream.handleData(header, readData); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new InvalidParametersError('Both endpoints are clients')\n    }\n    if (this._streams.has(id)) {\n      return\n    }\n\n    this.log?.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.config.maxInboundStreams) {\n      this.log?.('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, undefined, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n    // the stream should now be tracked\n    this._streams.set(id, stream)\n\n    this.onIncomingStream?.(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): void {\n    this.log?.trace('sending frame %o', header)\n    if (header.type === FrameType.Data) {\n      if (data === undefined) {\n        throw new InvalidFrameError('Invalid frame')\n      }\n      this.source.push(\n        new Uint8ArrayList(encodeHeader(header), data)\n      )\n    } else {\n      this.source.push(encodeHeader(header))\n    }\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log?.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log?.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log?.('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing != null && typeof thing.then === 'function'\n}\n", "/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxerInit } from './muxer.js'\nimport type { ComponentLogger, StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode, type FrameHeader, type FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport interface YamuxMuxerComponents {\n  logger: ComponentLogger\n}\n\nexport function yamux (init: YamuxMuxerInit = {}): (components: YamuxMuxerComponents) => StreamMuxerFactory {\n  return (components) => new Yamux(components, init)\n}\n"],
  "mappings": "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",
  "names": ["FrameType", "Flag", "GoAwayCode", "_a", "_b", "isPromise", "_a", "err", "isPromise", "res", "peekable", "src_default", "StreamState", "_a", "src_default", "_b", "_a", "_b", "isPromise"]
}
