{
  "version": 3,
  "sources": ["../../@libp2p/interface/src/peer-discovery/index.ts", "../../@libp2p/interface/src/transport/index.ts", "../../@libp2p/interface/src/errors.ts", "../../@libp2p/interface/src/events.browser.ts", "../../@libp2p/interface/src/events.ts", "../../@libp2p/interface/src/event-target.ts", "../../@libp2p/interface/src/connection/index.ts", "../../@libp2p/interface/src/content-routing/index.ts", "../../@libp2p/interface/src/peer-id/index.ts", "../../@libp2p/interface/src/peer-routing/index.ts", "../../@libp2p/interface/src/peer-store/tags.ts", "../../@libp2p/interface/src/pubsub/index.ts", "../../@libp2p/interface/src/startable.ts", "../../@libp2p/interface/src/index.ts"],
  "sourcesContent": ["import type { TypedEventTarget } from '../event-target.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery')\n\n/**\n * Implementers of this interface can provide a PeerDiscovery implementation to\n * interested callers.\n */\nexport interface PeerDiscoveryProvider {\n  [peerDiscoverySymbol]: PeerDiscovery\n}\n\nexport interface PeerDiscoveryEvents {\n  'peer': CustomEvent<PeerInfo>\n}\n\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "import type { Connection, ConnectionLimits, MultiaddrConnection } from '../connection/index.js'\nimport type { TypedEventTarget } from '../event-target.js'\nimport type { AbortOptions } from '../index.js'\nimport type { StreamMuxerFactory } from '../stream-muxer/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ListenerEvents {\n  /**\n   * This event signals to the transport manager that the listening addresses\n   * have changed and may be emitted at any point and/or multiple times\n   */\n  'listening': CustomEvent\n\n  /**\n   * Emitted if listening on an address failed\n   */\n  'error': CustomEvent<Error>\n\n  /**\n   * Emitted when the listener has been shut down, has no open connections and\n   * will no longer accept new connections\n   */\n  'close': CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection and notifies\n   * other libp2p components about a new incoming connection.\n   */\n  upgrader: Upgrader\n}\n\nexport interface DialTransportOptions<DialEvents extends ProgressEvent = ProgressEvent> extends AbortOptions, ProgressOptions<DialEvents> {\n  /**\n   * The upgrader turns a MultiaddrConnection into a Connection which should be\n   * returned by the transport's dial method\n   */\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport offers dial and listen methods to establish connections.\n */\nexport interface Transport<DialEvents extends ProgressEvent = ProgressEvent> {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialTransportOptions<DialEvents>): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are vali for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\nexport interface UpgraderOptions<ConnectionUpgradeEvents extends ProgressEvent = ProgressEvent> extends ProgressOptions<ConnectionUpgradeEvents>, AbortOptions {\n  skipEncryption?: boolean\n  skipProtection?: boolean\n  muxerFactory?: StreamMuxerFactory\n  limits?: ConnectionLimits\n}\n\nexport type InboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-inbound-connection'> |\nProgressEvent<'upgrader:multiplex-inbound-connection'>\n\nexport type OutboundConnectionUpgradeEvents =\nProgressEvent<'upgrader:encrypt-outbound-connection'> |\nProgressEvent<'upgrader:multiplex-outbound-connection'>\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection created by the `dial` method of a transport\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<OutboundConnectionUpgradeEvents>): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection received by a transport listener and\n   * notifies other libp2p components about the new connection\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions<InboundConnectionUpgradeEvents>): Promise<void>\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when and attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n", "/**\n * Noop for browser compatibility\n */\nexport function setMaxListeners (): void {}\n", "import { setMaxListeners as nodeSetMaxListeners } from 'events'\n\n/**\n * Create a setMaxListeners that doesn't break browser usage\n */\nexport const setMaxListeners: typeof nodeSetMaxListeners = (n, ...eventTargets) => {\n  try {\n    nodeSetMaxListeners(n, ...eventTargets)\n  } catch {\n    // swallow error, gulp\n  }\n}\n", "import { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n * etc\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n", "import type { AbortOptions, Logger } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n\n  /**\n   * The stream logger\n   */\n  log: Logger\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a limited connection - one that has restrictions\n   * on the amount of data that may be transferred or how long it may be open for.\n   *\n   * These limits are typically enforced by a relay server, if the protocol\n   * will be transferring a lot of data or the stream will be open for a long time\n   * consider upgrading to a direct connection before opening the stream.\n   *\n   * @default false\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * By default when negotiating a protocol the dialer writes then protocol name\n   * then reads the response.\n   *\n   * When a only a single protocol is being negotiated on an outbound stream,\n   * and the stream is written to before being read from, we can optimistically\n   * write the protocol name and the first chunk of data together in the first\n   * message.\n   *\n   * Reading and handling the protocol response is done asynchronously, which\n   * means we can skip a round trip on writing to newly opened streams which\n   * significantly reduces the time-to-first-byte on a stream.\n   *\n   * The side-effect of this is that the underlying stream won't negotiate the\n   * protocol until either data is written to or read from the stream so it will\n   * not be opened on the remote until this is done.\n   *\n   * Pass `false` here to optimistically write the protocol name and first chunk\n   * of data in the first message.\n   *\n   * If multiple protocols are being negotiated, negotiation is always completed\n   * in full before the stream is returned so this option has no effect.\n   *\n   * @default true\n   */\n  negotiateFully?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * Connection limits are present on connections that are only allowed to\n * transfer a certain amount of bytes or be open for a certain number\n * of seconds.\n *\n * These limits are applied by Circuit Relay v2 servers, for example and\n * the connection will normally be closed abruptly if the limits are\n * exceeded.\n */\nexport interface ConnectionLimits {\n  /**\n   * If present this is the number of bytes remaining that may be\n   * transferred over this connection\n   */\n  bytes?: bigint\n\n  /**\n   * If present this is the number of seconds that this connection will\n   * remain open for\n   */\n  seconds?: number\n}\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound conections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * If present, this connection has limits applied to it, perhaps by an\n   * intermediate relay. Once the limits have been reached the connection will\n   * be closed by the relay.\n   */\n  limits?: ConnectionLimits\n\n  /**\n   * The time in milliseconds it takes to make a round trip to the remote peer.\n   *\n   * This is updated periodically by the connection monitor.\n   */\n  rtt?: number\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The connection logger\n   */\n  log: Logger\n}\n\nexport const connectionSymbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[connectionSymbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection, options?: AbortOptions): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection lifecycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * The multiaddr connection logger\n   */\n  log: Logger\n}\n", "import type { RoutingOptions } from '../index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing')\n\n/**\n * Implementers of this interface can provide a ContentRouting implementation to\n * interested callers.\n */\nexport interface ContentRoutingProvider {\n  [contentRoutingSymbol]: ContentRouting\n}\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * If network peers need to be periodically reminded that the caller can\n   * provide content corresponding to the passed CID, call this function to no\n   * longer remind them.\n   */\n  cancelReprovide (key: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: RoutingOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: RoutingOptions): Promise<Uint8Array>\n}\n", "import type { Ed25519PublicKey, KeyType, RSAPublicKey, Secp256k1PublicKey } from '../keys/index.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\n/**\n * A PeerId generated from an RSA public key - it is a base58btc encoded sha-256\n * hash of the public key.\n *\n * RSA public keys are too large to pass around freely, instead Ed25519 or\n * secp256k1 should be preferred as they can embed their public key in the\n * PeerId itself.\n *\n * @deprecated Ed25519 or secp256k1 keys are preferred to RSA\n */\nexport interface RSAPeerId {\n  readonly type: 'RSA'\n\n  /**\n   * RSA public keys are too large to embed in the multihash commonly used to\n   * refer to peers, so this will only be defined if the public key has\n   * previously been found through a routing query or during normal protocol\n   * operations\n   */\n  readonly publicKey?: RSAPublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the SHA2-256 hash of the public\n   * key\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x12, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Ed25519PeerId {\n  readonly type: 'Ed25519'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Secp256k1PeerId {\n  readonly type: 'secp256k1'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface URLPeerId {\n  readonly type: 'url'\n\n  /**\n   * This will always be undefined as URL Peers do not have public keys\n   */\n  readonly publicKey: undefined\n\n  /**\n   * Returns CID from `toCID()` encoded as a base36 string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the URL encoded as an identity\n   * hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the Transport IPFS Gateway HTTP code and the same\n   * multihash as `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x0920, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\n/**\n * This is a union of all known PeerId types - use the `.type` field to\n * disambiguate them\n */\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId | URLPeerId\n\n/**\n * All PeerId implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\n/**\n * Returns true if the passed argument is a PeerId implementation\n */\nexport function isPeerId (other?: any): other is PeerId {\n  return Boolean(other?.[peerIdSymbol])\n}\n", "import type { RoutingOptions } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing')\n\n/**\n * Implementers of this interface can provide a PeerRouting implementation to\n * interested callers.\n */\nexport interface PeerRoutingProvider {\n  [peerRoutingSymbol]: PeerRouting\n}\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: RoutingOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>\n}\n", "/**\n * When a peer that is tagged with this prefix disconnects, we will attempt to\n * redial it, up to a limit.\n *\n * To allow multiple components to add/remove their own keep-alive tags without\n * accidentally overwriting those of other components, attach a unique suffix to\n * the tag, e.g. `keep-alive-circuit-relay` or `keep-alive-kad-dht`, etc.\n */\nexport const KEEP_ALIVE = 'keep-alive'\n", "import type { Stream } from '../connection/index.js'\nimport type { TypedEventTarget } from '../event-target.js'\nimport type { PublicKey } from '../keys/index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  'message': CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  'close': CustomEvent<never>\n}\n\n/**\n * All Pubsub implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const pubSubSymbol = Symbol.for('@libp2p/pubsub')\n\n/**\n * Returns true if the passed argument is a PubSub implementation\n */\nexport function isPubSub (obj?: any): obj is PubSub {\n  return Boolean(obj?.[pubSubSymbol])\n}\n", "/**\n * Implemented by components that have a lifecycle\n */\nexport interface Startable {\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\nexport function isStartable (obj: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions, Stream } from './connection/index.js'\nimport type { ContentRouting } from './content-routing/index.js'\nimport type { TypedEventTarget } from './event-target.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys/index.js'\nimport type { Metrics } from './metrics/index.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id/index.js'\nimport type { PeerInfo } from './peer-info/index.js'\nimport type { PeerRouting } from './peer-routing/index.js'\nimport type { Address, Peer, PeerStore } from './peer-store/index.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions } from './stream-handler/index.js'\nimport type { Topology } from './topology/index.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\n/**\n * Peer logger component for libp2p\n */\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  'start': CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  'stop': CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added, the first one is discarded.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behaviour.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection/index.js'\nexport * from './connection-encrypter/index.js'\nexport * from './connection-gater/index.js'\nexport * from './content-routing/index.js'\nexport * from './keys/index.js'\nexport * from './metrics/index.js'\nexport * from './peer-discovery/index.js'\nexport * from './peer-id/index.js'\nexport * from './peer-info/index.js'\nexport * from './peer-routing/index.js'\nexport * from './peer-store/index.js'\nexport * from './peer-store/tags.js'\nexport * from './pubsub/index.js'\nexport * from './record/index.js'\nexport * from './stream-handler/index.js'\nexport * from './stream-muxer/index.js'\nexport * from './topology/index.js'\nexport * from './transport/index.js'\nexport * from './errors.js'\nexport * from './event-target.js'\nexport * from './events.js'\nexport * from './startable.js'\n"],
  "mappings": "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",
  "names": ["FaultTolerance", "setMaxListeners", "setMaxListeners", "TopicValidatorResult"]
}
