import {
  multiaddr
} from "./chunk-4JGVO3XG.js";
import {
  peerIdFromString
} from "./chunk-DGMPK36G.js";
import {
  TypedEventEmitter,
  peerDiscoverySymbol,
  serviceCapabilities
} from "./chunk-W7L7L57K.js";
import {
  __publicField
} from "./chunk-QY3AG7D4.js";

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS4 = base("dns4");
var DNS6 = base("dns6");
var DNSADDR = base("dnsaddr");
var DNS = or(base("dns"), DNSADDR, DNS4, DNS6);
var IP = or(base("ip4"), base("ip6"));
var TCP = or(and(IP, base("tcp")), and(DNS, base("tcp")));
var UDP = and(IP, base("udp"));
var UTP = and(UDP, base("utp"));
var QUIC = and(UDP, base("quic"));
var QUICV1 = and(UDP, base("quic-v1"));
var _WebSockets = or(and(TCP, base("ws")), and(DNS, base("ws")));
var WebSockets = or(and(_WebSockets, base("p2p")), _WebSockets);
var _WebSocketsSecure = or(and(TCP, base("wss")), and(DNS, base("wss")), and(TCP, base("tls"), base("ws")), and(DNS, base("tls"), base("ws")));
var WebSocketsSecure = or(and(_WebSocketsSecure, base("p2p")), _WebSocketsSecure);
var HTTP = or(and(TCP, base("http")), and(IP, base("http")), and(DNS, base("http")));
var HTTPS = or(and(TCP, base("https")), and(IP, base("https")), and(DNS, base("https")));
var _WebRTCDirect = and(UDP, base("webrtc-direct"), base("certhash"));
var WebRTCDirect = or(and(_WebRTCDirect, base("p2p")), _WebRTCDirect);
var _WebTransport = and(QUICV1, base("webtransport"), base("certhash"), base("certhash"));
var WebTransport = or(and(_WebTransport, base("p2p")), _WebTransport);
var P2PWebRTCStar = or(and(WebSockets, base("p2p-webrtc-star"), base("p2p")), and(WebSocketsSecure, base("p2p-webrtc-star"), base("p2p")), and(WebSockets, base("p2p-webrtc-star")), and(WebSocketsSecure, base("p2p-webrtc-star")));
var WebSocketStar = or(and(WebSockets, base("p2p-websocket-star"), base("p2p")), and(WebSocketsSecure, base("p2p-websocket-star"), base("p2p")), and(WebSockets, base("p2p-websocket-star")), and(WebSocketsSecure, base("p2p-websocket-star")));
var P2PWebRTCDirect = or(and(HTTP, base("p2p-webrtc-direct"), base("p2p")), and(HTTPS, base("p2p-webrtc-direct"), base("p2p")), and(HTTP, base("p2p-webrtc-direct")), and(HTTPS, base("p2p-webrtc-direct")));
var Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
var Stardust = or(and(Reliable, base("p2p-stardust"), base("p2p")), and(Reliable, base("p2p-stardust")));
var _P2P = or(and(Reliable, base("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base("p2p"));
var _Circuit = or(and(_P2P, base("p2p-circuit"), _P2P), and(_P2P, base("p2p-circuit")), and(base("p2p-circuit"), _P2P), and(Reliable, base("p2p-circuit")), and(base("p2p-circuit"), Reliable), base("p2p-circuit"));
var CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var WebRTC = or(and(Circuit, base("webrtc"), base("p2p")), and(Circuit, base("webrtc")), and(Reliable, base("webrtc"), base("p2p")), and(Reliable, base("webrtc")), base("webrtc"));
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base(n) {
  const name = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name;
    },
    matches,
    partialMatch
  };
}

// node_modules/@libp2p/bootstrap/dist/src/index.js
var DEFAULT_BOOTSTRAP_TAG_NAME = "bootstrap";
var DEFAULT_BOOTSTRAP_TAG_VALUE = 50;
var DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT = 1e3;
var _a, _b, _c;
var Bootstrap = class extends TypedEventEmitter {
  constructor(components, options = { list: [] }) {
    if (options.list == null || options.list.length === 0) {
      throw new Error("Bootstrap requires a list of peer addresses");
    }
    super();
    __publicField(this, "log");
    __publicField(this, "timer");
    __publicField(this, "list");
    __publicField(this, "timeout");
    __publicField(this, "components");
    __publicField(this, "_init");
    __publicField(this, _a, this);
    __publicField(this, _b, "@libp2p/bootstrap");
    __publicField(this, _c, [
      "@libp2p/peer-discovery"
    ]);
    this.components = components;
    this.log = components.logger.forComponent("libp2p:bootstrap");
    this.timeout = options.timeout ?? DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT;
    this.list = [];
    for (const candidate of options.list) {
      if (!P2P.matches(candidate)) {
        this.log.error("Invalid multiaddr");
        continue;
      }
      const ma = multiaddr(candidate);
      const peerIdStr = ma.getPeerId();
      if (peerIdStr == null) {
        this.log.error("Invalid bootstrap multiaddr without peer id");
        continue;
      }
      const peerData = {
        id: peerIdFromString(peerIdStr),
        multiaddrs: [ma]
      };
      this.list.push(peerData);
    }
    this._init = options;
  }
  isStarted() {
    return Boolean(this.timer);
  }
  /**
   * Start emitting events
   */
  start() {
    if (this.isStarted()) {
      return;
    }
    this.log("Starting bootstrap node discovery, discovering peers after %s ms", this.timeout);
    this.timer = setTimeout(() => {
      void this._discoverBootstrapPeers().catch((err) => {
        this.log.error(err);
      });
    }, this.timeout);
  }
  /**
   * Emit each address in the list as a PeerInfo
   */
  async _discoverBootstrapPeers() {
    if (this.timer == null) {
      return;
    }
    for (const peerData of this.list) {
      await this.components.peerStore.merge(peerData.id, {
        tags: {
          [this._init.tagName ?? DEFAULT_BOOTSTRAP_TAG_NAME]: {
            value: this._init.tagValue ?? DEFAULT_BOOTSTRAP_TAG_VALUE,
            ttl: this._init.tagTTL
          }
        },
        multiaddrs: peerData.multiaddrs
      });
      if (this.timer == null) {
        return;
      }
      this.safeDispatchEvent("peer", { detail: peerData });
      this.components.connectionManager.openConnection(peerData.id).catch((err) => {
        this.log.error("could not dial bootstrap peer %p", peerData.id, err);
      });
    }
  }
  /**
   * Stop emitting events
   */
  stop() {
    if (this.timer != null) {
      clearTimeout(this.timer);
    }
    this.timer = void 0;
  }
};
_a = peerDiscoverySymbol, _b = Symbol.toStringTag, _c = serviceCapabilities;
__publicField(Bootstrap, "tag", "bootstrap");
function bootstrap(init) {
  return (components) => new Bootstrap(components, init);
}

export {
  bootstrap
};
//# sourceMappingURL=chunk-VM2ZXPUC.js.map
